---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: 缓存体系结构中的数据C#（） |Microsoft Docs
author: rick-anderson
description: 在上一教程中，我们学习了如何在表示层应用缓存。 在本教程中，我们将了解如何利用我们的分层 architectu 。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 192cadb8e2f862ac2a97a36b375e247b281ece93
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74600828"
---
# <a name="caching-data-in-the-architecture-c"></a><span data-ttu-id="21ea6-104">缓存体系结构中的数据 (C#)</span><span class="sxs-lookup"><span data-stu-id="21ea6-104">Caching Data in the Architecture (C#)</span></span>

<span data-ttu-id="21ea6-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="21ea6-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="21ea6-106">[下载示例应用](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe)或[下载 PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="21ea6-106">[Download Sample App](https://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) or [Download PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span></span>

> <span data-ttu-id="21ea6-107">在上一教程中，我们学习了如何在表示层应用缓存。</span><span class="sxs-lookup"><span data-stu-id="21ea6-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="21ea6-108">在本教程中，我们将了解如何利用我们的分层体系结构来缓存业务逻辑层中的数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="21ea6-109">为此，我们要扩展体系结构，使其包含缓存层。</span><span class="sxs-lookup"><span data-stu-id="21ea6-109">We do this by extending the architecture to include a Caching Layer.</span></span>

## <a name="introduction"></a><span data-ttu-id="21ea6-110">简介</span><span class="sxs-lookup"><span data-stu-id="21ea6-110">Introduction</span></span>

<span data-ttu-id="21ea6-111">如前面的教程中所述，缓存 ObjectDataSource 数据就像设置几个属性一样简单。</span><span class="sxs-lookup"><span data-stu-id="21ea6-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="21ea6-112">遗憾的是，ObjectDataSource 在表示层应用缓存，这会在 ASP.NET 页中将缓存策略紧密耦合在一起。</span><span class="sxs-lookup"><span data-stu-id="21ea6-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="21ea6-113">创建分层体系结构的原因之一是允许此类放开中断。</span><span class="sxs-lookup"><span data-stu-id="21ea6-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="21ea6-114">例如，业务逻辑层用于将业务逻辑与 ASP.NET 页面分离，而数据访问层则使数据访问详细信息分离。</span><span class="sxs-lookup"><span data-stu-id="21ea6-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="21ea6-115">这会使业务逻辑和数据访问详细信息的这种分离成为一种更好的方法，因为它使系统更具可读性，更易于维护，并且更灵活地进行更改。</span><span class="sxs-lookup"><span data-stu-id="21ea6-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="21ea6-116">它还允许对使用表示层的开发人员进行域知识和部门划分，无需熟悉数据库的详细信息，就能完成工作。</span><span class="sxs-lookup"><span data-stu-id="21ea6-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="21ea6-117">将缓存策略与表示层分离会提供类似的好处。</span><span class="sxs-lookup"><span data-stu-id="21ea6-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="21ea6-118">在本教程中，我们将补充体系结构，使之包含使用缓存策略的*缓存层*（或 CL）。</span><span class="sxs-lookup"><span data-stu-id="21ea6-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="21ea6-119">该缓存层将包括一个 `ProductsCL` 类，该类通过 `GetProducts()`、`GetProductsByCategoryID(categoryID)`等方法提供对产品信息的访问。在调用时，将首先尝试从缓存中检索数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="21ea6-120">如果缓存为空，这些方法将在 BLL 中调用相应的 `ProductsBLL` 方法，进而从 DAL 获取数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="21ea6-121">`ProductsCL` 方法缓存从 BLL 检索的数据，然后再将其返回。</span><span class="sxs-lookup"><span data-stu-id="21ea6-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="21ea6-122">如图1所示，CL 驻留在表示层和业务逻辑层之间。</span><span class="sxs-lookup"><span data-stu-id="21ea6-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>

![缓存层（CL）是体系结构中的另一层](caching-data-in-the-architecture-cs/_static/image1.png)

<span data-ttu-id="21ea6-124">**图 1**：缓存层（CL）是体系结构中的另一层</span><span class="sxs-lookup"><span data-stu-id="21ea6-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>

## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="21ea6-125">步骤1：创建缓存层类</span><span class="sxs-lookup"><span data-stu-id="21ea6-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="21ea6-126">在本教程中，我们将创建一个非常简单的 CL，其中包含只有少量方法的单个类 `ProductsCL`。</span><span class="sxs-lookup"><span data-stu-id="21ea6-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="21ea6-127">为整个应用程序构建完整的缓存层需要创建 `CategoriesCL`、`EmployeesCL`和 `SuppliersCL` 类，并为 BLL 中的每个数据访问或修改方法提供这些缓存层类中的方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="21ea6-128">与 BLL 和 DAL 一样，应理想地将缓存层实现为单独的类库项目;但是，我们会将其实现为 `App_Code` 文件夹中的类。</span><span class="sxs-lookup"><span data-stu-id="21ea6-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="21ea6-129">若要更清晰地将 DAL 类与 DAL 和 BLL 类分开，请在 `App_Code` 文件夹中创建一个新的子文件夹。</span><span class="sxs-lookup"><span data-stu-id="21ea6-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="21ea6-130">右键单击解决方案资源管理器中的 "`App_Code`" 文件夹，选择 "新建文件夹"，然后将新文件夹命名为 "`CL`"。</span><span class="sxs-lookup"><span data-stu-id="21ea6-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="21ea6-131">创建此文件夹后，将添加到名为 `ProductsCL.cs`的新类中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-131">After creating this folder, add to it a new class named `ProductsCL.cs`.</span></span>

![添加一个名为 CL 的新文件夹和一个名为 ProductsCL.cs 的类](caching-data-in-the-architecture-cs/_static/image2.png)

<span data-ttu-id="21ea6-133">**图 2**：添加名为 `CL` 的新文件夹和名为 `ProductsCL.cs` 的类</span><span class="sxs-lookup"><span data-stu-id="21ea6-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.cs`</span></span>

<span data-ttu-id="21ea6-134">`ProductsCL` 类应包含一组相同的数据访问和修改方法，如在其相应的业务逻辑层类（`ProductsBLL`）中找到。</span><span class="sxs-lookup"><span data-stu-id="21ea6-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="21ea6-135">只需创建这两种方法，就可以在这里构建一些方法，让你了解 CL 所使用的模式。</span><span class="sxs-lookup"><span data-stu-id="21ea6-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="21ea6-136">具体而言，我们将在步骤3中添加 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法，在步骤4中添加 `UpdateProduct` 重载。</span><span class="sxs-lookup"><span data-stu-id="21ea6-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="21ea6-137">您可以在休闲中添加剩余的 `ProductsCL` 方法和 `CategoriesCL`、`EmployeesCL`和 `SuppliersCL` 类。</span><span class="sxs-lookup"><span data-stu-id="21ea6-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="21ea6-138">步骤2：读取和写入数据缓存</span><span class="sxs-lookup"><span data-stu-id="21ea6-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="21ea6-139">前面的教程中所述的 ObjectDataSource 缓存功能在内部使用 ASP.NET 数据缓存来存储从 BLL 检索的数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="21ea6-140">还可以从 ASP.NET 页的代码隐藏类或 web 应用程序体系结构中的类以编程方式访问数据缓存。</span><span class="sxs-lookup"><span data-stu-id="21ea6-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="21ea6-141">若要从 ASP.NET 页的代码隐藏类读取和写入数据缓存，请使用以下模式：</span><span class="sxs-lookup"><span data-stu-id="21ea6-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

<span data-ttu-id="21ea6-142">[`Cache` 类](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) [`Insert` 方法](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx)具有多个重载。</span><span class="sxs-lookup"><span data-stu-id="21ea6-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="21ea6-143">`Cache["key"] = value` 和 `Cache.Insert(key, value)` 是同义词，这两种方法都使用指定的密钥将项添加到缓存，而不定义到期。</span><span class="sxs-lookup"><span data-stu-id="21ea6-143">`Cache["key"] = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="21ea6-144">通常，我们希望在将项添加到缓存时指定到期时间，无论是依赖项、基于时间的过期，还是同时指定两者。</span><span class="sxs-lookup"><span data-stu-id="21ea6-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="21ea6-145">使用另一个 `Insert` 方法的重载来提供依赖项或基于时间的过期信息。</span><span class="sxs-lookup"><span data-stu-id="21ea6-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="21ea6-146">缓存层的方法首先需要检查请求的数据是否在缓存中，如果是，则从那里返回数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="21ea6-147">如果请求的数据不在缓存中，则需要调用相应的 BLL 方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="21ea6-148">应缓存并返回其返回值，如下图所示。</span><span class="sxs-lookup"><span data-stu-id="21ea6-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>

![缓存层 s 方法返回缓存中的数据（如果可用）](caching-data-in-the-architecture-cs/_static/image3.png)

<span data-ttu-id="21ea6-150">**图 3**：缓存层 s 方法返回缓存中的数据（如果可用）</span><span class="sxs-lookup"><span data-stu-id="21ea6-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>

<span data-ttu-id="21ea6-151">图3中所示的序列是使用以下模式在 CL 类中完成的：</span><span class="sxs-lookup"><span data-stu-id="21ea6-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

<span data-ttu-id="21ea6-152">此处， *type*是在缓存 `Northwind.ProductsDataTable`中存储的数据的类型，例如， *key*是唯一标识缓存项的键。</span><span class="sxs-lookup"><span data-stu-id="21ea6-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="21ea6-153">如果缓存中不存在具有指定*键*的项，则将 `null`*实例*，并将从适当的 BLL 方法检索数据并将其添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-153">If the item with the specified *key* is not in the cache, then *instance* will be `null` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="21ea6-154">达到 `return instance` 时，*实例*将包含对数据的引用，无论是从缓存中提取，还是从 BLL 拉取。</span><span class="sxs-lookup"><span data-stu-id="21ea6-154">By the time `return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="21ea6-155">访问缓存中的数据时，请务必使用以上模式。</span><span class="sxs-lookup"><span data-stu-id="21ea6-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="21ea6-156">以下模式（乍一看）看上去等效，包含引入争用条件的细微差异。</span><span class="sxs-lookup"><span data-stu-id="21ea6-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="21ea6-157">争用条件很难调试，因为它们偶尔显示，难以重现。</span><span class="sxs-lookup"><span data-stu-id="21ea6-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

<span data-ttu-id="21ea6-158">这一秒的不同之处在于，代码片段不正确，而不是在本地变量中存储对缓存项的引用，而是在条件语句*和*`return`中直接访问数据缓存。</span><span class="sxs-lookup"><span data-stu-id="21ea6-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `return`.</span></span> <span data-ttu-id="21ea6-159">假设在达到此代码时，`Cache["key"]` 不`null`，但在到达 `return` 语句之前，将从缓存中逐出系统的*键*。</span><span class="sxs-lookup"><span data-stu-id="21ea6-159">Imagine that when this code is reached, `Cache["key"]` is non-`null`, but before the `return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="21ea6-160">在这种罕见情况下，代码将返回 `null` 值，而不是所需类型的对象。</span><span class="sxs-lookup"><span data-stu-id="21ea6-160">In this rare case, the code will return a `null` value rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="21ea6-161">数据缓存是线程安全的，因此，无需同步线程访问来进行简单的读取或写入。</span><span class="sxs-lookup"><span data-stu-id="21ea6-161">The data cache is thread-safe, so you don t need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="21ea6-162">但是，如果需要对缓存中需要为原子的数据执行多个操作，则需要负责实现锁定或某些其他机制以确保线程安全。</span><span class="sxs-lookup"><span data-stu-id="21ea6-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="21ea6-163">有关详细信息，请参阅[同步访问 ASP.NET 缓存](http://www.ddj.com/184406369)。</span><span class="sxs-lookup"><span data-stu-id="21ea6-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>

<span data-ttu-id="21ea6-164">可以使用如下所示的[`Remove` 方法](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx)，以编程方式从数据缓存中收回项：</span><span class="sxs-lookup"><span data-stu-id="21ea6-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="21ea6-165">步骤3：返回`ProductsCL`类中的产品信息</span><span class="sxs-lookup"><span data-stu-id="21ea6-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="21ea6-166">在本教程中，我们将实现两种方法，用于从 `ProductsCL` 类返回产品信息： `GetProducts()` 和 `GetProductsByCategoryID(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="21ea6-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="21ea6-167">与业务逻辑层中的 `ProductsBL` 类一样，CL 中的 `GetProducts()` 方法会将所有产品的相关信息作为 `Northwind.ProductsDataTable` 对象返回，同时 `GetProductsByCategoryID(categoryID)` 返回指定类别中的所有产品。</span><span class="sxs-lookup"><span data-stu-id="21ea6-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="21ea6-168">下面的代码演示了 `ProductsCL` 类中的部分方法：</span><span class="sxs-lookup"><span data-stu-id="21ea6-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>

[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

<span data-ttu-id="21ea6-169">首先，请注意应用于类和方法的 `DataObject` 和 `DataObjectMethodAttribute` 特性。</span><span class="sxs-lookup"><span data-stu-id="21ea6-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="21ea6-170">这些属性向 ObjectDataSource 向导提供信息，指示应在向导步骤中显示的类和方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="21ea6-171">由于将从表示层中的 ObjectDataSource 访问 CL 类和方法，因此我添加了这些属性来增强设计时体验。</span><span class="sxs-lookup"><span data-stu-id="21ea6-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="21ea6-172">有关这些属性及其影响的更全面说明，请参阅 "[创建业务逻辑层](../introduction/creating-a-business-logic-layer-cs.md)" 教程。</span><span class="sxs-lookup"><span data-stu-id="21ea6-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-cs.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="21ea6-173">在 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法中，从 `GetCacheItem(key)` 方法返回的数据将被分配给本地变量。</span><span class="sxs-lookup"><span data-stu-id="21ea6-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="21ea6-174">`GetCacheItem(key)` 方法，我们稍后将对此进行检查，根据指定的*键*返回缓存中的特定项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="21ea6-175">如果在缓存中找不到此类数据，则从相应的 `ProductsBLL` 类方法检索该数据，然后使用 `AddCacheItem(key, value)` 方法将其添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="21ea6-176">`GetCacheItem(key)` 和 `AddCacheItem(key, value)` 方法分别为数据缓存、读取和写入值。</span><span class="sxs-lookup"><span data-stu-id="21ea6-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="21ea6-177">`GetCacheItem(key)` 方法是这二者中较简单的方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="21ea6-178">它只使用传入的*密钥*从缓存类返回值：</span><span class="sxs-lookup"><span data-stu-id="21ea6-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

<span data-ttu-id="21ea6-179">`GetCacheItem(key)` 不使用提供的*键值*，而是调用 `GetCacheKey(key)` 方法，该方法将返回前面带有 ProductsCache 的*键*。</span><span class="sxs-lookup"><span data-stu-id="21ea6-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="21ea6-180">`AddCacheItem(key, value)` 方法还使用保存 ProductsCache 字符串的 `MasterCacheKeyArray`，如下所示。</span><span class="sxs-lookup"><span data-stu-id="21ea6-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="21ea6-181">在 ASP.NET 页的代码隐藏类中，可以使用 `Page` 类[`Cache` 属性](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)访问数据缓存，并允许使用类似于 `Cache["key"] = value`的语法，如步骤2中所述。</span><span class="sxs-lookup"><span data-stu-id="21ea6-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache["key"] = value`, as discussed in Step 2.</span></span> <span data-ttu-id="21ea6-182">从体系结构内的类，可以使用 `HttpRuntime.Cache` 或 `HttpContext.Current.Cache`访问数据缓存。</span><span class="sxs-lookup"><span data-stu-id="21ea6-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="21ea6-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)的博客文章[HttpRuntime 和 httpcontext.current](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache)说明了使用 `HttpRuntime` 而不是 `HttpContext.Current`时的轻微性能优势。因此，`ProductsCL` 使用 `HttpRuntime`。</span><span class="sxs-lookup"><span data-stu-id="21ea6-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="21ea6-184">如果使用类库项目来实现您的体系结构，则需要添加对 `System.Web` 程序集的引用，以便使用[HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx)和[HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)类。</span><span class="sxs-lookup"><span data-stu-id="21ea6-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>

<span data-ttu-id="21ea6-185">如果在缓存中找不到该项，`ProductsCL` 类的方法将从 BLL 获取数据，并使用 `AddCacheItem(key, value)` 方法将其添加到缓存中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="21ea6-186">若要将*值*添加到缓存，可以使用以下代码，该代码使用60秒的过期时间：</span><span class="sxs-lookup"><span data-stu-id="21ea6-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

<span data-ttu-id="21ea6-187">`DateTime.Now.AddSeconds(CacheDuration)` 在将来指定基于时间的过期60秒， [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx)指示没有可调过期时间。</span><span class="sxs-lookup"><span data-stu-id="21ea6-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="21ea6-188">尽管这 `Insert` 方法重载都具有输入参数用于绝对和可调过期，但你只能提供两个参数中的一个。</span><span class="sxs-lookup"><span data-stu-id="21ea6-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="21ea6-189">如果尝试同时指定绝对时间和时间跨度，`Insert` 方法将引发 `ArgumentException` 异常。</span><span class="sxs-lookup"><span data-stu-id="21ea6-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="21ea6-190">`AddCacheItem(key, value)` 方法的这一实现当前有一些缺点。</span><span class="sxs-lookup"><span data-stu-id="21ea6-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="21ea6-191">我们将在步骤4中解决并解决这些问题。</span><span class="sxs-lookup"><span data-stu-id="21ea6-191">We'll address and overcome these issues in Step 4.</span></span>

## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="21ea6-192">步骤4：通过体系结构修改数据时使缓存无效</span><span class="sxs-lookup"><span data-stu-id="21ea6-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="21ea6-193">除了数据检索方法，缓存层还需要提供与 BLL 相同的方法用于插入、更新和删除数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="21ea6-194">CL s 数据修改方法不会修改缓存的数据，而是调用与 BLL s 对应的数据修改方法，然后使缓存无效。</span><span class="sxs-lookup"><span data-stu-id="21ea6-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="21ea6-195">如前面的教程中所示，此行为与在启用缓存功能并调用其 `Insert`、`Update`或 `Delete` 方法时，ObjectDataSource 应用的行为相同。</span><span class="sxs-lookup"><span data-stu-id="21ea6-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="21ea6-196">下面的 `UpdateProduct` 重载说明了如何在 CL 中实现数据修改方法：</span><span class="sxs-lookup"><span data-stu-id="21ea6-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

<span data-ttu-id="21ea6-197">将调用相应的数据修改业务逻辑层方法，但在返回其响应之前，需要使缓存无效。</span><span class="sxs-lookup"><span data-stu-id="21ea6-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="21ea6-198">遗憾的是，将缓存无效，这并不是很简单，因为 `ProductsCL` 类 `GetProducts()` 和 `GetProductsByCategoryID(categoryID)` 方法都将项添加到具有不同键的缓存，而 `GetProductsByCategoryID(categoryID)` 方法为每个唯一的*类别 id*添加了不同的缓存项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="21ea6-199">在使缓存失效时，我们需要删除 `ProductsCL` 类可能已添加的*所有*项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="21ea6-200">这可以通过将*缓存依赖*项与添加到 `AddCacheItem(key, value)` 方法中的缓存的每一项进行关联来实现。</span><span class="sxs-lookup"><span data-stu-id="21ea6-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="21ea6-201">通常，缓存依赖关系可以是缓存中的另一项、文件系统中的文件或 Microsoft SQL Server 数据库中的数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="21ea6-202">如果依赖项发生更改或已从缓存中删除，则与之关联的缓存项将自动从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="21ea6-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="21ea6-203">对于本教程，我们想要在缓存中创建一个附加项，以用作通过 `ProductsCL` 类添加的所有项的缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="21ea6-204">这样一来，只需删除缓存依赖项，就可以从缓存中删除所有这些项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="21ea6-205">让我们更新 `AddCacheItem(key, value)` 方法，以便通过此方法添加到缓存中的每一项都与单个缓存依赖项相关联：</span><span class="sxs-lookup"><span data-stu-id="21ea6-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

<span data-ttu-id="21ea6-206">`MasterCacheKeyArray` 是保存单个值 ProductsCache 的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="21ea6-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="21ea6-207">首先，将缓存项添加到缓存，并为其分配当前日期和时间。</span><span class="sxs-lookup"><span data-stu-id="21ea6-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="21ea6-208">如果缓存项已存在，则更新该缓存项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="21ea6-209">接下来，创建缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="21ea6-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="21ea6-210">[`CacheDependency` 类](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx)的构造函数有多个重载，但此处使用的不需要两个 `string` 数组输入。</span><span class="sxs-lookup"><span data-stu-id="21ea6-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `string` array inputs.</span></span> <span data-ttu-id="21ea6-211">第一个指定要用作依赖项的文件集。</span><span class="sxs-lookup"><span data-stu-id="21ea6-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="21ea6-212">由于我们不想使用任何基于文件的依赖项，因此会将 `null` 的值用于第一个输入参数。</span><span class="sxs-lookup"><span data-stu-id="21ea6-212">Since we don t want to use any file-based dependencies, a value of `null` is used for the first input parameter.</span></span> <span data-ttu-id="21ea6-213">第二个输入参数指定用作依赖项的缓存键集。</span><span class="sxs-lookup"><span data-stu-id="21ea6-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="21ea6-214">这里，我们指定了单个依赖项，`MasterCacheKeyArray`。</span><span class="sxs-lookup"><span data-stu-id="21ea6-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="21ea6-215">然后，将 `CacheDependency` 传递到 `Insert` 方法中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="21ea6-216">对 `AddCacheItem(key, value)`进行此修改后，invaliding 缓存就像删除依赖项一样简单。</span><span class="sxs-lookup"><span data-stu-id="21ea6-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>

[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="21ea6-217">步骤5：从表示层调用缓存层</span><span class="sxs-lookup"><span data-stu-id="21ea6-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="21ea6-218">缓存层的类和方法可用于使用我们在这些教程中所检查的技术来处理数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="21ea6-219">若要演示如何使用缓存数据，请将所做的更改保存到 `ProductsCL` 类，然后在 `Caching` 文件夹中打开 `FromTheArchitecture.aspx` 页，并添加 GridView。</span><span class="sxs-lookup"><span data-stu-id="21ea6-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="21ea6-220">从 GridView s 智能标记创建新的 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="21ea6-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="21ea6-221">在向导的第一步中，你应看到 `ProductsCL` 类作为下拉列表中的选项之一。</span><span class="sxs-lookup"><span data-stu-id="21ea6-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>

<span data-ttu-id="21ea6-222">["业务对象" 下拉列表中包含 ProductsCL 类 ![](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="21ea6-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span></span>

<span data-ttu-id="21ea6-223">**图 4**： "业务对象" 下拉列表中包含了 `ProductsCL` 类（[单击以查看完全大小的图像](caching-data-in-the-architecture-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="21ea6-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image6.png))</span></span>

<span data-ttu-id="21ea6-224">选择 `ProductsCL`后，单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="21ea6-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="21ea6-225">"选择" 选项卡中的下拉列表具有两个项-`GetProducts()` "和" `GetProductsByCategoryID(categoryID)` "，" 更新 "选项卡具有唯一的 `UpdateProduct` 重载。</span><span class="sxs-lookup"><span data-stu-id="21ea6-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="21ea6-226">从 "更新" 选项卡中选择 "`GetProducts()` 方法"，`UpdateProducts` 然后单击 "完成"。</span><span class="sxs-lookup"><span data-stu-id="21ea6-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>

<span data-ttu-id="21ea6-227">[下拉列表中列出了 ProductsCL 类的方法 ![](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="21ea6-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span></span>

<span data-ttu-id="21ea6-228">**图 5**：下拉列表中列出了 `ProductsCL` 类的方法（[单击查看完全大小的图像](caching-data-in-the-architecture-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="21ea6-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image9.png))</span></span>

<span data-ttu-id="21ea6-229">完成向导后，Visual Studio 会将 "ObjectDataSource s" `OldValuesParameterFormatString` 属性设置为 "`original_{0}` 并将相应的字段添加到 GridView。</span><span class="sxs-lookup"><span data-stu-id="21ea6-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="21ea6-230">将 `OldValuesParameterFormatString` 属性改回其默认值 `{0}`，并配置 GridView 以支持分页、排序和编辑。</span><span class="sxs-lookup"><span data-stu-id="21ea6-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="21ea6-231">由于 CL 使用的 `UploadProducts` 重载只接受经过编辑的产品的名称和价格，因此限制 GridView，使只有这些字段可以编辑。</span><span class="sxs-lookup"><span data-stu-id="21ea6-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="21ea6-232">在前面的教程中，我们定义了一个 GridView，其中包含 `ProductName`、`CategoryName`和 `UnitPrice` 字段的字段。</span><span class="sxs-lookup"><span data-stu-id="21ea6-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="21ea6-233">可以随意复制此格式设置和结构，在这种情况下，GridView 和 ObjectDataSource 的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="21ea6-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

<span data-ttu-id="21ea6-234">此时，我们有一个使用缓存层的页面。</span><span class="sxs-lookup"><span data-stu-id="21ea6-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="21ea6-235">若要查看缓存的运行情况，请在 `ProductsCL` 类 `GetProducts()` 和 `UpdateProduct` 方法中设置断点。</span><span class="sxs-lookup"><span data-stu-id="21ea6-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="21ea6-236">访问浏览器中的页面，并在排序和分页时单步执行代码，以便查看从缓存中提取的数据。</span><span class="sxs-lookup"><span data-stu-id="21ea6-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="21ea6-237">然后更新记录，并注意缓存已失效，因此，在将数据重新绑定到 GridView 时，将从 BLL 中检索该记录。</span><span class="sxs-lookup"><span data-stu-id="21ea6-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="21ea6-238">本文随附的下载内容中提供的缓存层不完整。</span><span class="sxs-lookup"><span data-stu-id="21ea6-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="21ea6-239">它只包含一个类，`ProductsCL`，仅体育几个方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="21ea6-240">而且，只有单个 ASP.NET 页面使用 CL （`~/Caching/FromTheArchitecture.aspx`），所有其他页面仍直接引用 BLL。</span><span class="sxs-lookup"><span data-stu-id="21ea6-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="21ea6-241">如果你计划在应用程序中使用 CL，则表示层中的所有调用都应转向 CL，这将要求 CL 的类和方法涵盖表示层当前使用的 BLL 中的这些类和方法。</span><span class="sxs-lookup"><span data-stu-id="21ea6-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>

## <a name="summary"></a><span data-ttu-id="21ea6-242">总结</span><span class="sxs-lookup"><span data-stu-id="21ea6-242">Summary</span></span>

<span data-ttu-id="21ea6-243">尽管可以使用 ASP.NET 2.0 s SqlDataSource 和 ObjectDataSource 控件在表示层应用缓存，但理想情况下，会将缓存责任委托给体系结构中的一个单独的层。</span><span class="sxs-lookup"><span data-stu-id="21ea6-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="21ea6-244">在本教程中，我们创建了一个驻留在表示层和业务逻辑层之间的缓存层。</span><span class="sxs-lookup"><span data-stu-id="21ea6-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="21ea6-245">缓存层需要提供相同的类和方法集，它们存在于 BLL 中，并从表示层中调用。</span><span class="sxs-lookup"><span data-stu-id="21ea6-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="21ea6-246">本教程介绍了此示例中的缓存层示例，并介绍了如何进行*被动加载*。</span><span class="sxs-lookup"><span data-stu-id="21ea6-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="21ea6-247">使用被动加载时，仅当对数据进行请求并且缓存中缺少数据时，才会将数据加载到缓存中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="21ea6-248">还可以将数据*主动加载*到缓存中，这种方法在实际需要数据之前将数据加载到缓存中。</span><span class="sxs-lookup"><span data-stu-id="21ea6-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="21ea6-249">在下一教程中，我们将在查看如何在应用程序启动时将静态值存储到缓存中时，将看到一个主动加载的示例。</span><span class="sxs-lookup"><span data-stu-id="21ea6-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="21ea6-250">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="21ea6-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="21ea6-251">关于作者</span><span class="sxs-lookup"><span data-stu-id="21ea6-251">About the Author</span></span>

<span data-ttu-id="21ea6-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="21ea6-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="21ea6-253">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="21ea6-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="21ea6-254">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="21ea6-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="21ea6-255">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="21ea6-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="21ea6-256">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="21ea6-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="21ea6-257">特别感谢</span><span class="sxs-lookup"><span data-stu-id="21ea6-257">Special Thanks To</span></span>

<span data-ttu-id="21ea6-258">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="21ea6-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="21ea6-259">本教程的主管审查人员是 Teresa Murph。</span><span class="sxs-lookup"><span data-stu-id="21ea6-259">Lead reviewer for this tutorial was Teresa Murph.</span></span> <span data-ttu-id="21ea6-260">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="21ea6-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="21ea6-261">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="21ea6-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="21ea6-262">[上一页](caching-data-with-the-objectdatasource-cs.md)
> [下一页](caching-data-at-application-startup-cs.md)</span><span class="sxs-lookup"><span data-stu-id="21ea6-262">[Previous](caching-data-with-the-objectdatasource-cs.md)
[Next](caching-data-at-application-startup-cs.md)</span></span>

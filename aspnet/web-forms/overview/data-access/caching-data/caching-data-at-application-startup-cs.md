---
uid: web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
title: 在应用程序启动时缓存C#数据（） |Microsoft Docs
author: rick-anderson
description: 在任何 Web 应用程序中，一些数据会频繁使用，一些数据将不常使用。 我们可以提高 ASP.NET 应用程序的性能。
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 22ca8efa-7cd1-45a7-b9ce-ce6eb3b3ff95
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-at-application-startup-cs
msc.type: authoredcontent
ms.openlocfilehash: a0b55b0df1b7843120de284891e16178df23fabe
ms.sourcegitcommit: fe5c7512383a9b0a05d321ff10d3cca1611556f0
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/05/2019
ms.locfileid: "70386611"
---
# <a name="caching-data-at-application-startup-c"></a><span data-ttu-id="f1d2d-104">在应用程序启动时缓存数据 (C#)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-104">Caching Data at Application Startup (C#)</span></span>

<span data-ttu-id="f1d2d-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="f1d2d-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="f1d2d-106">Download PDF</span></span>](caching-data-at-application-startup-cs/_static/datatutorial60cs1.pdf)

> <span data-ttu-id="f1d2d-107">在任何 Web 应用程序中，一些数据会频繁使用，一些数据将不常使用。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-107">In any Web application some data will be frequently used and some data will be infrequently used.</span></span> <span data-ttu-id="f1d2d-108">我们可以预先加载频繁使用的数据（一种称为 "缓存" 的方法），提高 ASP.NET 应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-108">We can improve the performance of our ASP.NET application by loading in advance the frequently-used data, a technique known as Caching.</span></span> <span data-ttu-id="f1d2d-109">本教程演示一种主动加载方法，该方法是在应用程序启动时将数据加载到缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-109">This tutorial demonstrates one approach to proactive loading, which is to load data into the cache at application startup.</span></span>

## <a name="introduction"></a><span data-ttu-id="f1d2d-110">介绍</span><span class="sxs-lookup"><span data-stu-id="f1d2d-110">Introduction</span></span>

<span data-ttu-id="f1d2d-111">前面的两个教程介绍了如何在表示层和缓存层中缓存数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-111">The two previous tutorials looked at caching data in the Presentation and Caching Layers.</span></span> <span data-ttu-id="f1d2d-112">使用[Objectdatasource 缓存数据](caching-data-with-the-objectdatasource-cs.md)时，我们了解到使用 objectdatasource 的缓存功能来缓存表示层中的数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-112">In [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md), we looked at using the ObjectDataSource's caching features to cache data in the Presentation Layer.</span></span> <span data-ttu-id="f1d2d-113">在[体系结构中缓存数据](caching-data-in-the-architecture-cs.md)在新的、单独的缓存层中检查了缓存。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-113">[Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) examined caching in a new, separate Caching Layer.</span></span> <span data-ttu-id="f1d2d-114">这两个教程使用数据缓存中的 "*被动" 加载*。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-114">Both of these tutorials used *reactive loading* in working with the data cache.</span></span> <span data-ttu-id="f1d2d-115">对于被动加载，每次请求数据时，系统会先检查它是否在缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-115">With reactive loading, each time the data is requested, the system first checks if it's in the cache.</span></span> <span data-ttu-id="f1d2d-116">如果不是，则它从原始源中获取数据（如数据库），然后将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-116">If not, it grabs the data from the originating source, such as the database, and then stores it in the cache.</span></span> <span data-ttu-id="f1d2d-117">被动加载的主要优点在于它的实现。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-117">The main advantage to reactive loading is its ease of implementation.</span></span> <span data-ttu-id="f1d2d-118">它的缺点之一是跨请求的性能不均衡。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-118">One of its disadvantages is its uneven performance across requests.</span></span> <span data-ttu-id="f1d2d-119">假设某个页面使用前面教程中的缓存层来显示产品信息。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-119">Imagine a page that uses the Caching Layer from the preceding tutorial to display product information.</span></span> <span data-ttu-id="f1d2d-120">如果是第一次访问此页面，或由于内存限制或已达到指定的过期时间而逐出缓存数据后首次访问此页面，则必须从数据库中检索数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-120">When this page is visited for the first time, or visited for the first time after the cached data has been evicted due to memory constraints or the specified expiry having been reached, the data must be retrieved from the database.</span></span> <span data-ttu-id="f1d2d-121">因此，这些用户请求所用的时间超过了可由缓存提供服务的用户请求。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-121">Therefore, these users requests will take longer than users requests that can be served by the cache.</span></span>

<span data-ttu-id="f1d2d-122">*主动加载*提供备用缓存管理策略，可在需要时通过加载缓存数据来平滑处理请求的性能。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-122">*Proactive loading* provides an alternative cache management strategy that smoothes out the performance across requests by loading the cached data before it's needed.</span></span> <span data-ttu-id="f1d2d-123">通常情况下，主动加载将使用在已对基础数据进行更新时定期检查或通知的某个进程。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-123">Typically, proactive loading uses some process that either periodically checks or is notified when there has been an update to the underlying data.</span></span> <span data-ttu-id="f1d2d-124">然后，此过程更新缓存以使其保持最新。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-124">This process then updates the cache to keep it fresh.</span></span> <span data-ttu-id="f1d2d-125">如果基础数据来自慢速数据库连接、Web 服务或其他一些特别缓慢的数据源，则主动加载特别有用。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-125">Proactive loading is especially useful if the underlying data comes from a slow database connection, a Web service, or some other particularly sluggish data source.</span></span> <span data-ttu-id="f1d2d-126">但这种主动加载方法更难实现，因为这种方法需要创建、管理和部署一个过程来检查更改和更新缓存。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-126">But this approach to proactive loading is more difficult to implement, as it requires creating, managing, and deploying a process to check for changes and update the cache.</span></span>

<span data-ttu-id="f1d2d-127">主动加载的另一种风格和我们在本教程中要探讨的类型是在应用程序启动时将数据加载到缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-127">Another flavor of proactive loading, and the type we'll be exploring in this tutorial, is loading data into the cache at application startup.</span></span> <span data-ttu-id="f1d2d-128">此方法特别适用于缓存静态数据，如数据库查找表中的记录。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-128">This approach is especially useful for caching static data, such as the records in database lookup tables.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d2d-129">若要更深入地了解主动和被动加载之间的差异，以及优缺点的优点、缺点和实施建议，请参阅[.NET Framework 应用程序的缓存体系结构指南](https://msdn.microsoft.com/library/ms978498.aspx)的[管理缓存内容](https://msdn.microsoft.com/library/ms978503.aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-129">For a more in-depth look at the differences between proactive and reactive loading, as well as lists of pros, cons, and implementation recommendations, refer to the [Managing the Contents of a Cache](https://msdn.microsoft.com/library/ms978503.aspx) section of the [Caching Architecture Guide for .NET Framework Applications](https://msdn.microsoft.com/library/ms978498.aspx).</span></span>

## <a name="step-1-determining-what-data-to-cache-at-application-startup"></a><span data-ttu-id="f1d2d-130">步骤1：确定要在应用程序启动时缓存的数据</span><span class="sxs-lookup"><span data-stu-id="f1d2d-130">Step 1: Determining What Data to Cache at Application Startup</span></span>

<span data-ttu-id="f1d2d-131">使用前两个教程中所述的 "被动" 加载的缓存示例适用于可能会定期更改且不需要 exorbitantly 长时间生成的数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-131">The caching examples using reactive loading that we examined in the previous two tutorials work well with data that may periodically change and does not take exorbitantly long to generate.</span></span> <span data-ttu-id="f1d2d-132">但是，如果缓存的数据永远不会发生更改，则被动加载所使用的过期时间将是多余的。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-132">But if the cached data never changes, the expiry used by reactive loading is superfluous.</span></span> <span data-ttu-id="f1d2d-133">同样，如果要缓存的数据需要很长时间才能生成，则在检索基础数据时，其请求查找缓存为空的用户必须经受较长的等待时间。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-133">Likewise, if the data being cached takes an exceedingly long time to generate, then those users whose requests find the cache empty will have to endure a lengthy wait while the underlying data is retrieved.</span></span> <span data-ttu-id="f1d2d-134">请考虑缓存静态数据，以及在应用程序启动时需要很长时间生成的数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-134">Consider caching static data and data that takes an exceptionally long time to generate at application startup.</span></span>

<span data-ttu-id="f1d2d-135">尽管数据库具有很多动态、频繁变化的值，但大多数情况下也有大量静态数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-135">While databases have many dynamic, frequently-changing values, most also have a fair amount of static data.</span></span> <span data-ttu-id="f1d2d-136">例如，几乎所有数据模型都具有一个或多个列，其中包含一组固定的选项中的特定值。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-136">For example, virtually all data models have one or more columns that contain a particular value from a fixed set of choices.</span></span> <span data-ttu-id="f1d2d-137">`Patients` 数据库表可能有一个 `PrimaryLanguage` 列，其值集可能是英语、西班牙语、法语、俄语、日语等。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-137">A `Patients` database table might have a `PrimaryLanguage` column, whose set of values could be English, Spanish, French, Russian, Japanese, and so on.</span></span> <span data-ttu-id="f1d2d-138">通常，这些类型的列是使用*查找表*实现的。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-138">Oftentimes, these types of columns are implemented using *lookup tables*.</span></span> <span data-ttu-id="f1d2d-139">不是将字符串英语或法语存储在 `Patients` 表中，而是创建第二个表，其中通常包含两列：唯一标识符和字符串说明-对于每个可能的值都有一条记录。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-139">Rather than storing the string English or French in the `Patients` table, a second table is created that has, commonly, two columns - a unique identifier and a string description - with a record for each possible value.</span></span> <span data-ttu-id="f1d2d-140">`Patients` 表中的 `PrimaryLanguage` 列存储查找表中对应的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-140">The `PrimaryLanguage` column in the `Patients` table stores the corresponding unique identifier in the lookup table.</span></span> <span data-ttu-id="f1d2d-141">在图1中，患者 John Doe 的主要语言是英语，而 Ed Johnson 是俄语。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-141">In Figure 1, patient John Doe's primary language is English, while Ed Johnson's is Russian.</span></span>

!["语言" 表是 "患者" 表使用的查找表](caching-data-at-application-startup-cs/_static/image1.png)

<span data-ttu-id="f1d2d-143">**图 1**： `Languages` 表是 `Patients` 表使用的查找表</span><span class="sxs-lookup"><span data-stu-id="f1d2d-143">**Figure 1**: The `Languages` Table is a Lookup Table Used by the `Patients` Table</span></span>

<span data-ttu-id="f1d2d-144">用于编辑或创建新患者的用户界面将包括由 `Languages` 表中的记录填充的允许语言的下拉列表。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-144">The user interface for editing or creating a new patient would include a drop-down list of allowable languages populated by the records in the `Languages` table.</span></span> <span data-ttu-id="f1d2d-145">如果不进行缓存，则每次访问该接口时，系统都必须查询 `Languages` 表。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-145">Without caching, each time this interface is visited the system must query the `Languages` table.</span></span> <span data-ttu-id="f1d2d-146">因为查找表值更改很少（如果有），所以这是不必要的。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-146">This is wasteful and unnecessary since lookup table values change very infrequently, if ever.</span></span>

<span data-ttu-id="f1d2d-147">我们可以使用前面教程中所述的相同反应加载方法来缓存 `Languages` 数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-147">We could cache the `Languages` data using the same reactive loading techniques examined in the previous tutorials.</span></span> <span data-ttu-id="f1d2d-148">但是，反应性加载将使用基于时间的过期，这对于静态查找表数据不是必需的。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-148">Reactive loading, however, uses a time-based expiry, which is not needed for static lookup table data.</span></span> <span data-ttu-id="f1d2d-149">虽然使用被动加载的缓存比根本不缓存更好，但最好的方法是在应用程序启动时，将查找表数据主动加载到缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-149">While caching using reactive loading would be better than no caching at all, the best approach would be to proactively load the lookup table data into the cache at application startup.</span></span>

<span data-ttu-id="f1d2d-150">在本教程中，我们将介绍如何缓存查找表数据和其他静态信息。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-150">In this tutorial we will look at how to cache lookup table data and other static information.</span></span>

## <a name="step-2-examining-the-different-ways-to-cache-data"></a><span data-ttu-id="f1d2d-151">步骤2：检查缓存数据的不同方式</span><span class="sxs-lookup"><span data-stu-id="f1d2d-151">Step 2: Examining the Different Ways to Cache Data</span></span>

<span data-ttu-id="f1d2d-152">可以使用多种方法以编程方式在 ASP.NET 应用程序中缓存信息。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-152">Information can be programmatically cached in an ASP.NET application using a variety of approaches.</span></span> <span data-ttu-id="f1d2d-153">我们已在前面的教程中了解到如何使用数据缓存。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-153">We ve already seen how to use the data cache in previous tutorials.</span></span> <span data-ttu-id="f1d2d-154">或者，可以使用*静态成员*或*应用程序状态*以编程方式缓存对象。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-154">Alternatively, objects can be programmatically cached using *static members* or *application state*.</span></span>

<span data-ttu-id="f1d2d-155">使用类时，通常必须先对类进行实例化，然后才能访问其成员。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-155">When working with a class, typically the class must first be instantiated before its members can be accessed.</span></span> <span data-ttu-id="f1d2d-156">例如，若要从我们的业务逻辑层中的某个类调用方法，必须首先创建类的实例：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-156">For example, in order to invoke a method from one of the classes in our Business Logic Layer, we must first create an instance of the class:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample1.cs)]

<span data-ttu-id="f1d2d-157">在可以调用*SomeMethod*或使用*SomeProperty*之前，必须先使用 `new` 关键字创建类的实例。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-157">Before we can invoke *SomeMethod* or work with *SomeProperty*, we must first create an instance of the class using the `new` keyword.</span></span> <span data-ttu-id="f1d2d-158">*SomeMethod*和*SomeProperty*与特定实例关联。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-158">*SomeMethod* and *SomeProperty* are associated with a particular instance.</span></span> <span data-ttu-id="f1d2d-159">这些成员的生存期与其关联对象的生存期相关联。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-159">The lifetime of these members is tied to the lifetime of their associated object.</span></span> <span data-ttu-id="f1d2d-160">另一方面，*静态成员*是在类的*所有*实例之间共享的变量、属性和方法，因此，其生存期与类相同。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-160">*Static members*, on the other hand, are variables, properties, and methods that are shared among *all* instances of the class and, consequently, have a lifetime as long as the class.</span></span> <span data-ttu-id="f1d2d-161">静态成员由关键字 `static`表示。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-161">Static members are denoted by the keyword `static`.</span></span>

<span data-ttu-id="f1d2d-162">除了静态成员以外，还可以使用应用程序状态来缓存数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-162">In addition to static members, data can be cached using application state.</span></span> <span data-ttu-id="f1d2d-163">每个 ASP.NET 应用程序都维护一个在应用程序的所有用户和页面之间共享的名称/值集合。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-163">Each ASP.NET application maintains a name/value collection that's shared across all users and pages of the application.</span></span> <span data-ttu-id="f1d2d-164">可以使用[`HttpContext` 类](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)的[`Application` 属性](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx)访问此集合，并使用 ASP.NET 页的代码隐藏类（如下所示）：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-164">This collection can be accessed using the [`HttpContext` class](https://msdn.microsoft.com/library/system.web.httpcontext.aspx)'s [`Application` property](https://msdn.microsoft.com/library/system.web.httpcontext.application.aspx), and used from an ASP.NET page's code-behind class like so:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample2.cs)]

<span data-ttu-id="f1d2d-165">数据缓存提供了一种更丰富的 API 用于缓存数据，并提供基于时间和依赖依赖关系的 expiries、缓存项优先级等的机制。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-165">The data cache provides a much richer API for caching data, providing mechanisms for time- and dependency-based expiries, cache item priorities, and so forth.</span></span> <span data-ttu-id="f1d2d-166">对于静态成员和应用程序状态，页面开发人员必须手动添加此类功能。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-166">With static members and application state, such features must be manually added by the page developer.</span></span> <span data-ttu-id="f1d2d-167">但是，在应用程序的生存期内缓存数据时，数据缓存的优点是差异。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-167">When caching data at application startup for the lifetime of the application, however, the data cache's advantages are moot.</span></span> <span data-ttu-id="f1d2d-168">在本教程中，我们将介绍使用所有三种方法来缓存静态数据的代码。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-168">In this tutorial we'll look at code that uses all three techniques for caching static data.</span></span>

## <a name="step-3-caching-thesupplierstable-data"></a><span data-ttu-id="f1d2d-169">步骤3：缓存`Suppliers`表数据</span><span class="sxs-lookup"><span data-stu-id="f1d2d-169">Step 3: Caching the`Suppliers`Table Data</span></span>

<span data-ttu-id="f1d2d-170">我们迄今为止实现的 Northwind 数据库表不包含任何传统的查找表。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-170">The Northwind database tables we ve implemented to date do not include any traditional lookup tables.</span></span> <span data-ttu-id="f1d2d-171">在我们的 DAL 中实现的四个数据表都是值是非静态的模型表。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-171">The four DataTables implemented in our DAL all model tables whose values are non-static.</span></span> <span data-ttu-id="f1d2d-172">对于本教程，我们只是假设 `Suppliers` 表的数据是静态的，而不是花时间将新的 DataTable 添加到 DAL，然后将新的类和方法添加到 BLL。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-172">Rather than spending the time to add a new DataTable to the DAL and then a new class and methods to the BLL, for this tutorial let's just pretend that the `Suppliers` table's data is static.</span></span> <span data-ttu-id="f1d2d-173">因此，我们可以在应用程序启动时缓存此数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-173">Therefore, we could cache this data at application startup.</span></span>

<span data-ttu-id="f1d2d-174">若要开始，请在 `CL` 文件夹中创建一个名为 `StaticCache.cs` 的新类。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-174">To start, create a new class named `StaticCache.cs` in the `CL` folder.</span></span>

![在 CL 文件夹中创建 StaticCache.cs 类](caching-data-at-application-startup-cs/_static/image2.png)

<span data-ttu-id="f1d2d-176">**图 2**：在 `CL` 文件夹中创建 `StaticCache.cs` 类</span><span class="sxs-lookup"><span data-stu-id="f1d2d-176">**Figure 2**: Create the `StaticCache.cs` Class in the `CL` Folder</span></span>

<span data-ttu-id="f1d2d-177">我们需要添加一个方法，用于在启动时将数据加载到相应的缓存存储中，以及从该缓存返回数据的方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-177">We need to add a method that loads the data at startup into the appropriate cache store, as well as methods that return data from this cache.</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample3.cs)]

<span data-ttu-id="f1d2d-178">上面的代码使用静态成员变量 `suppliers`来保存 `SuppliersBLL` 类 `GetSuppliers()` 方法的结果，该方法是从 `LoadStaticCache()` 方法调用的。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-178">The above code uses a static member variable, `suppliers`, to hold the results from the `SuppliersBLL` class's `GetSuppliers()` method, which is called from the `LoadStaticCache()` method.</span></span> <span data-ttu-id="f1d2d-179">在应用程序启动过程中，将调用 `LoadStaticCache()` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-179">The `LoadStaticCache()` method is meant to be called during the application's start.</span></span> <span data-ttu-id="f1d2d-180">在应用程序启动时加载此数据后，需要使用供应商数据的任何页面都可以调用 `StaticCache` 类的 `GetSuppliers()` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-180">Once this data has been loaded at application startup, any page that needs to work with supplier data can call the `StaticCache` class's `GetSuppliers()` method.</span></span> <span data-ttu-id="f1d2d-181">因此，在应用程序启动时，对数据库的调用只会出现一次。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-181">Therefore, the call to the database to get the suppliers only happens once, at application start.</span></span>

<span data-ttu-id="f1d2d-182">我们可以使用或使用应用程序状态或数据缓存，而不是使用静态成员变量作为缓存存储区。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-182">Rather than using a static member variable as the cache store, we could have alternatively used application state or the data cache.</span></span> <span data-ttu-id="f1d2d-183">下面的代码演示重组的类以使用应用程序状态：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-183">The following code shows the class retooled to use application state:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample4.cs)]

<span data-ttu-id="f1d2d-184">在 `LoadStaticCache()`中，提供商信息存储到应用程序变量*键*。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-184">In `LoadStaticCache()`, the supplier information is stored to the application variable *key*.</span></span> <span data-ttu-id="f1d2d-185">它作为相应的类型（`Northwind.SuppliersDataTable`）从 `GetSuppliers()`中返回。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-185">It's returned as the appropriate type (`Northwind.SuppliersDataTable`) from `GetSuppliers()`.</span></span> <span data-ttu-id="f1d2d-186">尽管可以使用 `Application["key"]`在 ASP.NET 页面的代码隐藏类中访问应用程序状态，但在体系结构中，我们必须使用 `HttpContext.Current.Application["key"]` 才能获取当前 `HttpContext`。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-186">While application state can be accessed in the code-behind classes of ASP.NET pages using `Application["key"]`, in the architecture we must use `HttpContext.Current.Application["key"]` in order to get the current `HttpContext`.</span></span>

<span data-ttu-id="f1d2d-187">同样，可以将数据缓存用作缓存存储，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-187">Likewise, the data cache can be used as a cache store, as the following code shows:</span></span>

[!code-csharp[Main](caching-data-at-application-startup-cs/samples/sample5.cs)]

<span data-ttu-id="f1d2d-188">若要将项添加到数据缓存，但不使用基于时间的过期时间，请使用 `System.Web.Caching.Cache.NoAbsoluteExpiration`，并 `System.Web.Caching.Cache.NoSlidingExpiration` 值作为输入参数。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-188">To add an item to the data cache with no time-based expiry, use the `System.Web.Caching.Cache.NoAbsoluteExpiration` and `System.Web.Caching.Cache.NoSlidingExpiration` values as input parameters.</span></span> <span data-ttu-id="f1d2d-189">选择了数据缓存 `Insert` 方法的特定重载，以便可以指定缓存项的*优先级*。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-189">This particular overload of the data cache's `Insert` method was selected so that we could specify the *priority* of the cache item.</span></span> <span data-ttu-id="f1d2d-190">当可用内存不足时，该优先级用于确定要从缓存中清除哪些项。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-190">The priority is used to determine what items to scavenge from the cache when available memory runs low.</span></span> <span data-ttu-id="f1d2d-191">此处，我们使用 priority `NotRemovable`，这可以确保不会清理此缓存项。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-191">Here we use the priority `NotRemovable`, which ensures that this cache item won't be scavenged.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d2d-192">本教程的下载将使用静态成员变量方法实现 `StaticCache` 类。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-192">This tutorial's download implements the `StaticCache` class using the static member variable approach.</span></span> <span data-ttu-id="f1d2d-193">类文件的注释中提供了应用程序状态和数据缓存技术的代码。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-193">The code for the application state and data cache techniques is available in the comments in the class file.</span></span>

## <a name="step-4-executing-code-at-application-startup"></a><span data-ttu-id="f1d2d-194">步骤4：在应用程序启动时执行代码</span><span class="sxs-lookup"><span data-stu-id="f1d2d-194">Step 4: Executing Code at Application Startup</span></span>

<span data-ttu-id="f1d2d-195">若要在 web 应用程序首次启动时执行代码，我们需要创建一个名为 `Global.asax`的特殊文件。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-195">To execute code when a web application first starts, we need to create a special file named `Global.asax`.</span></span> <span data-ttu-id="f1d2d-196">此文件可以包含应用程序、会话和请求级事件的事件处理程序，并且可以在此处添加应用程序每次启动时执行的代码。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-196">This file can contain event handlers for application-, session-, and request-level events, and it is here where we can add code that will be executed whenever the application starts.</span></span>

<span data-ttu-id="f1d2d-197">在 Visual Studio 的解决方案资源管理器中右键单击网站项目名称，然后选择 "添加新项"，将 `Global.asax` 文件添加到 web 应用程序的根目录中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-197">Add the `Global.asax` file to your web application's root directory by right-clicking on the website project name in Visual Studio's Solution Explorer and choosing Add New Item.</span></span> <span data-ttu-id="f1d2d-198">从 "添加新项" 对话框中，选择 "全局应用程序类" 项类型，然后单击 "添加" 按钮。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-198">From the Add New Item dialog box, select the Global Application Class item type and then click the Add button.</span></span>

> [!NOTE]
> <span data-ttu-id="f1d2d-199">如果项目中已经有 `Global.asax` 文件，则 "添加新项" 对话框中将不会列出全局应用程序类项类型。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-199">If you already have a `Global.asax` file in your project, the Global Application Class item type will not be listed in the Add New Item dialog box.</span></span>

<span data-ttu-id="f1d2d-200">[![将 global.asax 文件添加到 Web 应用程序的根目录](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-200">[![Add the Global.asax File to Your Web Application's Root Directory](caching-data-at-application-startup-cs/_static/image4.png)](caching-data-at-application-startup-cs/_static/image3.png)</span></span>

<span data-ttu-id="f1d2d-201">**图 3**：将 `Global.asax` 文件添加到 Web 应用程序的根目录（[单击以查看完全大小的映像](caching-data-at-application-startup-cs/_static/image5.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d2d-201">**Figure 3**: Add the `Global.asax` File to Your Web Application's Root Directory ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image5.png))</span></span>

<span data-ttu-id="f1d2d-202">默认 `Global.asax` 文件模板在服务器端 `<script>` 标记中包含五个方法：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-202">The default `Global.asax` file template includes five methods within a server-side `<script>` tag:</span></span>

- <span data-ttu-id="f1d2d-203">**`Application_Start`** 在 web 应用程序首次启动时执行</span><span class="sxs-lookup"><span data-stu-id="f1d2d-203">**`Application_Start`** executes when the web application first starts</span></span>
- <span data-ttu-id="f1d2d-204">应用程序关闭时运行的 **`Application_End`**</span><span class="sxs-lookup"><span data-stu-id="f1d2d-204">**`Application_End`** runs when the application is shutting down</span></span>
- <span data-ttu-id="f1d2d-205">每当未处理的异常到达应用程序时， **`Application_Error`** 执行</span><span class="sxs-lookup"><span data-stu-id="f1d2d-205">**`Application_Error`** executes whenever an unhandled exception reaches the application</span></span>
- <span data-ttu-id="f1d2d-206">创建新会话时执行 **`Session_Start`**</span><span class="sxs-lookup"><span data-stu-id="f1d2d-206">**`Session_Start`** executes when a new session is created</span></span>
- <span data-ttu-id="f1d2d-207">会话过期或弃用时， **`Session_End`** 运行</span><span class="sxs-lookup"><span data-stu-id="f1d2d-207">**`Session_End`** runs when a session is expired or abandoned</span></span>

<span data-ttu-id="f1d2d-208">在应用程序的生命周期中，只调用一次 `Application_Start` 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-208">The `Application_Start` event handler is called only once during an application's life cycle.</span></span> <span data-ttu-id="f1d2d-209">应用程序在第一次从应用程序请求 ASP.NET 资源时开始运行，并在应用程序重新启动之前继续运行，这可能是通过修改 `/Bin` 文件夹的内容，修改 `Global.asax`，修改 `App_Code` 文件夹中的内容或修改 `Web.config` 文件的原因而发生。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-209">The application starts the first time an ASP.NET resource is requested from the application and continues to run until the application is restarted, which can happen by modifying the contents of the `/Bin` folder, modifying `Global.asax`, modifying the contents in the `App_Code` folder, or modifying the `Web.config` file, among other causes.</span></span> <span data-ttu-id="f1d2d-210">有关应用程序生命周期的详细讨论，请参阅[ASP.NET 应用程序生命周期概述](https://msdn.microsoft.com/library/ms178473.aspx)。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-210">Refer to [ASP.NET Application Life Cycle Overview](https://msdn.microsoft.com/library/ms178473.aspx) for a more detailed discussion on the application life cycle.</span></span>

<span data-ttu-id="f1d2d-211">对于这些教程，我们只需将代码添加到 `Application_Start` 方法，因此可随意删除其他方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-211">For these tutorials we only need to add code to the `Application_Start` method, so feel free to remove the others.</span></span> <span data-ttu-id="f1d2d-212">在 `Application_Start`中，只需调用 `StaticCache` 类的 `LoadStaticCache()` 方法，该方法将加载并缓存供应商信息：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-212">In `Application_Start`, simply call the `StaticCache` class's `LoadStaticCache()` method, which will load and cache the supplier information:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample6.aspx)]

<span data-ttu-id="f1d2d-213">就这么简单！</span><span class="sxs-lookup"><span data-stu-id="f1d2d-213">That's all there is to it!</span></span> <span data-ttu-id="f1d2d-214">在应用程序启动时，`LoadStaticCache()` 方法将从 BLL 获取供应商信息，并将其存储在静态成员变量中（或在 `StaticCache` 类中最后使用的任何缓存存储）。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-214">At application startup, the `LoadStaticCache()` method will grab the supplier information from the BLL, and store it in a static member variable (or whatever cache store you ended up using in the `StaticCache` class).</span></span> <span data-ttu-id="f1d2d-215">若要验证此行为，请在 `Application_Start` 方法中设置断点并运行应用程序。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-215">To verify this behavior, set a breakpoint in the `Application_Start` method and run your application.</span></span> <span data-ttu-id="f1d2d-216">请注意，将在应用程序启动时命中该断点。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-216">Note that the breakpoint is hit upon the application starting.</span></span> <span data-ttu-id="f1d2d-217">但后续请求不会导致执行 `Application_Start` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-217">Subsequent requests, however, do not cause the `Application_Start` method to execute.</span></span>

<span data-ttu-id="f1d2d-218">[![使用断点验证是否正在执行 Application_Start 事件处理程序](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-218">[![Use a Breakpoint to Verify that the Application_Start Event Handler is Being Executed](caching-data-at-application-startup-cs/_static/image7.png)](caching-data-at-application-startup-cs/_static/image6.png)</span></span>

<span data-ttu-id="f1d2d-219">**图 4**：使用断点验证是否正在执行 `Application_Start` 事件处理程序（[单击查看完全大小的映像](caching-data-at-application-startup-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d2d-219">**Figure 4**: Use a Breakpoint to Verify that the `Application_Start` Event Handler is Being Executed ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image8.png))</span></span>

> [!NOTE]
> <span data-ttu-id="f1d2d-220">如果在首次启动调试时未命中 `Application_Start` 断点，则是因为应用程序已启动。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-220">If you do not hit the `Application_Start` breakpoint when you first start debugging, it is because your application has already started.</span></span> <span data-ttu-id="f1d2d-221">通过修改 `Global.asax` 或 `Web.config` 文件来强制应用程序重启，然后重试。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-221">Force the application to restart by modifying your `Global.asax` or `Web.config` files and then try again.</span></span> <span data-ttu-id="f1d2d-222">您可以在其中一个文件的末尾添加（或删除）空白行，以快速重新启动该应用程序。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-222">You can simply add (or remove) a blank line at the end of one of these files to quickly restart the application.</span></span>

## <a name="step-5-displaying-the-cached-data"></a><span data-ttu-id="f1d2d-223">步骤5：显示缓存的数据</span><span class="sxs-lookup"><span data-stu-id="f1d2d-223">Step 5: Displaying the Cached Data</span></span>

<span data-ttu-id="f1d2d-224">此时，`StaticCache` 类具有在应用程序启动时缓存的供应商数据版本，可通过其 `GetSuppliers()` 方法进行访问。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-224">At this point the `StaticCache` class has a version of the supplier data cached at application startup that can be accessed through its `GetSuppliers()` method.</span></span> <span data-ttu-id="f1d2d-225">若要在表示层处理此类数据，可以使用 ObjectDataSource 或以编程方式从 ASP.NET 页的代码隐藏类调用 `StaticCache` 类的 `GetSuppliers()` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-225">To work with this data from the Presentation Layer, we can use an ObjectDataSource or programmatically invoke the `StaticCache` class's `GetSuppliers()` method from an ASP.NET page's code-behind class.</span></span> <span data-ttu-id="f1d2d-226">让我们看一下如何使用 ObjectDataSource 和 GridView 控件显示缓存的供应商信息。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-226">Let's look at using the ObjectDataSource and GridView controls to display the cached supplier information.</span></span>

<span data-ttu-id="f1d2d-227">首先打开 `Caching` 文件夹中的 "`AtApplicationStartup.aspx`" 页。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-227">Start by opening the `AtApplicationStartup.aspx` page in the `Caching` folder.</span></span> <span data-ttu-id="f1d2d-228">将 GridView 从工具箱拖到设计器上，将其 `ID` 属性设置为 `Suppliers`。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-228">Drag a GridView from the Toolbox onto the designer, setting its `ID` property to `Suppliers`.</span></span> <span data-ttu-id="f1d2d-229">接下来，在 GridView 的智能标记中，选择创建名为 `SuppliersCachedDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-229">Next, from the GridView's smart tag choose to create a new ObjectDataSource named `SuppliersCachedDataSource`.</span></span> <span data-ttu-id="f1d2d-230">将 ObjectDataSource 配置为使用 `StaticCache` 类的 `GetSuppliers()` 方法。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-230">Configure the ObjectDataSource to use the `StaticCache` class's `GetSuppliers()` method.</span></span>

<span data-ttu-id="f1d2d-231">[![将 ObjectDataSource 配置为使用 StaticCache 类](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-231">[![Configure the ObjectDataSource to use the StaticCache Class](caching-data-at-application-startup-cs/_static/image10.png)](caching-data-at-application-startup-cs/_static/image9.png)</span></span>

<span data-ttu-id="f1d2d-232">**图 5**：将 ObjectDataSource 配置为使用 `StaticCache` 类（[单击以查看完全大小的映像](caching-data-at-application-startup-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d2d-232">**Figure 5**: Configure the ObjectDataSource to use the `StaticCache` Class ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image11.png))</span></span>

<span data-ttu-id="f1d2d-233">[![使用 GetSuppliers （）方法检索缓存的供应商数据](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-233">[![Use the GetSuppliers() Method to Retrieve the Cached Supplier Data](caching-data-at-application-startup-cs/_static/image13.png)](caching-data-at-application-startup-cs/_static/image12.png)</span></span>

<span data-ttu-id="f1d2d-234">**图 6**：使用 `GetSuppliers()` 方法检索缓存的供应商数据（[单击查看完全大小的图像](caching-data-at-application-startup-cs/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d2d-234">**Figure 6**: Use the `GetSuppliers()` Method to Retrieve the Cached Supplier Data ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image14.png))</span></span>

<span data-ttu-id="f1d2d-235">完成向导后，Visual Studio 将自动为 `SuppliersDataTable`中的每个数据字段添加 BoundFields。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-235">After completing the wizard, Visual Studio will automatically add BoundFields for each of the data fields in `SuppliersDataTable`.</span></span> <span data-ttu-id="f1d2d-236">GridView 和 ObjectDataSource 的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="f1d2d-236">Your GridView and ObjectDataSource's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](caching-data-at-application-startup-cs/samples/sample7.aspx)]

<span data-ttu-id="f1d2d-237">图7显示了通过浏览器查看的页面。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-237">Figure 7 shows the page when viewed through a browser.</span></span> <span data-ttu-id="f1d2d-238">由于我们从 BLL 的 `SuppliersBLL` 类中提取数据，因此输出是相同的，但使用 `StaticCache` 类返回在应用程序启动时缓存的供应商数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-238">The output is the same had we pulled the data from the BLL's `SuppliersBLL` class, but using the `StaticCache` class returns the supplier data as cached at application startup.</span></span> <span data-ttu-id="f1d2d-239">可以在 `StaticCache` 类的 `GetSuppliers()` 方法中设置断点来验证此行为。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-239">You can set breakpoints in the `StaticCache` class's `GetSuppliers()` method to verify this behavior.</span></span>

<span data-ttu-id="f1d2d-240">[![缓存的供应商数据显示在 GridView 中](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-240">[![The Cached Supplier Data is Displayed in a GridView](caching-data-at-application-startup-cs/_static/image16.png)](caching-data-at-application-startup-cs/_static/image15.png)</span></span>

<span data-ttu-id="f1d2d-241">**图 7**：在 GridView 中显示缓存的供应商数据（[单击以查看完全大小的图像](caching-data-at-application-startup-cs/_static/image17.png)）</span><span class="sxs-lookup"><span data-stu-id="f1d2d-241">**Figure 7**: The Cached Supplier Data is Displayed in a GridView ([Click to view full-size image](caching-data-at-application-startup-cs/_static/image17.png))</span></span>

## <a name="summary"></a><span data-ttu-id="f1d2d-242">摘要</span><span class="sxs-lookup"><span data-stu-id="f1d2d-242">Summary</span></span>

<span data-ttu-id="f1d2d-243">大多数数据模型都包含大量静态数据，通常以查找表的形式实现。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-243">Most every data model contains a fair amount of static data, usually implemented in the form of lookup tables.</span></span> <span data-ttu-id="f1d2d-244">由于此信息是静态的，因此在每次需要显示此信息时，无需持续访问数据库。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-244">Since this information is static, there's no reason to continually access the database each time this information needs to be displayed.</span></span> <span data-ttu-id="f1d2d-245">而且，在缓存数据时，由于其静态性质，无需过期。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-245">Furthermore, due to its static nature, when caching the data there's no need for an expiry.</span></span> <span data-ttu-id="f1d2d-246">在本教程中，我们介绍了如何使用此类数据并将其缓存到数据缓存、应用程序状态和静态成员变量中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-246">In this tutorial we saw how to take such data and cache it in the data cache, application state, and through a static member variable.</span></span> <span data-ttu-id="f1d2d-247">此信息在应用程序启动时缓存，并在应用程序的整个生存期内保留在缓存中。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-247">This information is cached at application startup and remains in the cache throughout the application's lifetime.</span></span>

<span data-ttu-id="f1d2d-248">在本教程和过去的两个教程中，我们已在应用程序的生存期和使用基于时间的 expiries 的持续时间内查看缓存数据。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-248">In this tutorial and the past two, we ve looked at caching data for the duration of the application's lifetime as well as using time-based expiries.</span></span> <span data-ttu-id="f1d2d-249">但是，在缓存数据库数据时，基于时间的到期时间可能会低于理想的时间。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-249">When caching database data, though, a time-based expiry may be less than ideal.</span></span> <span data-ttu-id="f1d2d-250">不会定期刷新缓存，只是在修改基础数据库数据时才会逐出缓存的项。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-250">Rather than periodically flushing the cache, it would be optimal to only evict the cached item when the underlying database data is modified.</span></span> <span data-ttu-id="f1d2d-251">使用 SQL 缓存依赖项可以实现此理想选择，我们将在下一教程中对此进行介绍。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-251">This ideal is possible through the use of SQL cache dependencies, which we'll examine in our next tutorial.</span></span>

<span data-ttu-id="f1d2d-252">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="f1d2d-252">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="f1d2d-253">关于作者</span><span class="sxs-lookup"><span data-stu-id="f1d2d-253">About the Author</span></span>

<span data-ttu-id="f1d2d-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-254">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="f1d2d-255">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-255">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="f1d2d-256">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-256">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="f1d2d-257">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-257">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="f1d2d-258">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-258">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="f1d2d-259">特别感谢</span><span class="sxs-lookup"><span data-stu-id="f1d2d-259">Special Thanks To</span></span>

<span data-ttu-id="f1d2d-260">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-260">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="f1d2d-261">本教程的领导评审者是 Teresa Murphy 和 Zack。</span><span class="sxs-lookup"><span data-stu-id="f1d2d-261">Lead reviewers for this tutorial were Teresa Murphy and Zack Jones.</span></span> <span data-ttu-id="f1d2d-262">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="f1d2d-262">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="f1d2d-263">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-263">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="f1d2d-264">[上一页](caching-data-in-the-architecture-cs.md)
> [下一页](using-sql-cache-dependencies-cs.md)</span><span class="sxs-lookup"><span data-stu-id="f1d2d-264">[Previous](caching-data-in-the-architecture-cs.md)
[Next](using-sql-cache-dependencies-cs.md)</span></span>

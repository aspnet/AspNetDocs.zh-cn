---
uid: web-forms/overview/data-access/caching-data/using-sql-cache-dependencies-cs
title: 使用 SQL 缓存依赖项C#（） |Microsoft Docs
author: rick-anderson
description: 最简单的缓存策略是允许缓存数据在指定的时间段后过期。 但这种简单的方法意味着缓存的数据 maintai
ms.author: riande
ms.date: 05/30/2007
ms.assetid: 0e91842c-7f10-4aed-8c23-4ee3e2774014
msc.legacyurl: /web-forms/overview/data-access/caching-data/using-sql-cache-dependencies-cs
msc.type: authoredcontent
ms.openlocfilehash: 5bc27a08e39606c25b8f99d6ea057d2a853f08a6
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78443084"
---
# <a name="using-sql-cache-dependencies-c"></a><span data-ttu-id="0c0ff-104">使用 SQL 缓存依赖项 (C#)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-104">Using SQL Cache Dependencies (C#)</span></span>

<span data-ttu-id="0c0ff-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="0c0ff-106">[下载代码](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_61_CS.zip)或[下载 PDF](using-sql-cache-dependencies-cs/_static/datatutorial61cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_61_CS.zip) or [Download PDF](using-sql-cache-dependencies-cs/_static/datatutorial61cs1.pdf)</span></span>

> <span data-ttu-id="0c0ff-107">最简单的缓存策略是允许缓存数据在指定的时间段后过期。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-107">The simplest caching strategy is to allow cached data to expire after a specified period of time.</span></span> <span data-ttu-id="0c0ff-108">但这种简单的方法意味着缓存的数据与其基础数据源不保持关联，导致陈旧的数据过长或当前过期的数据太快过期。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-108">But this simple approach means that the cached data maintains no association with its underlying data source, resulting in stale data that is held too long or current data that is expired too soon.</span></span> <span data-ttu-id="0c0ff-109">更好的方法是使用 SqlCacheDependency 类，以便在 SQL 数据库中修改数据之前，数据将一直保持缓存状态。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-109">A better approach is to use the SqlCacheDependency class so that data remains cached until its underlying data has been modified in the SQL database.</span></span> <span data-ttu-id="0c0ff-110">本教程将向您介绍如何操作。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-110">This tutorial shows you how.</span></span>

## <a name="introduction"></a><span data-ttu-id="0c0ff-111">简介</span><span class="sxs-lookup"><span data-stu-id="0c0ff-111">Introduction</span></span>

<span data-ttu-id="0c0ff-112">使用 "体系结构" 教程中的 ObjectDataSource 和[缓存数据](caching-data-in-the-architecture-cs.md)在[缓存数据](caching-data-with-the-objectdatasource-cs.md)中检查的缓存方法使用基于时间的过期，在指定的时间段后从缓存中逐出数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-112">The caching techniques examined in the [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md) and [Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) tutorials used a time-based expiry to evict the data from the cache after a specified period.</span></span> <span data-ttu-id="0c0ff-113">这种方法是在缓存性能提高与数据过期情况之间取得平衡的最简单方法。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-113">This approach is the simplest way to balance the performance gains of caching against data staleness.</span></span> <span data-ttu-id="0c0ff-114">通过选择时间为*x*秒的时间，页面开发人员只需为*x*秒的缓存提供性能优势，但 concedes 的数据将永远不会超过最长*x*秒的时间。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-114">By selecting a time expiry of *x* seconds, a page developer concedes to enjoy the performance benefits of caching for only *x* seconds, but can rest easy that her data will never be stale longer than a maximum of *x* seconds.</span></span> <span data-ttu-id="0c0ff-115">当然，对于静态数据， *x*可以扩展到 web 应用程序的生存期，如在[应用程序启动时缓存数据](caching-data-at-application-startup-cs.md)教程中所述。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-115">Of course, for static data, *x* can be extended to the lifetime of the web application, as was examined in the [Caching Data at Application Startup](caching-data-at-application-startup-cs.md) tutorial.</span></span>

<span data-ttu-id="0c0ff-116">在缓存数据库数据时，通常会选择基于时间的过期，以方便使用，但这通常是一种不充分的解决方案。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-116">When caching database data, a time-based expiry is often chosen for its ease of use but is frequently an inadequate solution.</span></span> <span data-ttu-id="0c0ff-117">理想情况下，数据库数据将保持缓存状态，直到在数据库中修改了基础数据时;只有这样才会逐出缓存。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-117">Ideally, the database data would remain cached until the underlying data has been modified in the database; only then would the cache be evicted.</span></span> <span data-ttu-id="0c0ff-118">此方法可最大程度地提高缓存性能，并最大程度地减少过时数据的持续时间。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-118">This approach maximizes the performance benefits of caching and minimizes the duration of stale data.</span></span> <span data-ttu-id="0c0ff-119">但是，为了享受这些权益，必须有一些系统知道何时修改了基础数据库数据，并从缓存中逐出了相应的项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-119">However, in order to enjoy these benefits there must be some system in place that knows when the underlying database data has been modified and evicts the corresponding items from the cache.</span></span> <span data-ttu-id="0c0ff-120">在 ASP.NET 2.0 之前，页面开发人员负责实现此系统。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-120">Prior to ASP.NET 2.0, page developers were responsible for implementing this system.</span></span>

<span data-ttu-id="0c0ff-121">ASP.NET 2.0 提供[`SqlCacheDependency` 类](https://msdn.microsoft.com/library/system.web.caching.sqlcachedependency.aspx)和必要的基础结构，以确定数据库中发生更改的时间，以便可以逐出相应的缓存项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-121">ASP.NET 2.0 provides a [`SqlCacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.sqlcachedependency.aspx) and the necessary infrastructure to determine when a change has occurred in the database so that the corresponding cached items can be evicted.</span></span> <span data-ttu-id="0c0ff-122">可通过两种方法来确定基础数据更改的时间：通知和轮询。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-122">There are two techniques for determining when the underlying data has changed: notification and polling.</span></span> <span data-ttu-id="0c0ff-123">讨论了通知与轮询之间的差异后，我们将创建支持轮询所需的基础结构，并探索如何在声明性和编程方案中使用 `SqlCacheDependency` 类。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-123">After discussing the differences between notification and polling, we'll create the infrastructure necessary to support polling and then explore how to use the `SqlCacheDependency` class in declarative and programmatically scenarios.</span></span>

## <a name="understanding-notification-and-polling"></a><span data-ttu-id="0c0ff-124">了解通知和轮询</span><span class="sxs-lookup"><span data-stu-id="0c0ff-124">Understanding Notification and Polling</span></span>

<span data-ttu-id="0c0ff-125">可以使用两种方法来确定何时修改数据库中的数据：通知和轮询。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-125">There are two techniques that can be used to determine when the data in a database has been modified: notification and polling.</span></span> <span data-ttu-id="0c0ff-126">使用通知时，数据库将在上次执行查询后更改了特定查询的结果时，自动对 ASP.NET 运行时发出警报，此时将逐出与查询关联的缓存项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-126">With notification, the database automatically alerts the ASP.NET runtime when the results of a particular query have been changed since the query was last executed, at which point the cached items associated with the query are evicted.</span></span> <span data-ttu-id="0c0ff-127">使用轮询，数据库服务器将保留有关特定表上次更新时间的信息。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-127">With polling, the database server maintains information about when particular tables have last been updated.</span></span> <span data-ttu-id="0c0ff-128">ASP.NET 运行时定期轮询数据库，以检查自将哪些表输入缓存后，哪些表发生了更改。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-128">The ASP.NET runtime periodically polls the database to check what tables have changed since they were entered into the cache.</span></span> <span data-ttu-id="0c0ff-129">已修改其数据的那些表的关联缓存项被逐出。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-129">Those tables whose data has been modified have their associated cache items evicted.</span></span>

<span data-ttu-id="0c0ff-130">通知选项所需的安装比轮询少，并且更精细，因为它在查询级别（而不是表级别）跟踪更改。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-130">The notification option requires less setup than polling and is more granular since it tracks changes at the query level rather than at the table level.</span></span> <span data-ttu-id="0c0ff-131">遗憾的是，通知仅在 Microsoft SQL Server 2005 （即非 Express 版本）的完整版中提供。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-131">Unfortunately, notifications are only available in the full editions of Microsoft SQL Server 2005 (i.e., the non-Express editions).</span></span> <span data-ttu-id="0c0ff-132">但是，轮询选项可用于从7.0 到 2005 Microsoft SQL Server 的所有版本。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-132">However, the polling option can be used for all versions of Microsoft SQL Server from 7.0 to 2005.</span></span> <span data-ttu-id="0c0ff-133">由于这些教程使用 Express edition SQL Server 2005，因此我们将重点介绍如何设置和使用 "轮询" 选项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-133">Since these tutorials use the Express edition of SQL Server 2005, we will focus on setting up and using the polling option.</span></span> <span data-ttu-id="0c0ff-134">有关 SQL Server 2005 s 通知功能的详细资源，请参阅本教程末尾的进一步阅读部分。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-134">Consult the Further Reading section at the end of this tutorial for further resources on SQL Server 2005 s notification capabilities.</span></span>

<span data-ttu-id="0c0ff-135">使用轮询时，必须将数据库配置为包含一个名为 `AspNet_SqlCacheTablesForChangeNotification` 的表，该表包含三列 `tableName`、`notificationCreated`和 `changeId`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-135">With polling, the database must be configured to include a table named `AspNet_SqlCacheTablesForChangeNotification` that has three columns - `tableName`, `notificationCreated`, and `changeId`.</span></span> <span data-ttu-id="0c0ff-136">对于包含可能需要在 web 应用程序的 SQL 缓存依赖项中使用的数据的每个表，此表都包含一行。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-136">This table contains a row for each table that has data that might need to be used in a SQL cache dependency in the web application.</span></span> <span data-ttu-id="0c0ff-137">`tableName` 列指定表的名称，`notificationCreated` 指示该行添加到表中的日期和时间。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-137">The `tableName` column specifies the name of the table while `notificationCreated` indicates the date and time the row was added to the table.</span></span> <span data-ttu-id="0c0ff-138">`changeId` 列的类型为 `int`，其初始值为0。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-138">The `changeId` column is of type `int` and has an initial value of 0.</span></span> <span data-ttu-id="0c0ff-139">每次对表进行修改时，其值都是递增的。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-139">Its value is incremented with each modification to the table.</span></span>

<span data-ttu-id="0c0ff-140">除了 `AspNet_SqlCacheTablesForChangeNotification` 表，数据库还需要在可能出现在 SQL 缓存依赖关系中的每个表中包含触发器。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-140">In addition to the `AspNet_SqlCacheTablesForChangeNotification` table, the database also needs to include triggers on each of the tables that may appear in a SQL cache dependency.</span></span> <span data-ttu-id="0c0ff-141">在插入、更新或删除行时，将执行这些触发器，并递增 `AspNet_SqlCacheTablesForChangeNotification`中的表 `changeId` 值。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-141">These triggers are executed whenever a row is inserted, updated, or deleted and increment the table s `changeId` value in `AspNet_SqlCacheTablesForChangeNotification`.</span></span>

<span data-ttu-id="0c0ff-142">使用 `SqlCacheDependency` 对象缓存数据时，ASP.NET 运行时将跟踪表的当前 `changeId`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-142">The ASP.NET runtime tracks the current `changeId` for a table when caching data using a `SqlCacheDependency` object.</span></span> <span data-ttu-id="0c0ff-143">定期检查该数据库，并逐出 `changeId` 不同于数据库中的值的任何 `SqlCacheDependency` 对象，因为不同的 `changeId` 值表明自缓存数据以来对该表进行了更改。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-143">The database is periodically checked and any `SqlCacheDependency` objects whose `changeId` differs from the value in the database are evicted since a differing `changeId` value indicates that there has been a change to the table since the data was cached.</span></span>

## <a name="step-1-exploring-theaspnet_regsqlexecommand-line-program"></a><span data-ttu-id="0c0ff-144">步骤1：浏览`aspnet_regsql.exe`命令行程序</span><span class="sxs-lookup"><span data-stu-id="0c0ff-144">Step 1: Exploring the`aspnet_regsql.exe`Command Line Program</span></span>

<span data-ttu-id="0c0ff-145">使用轮询方法时，必须将数据库设置为包含上述基础结构：预定义的表（`AspNet_SqlCacheTablesForChangeNotification`）、少量的存储过程，以及在 web 应用程序中的 SQL 缓存依赖项中可能使用的每个表的触发器。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-145">With the polling approach the database must be setup to contain the infrastructure described above: a predefined table (`AspNet_SqlCacheTablesForChangeNotification`), a handful of stored procedures, and triggers on each of the tables that may be used in SQL cache dependencies in the web application.</span></span> <span data-ttu-id="0c0ff-146">可以通过命令行程序 `aspnet_regsql.exe`创建这些表、存储过程和触发器，该程序位于 `$WINDOWS$\Microsoft.NET\Framework\version` 文件夹中。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-146">These tables, stored procedures, and triggers can be created through the command line program `aspnet_regsql.exe`, which is found in the `$WINDOWS$\Microsoft.NET\Framework\version` folder.</span></span> <span data-ttu-id="0c0ff-147">若要创建 `AspNet_SqlCacheTablesForChangeNotification` 表和关联的存储过程，请从命令行运行以下命令：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-147">To create the `AspNet_SqlCacheTablesForChangeNotification` table and associated stored procedures, run the following from the command line:</span></span>

[!code-console[Main](using-sql-cache-dependencies-cs/samples/sample1.cmd)]

> [!NOTE]
> <span data-ttu-id="0c0ff-148">若要执行这些命令，指定的数据库登录名必须在[`db_securityadmin`](https://msdn.microsoft.com/library/ms188685.aspx)和[`db_ddladmin`](https://msdn.microsoft.com/library/ms190667.aspx)角色中。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-148">To execute these commands the specified database login must be in the [`db_securityadmin`](https://msdn.microsoft.com/library/ms188685.aspx) and [`db_ddladmin`](https://msdn.microsoft.com/library/ms190667.aspx) roles.</span></span> <span data-ttu-id="0c0ff-149">若要检查 `aspnet_regsql.exe` 命令行程序发送到数据库的 T-sql，请参阅[此博客文章](http://scottonwriting.net/sowblog/posts/10709.aspx)。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-149">To examine the T-SQL sent to the database by the `aspnet_regsql.exe` command line program, refer to [this blog entry](http://scottonwriting.net/sowblog/posts/10709.aspx).</span></span>

<span data-ttu-id="0c0ff-150">例如，若要使用 Windows 身份验证将用于轮询的基础结构添加到名为 `ScottsServer` 的数据库服务器上名为 `pubs` 的 Microsoft SQL Server 数据库，请导航到相应的目录，然后在命令行中输入以下命令：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-150">For example, to add the infrastructure for polling to a Microsoft SQL Server database named `pubs` on a database server named `ScottsServer` using Windows Authentication, navigate to the appropriate directory and, from the command line, enter:</span></span>

[!code-console[Main](using-sql-cache-dependencies-cs/samples/sample2.cmd)]

<span data-ttu-id="0c0ff-151">添加数据库级基础结构后，需要将触发器添加到将在 SQL 缓存依赖项中使用的那些表。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-151">After the database-level infrastructure has been added, we need to add the triggers to those tables that will be used in SQL cache dependencies.</span></span> <span data-ttu-id="0c0ff-152">再次使用 `aspnet_regsql.exe` 命令行程序，但使用 `-t` 开关指定表名称，而不是使用 `-ed` 开关来使用 `-et`，如下所示：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-152">Use the `aspnet_regsql.exe` command line program again, but specify the table name using the `-t` switch and instead of using the `-ed` switch use `-et`, like so:</span></span>

[!code-html[Main](using-sql-cache-dependencies-cs/samples/sample3.html)]

<span data-ttu-id="0c0ff-153">若要将触发器添加到 `ScottsServer`上 `pubs` 数据库的 `authors` 和 `titles` 表中，请使用：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-153">To add the triggers to the `authors` and `titles` tables on the `pubs` database on `ScottsServer`, use:</span></span>

[!code-console[Main](using-sql-cache-dependencies-cs/samples/sample4.cmd)]

<span data-ttu-id="0c0ff-154">对于本教程，请将触发器添加到 `Products`、`Categories`和 `Suppliers` 表中。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-154">For this tutorial add the triggers to the `Products`, `Categories`, and `Suppliers` tables.</span></span> <span data-ttu-id="0c0ff-155">我们将在步骤3中介绍特定的命令行语法。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-155">We'll look at the particular command line syntax in Step 3.</span></span>

## <a name="step-2-referencing-a-microsoft-sql-server-2005-express-edition-database-inapp_data"></a><span data-ttu-id="0c0ff-156">步骤2：在`App_Data` 中引用 Microsoft SQL Server 2005 Express Edition 数据库</span><span class="sxs-lookup"><span data-stu-id="0c0ff-156">Step 2: Referencing a Microsoft SQL Server 2005 Express Edition Database in`App_Data`</span></span>

<span data-ttu-id="0c0ff-157">`aspnet_regsql.exe` 命令行程序需要数据库和服务器名称才能添加必要的轮询基础结构。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-157">The `aspnet_regsql.exe` command line program requires the database and server name in order to add the necessary polling infrastructure.</span></span> <span data-ttu-id="0c0ff-158">但 `App_Data` 文件夹中 Microsoft SQL Server 2005 Express 数据库的数据库和服务器名称是什么？</span><span class="sxs-lookup"><span data-stu-id="0c0ff-158">But what is the database and server name for a Microsoft SQL Server 2005 Express database that resides in the `App_Data` folder?</span></span> <span data-ttu-id="0c0ff-159">我发现，最简单的方法是将数据库附加到 `localhost\SQLExpress` 的数据库实例，并使用[SQL Server Management Studio](https://msdn.microsoft.com/library/ms174173.aspx)重命名数据，而不必了解数据库和服务器的名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-159">Rather than having to discover what the database and server names are, I ve found that the simplest approach is to attach the database to the `localhost\SQLExpress` database instance and rename the data using [SQL Server Management Studio](https://msdn.microsoft.com/library/ms174173.aspx).</span></span> <span data-ttu-id="0c0ff-160">如果计算机上安装了 SQL Server 2005 的完整版本之一，则计算机上可能已安装了 SQL Server Management Studio。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-160">If you have one of the full versions of SQL Server 2005 installed on your machine, then you likely already have SQL Server Management Studio installed on your computer.</span></span> <span data-ttu-id="0c0ff-161">如果只有 Express edition，则可以下载免费的[Microsoft SQL Server Management Studio Express edition](https://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=C243A5AE-4BD1-4E3D-94B8-5A0F62BF7796)。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-161">If you only have the Express edition, you can download the free [Microsoft SQL Server Management Studio Express Edition](https://www.microsoft.com/downloads/details.aspx?displaylang=en&amp;FamilyID=C243A5AE-4BD1-4E3D-94B8-5A0F62BF7796).</span></span>

<span data-ttu-id="0c0ff-162">首先关闭 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-162">Start by closing Visual Studio.</span></span> <span data-ttu-id="0c0ff-163">接下来，打开 SQL Server Management Studio 并选择使用 Windows 身份验证连接到 `localhost\SQLExpress` 服务器。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-163">Next, open SQL Server Management Studio and choose to connect to the `localhost\SQLExpress` server using Windows Authentication.</span></span>

![附加到 localhost\SQLExpress 服务器](using-sql-cache-dependencies-cs/_static/image1.gif)

<span data-ttu-id="0c0ff-165">**图 1**：附加到 `localhost\SQLExpress` 服务器</span><span class="sxs-lookup"><span data-stu-id="0c0ff-165">**Figure 1**: Attach to the `localhost\SQLExpress` Server</span></span>

<span data-ttu-id="0c0ff-166">连接到服务器后，Management Studio 将显示服务器，并为数据库和安全性等提供子文件夹。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-166">After connecting to the server, Management Studio will show the server and have subfolders for the databases, security, and so forth.</span></span> <span data-ttu-id="0c0ff-167">右键单击 "数据库" 文件夹，然后选择 "附加" 选项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-167">Right-click on the Databases folder and choose the Attach option.</span></span> <span data-ttu-id="0c0ff-168">此时将显示 "附加数据库" 对话框（请参阅图2）。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-168">This will bring up the Attach Databases dialog box (see Figure 2).</span></span> <span data-ttu-id="0c0ff-169">单击 "添加" 按钮，然后选择 web 应用程序 `App_Data` 文件夹中的 `NORTHWND.MDF` 数据库文件夹。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-169">Click the Add button and select the `NORTHWND.MDF` database folder in your web application s `App_Data` folder.</span></span>

<span data-ttu-id="0c0ff-170">[![附加 NORTHWND.MDF。App_Data 文件夹中的 MDF 数据库](using-sql-cache-dependencies-cs/_static/image2.gif)](using-sql-cache-dependencies-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-170">[![Attach the NORTHWND.MDF Database from the App_Data Folder](using-sql-cache-dependencies-cs/_static/image2.gif)](using-sql-cache-dependencies-cs/_static/image1.png)</span></span>

<span data-ttu-id="0c0ff-171">**图 2**：从 `App_Data` 文件夹附加 `NORTHWND.MDF` 数据库（[单击查看完全大小的映像](using-sql-cache-dependencies-cs/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-171">**Figure 2**: Attach the `NORTHWND.MDF` Database from the `App_Data` Folder ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image2.png))</span></span>

<span data-ttu-id="0c0ff-172">这会将数据库添加到 "数据库" 文件夹。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-172">This will add the database to the Databases folder.</span></span> <span data-ttu-id="0c0ff-173">数据库名称可能是数据库文件的完整路径，或者是[GUID](http://en.wikipedia.org/wiki/Globally_Unique_Identifier)前面预置的完整路径。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-173">The database name might be the full path to the database file or the full path prepended with a [GUID](http://en.wikipedia.org/wiki/Globally_Unique_Identifier).</span></span> <span data-ttu-id="0c0ff-174">若要避免在使用 aspnet\_regsql 命令行工具时必须键入此冗长的数据库名称，请右键单击 "刚附加的数据库"，然后选择 "重命名"，将数据库重命名为更友好的名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-174">To avoid having to type in this lengthy database name when using the aspnet\_regsql.exe command line tool, rename the database to a more human-friendly name by right-clicking on database just attached and choosing Rename.</span></span> <span data-ttu-id="0c0ff-175">我已将数据库重命名为 DataTutorials。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-175">I ve renamed my database to DataTutorials .</span></span>

![将附加的数据库重命名为更友好的名称](using-sql-cache-dependencies-cs/_static/image3.gif)

<span data-ttu-id="0c0ff-177">**图 3**：将附加的数据库重命名为更友好的名称</span><span class="sxs-lookup"><span data-stu-id="0c0ff-177">**Figure 3**: Rename the Attached Database to a More Human-Friendly Name</span></span>

## <a name="step-3-adding-the-polling-infrastructure-to-the-northwind-database"></a><span data-ttu-id="0c0ff-178">步骤3：将轮询基础结构添加到 Northwind 数据库</span><span class="sxs-lookup"><span data-stu-id="0c0ff-178">Step 3: Adding the Polling Infrastructure to the Northwind Database</span></span>

<span data-ttu-id="0c0ff-179">现在，我们已将 `NORTHWND.MDF` 数据库附加到 `App_Data` 文件夹中，接下来可以添加轮询基础结构。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-179">Now that we have attached the `NORTHWND.MDF` database from the `App_Data` folder, we re ready to add the polling infrastructure.</span></span> <span data-ttu-id="0c0ff-180">假设你已将数据库重命名为 DataTutorials，请运行以下四个命令：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-180">Assuming that you ve renamed the database to DataTutorials, run the following four commands:</span></span>

[!code-console[Main](using-sql-cache-dependencies-cs/samples/sample5.cmd)]

<span data-ttu-id="0c0ff-181">运行这四个命令后，在 Management Studio 中右键单击数据库名称，然后单击 "任务" 子菜单，然后选择 "分离"。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-181">After running these four commands, right-click on the database name in Management Studio, go to the Tasks submenu, and choose Detach.</span></span> <span data-ttu-id="0c0ff-182">然后关闭 Management Studio 再重新打开 Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-182">Then close Management Studio and reopen Visual Studio.</span></span>

<span data-ttu-id="0c0ff-183">重新打开 Visual Studio 后，通过服务器资源管理器钻取到数据库。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-183">Once Visual Studio has reopened, drill into the database through the Server Explorer.</span></span> <span data-ttu-id="0c0ff-184">注意新表（`AspNet_SqlCacheTablesForChangeNotification`）、新存储过程和 `Products`、`Categories`和 `Suppliers` 表的触发器。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-184">Note the new table (`AspNet_SqlCacheTablesForChangeNotification`), the new stored procedures, and the triggers on the `Products`, `Categories`, and `Suppliers` tables.</span></span>

![数据库现在包括必要的轮询基础结构](using-sql-cache-dependencies-cs/_static/image4.gif)

<span data-ttu-id="0c0ff-186">**图 4**：数据库现在包括必要的轮询基础结构</span><span class="sxs-lookup"><span data-stu-id="0c0ff-186">**Figure 4**: The Database Now Includes the Necessary Polling Infrastructure</span></span>

## <a name="step-4-configuring-the-polling-service"></a><span data-ttu-id="0c0ff-187">步骤4：配置轮询服务</span><span class="sxs-lookup"><span data-stu-id="0c0ff-187">Step 4: Configuring the Polling Service</span></span>

<span data-ttu-id="0c0ff-188">在数据库中创建所需的表、触发器和存储过程后，最后一步是配置轮询服务，该服务是通过 `Web.config` 指定要使用的数据库和以毫秒为单位的轮询频率来完成的。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-188">After creating the needed tables, triggers, and stored procedures in the database, the final step is to configure the polling service, which is done through `Web.config` by specifying the databases to use and the polling frequency in milliseconds.</span></span> <span data-ttu-id="0c0ff-189">以下标记每秒轮询一次 Northwind 数据库。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-189">The following markup polls the Northwind database once every second.</span></span>

[!code-xml[Main](using-sql-cache-dependencies-cs/samples/sample6.xml)]

<span data-ttu-id="0c0ff-190">`<add>` 元素（NorthwindDB）中的 `name` 值将可读名称与特定数据库相关联。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-190">The `name` value in the `<add>` element ( NorthwindDB ) associates a human-readable name with a particular database.</span></span> <span data-ttu-id="0c0ff-191">使用 SQL 缓存依赖项时，需要引用此处定义的数据库名称以及缓存数据所基于的表。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-191">When working with SQL cache dependencies, we'll need to refer to the database name defined here as well as the table that the cached data is based on.</span></span> <span data-ttu-id="0c0ff-192">我们将了解如何使用 `SqlCacheDependency` 类以编程方式将 SQL 缓存依赖项与步骤6中的缓存数据相关联。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-192">We'll see how to use the `SqlCacheDependency` class to programmatically associate SQL cache dependencies with cached data in Step 6.</span></span>

<span data-ttu-id="0c0ff-193">建立 SQL 缓存依赖关系后，轮询系统将每隔 `pollTime` 毫秒连接到 `<databases>` 元素中定义的数据库，并执行 `AspNet_SqlCachePollingStoredProcedure` 存储过程。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-193">Once a SQL cache dependency has been established, the polling system will connect to the databases defined in the `<databases>` elements every `pollTime` milliseconds and execute the `AspNet_SqlCachePollingStoredProcedure` stored procedure.</span></span> <span data-ttu-id="0c0ff-194">使用 `aspnet_regsql.exe` 命令行工具在第3步中添加了此存储过程-返回 `AspNet_SqlCacheTablesForChangeNotification`中每条记录的 `tableName` 和 `changeId` 值。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-194">This stored procedure - which was added back in Step 3 using the `aspnet_regsql.exe` command line tool - returns the `tableName` and `changeId` values for each record in `AspNet_SqlCacheTablesForChangeNotification`.</span></span> <span data-ttu-id="0c0ff-195">过时的 SQL 缓存依赖关系从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-195">Outdated SQL cache dependencies are evicted from the cache.</span></span>

<span data-ttu-id="0c0ff-196">`pollTime` 设置在性能和数据过期之间引入了折衷。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-196">The `pollTime` setting introduces a tradeoff between performance and data staleness.</span></span> <span data-ttu-id="0c0ff-197">小型 `pollTime` 值将增加对数据库的请求数，但会更快地逐出缓存中的陈旧数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-197">A small `pollTime` value increases the number of requests to the database, but more quickly evicts stale data from the cache.</span></span> <span data-ttu-id="0c0ff-198">较大的 `pollTime` 值可以减少数据库请求的数量，但会增加后端数据发生变化和逐出相关缓存项之间的延迟时间。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-198">A larger `pollTime` value reduces the number of database requests, but increases the delay between when the backend data changes and when the related cache items are evicted.</span></span> <span data-ttu-id="0c0ff-199">幸运的是，数据库请求正在执行一个简单的存储过程，该存储过程只返回简单的轻型表中的几个行。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-199">Fortunately, the database request is executing a simple stored procedure that s returning just a few rows from a simple, lightweight table.</span></span> <span data-ttu-id="0c0ff-200">但请使用不同的 `pollTime` 值进行试验，以便在应用程序的数据库访问和数据过期情况之间获得理想的平衡。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-200">But do experiment with different `pollTime` values to find an ideal balance between database access and data staleness for your application.</span></span> <span data-ttu-id="0c0ff-201">允许的最小 `pollTime` 值为500。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-201">The smallest `pollTime` value allowed is 500.</span></span>

> [!NOTE]
> <span data-ttu-id="0c0ff-202">上面的示例在 `<sqlCacheDependency>` 元素中提供了单个 `pollTime` 值，但你可以选择在 `<add>` 元素中指定 `pollTime` 值。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-202">The above example provides a single `pollTime` value in the `<sqlCacheDependency>` element, but you can optionally specify the `pollTime` value in the `<add>` element.</span></span> <span data-ttu-id="0c0ff-203">如果已指定多个数据库，并且想要自定义每个数据库的轮询频率，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-203">This is useful if you have multiple databases specified and want to customize the polling frequency per database.</span></span>

## <a name="step-5-declaratively-working-with-sql-cache-dependencies"></a><span data-ttu-id="0c0ff-204">步骤5：以声明方式使用 SQL 缓存依赖项</span><span class="sxs-lookup"><span data-stu-id="0c0ff-204">Step 5: Declaratively Working with SQL Cache Dependencies</span></span>

<span data-ttu-id="0c0ff-205">在步骤1到步骤4中，我们介绍了如何设置所需的数据库基础结构并配置轮询系统。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-205">In Steps 1 through 4 we looked at how to setup the necessary database infrastructure and configure the polling system.</span></span> <span data-ttu-id="0c0ff-206">使用此基础结构后，现在可以使用编程方式或声明性技术，将项添加到数据缓存，其中包含关联的 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-206">With this infrastructure in place, we can now add items to the data cache with an associated SQL cache dependency using either programmatic or declarative techniques.</span></span> <span data-ttu-id="0c0ff-207">在此步骤中，我们将检查如何以声明方式使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-207">In this step we'll examine how to declaratively work with SQL cache dependencies.</span></span> <span data-ttu-id="0c0ff-208">在步骤6中，我们将介绍编程方法。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-208">In Step 6 we'll look at the programmatic approach.</span></span>

<span data-ttu-id="0c0ff-209">[利用 objectdatasource 教程缓存数据](caching-data-with-the-objectdatasource-cs.md)探讨了 objectdatasource 的声明性缓存功能。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-209">The [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md) tutorial explored the declarative caching capabilities of the ObjectDataSource.</span></span> <span data-ttu-id="0c0ff-210">只需将 `EnableCaching` 属性设置为 `true` 并将 `CacheDuration` 属性设置为某个时间间隔，ObjectDataSource 就会根据指定的时间间隔自动缓存从其基础对象返回的数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-210">By simply setting the `EnableCaching` property to `true` and the `CacheDuration` property to some time interval, the ObjectDataSource will automatically cache the data returned from its underlying object for the specified interval.</span></span> <span data-ttu-id="0c0ff-211">ObjectDataSource 还可以使用一个或多个 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-211">The ObjectDataSource can also use one or more SQL cache dependencies.</span></span>

<span data-ttu-id="0c0ff-212">若要以声明方式使用 SQL 缓存依赖项，请打开 `Caching` 文件夹中的 "`SqlCacheDependencies.aspx`" 页，并将 GridView 从工具箱拖到设计器上。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-212">To demonstrate using SQL cache dependencies declaratively, open the `SqlCacheDependencies.aspx` page in the `Caching` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="0c0ff-213">将 GridView `ID` 设置为 `ProductsDeclarative`，并从其智能标记中，选择将其绑定到名为 `ProductsDataSourceDeclarative`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-213">Set the GridView s `ID` to `ProductsDeclarative` and, from its smart tag, choose to bind it to a new ObjectDataSource named `ProductsDataSourceDeclarative`.</span></span>

<span data-ttu-id="0c0ff-214">[![创建一个名为 ProductsDataSourceDeclarative 的新 ObjectDataSource](using-sql-cache-dependencies-cs/_static/image5.gif)](using-sql-cache-dependencies-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-214">[![Create a New ObjectDataSource Named ProductsDataSourceDeclarative](using-sql-cache-dependencies-cs/_static/image5.gif)](using-sql-cache-dependencies-cs/_static/image3.png)</span></span>

<span data-ttu-id="0c0ff-215">**图 5**：创建名为 `ProductsDataSourceDeclarative` 的新 ObjectDataSource （[单击以查看完全大小的映像](using-sql-cache-dependencies-cs/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-215">**Figure 5**: Create a New ObjectDataSource Named `ProductsDataSourceDeclarative` ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image4.png))</span></span>

<span data-ttu-id="0c0ff-216">将 ObjectDataSource 配置为使用 `ProductsBLL` 类，并在 "选择" 选项卡中设置下拉列表以 `GetProducts()`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-216">Configure the ObjectDataSource to use the `ProductsBLL` class and set the drop-down list in the SELECT tab to `GetProducts()`.</span></span> <span data-ttu-id="0c0ff-217">在 "更新" 选项卡中，选择具有三个输入参数的 `UpdateProduct` 重载-`productName`、`unitPrice`和 `productID`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-217">In the UPDATE tab, choose the `UpdateProduct` overload with three input parameters - `productName`, `unitPrice`, and `productID`.</span></span> <span data-ttu-id="0c0ff-218">在 "插入" 和 "删除" 选项卡中将下拉列表设置为 "（无）"。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-218">Set the drop-down lists to (None) in the INSERT and DELETE tabs.</span></span>

<span data-ttu-id="0c0ff-219">[![将 UpdateProduct 重载用于三个输入参数](using-sql-cache-dependencies-cs/_static/image6.gif)](using-sql-cache-dependencies-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-219">[![Use the UpdateProduct Overload with Three Input Parameters](using-sql-cache-dependencies-cs/_static/image6.gif)](using-sql-cache-dependencies-cs/_static/image5.png)</span></span>

<span data-ttu-id="0c0ff-220">**图 6**：将 UpdateProduct 重载用于三个输入参数（[单击以查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-220">**Figure 6**: Use the UpdateProduct Overload with Three Input Parameters ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image6.png))</span></span>

<span data-ttu-id="0c0ff-221">[![将 "插入" 和 "删除" 选项卡的下拉列表设置为 "（无）"](using-sql-cache-dependencies-cs/_static/image7.gif)](using-sql-cache-dependencies-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-221">[![Set the Drop-Down List to (None) for the INSERT and DELETE Tabs](using-sql-cache-dependencies-cs/_static/image7.gif)](using-sql-cache-dependencies-cs/_static/image7.png)</span></span>

<span data-ttu-id="0c0ff-222">**图 7**：将 "插入" 和 "删除" 选项卡的下拉列表设置为 "（无）" （[单击查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-222">**Figure 7**: Set the Drop-Down List to (None) for the INSERT and DELETE Tabs ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image8.png))</span></span>

<span data-ttu-id="0c0ff-223">完成 "配置数据源" 向导后，Visual Studio 将为每个数据字段在 GridView 中创建 BoundFields 和 CheckBoxFields。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-223">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and CheckBoxFields in the GridView for each of the data fields.</span></span> <span data-ttu-id="0c0ff-224">删除所有字段但 `ProductName`、`CategoryName`和 `UnitPrice`，并根据需要设置这些字段的格式。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-224">Remove all fields but `ProductName`, `CategoryName`, and `UnitPrice`, and format these fields as you see fit.</span></span> <span data-ttu-id="0c0ff-225">从 GridView s 智能标记中，选中 "启用分页"、"启用排序" 和 "启用编辑" 复选框。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-225">From the GridView s smart tag, check the Enable Paging, Enable Sorting, and Enable Editing checkboxes.</span></span> <span data-ttu-id="0c0ff-226">Visual Studio 会将 ObjectDataSource `OldValuesParameterFormatString` 属性设置为 `original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-226">Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}`.</span></span> <span data-ttu-id="0c0ff-227">为了使 GridView s 编辑功能正常工作，请从声明性语法中完全删除此属性，或将其设置回默认值 `{0}`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-227">In order for the GridView s edit feature to work properly, either remove this property entirely from the declarative syntax or set it back to its default value, `{0}`.</span></span>

<span data-ttu-id="0c0ff-228">最后，在 GridView 上方添加标签 Web 控件，并将其 `ID` 属性设置为 `ODSEvents`，并将其 `EnableViewState` 属性设置为 "`false`"。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-228">Finally, add a Label Web control above the GridView and set its `ID` property to `ODSEvents` and its `EnableViewState` property to `false`.</span></span> <span data-ttu-id="0c0ff-229">进行这些更改后，页的声明性标记应如下所示。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-229">After making these changes, your page s declarative markup should look similar to the following.</span></span> <span data-ttu-id="0c0ff-230">请注意，我对 GridView 字段进行了一些美观的自定义，这些字段对演示 SQL 缓存依赖项功能并不是必需的。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-230">Note that I ve made a number of aesthetic customizations to the GridView fields that are not necessary to demonstrate the SQL cache dependency functionality.</span></span>

[!code-aspx[Main](using-sql-cache-dependencies-cs/samples/sample7.aspx)]

<span data-ttu-id="0c0ff-231">接下来，为 ObjectDataSource `Selecting` 事件创建事件处理程序，并在其中添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-231">Next, create an event handler for the ObjectDataSource s `Selecting` event and in it add the following code:</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample8.cs)]

<span data-ttu-id="0c0ff-232">请记住，仅当从其基础对象检索数据时才会触发 ObjectDataSource `Selecting` 事件。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-232">Recall that the ObjectDataSource s `Selecting` event fires only when retrieving data from its underlying object.</span></span> <span data-ttu-id="0c0ff-233">如果 ObjectDataSource 访问自己的缓存中的数据，则不会触发此事件。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-233">If the ObjectDataSource accesses the data from its own cache, this event is not fired.</span></span>

<span data-ttu-id="0c0ff-234">现在，请通过浏览器访问此页。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-234">Now, visit this page through a browser.</span></span> <span data-ttu-id="0c0ff-235">由于我们尚未实现任何缓存，每次页面、排序或编辑网格时，该页应显示文本，选择 "触发事件"，如图8所示。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-235">Since we ve yet to implement any caching, each time you page, sort, or edit the grid the page should display the text, �Selecting event fired, as Figure 8 shows.</span></span>

<span data-ttu-id="0c0ff-236">[![每次对 GridView 进行分页、编辑或排序时激发的选择事件](using-sql-cache-dependencies-cs/_static/image8.gif)](using-sql-cache-dependencies-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-236">[![The ObjectDataSource s Selecting Event Fires Each Time the GridView is Paged, Edited, or Sorted](using-sql-cache-dependencies-cs/_static/image8.gif)](using-sql-cache-dependencies-cs/_static/image9.png)</span></span>

<span data-ttu-id="0c0ff-237">**图 8**：每次对 GridView 进行分页、编辑或排序时都会触发 `Selecting` 事件（[单击以查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image10.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-237">**Figure 8**: The ObjectDataSource s `Selecting` Event Fires Each Time the GridView is Paged, Edited, or Sorted ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image10.png))</span></span>

<span data-ttu-id="0c0ff-238">正如我们在[使用 ObjectDataSource 缓存数据](caching-data-with-the-objectdatasource-cs.md)中看到的那样，将 `EnableCaching` 属性设置为 `true` 会导致 ObjectDataSource 在其 `CacheDuration` 属性指定的持续时间内缓存其数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-238">As we saw in the [Caching Data with the ObjectDataSource](caching-data-with-the-objectdatasource-cs.md) tutorial, setting the `EnableCaching` property to `true` causes the ObjectDataSource to cache its data for the duration specified by its `CacheDuration` property.</span></span> <span data-ttu-id="0c0ff-239">ObjectDataSource 还具有一个[`SqlCacheDependency` 属性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sqlcachedependency.aspx)，该属性使用模式将一个或多个 SQL 缓存依赖项添加到缓存的数据中：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-239">The ObjectDataSource also has a [`SqlCacheDependency` property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.sqlcachedependency.aspx), which adds one or more SQL cache dependencies to the cached data using the pattern:</span></span>

[!code-css[Main](using-sql-cache-dependencies-cs/samples/sample9.css)]

<span data-ttu-id="0c0ff-240">其中*databaseName*是 `Web.config`中 `<add>` 元素的 `name` 属性中指定的数据库名称， *tableName*是数据库表的名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-240">Where *databaseName* is the name of the database as specified in the `name` attribute of the `<add>` element in `Web.config`, and *tableName* is the name of the database table.</span></span> <span data-ttu-id="0c0ff-241">例如，若要创建一个 ObjectDataSource，使其基于与 Northwind `Products` 表的 SQL 缓存依赖项无限缓存数据，请将 ObjectDataSource 的 `EnableCaching` 属性设置为 `true`，并将其 `SqlCacheDependency` 属性设置为 "NorthwindDB： Products"。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-241">For example, to create an ObjectDataSource that caches data indefinitely based on a SQL cache dependency against the Northwind s `Products` table, set the ObjectDataSource s `EnableCaching` property to `true` and its `SqlCacheDependency` property to NorthwindDB:Products .</span></span>

> [!NOTE]
> <span data-ttu-id="0c0ff-242">您可以使用 SQL 缓存依赖关系*和*基于时间的过期，方法是将 `EnableCaching` 设置为 `true`，`CacheDuration` 时间间隔，并 `SqlCacheDependency` 数据库和表名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-242">You can use a SQL cache dependency *and* a time-based expiry by setting `EnableCaching` to `true`, `CacheDuration` to the time interval, and `SqlCacheDependency` to the database and table name(s).</span></span> <span data-ttu-id="0c0ff-243">此 ObjectDataSource 将在达到基于时间的过期时间或轮询系统注意到基础数据库数据已更改（以先发生者为准）时逐出其数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-243">The ObjectDataSource will evict its data when the time-based expiry is reached or when the polling system notes that the underlying database data has changed, whichever happens first.</span></span>

<span data-ttu-id="0c0ff-244">`SqlCacheDependencies.aspx` 中的 GridView 显示两个表中的数据-`Products` 和 `Categories` （通过 `JOIN` 上的 `Categories`检索 product s `CategoryName` 字段）。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-244">The GridView in `SqlCacheDependencies.aspx` displays data from two tables - `Products` and `Categories` (the product s `CategoryName` field is retrieved via a `JOIN` on `Categories`).</span></span> <span data-ttu-id="0c0ff-245">因此，我们希望指定两个 SQL 缓存依赖关系： NorthwindDB： Products;NorthwindDB：类别。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-245">Therefore, we want to specify two SQL cache dependencies: NorthwindDB:Products;NorthwindDB:Categories .</span></span>

<span data-ttu-id="0c0ff-246">[![通过对产品和类别使用 SQL 缓存依赖项配置 ObjectDataSource 来支持缓存](using-sql-cache-dependencies-cs/_static/image9.gif)](using-sql-cache-dependencies-cs/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-246">[![Configure the ObjectDataSource to Support Caching Using SQL Cache Dependencies on Products and Categories](using-sql-cache-dependencies-cs/_static/image9.gif)](using-sql-cache-dependencies-cs/_static/image11.png)</span></span>

<span data-ttu-id="0c0ff-247">**图 9**：使用 `Products` 和 `Categories` 上的 SQL 缓存依赖项配置 ObjectDataSource 以支持缓存（[单击查看完全大小的映像](using-sql-cache-dependencies-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-247">**Figure 9**: Configure the ObjectDataSource to Support Caching Using SQL Cache Dependencies on `Products` and `Categories` ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image12.png))</span></span>

<span data-ttu-id="0c0ff-248">配置 ObjectDataSource 以支持缓存后，请通过浏览器重新访问该页面。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-248">After configuring the ObjectDataSource to support caching, revisit the page through a browser.</span></span> <span data-ttu-id="0c0ff-249">同样，在第一次访问时应显示选中 "激发的事件" 的文本，但分页、排序或单击 "编辑" 或 "取消" 按钮时应消失。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-249">Again, the text �Selecting event fired should appear on the first page visit, but should go away when paging, sorting, or clicking the Edit or Cancel buttons.</span></span> <span data-ttu-id="0c0ff-250">这是因为在将数据加载到 ObjectDataSource s 缓存中后，它将保留在那里，直到修改了 `Products` 或 `Categories` 表，或者通过 GridView 更新数据为止。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-250">This is because after the data is loaded into the ObjectDataSource s cache, it remains there until the `Products` or `Categories` tables are modified or the data is updated through the GridView.</span></span>

<span data-ttu-id="0c0ff-251">通过网格分页并注意到缺少选中 "引发的事件" 文本后，打开新的浏览器窗口，并导航到编辑、插入和删除部分（`~/EditInsertDelete/Basics.aspx`）中的基础教程。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-251">After paging through the grid and noting the lack of the �Selecting event fired text, open a new browser window and navigate to the Basics tutorial in the Editing, Inserting, and Deleting section (`~/EditInsertDelete/Basics.aspx`).</span></span> <span data-ttu-id="0c0ff-252">更新产品的名称或价格。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-252">Update the name or price of a product.</span></span> <span data-ttu-id="0c0ff-253">然后，从到第一个浏览器窗口，查看不同的数据页，对网格排序，或者单击行的 "编辑" 按钮。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-253">Then, from to the first browser window, view a different page of data, sort the grid, or click a row s Edit button.</span></span> <span data-ttu-id="0c0ff-254">此时，激发的选择事件应该重新出现，因为基础数据库数据已修改（请参阅图10）。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-254">This time, the �Selecting event fired should reappear, as the underlying database data has been modified (see Figure 10).</span></span> <span data-ttu-id="0c0ff-255">如果未显示该文本，请稍等片刻，然后重试。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-255">If the text does not appear, wait a few moments and try again.</span></span> <span data-ttu-id="0c0ff-256">请记住，轮询服务每隔 `pollTime` 毫秒检查对 `Products` 表所做的更改，因此在更新基础数据和逐出缓存数据之间存在延迟。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-256">Remember that the polling service is checking for changes to the `Products` table every `pollTime` milliseconds, so there is a delay between when the underlying data is updated and when the cached data is evicted.</span></span>

<span data-ttu-id="0c0ff-257">[![修改产品表逐出缓存的产品数据](using-sql-cache-dependencies-cs/_static/image10.gif)](using-sql-cache-dependencies-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-257">[![Modifying the Products Table Evicts the Cached Product Data](using-sql-cache-dependencies-cs/_static/image10.gif)](using-sql-cache-dependencies-cs/_static/image13.png)</span></span>

<span data-ttu-id="0c0ff-258">**图 10**：修改 Products 表逐出缓存的产品数据（[单击查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-258">**Figure 10**: Modifying the Products Table Evicts the Cached Product Data ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image14.png))</span></span>

## <a name="step-6-programmatically-working-with-thesqlcachedependencyclass"></a><span data-ttu-id="0c0ff-259">步骤6：以编程方式使用`SqlCacheDependency`类</span><span class="sxs-lookup"><span data-stu-id="0c0ff-259">Step 6: Programmatically Working with the`SqlCacheDependency`Class</span></span>

<span data-ttu-id="0c0ff-260">[体系结构教程中的缓存数据](caching-data-in-the-architecture-cs.md)查看了在体系结构中使用单独的缓存层的好处，而不是将缓存与 ObjectDataSource 紧密耦合起来。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-260">The [Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) tutorial looked at the benefits of using a separate Caching Layer in the architecture as opposed to tightly coupling the caching with the ObjectDataSource.</span></span> <span data-ttu-id="0c0ff-261">在本教程中，我们创建了一个 `ProductsCL` 类，以编程方式使用数据缓存。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-261">In that tutorial we created a `ProductsCL` class to demonstrate programmatically working with the data cache.</span></span> <span data-ttu-id="0c0ff-262">若要在缓存层中使用 SQL 缓存依赖项，请使用 `SqlCacheDependency` 类。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-262">To utilize SQL cache dependencies in the Caching Layer, use the `SqlCacheDependency` class.</span></span>

<span data-ttu-id="0c0ff-263">使用轮询系统时，`SqlCacheDependency` 对象必须与特定的数据库和表对相关联。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-263">With the polling system, a `SqlCacheDependency` object must be associated with a particular database and table pair.</span></span> <span data-ttu-id="0c0ff-264">例如，下面的代码创建一个基于 Northwind 数据库 `Products` 表的 `SqlCacheDependency` 对象：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-264">The following code, for example, creates a `SqlCacheDependency` object based on the Northwind database s `Products` table:</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample10.cs)]

<span data-ttu-id="0c0ff-265">`SqlCacheDependency` 构造函数的两个输入参数分别为数据库名称和表名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-265">The two input parameters to the `SqlCacheDependency` s constructor are the database and table names, respectively.</span></span> <span data-ttu-id="0c0ff-266">与 ObjectDataSource `SqlCacheDependency` 属性一样，使用的数据库名称与 `Web.config`中 `<add>` 元素的 `name` 属性中指定的值相同。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-266">Like with the ObjectDataSource s `SqlCacheDependency` property, the database name used is the same as the value specified in the `name` attribute of the `<add>` element in `Web.config`.</span></span> <span data-ttu-id="0c0ff-267">表名是数据库表的实际名称。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-267">The table name is the actual name of the database table.</span></span>

<span data-ttu-id="0c0ff-268">若要将 `SqlCacheDependency` 与添加到数据缓存中的项相关联，请使用接受依赖项的 `Insert` 方法重载之一。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-268">To associate a `SqlCacheDependency` with an item added to the data cache, use one of the `Insert` method overloads that accepts a dependency.</span></span> <span data-ttu-id="0c0ff-269">下面的代码会无限期地将*值*添加到数据缓存，但会将其与 `Products` 表中的 `SqlCacheDependency` 关联。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-269">The following code adds *value* to the data cache for an indefinite duration, but associates it with a `SqlCacheDependency` on the `Products` table.</span></span> <span data-ttu-id="0c0ff-270">简而言之，*值*将保留在缓存中，直到由于内存限制被逐出或轮询系统检测到 `Products` 表自从缓存后已更改。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-270">In short, *value* will remain in the cache until it is evicted due to memory constraints or because the polling system has detected that the `Products` table has changed since it was cached.</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample11.cs)]

<span data-ttu-id="0c0ff-271">缓存层 s `ProductsCL` 类当前使用60秒的基于时间的过期时间从 `Products` 表中缓存数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-271">The Caching Layer s `ProductsCL` class currently caches data from the `Products` table using a time-based expiry of 60 seconds.</span></span> <span data-ttu-id="0c0ff-272">让我们更新此类，以使其使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-272">Let s update this class so that it uses SQL cache dependencies instead.</span></span> <span data-ttu-id="0c0ff-273">`ProductsCL` 类 s `AddCacheItem` 方法（负责将数据添加到缓存）当前包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-273">The `ProductsCL` class s `AddCacheItem` method, which is responsible for adding the data to the cache, currently contains the following code:</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample12.cs)]

<span data-ttu-id="0c0ff-274">更新此代码以使用 `SqlCacheDependency` 对象，而不使用 `MasterCacheKeyArray` 缓存依赖关系：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-274">Update this code to use a `SqlCacheDependency` object instead of the `MasterCacheKeyArray` cache dependency:</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample13.cs)]

<span data-ttu-id="0c0ff-275">若要测试此功能，请将 GridView 添加到现有 `ProductsDeclarative` GridView 下的页面。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-275">To test this functionality, add a GridView to the page beneath the existing `ProductsDeclarative` GridView.</span></span> <span data-ttu-id="0c0ff-276">将这个新 GridView `ID` 设置为 `ProductsProgrammatic`，并通过其智能标记将其绑定到名为 `ProductsDataSourceProgrammatic`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-276">Set this new GridView s `ID` to `ProductsProgrammatic` and, through its smart tag, bind it to a new ObjectDataSource named `ProductsDataSourceProgrammatic`.</span></span> <span data-ttu-id="0c0ff-277">将 ObjectDataSource 配置为使用 `ProductsCL` 类，将 "选择" 和 "更新" 选项卡中的下拉列表分别设置为 `GetProducts` 和 `UpdateProduct`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-277">Configure the ObjectDataSource to use the `ProductsCL` class, setting the drop-down lists in the SELECT and UPDATE tabs to `GetProducts` and `UpdateProduct`, respectively.</span></span>

<span data-ttu-id="0c0ff-278">[![将 ObjectDataSource 配置为使用 ProductsCL 类](using-sql-cache-dependencies-cs/_static/image11.gif)](using-sql-cache-dependencies-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-278">[![Configure the ObjectDataSource to Use the ProductsCL Class](using-sql-cache-dependencies-cs/_static/image11.gif)](using-sql-cache-dependencies-cs/_static/image15.png)</span></span>

<span data-ttu-id="0c0ff-279">**图 11**：将 ObjectDataSource 配置为使用 `ProductsCL` 类（[单击以查看完全大小的映像](using-sql-cache-dependencies-cs/_static/image16.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-279">**Figure 11**: Configure the ObjectDataSource to Use the `ProductsCL` Class ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image16.png))</span></span>

<span data-ttu-id="0c0ff-280">[![从 "选择选项卡 s" 下拉列表中选择 GetProducts 方法](using-sql-cache-dependencies-cs/_static/image12.gif)](using-sql-cache-dependencies-cs/_static/image17.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-280">[![Select the GetProducts Method from the SELECT Tab s Drop-Down List](using-sql-cache-dependencies-cs/_static/image12.gif)](using-sql-cache-dependencies-cs/_static/image17.png)</span></span>

<span data-ttu-id="0c0ff-281">**图 12**：从 "选择选项卡 s" 下拉列表中选择 `GetProducts` 方法（[单击以查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-281">**Figure 12**: Select the `GetProducts` Method from the SELECT Tab s Drop-Down List ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image18.png))</span></span>

<span data-ttu-id="0c0ff-282">[![从 "更新" 选项卡的下拉列表中选择 "UpdateProduct" 方法](using-sql-cache-dependencies-cs/_static/image13.gif)](using-sql-cache-dependencies-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-282">[![Choose the UpdateProduct Method from the UPDATE Tab s Drop-Down List](using-sql-cache-dependencies-cs/_static/image13.gif)](using-sql-cache-dependencies-cs/_static/image19.png)</span></span>

<span data-ttu-id="0c0ff-283">**图 13**：从 "更新" 选项卡的下拉列表中选择 "UpdateProduct" 方法（[单击以查看完全大小的图像](using-sql-cache-dependencies-cs/_static/image20.png)）</span><span class="sxs-lookup"><span data-stu-id="0c0ff-283">**Figure 13**: Choose the UpdateProduct Method from the UPDATE Tab s Drop-Down List ([Click to view full-size image](using-sql-cache-dependencies-cs/_static/image20.png))</span></span>

<span data-ttu-id="0c0ff-284">完成 "配置数据源" 向导后，Visual Studio 将为每个数据字段在 GridView 中创建 BoundFields 和 CheckBoxFields。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-284">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and CheckBoxFields in the GridView for each of the data fields.</span></span> <span data-ttu-id="0c0ff-285">与添加到此页的第一个 GridView 类似，删除所有字段但 `ProductName`、`CategoryName`和 `UnitPrice`，并根据需要设置这些字段的格式。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-285">Like with the first GridView added to this page, remove all fields but `ProductName`, `CategoryName`, and `UnitPrice`, and format these fields as you see fit.</span></span> <span data-ttu-id="0c0ff-286">从 GridView s 智能标记中，选中 "启用分页"、"启用排序" 和 "启用编辑" 复选框。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-286">From the GridView s smart tag, check the Enable Paging, Enable Sorting, and Enable Editing checkboxes.</span></span> <span data-ttu-id="0c0ff-287">与 `ProductsDataSourceDeclarative` ObjectDataSource 一样，Visual Studio 会将 `ProductsDataSourceProgrammatic` ObjectDataSource s `OldValuesParameterFormatString` 属性设置为 `original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-287">As with the `ProductsDataSourceDeclarative` ObjectDataSource, Visual Studio will set the `ProductsDataSourceProgrammatic` ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}`.</span></span> <span data-ttu-id="0c0ff-288">为了使 GridView s 编辑功能正常工作，请将此属性设置回 `{0}` （或从声明性语法中删除属性赋值）。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-288">In order for the GridView s edit feature to work properly, set this property back to `{0}` (or remove the property assignment from the declarative syntax altogether).</span></span>

<span data-ttu-id="0c0ff-289">完成这些任务后，生成的 GridView 和 ObjectDataSource 声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-289">After completing these tasks, the resulting GridView and ObjectDataSource declarative markup should look like the following:</span></span>

[!code-aspx[Main](using-sql-cache-dependencies-cs/samples/sample14.aspx)]

<span data-ttu-id="0c0ff-290">若要测试缓存层中的 SQL 缓存依赖关系，请在 `ProductCL` 类 s `AddCacheItem` 方法中设置断点，然后开始调试。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-290">To test the SQL cache dependency in the Caching Layer set a breakpoint in the `ProductCL` class s `AddCacheItem` method and then start debugging.</span></span> <span data-ttu-id="0c0ff-291">首次访问 `SqlCacheDependencies.aspx`时，应在第一次请求数据并将其放入缓存时命中断点。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-291">When you first visit `SqlCacheDependencies.aspx`, the breakpoint should be hit as the data is requested for the first time and placed into the cache.</span></span> <span data-ttu-id="0c0ff-292">接下来，在 GridView 中移动到另一页或对其中一列进行排序。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-292">Next, move to another page in the GridView or sort one of the columns.</span></span> <span data-ttu-id="0c0ff-293">这会导致 GridView 重新查询其数据，但应在缓存中找到数据，因为未修改 `Products` 数据库表。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-293">This causes the GridView to requery its data, but the data should be found in the cache since the `Products` database table has not been modified.</span></span> <span data-ttu-id="0c0ff-294">如果在缓存中未找到数据，请确保计算机上有足够的可用内存，然后重试。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-294">If the data is repeatedly not found in the cache, make sure there is sufficient memory available on your computer and try again.</span></span>

<span data-ttu-id="0c0ff-295">通过 GridView 的几个页面进行分页后，打开第二个浏览器窗口，并导航到编辑、插入和删除部分（`~/EditInsertDelete/Basics.aspx`）中的基础教程。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-295">After paging through a few pages of the GridView, open a second browser window and navigate to the Basics tutorial in the Editing, Inserting, and Deleting section (`~/EditInsertDelete/Basics.aspx`).</span></span> <span data-ttu-id="0c0ff-296">更新 Products 表中的记录，然后在第一个浏览器窗口中查看新页或单击某个排序标头。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-296">Update a record from the Products table and then, from the first browser window, view a new page or click on one of the sorting headers.</span></span>

<span data-ttu-id="0c0ff-297">在这种情况下，你将看到以下两个内容之一：将命中断点，这表示由于数据库中的更改，已逐出缓存的数据;否则，将不会命中断点，这意味着 `SqlCacheDependencies.aspx` 现在显示过时数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-297">In this scenario you will see one of two things: either the breakpoint will be hit, indicating that the cached data was evicted due to the change in the database; or, the breakpoint will not be hit, meaning that `SqlCacheDependencies.aspx` is now showing stale data.</span></span> <span data-ttu-id="0c0ff-298">如果未命中断点，则很可能是因为数据更改后轮询服务尚未触发。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-298">If the breakpoint is not hit, it is likely because the polling service has not yet fired since the data was changed.</span></span> <span data-ttu-id="0c0ff-299">请记住，轮询服务每隔 `pollTime` 毫秒检查对 `Products` 表所做的更改，因此在更新基础数据和逐出缓存数据之间存在延迟。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-299">Remember that the polling service is checking for changes to the `Products` table every `pollTime` milliseconds, so there is a delay between when the underlying data is updated and when the cached data is evicted.</span></span>

> [!NOTE]
> <span data-ttu-id="0c0ff-300">在 `SqlCacheDependencies.aspx`中通过 GridView 编辑某个产品时，更有可能出现这种延迟。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-300">This delay is more likely to appear when editing one of the products through the GridView in `SqlCacheDependencies.aspx`.</span></span> <span data-ttu-id="0c0ff-301">在[体系结构中的缓存数据](caching-data-in-the-architecture-cs.md)教程中，我们添加了 `MasterCacheKeyArray` 缓存依赖关系，以确保通过 `ProductsCL` 类 `UpdateProduct` 方法编辑的数据已从缓存中逐出。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-301">In the [Caching Data in the Architecture](caching-data-in-the-architecture-cs.md) tutorial we added the `MasterCacheKeyArray` cache dependency to ensure that the data being edited through the `ProductsCL` class s `UpdateProduct` method was evicted from the cache.</span></span> <span data-ttu-id="0c0ff-302">但是，在此步骤中修改 `AddCacheItem` 方法时，我们将替换此缓存依赖关系，因此 `ProductsCL` 类将继续显示缓存的数据，直到轮询系统记录对 `Products` 表的更改。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-302">However, we replaced this cache dependency when modifying the `AddCacheItem` method earlier in this step and therefore the `ProductsCL` class will continue to show the cached data until the polling system notes the change to the `Products` table.</span></span> <span data-ttu-id="0c0ff-303">本文将介绍如何在步骤7中重新引入 `MasterCacheKeyArray` 缓存依赖关系。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-303">We'll see how to reintroduce the `MasterCacheKeyArray` cache dependency in Step 7.</span></span>

## <a name="step-7-associating-multiple-dependencies-with-a-cached-item"></a><span data-ttu-id="0c0ff-304">步骤7：将多个依赖项与缓存项关联</span><span class="sxs-lookup"><span data-stu-id="0c0ff-304">Step 7: Associating Multiple Dependencies with a Cached Item</span></span>

<span data-ttu-id="0c0ff-305">请记住，在更新与产品相关的任何数据时，将使用 `MasterCacheKeyArray` 缓存依赖关系来确保从缓存中逐出与产品相关的*所有*数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-305">Recall that the `MasterCacheKeyArray` cache dependency is used to ensure that *all* product-related data is evicted from the cache when any single item associated within it is updated.</span></span> <span data-ttu-id="0c0ff-306">例如，`GetProductsByCategoryID(categoryID)` 方法为每个唯一的*类别 id*值缓存 `ProductsDataTables` 实例。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-306">For example, the `GetProductsByCategoryID(categoryID)` method caches `ProductsDataTables` instances for each unique *categoryID* value.</span></span> <span data-ttu-id="0c0ff-307">如果其中一个对象被逐出，则 `MasterCacheKeyArray` 缓存依赖项可确保其他对象也被删除。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-307">If one of these objects is evicted, the `MasterCacheKeyArray` cache dependency ensures that the others are also removed.</span></span> <span data-ttu-id="0c0ff-308">如果没有此缓存依赖项，则在修改缓存的数据时，可能存在其他缓存的产品数据可能已过期。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-308">Without this cache dependency, when the cached data is modified the possibility exists that other cached product data may be out of date.</span></span> <span data-ttu-id="0c0ff-309">因此，在使用 SQL 缓存依赖项时，必须维护 `MasterCacheKeyArray` 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-309">Consequently, it s important that we maintain the `MasterCacheKeyArray` cache dependency when using SQL cache dependencies.</span></span> <span data-ttu-id="0c0ff-310">但是，数据缓存 `Insert` 方法仅允许单个依赖项对象。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-310">However, the data cache s `Insert` method only allows for a single dependency object.</span></span>

<span data-ttu-id="0c0ff-311">此外，在使用 SQL 缓存依赖项时，可能需要将多个数据库表关联为依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-311">Furthermore, when working with SQL cache dependencies we may need to associate multiple database tables as dependencies.</span></span> <span data-ttu-id="0c0ff-312">例如，在 `ProductsCL` 类中缓存的 `ProductsDataTable` 包含每个产品的类别和供应商名称，但是 `AddCacheItem` 方法只使用对 `Products`的依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-312">For example, the `ProductsDataTable` cached in the `ProductsCL` class contains the category and supplier names for each product, but the `AddCacheItem` method only uses a dependency on `Products`.</span></span> <span data-ttu-id="0c0ff-313">在这种情况下，如果用户更新类别或供应商的名称，则缓存的产品数据将保留在缓存中，并将过期。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-313">In this situation, if the user updates the name of a category or supplier, the cached product data will remain in the cache and be out of date.</span></span> <span data-ttu-id="0c0ff-314">因此，我们想要使缓存的产品数据不仅依赖于 `Products` 表，还取决于 `Categories` 和 `Suppliers` 表。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-314">Therefore, we want to make the cached product data dependent on not only the `Products` table, but on the `Categories` and `Suppliers` tables as well.</span></span>

<span data-ttu-id="0c0ff-315">[`AggregateCacheDependency` 类](https://msdn.microsoft.com/library/system.web.caching.aggregatecachedependency.aspx)提供一种将多个依赖项与缓存项相关联的方法。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-315">The [`AggregateCacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.aggregatecachedependency.aspx) provides a means for associating multiple dependencies with a cache item.</span></span> <span data-ttu-id="0c0ff-316">首先创建 `AggregateCacheDependency` 实例。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-316">Start by creating an `AggregateCacheDependency` instance.</span></span> <span data-ttu-id="0c0ff-317">接下来，使用 `AggregateCacheDependency` s `Add` 方法添加依赖项集。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-317">Next, add the set of dependencies using the `AggregateCacheDependency` s `Add` method.</span></span> <span data-ttu-id="0c0ff-318">以后在数据缓存中插入项时，将传入 `AggregateCacheDependency` 实例。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-318">When inserting the item into the data cache thereafter, pass in the `AggregateCacheDependency` instance.</span></span> <span data-ttu-id="0c0ff-319">如果*任何*`AggregateCacheDependency` 实例的依赖项发生更改，则将逐出缓存的项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-319">When *any* of the `AggregateCacheDependency` instance s dependencies change, the cached item will be evicted.</span></span>

<span data-ttu-id="0c0ff-320">下面显示了 `ProductsCL` 类 `AddCacheItem` 方法的更新代码。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-320">The following shows the updated code for the `ProductsCL` class s `AddCacheItem` method.</span></span> <span data-ttu-id="0c0ff-321">方法将创建 `MasterCacheKeyArray` 缓存依赖项以及 `Products`、`Categories`和 `Suppliers` 表的 `SqlCacheDependency` 对象。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-321">The method creates the `MasterCacheKeyArray` cache dependency along with `SqlCacheDependency` objects for the `Products`, `Categories`, and `Suppliers` tables.</span></span> <span data-ttu-id="0c0ff-322">这全部合并为一个名为 `aggregateDependencies`的 `AggregateCacheDependency` 对象，然后将该对象传递到 `Insert` 方法。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-322">These are all combined into one `AggregateCacheDependency` object named `aggregateDependencies`, which is then passed into the `Insert` method.</span></span>

[!code-csharp[Main](using-sql-cache-dependencies-cs/samples/sample15.cs)]

<span data-ttu-id="0c0ff-323">请测试此新代码。现在，对 `Products`、`Categories`或 `Suppliers` 表的更改会导致缓存的数据被逐出。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-323">Test this new code out. Now changes to the `Products`, `Categories`, or `Suppliers` tables cause the cached data to be evicted.</span></span> <span data-ttu-id="0c0ff-324">此外，`ProductsCL` 类 `UpdateProduct` 方法（在通过 GridView 编辑产品时调用）可逐出 `MasterCacheKeyArray` 缓存依赖关系，这会使缓存的 `ProductsDataTable` 逐出，并在下一个请求中重新检索数据。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-324">Moreover, the `ProductsCL` class s `UpdateProduct` method, which is called when editing a product through the GridView, evicts the `MasterCacheKeyArray` cache dependency, which causes the cached `ProductsDataTable` to be evicted and the data to be re-retrieved on the next request.</span></span>

> [!NOTE]
> <span data-ttu-id="0c0ff-325">SQL 缓存依赖项还可与[输出缓存](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/output.aspx)一起使用。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-325">SQL cache dependencies can also be used with [output caching](https://quickstarts.asp.net/QuickStartv20/aspnet/doc/caching/output.aspx).</span></span> <span data-ttu-id="0c0ff-326">有关此功能的演示，请参阅：将[ASP.NET Output 缓存与 SQL Server 配合使用](https://msdn.microsoft.com/library/e3w8402y(VS.80).aspx)。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-326">For a demonstration of this functionality, see: [Using ASP.NET Output Caching with SQL Server](https://msdn.microsoft.com/library/e3w8402y(VS.80).aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="0c0ff-327">摘要</span><span class="sxs-lookup"><span data-stu-id="0c0ff-327">Summary</span></span>

<span data-ttu-id="0c0ff-328">缓存数据库数据时，数据在数据库中被修改之前，理想情况下将保留在缓存中。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-328">When caching database data, the data will ideally remain in the cache until it is modified in the database.</span></span> <span data-ttu-id="0c0ff-329">使用 ASP.NET 2.0，可以在声明性和编程方案中创建和使用 SQL 缓存依赖项。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-329">With ASP.NET 2.0, SQL cache dependencies can be created and used in both declarative and programmatic scenarios.</span></span> <span data-ttu-id="0c0ff-330">此方法的一大挑战是在数据被修改时发现。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-330">One of the challenges with this approach is in discovering when the data has been modified.</span></span> <span data-ttu-id="0c0ff-331">Microsoft SQL Server 2005 的完整版本提供了通知功能，可以在查询结果发生更改时向应用程序发出警报。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-331">The full versions of Microsoft SQL Server 2005 provide notification capabilities that can alert an application when a query result has changed.</span></span> <span data-ttu-id="0c0ff-332">对于 SQL Server 2005 和早期版本 SQL Server 的 Express 版本，必须改用轮询系统。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-332">For the Express Edition of SQL Server 2005 and older versions of SQL Server, a polling system must be used instead.</span></span> <span data-ttu-id="0c0ff-333">幸运的是，设置必要的轮询基础结构相当简单。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-333">Fortunately, setting up the necessary polling infrastructure is fairly straightforward.</span></span>

<span data-ttu-id="0c0ff-334">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="0c0ff-334">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="0c0ff-335">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="0c0ff-335">Further Reading</span></span>

<span data-ttu-id="0c0ff-336">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="0c0ff-336">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="0c0ff-337">在 Microsoft SQL Server 2005 中使用查询通知</span><span class="sxs-lookup"><span data-stu-id="0c0ff-337">Using Query Notifications in Microsoft SQL Server 2005</span></span>](https://msdn.microsoft.com/library/ms175110.aspx)
- [<span data-ttu-id="0c0ff-338">创建查询通知</span><span class="sxs-lookup"><span data-stu-id="0c0ff-338">Creating a Query Notification</span></span>](https://msdn.microsoft.com/library/ms188669.aspx)
- <span data-ttu-id="0c0ff-339">[用 `SqlCacheDependency` 类在 ASP.NET 中进行缓存](https://msdn.microsoft.com/library/ms178604(VS.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-339">[Caching in ASP.NET with the `SqlCacheDependency` Class](https://msdn.microsoft.com/library/ms178604(VS.80).aspx)</span></span>
- <span data-ttu-id="0c0ff-340">[ASP.NET SQL Server 注册工具（`aspnet_regsql.exe`）](https://msdn.microsoft.com/library/ms229862(vs.80).aspx)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-340">[ASP.NET SQL Server Registration Tool (`aspnet_regsql.exe`)](https://msdn.microsoft.com/library/ms229862(vs.80).aspx)</span></span>
- [<span data-ttu-id="0c0ff-341">`SqlCacheDependency` 概述</span><span class="sxs-lookup"><span data-stu-id="0c0ff-341">Overview of `SqlCacheDependency`</span></span>](http://www.aspnetresources.com/blog/sql_cache_depedency_overview.aspx)

## <a name="about-the-author"></a><span data-ttu-id="0c0ff-342">关于作者</span><span class="sxs-lookup"><span data-stu-id="0c0ff-342">About the Author</span></span>

<span data-ttu-id="0c0ff-343">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-343">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="0c0ff-344">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-344">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="0c0ff-345">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-345">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="0c0ff-346">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-346">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="0c0ff-347">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-347">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="0c0ff-348">特别感谢</span><span class="sxs-lookup"><span data-stu-id="0c0ff-348">Special Thanks To</span></span>

<span data-ttu-id="0c0ff-349">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-349">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="0c0ff-350">本教程的主管评审者是 Marko Rangel、Teresa Murphy 和 Hilton Giesenow。</span><span class="sxs-lookup"><span data-stu-id="0c0ff-350">Lead reviewers for this tutorial were Marko Rangel, Teresa Murphy, and Hilton Giesenow.</span></span> <span data-ttu-id="0c0ff-351">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="0c0ff-351">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="0c0ff-352">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-352">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0c0ff-353">[上一页](caching-data-at-application-startup-cs.md)
> [下一页](caching-data-with-the-objectdatasource-vb.md)</span><span class="sxs-lookup"><span data-stu-id="0c0ff-353">[Previous](caching-data-at-application-startup-cs.md)
[Next](caching-data-with-the-objectdatasource-vb.md)</span></span>

---
uid: web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
title: 实现开放式并发（C#） |Microsoft Docs
author: rick-anderson
description: 对于允许多个用户编辑数据的 web 应用程序，有两个用户可以同时编辑相同数据的风险。 在此 tutori 中 。
ms.author: riande
ms.date: 07/17/2006
ms.assetid: 56e15b33-93b8-43ad-8e19-44c6647ea05c
msc.legacyurl: /web-forms/overview/data-access/editing-inserting-and-deleting-data/implementing-optimistic-concurrency-cs
msc.type: authoredcontent
ms.openlocfilehash: 3cddb0efd28249ffc5708ece39c80581d078a5a2
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78492422"
---
# <a name="implementing-optimistic-concurrency-c"></a><span data-ttu-id="adbab-104">实现乐观并发 (C#)</span><span class="sxs-lookup"><span data-stu-id="adbab-104">Implementing Optimistic Concurrency (C#)</span></span>

<span data-ttu-id="adbab-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="adbab-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="adbab-106">[下载示例应用](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe)或[下载 PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="adbab-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_21_CS.exe) or [Download PDF](implementing-optimistic-concurrency-cs/_static/datatutorial21cs1.pdf)</span></span>

> <span data-ttu-id="adbab-107">对于允许多个用户编辑数据的 web 应用程序，有两个用户可以同时编辑相同数据的风险。</span><span class="sxs-lookup"><span data-stu-id="adbab-107">For a web application that allows multiple users to edit data, there is the risk that two users may be editing the same data at the same time.</span></span> <span data-ttu-id="adbab-108">在本教程中，我们将实现开放式并发控制来应对此风险。</span><span class="sxs-lookup"><span data-stu-id="adbab-108">In this tutorial we'll implement optimistic concurrency control to handle this risk.</span></span>

## <a name="introduction"></a><span data-ttu-id="adbab-109">介绍</span><span class="sxs-lookup"><span data-stu-id="adbab-109">Introduction</span></span>

<span data-ttu-id="adbab-110">对于仅允许用户查看数据的 web 应用程序，或仅包含可修改数据的单个用户的 web 应用程序，不会有两个并发用户意外覆盖另一个更改的威胁。</span><span class="sxs-lookup"><span data-stu-id="adbab-110">For web applications that only allow users to view data, or for those that include only a single user who can modify data, there's no threat of two concurrent users accidentally overwriting one another's changes.</span></span> <span data-ttu-id="adbab-111">但对于允许多个用户更新或删除数据的 web 应用程序，有可能会有一个用户对另一个并发用户的冲突进行修改。</span><span class="sxs-lookup"><span data-stu-id="adbab-111">For web applications that allow multiple users to update or delete data, however, there's the potential for one user's modifications to clash with another concurrent user's.</span></span> <span data-ttu-id="adbab-112">如果没有任何并发策略，当两个用户同时编辑一条记录时，最后提交她的更改的用户将覆盖第一个记录所做的更改。</span><span class="sxs-lookup"><span data-stu-id="adbab-112">Without any concurrency policy in place, when two users are simultaneously editing a single record, the user who commits her changes last will override the changes made by the first.</span></span>

<span data-ttu-id="adbab-113">例如，假设两个用户 Jisun 和 Sam 都在访问应用程序中的一个页面，允许访问者通过 GridView 控件更新和删除产品。</span><span class="sxs-lookup"><span data-stu-id="adbab-113">For example, imagine that two users, Jisun and Sam, were both visiting a page in our application that allowed visitors to update and delete the products through a GridView control.</span></span> <span data-ttu-id="adbab-114">同时单击 GridView 中的 "编辑" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-114">Both click the Edit button in the GridView around the same time.</span></span> <span data-ttu-id="adbab-115">Jisun 将产品名称更改为 "Chai 茶" 并单击 "更新" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-115">Jisun changes the product name to "Chai Tea" and clicks the Update button.</span></span> <span data-ttu-id="adbab-116">Net 结果是发送到数据库的 `UPDATE` 语句，该语句将设置产品的*所有*可更新字段（即使 Jisun 仅更新了一个字段，`ProductName`）。</span><span class="sxs-lookup"><span data-stu-id="adbab-116">The net result is an `UPDATE` statement that is sent to the database, which sets *all* of the product's updateable fields (even though Jisun only updated one field, `ProductName`).</span></span> <span data-ttu-id="adbab-117">此时，数据库的值为 "Chai 茶"、"供应商现 Liquids"、"供应商"。</span><span class="sxs-lookup"><span data-stu-id="adbab-117">At this point in time, the database has the values "Chai Tea," the category Beverages, the supplier Exotic Liquids, and so on for this particular product.</span></span> <span data-ttu-id="adbab-118">但是，Sam 上的 GridView 仍会在可编辑 GridView 行中显示为 "Chai" 的产品名称。</span><span class="sxs-lookup"><span data-stu-id="adbab-118">However, the GridView on Sam's screen still shows the product name in the editable GridView row as "Chai".</span></span> <span data-ttu-id="adbab-119">提交 Jisun 更改后的几秒钟后，Sam 会将类别更新为调味品并单击 "更新"。</span><span class="sxs-lookup"><span data-stu-id="adbab-119">A few seconds after Jisun's changes have been committed, Sam updates the category to Condiments and clicks Update.</span></span> <span data-ttu-id="adbab-120">这会导致向数据库发送 `UPDATE` 语句，该语句将产品名称设置为 "Chai"，将 `CategoryID` 设置为相应的饮料类别 ID 等。</span><span class="sxs-lookup"><span data-stu-id="adbab-120">This results in an `UPDATE` statement sent to the database that sets the product name to "Chai," the `CategoryID` to the corresponding Beverages category ID, and so on.</span></span> <span data-ttu-id="adbab-121">已覆盖 Jisun 对产品名称所做的更改。</span><span class="sxs-lookup"><span data-stu-id="adbab-121">Jisun's changes to the product name have been overwritten.</span></span> <span data-ttu-id="adbab-122">图1以图形方式描述此系列事件。</span><span class="sxs-lookup"><span data-stu-id="adbab-122">Figure 1 graphically depicts this series of events.</span></span>

<span data-ttu-id="adbab-123">[![两个用户同时更新 a 记录时，可能会有一个用户更改为覆盖其他](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-123">[![When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s](implementing-optimistic-concurrency-cs/_static/image2.png)](implementing-optimistic-concurrency-cs/_static/image1.png)</span></span>

<span data-ttu-id="adbab-124">**图 1**：当两个用户同时更新 a 记录时，可能会有一个用户更改为覆盖其他（[单击以查看实际尺寸的图像](implementing-optimistic-concurrency-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-124">**Figure 1**: When Two Users Simultaneously Update a Record There s Potential for One User s Changes to Overwrite the Other s ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image3.png))</span></span>

<span data-ttu-id="adbab-125">同样，当两个用户访问某个页面时，当另一个用户删除记录时，可能会有一个用户正在更新该记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-125">Similarly, when two users are visiting a page, one user might be in the midst of updating a record when it is deleted by another user.</span></span> <span data-ttu-id="adbab-126">或者，在用户加载页面和单击 "删除" 按钮时，其他用户可能已修改该记录的内容。</span><span class="sxs-lookup"><span data-stu-id="adbab-126">Or, between when a user loads a page and when they click the Delete button, another user may have modified the contents of that record.</span></span>

<span data-ttu-id="adbab-127">有三种可用的[并发控制](http://en.wikipedia.org/wiki/Concurrency_control)策略：</span><span class="sxs-lookup"><span data-stu-id="adbab-127">There are three [concurrency control](http://en.wikipedia.org/wiki/Concurrency_control) strategies available:</span></span>

- <span data-ttu-id="adbab-128">**不执行任何**操作-如果并发用户正在修改同一条记录，则让最后一个 commit 入选（默认行为）</span><span class="sxs-lookup"><span data-stu-id="adbab-128">**Do Nothing** -if concurrent users are modifying the same record, let the last commit win (the default behavior)</span></span>
- <span data-ttu-id="adbab-129">[**开放式并发**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control)-假设每次可能都存在并发冲突，而绝大多数时间都不会出现这种冲突;因此，如果发生冲突，只需通知用户其更改将无法保存，因为其他用户已修改了相同的数据</span><span class="sxs-lookup"><span data-stu-id="adbab-129">[**Optimistic Concurrency**](http://en.wikipedia.org/wiki/Optimistic_concurrency_control) - assume that while there may be concurrency conflicts every now and then, the vast majority of the time such conflicts won't arise; therefore, if a conflict does arise, simply inform the user that their changes can't be saved because another user has modified the same data</span></span>
- <span data-ttu-id="adbab-130">**悲观并发**-假设并发冲突很常见，并且由于其他用户的并发活动，用户不会被告知其更改未保存，因此，当一个用户开始更新记录时，将其锁定，从而阻止其他任何用户编辑或删除该记录，直到用户提交其修改为止</span><span class="sxs-lookup"><span data-stu-id="adbab-130">**Pessimistic Concurrency** - assume that concurrency conflicts are commonplace and that users won't tolerate being told their changes weren't saved due to another user's concurrent activity; therefore, when one user starts updating a record, lock it, thereby preventing any other users from editing or deleting that record until the user commits their modifications</span></span>

<span data-ttu-id="adbab-131">到目前为止，我们的所有教程都使用了默认的并发解决方案策略-即，我们让最后一次写入入选。</span><span class="sxs-lookup"><span data-stu-id="adbab-131">All of our tutorials thus far have used the default concurrency resolution strategy - namely, we've let the last write win.</span></span> <span data-ttu-id="adbab-132">在本教程中，我们将讨论如何实现开放式并发控制。</span><span class="sxs-lookup"><span data-stu-id="adbab-132">In this tutorial we'll examine how to implement optimistic concurrency control.</span></span>

> [!NOTE]
> <span data-ttu-id="adbab-133">在本系列教程中，我们不会讨论悲观并发示例。</span><span class="sxs-lookup"><span data-stu-id="adbab-133">We won't look at pessimistic concurrency examples in this tutorial series.</span></span> <span data-ttu-id="adbab-134">很少使用悲观并发，因为如果没有正确释放，此类锁会阻止其他用户更新数据。</span><span class="sxs-lookup"><span data-stu-id="adbab-134">Pessimistic concurrency is rarely used because such locks, if not properly relinquished, can prevent other users from updating data.</span></span> <span data-ttu-id="adbab-135">例如，如果用户锁定了某一记录进行编辑，然后在将其解除锁定之前离开了一天，则在原始用户返回并完成其更新之前，其他用户将无法更新该记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-135">For example, if a user locks a record for editing and then leaves for the day before unlocking it, no other user will be able to update that record until the original user returns and completes his update.</span></span> <span data-ttu-id="adbab-136">因此，在使用悲观并发的情况下，通常会有一个超时，如果达到此值，则会取消锁定。</span><span class="sxs-lookup"><span data-stu-id="adbab-136">Therefore, in situations where pessimistic concurrency is used, there's typically a timeout that, if reached, cancels the lock.</span></span> <span data-ttu-id="adbab-137">用于在用户完成订单过程时锁定特定座位位置的票证销售网站是悲观并发控制的一个示例。</span><span class="sxs-lookup"><span data-stu-id="adbab-137">Ticket sales websites, which lock a particular seating location for short period while the user completes the order process, is an example of pessimistic concurrency control.</span></span>

## <a name="step-1-looking-at-how-optimistic-concurrency-is-implemented"></a><span data-ttu-id="adbab-138">步骤 1：了解如何实现开放式并发</span><span class="sxs-lookup"><span data-stu-id="adbab-138">Step 1: Looking at How Optimistic Concurrency is Implemented</span></span>

<span data-ttu-id="adbab-139">乐观并发控制的工作原理是确保正在更新或删除的记录的值与更新或删除进程启动时的值相同。</span><span class="sxs-lookup"><span data-stu-id="adbab-139">Optimistic concurrency control works by ensuring that the record being updated or deleted has the same values as it did when the updating or deleting process started.</span></span> <span data-ttu-id="adbab-140">例如，当在可编辑 GridView 中单击 "编辑" 按钮时，将从数据库中读取记录的值并将其显示在文本框和其他 Web 控件中。</span><span class="sxs-lookup"><span data-stu-id="adbab-140">For example, when clicking the Edit button in an editable GridView, the record's values are read from the database and displayed in TextBoxes and other Web controls.</span></span> <span data-ttu-id="adbab-141">这些原始值由 GridView 保存。</span><span class="sxs-lookup"><span data-stu-id="adbab-141">These original values are saved by the GridView.</span></span> <span data-ttu-id="adbab-142">稍后，在用户进行更改并单击 "更新" 按钮后，原始值和新值将发送到业务逻辑层，然后再发送到数据访问层。</span><span class="sxs-lookup"><span data-stu-id="adbab-142">Later, after the user makes her changes and clicks the Update button, the original values plus the new values are sent to the Business Logic Layer, and then down to the Data Access Layer.</span></span> <span data-ttu-id="adbab-143">如果用户开始编辑的原始值与数据库中仍有的值相同，则数据访问层必须发出一条 SQL 语句，该语句将仅更新记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-143">The Data Access Layer must issue a SQL statement that will only update the record if the original values that the user started editing are identical to the values still in the database.</span></span> <span data-ttu-id="adbab-144">图2描绘了此事件序列。</span><span class="sxs-lookup"><span data-stu-id="adbab-144">Figure 2 depicts this sequence of events.</span></span>

<span data-ttu-id="adbab-145">[![更新或删除成功，则原始值必须等于当前数据库值](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-145">[![For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values](implementing-optimistic-concurrency-cs/_static/image5.png)](implementing-optimistic-concurrency-cs/_static/image4.png)</span></span>

<span data-ttu-id="adbab-146">**图 2**：要使更新或删除成功，原始值必须等于当前数据库值（[单击即可查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-146">**Figure 2**: For the Update or Delete to Succeed, the Original Values Must Be Equal to the Current Database Values ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image6.png))</span></span>

<span data-ttu-id="adbab-147">有多种方法可实现开放式并发（请参阅[Peter Bromberg](http://peterbromberg.net/)的[开放式并发更新逻辑](http://www.eggheadcafe.com/articles/20050719.asp)，简要了解一些选项）。</span><span class="sxs-lookup"><span data-stu-id="adbab-147">There are various approaches to implementing optimistic concurrency (see [Peter A. Bromberg](http://peterbromberg.net/)'s [Optimistic Concurrency Updating Logic](http://www.eggheadcafe.com/articles/20050719.asp) for a brief look at a number of options).</span></span> <span data-ttu-id="adbab-148">ADO.NET 类型化数据集提供一个实现，该实现只能用 checkbox 的勾选标记。</span><span class="sxs-lookup"><span data-stu-id="adbab-148">The ADO.NET Typed DataSet provides one implementation that can be configured with just the tick of a checkbox.</span></span> <span data-ttu-id="adbab-149">为类型化数据集中的 TableAdapter 启用乐观并发将增加 TableAdapter 的 `UPDATE` 和 `DELETE` 语句，以便在 `WHERE` 子句中包含所有原始值的比较。</span><span class="sxs-lookup"><span data-stu-id="adbab-149">Enabling optimistic concurrency for a TableAdapter in the Typed DataSet augments the TableAdapter's `UPDATE` and `DELETE` statements to include a comparison of all of the original values in the `WHERE` clause.</span></span> <span data-ttu-id="adbab-150">例如，下面的 `UPDATE` 语句仅在以下情况下才会更新产品的名称和价格：当前数据库值等于在 GridView 中更新记录时最初检索到的值。</span><span class="sxs-lookup"><span data-stu-id="adbab-150">The following `UPDATE` statement, for example, updates the name and price of a product only if the current database values are equal to the values that were originally retrieved when updating the record in the GridView.</span></span> <span data-ttu-id="adbab-151">`@ProductName` 和 `@UnitPrice` 参数包含用户输入的新值，而 `@original_ProductName` 和 `@original_UnitPrice` 包含在单击 "编辑" 按钮时最初加载到 GridView 的值：</span><span class="sxs-lookup"><span data-stu-id="adbab-151">The `@ProductName` and `@UnitPrice` parameters contain the new values entered by the user, whereas `@original_ProductName` and `@original_UnitPrice` contain the values that were originally loaded into the GridView when the Edit button was clicked:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample1.sql)]

> [!NOTE]
> <span data-ttu-id="adbab-152">为了便于阅读，此 `UPDATE` 语句已经过简化。</span><span class="sxs-lookup"><span data-stu-id="adbab-152">This `UPDATE` statement has been simplified for readability.</span></span> <span data-ttu-id="adbab-153">在实践中，`UnitPrice` 签入 `WHERE` 子句将更涉及，因为 `UnitPrice` 可以包含 `NULL` 并检查 `NULL = NULL` 是否始终返回 False （改为必须使用 `IS NULL`）。</span><span class="sxs-lookup"><span data-stu-id="adbab-153">In practice, the `UnitPrice` check in the `WHERE` clause would be more involved since `UnitPrice` can contain `NULL` s and checking if `NULL = NULL` always returns False (instead you must use `IS NULL`).</span></span>

<span data-ttu-id="adbab-154">除了使用其他基础 `UPDATE` 语句外，将 TableAdapter 配置为使用开放式并发还会修改其 DB 直接方法的签名。</span><span class="sxs-lookup"><span data-stu-id="adbab-154">In addition to using a different underlying `UPDATE` statement, configuring a TableAdapter to use optimistic concurrency also modifies the signature of its DB direct methods.</span></span> <span data-ttu-id="adbab-155">从我们的第一个教程开始，[*创建数据访问层*](../introduction/creating-a-data-access-layer-cs.md)，数据库直接方法是接受标量值列表作为输入参数（而不是强类型化的 DataRow 或 DataTable 实例）的方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-155">Recall from our first tutorial, [*Creating a Data Access Layer*](../introduction/creating-a-data-access-layer-cs.md), that DB direct methods were those that accepts a list of scalar values as input parameters (rather than a strongly-typed DataRow or DataTable instance).</span></span> <span data-ttu-id="adbab-156">使用开放式并发时，DB direct `Update()` 和 `Delete()` 方法还包括原始值的输入参数。</span><span class="sxs-lookup"><span data-stu-id="adbab-156">When using optimistic concurrency, the DB direct `Update()` and `Delete()` methods include input parameters for the original values as well.</span></span> <span data-ttu-id="adbab-157">此外，还必须更改使用批处理更新模式的 BLL 中的代码（接受 Datarow 的 `Update()` 方法重载，而不是标量值）。</span><span class="sxs-lookup"><span data-stu-id="adbab-157">Moreover, the code in the BLL for using the batch update pattern (the `Update()` method overloads that accept DataRows and DataTables rather than scalar values) must be changed as well.</span></span>

<span data-ttu-id="adbab-158">不要将现有 DAL 的 Tableadapter 扩展为使用乐观并发（这将需要更改 BLL 以适应），而是创建一个名为 `NorthwindOptimisticConcurrency`的新的类型化数据集，我们将添加一个使用乐观并发的 `Products` TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="adbab-158">Rather than extend our existing DAL's TableAdapters to use optimistic concurrency (which would necessitate changing the BLL to accommodate), let's instead create a new Typed DataSet named `NorthwindOptimisticConcurrency`, to which we'll add a `Products` TableAdapter that uses optimistic concurrency.</span></span> <span data-ttu-id="adbab-159">接下来，我们将创建一个 `ProductsOptimisticConcurrencyBLL` 业务逻辑层类，该类具有相应修改以支持开放式并发 DAL。</span><span class="sxs-lookup"><span data-stu-id="adbab-159">Following that, we'll create a `ProductsOptimisticConcurrencyBLL` Business Logic Layer class that has the appropriate modifications to support the optimistic concurrency DAL.</span></span> <span data-ttu-id="adbab-160">在此基础上进行了布局后，就可以创建 ASP.NET 页面了。</span><span class="sxs-lookup"><span data-stu-id="adbab-160">Once this groundwork has been laid, we'll be ready to create the ASP.NET page.</span></span>

## <a name="step-2-creating-a-data-access-layer-that-supports-optimistic-concurrency"></a><span data-ttu-id="adbab-161">步骤 2：创建支持开放式并发的数据访问层</span><span class="sxs-lookup"><span data-stu-id="adbab-161">Step 2: Creating a Data Access Layer That Supports Optimistic Concurrency</span></span>

<span data-ttu-id="adbab-162">若要创建新的类型化数据集，请右键单击 `App_Code` 文件夹中的 `DAL` 文件夹，然后添加一个名为 `NorthwindOptimisticConcurrency`的新数据集。</span><span class="sxs-lookup"><span data-stu-id="adbab-162">To create a new Typed DataSet, right-click on the `DAL` folder within the `App_Code` folder and add a new DataSet named `NorthwindOptimisticConcurrency`.</span></span> <span data-ttu-id="adbab-163">正如我们在第一个教程中看到的那样，这样做会将新的 TableAdapter 添加到类型化数据集，并自动启动 TableAdapter 配置向导。</span><span class="sxs-lookup"><span data-stu-id="adbab-163">As we saw in the first tutorial, doing so will add a new TableAdapter to the Typed DataSet, automatically launching the TableAdapter Configuration Wizard.</span></span> <span data-ttu-id="adbab-164">在第一个屏幕中，系统将提示你使用 `Web.config`中的 `NORTHWNDConnectionString` 设置来指定要连接到的数据库-连接到同一 Northwind 数据库。</span><span class="sxs-lookup"><span data-stu-id="adbab-164">In the first screen, we're prompted to specify the database to connect to - connect to the same Northwind database using the `NORTHWNDConnectionString` setting from `Web.config`.</span></span>

<span data-ttu-id="adbab-165">[![连接到同一 Northwind 数据库](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-165">[![Connect to the Same Northwind Database](implementing-optimistic-concurrency-cs/_static/image8.png)](implementing-optimistic-concurrency-cs/_static/image7.png)</span></span>

<span data-ttu-id="adbab-166">**图 3**：连接到同一 Northwind 数据库（[单击以查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-166">**Figure 3**: Connect to the Same Northwind Database ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image9.png))</span></span>

<span data-ttu-id="adbab-167">接下来，系统将提示您如何查询数据：通过即席 SQL 语句、新存储过程或现有存储过程。</span><span class="sxs-lookup"><span data-stu-id="adbab-167">Next, we are prompted as to how to query the data: through an ad-hoc SQL statement, a new stored procedure, or an existing stored procedure.</span></span> <span data-ttu-id="adbab-168">由于我们在原始 DAL 中使用了即席 SQL 查询，因此请在此处使用此选项。</span><span class="sxs-lookup"><span data-stu-id="adbab-168">Since we used ad-hoc SQL queries in our original DAL, use this option here as well.</span></span>

<span data-ttu-id="adbab-169">[![使用即席 SQL 语句指定要检索的数据](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-169">[![Specify the Data to Retrieve Using an Ad-Hoc SQL Statement](implementing-optimistic-concurrency-cs/_static/image11.png)](implementing-optimistic-concurrency-cs/_static/image10.png)</span></span>

<span data-ttu-id="adbab-170">**图 4**：使用即席 SQL 语句指定要检索的数据（[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-170">**Figure 4**: Specify the Data to Retrieve Using an Ad-Hoc SQL Statement ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image12.png))</span></span>

<span data-ttu-id="adbab-171">在下面的屏幕中，输入用于检索产品信息的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="adbab-171">On the following screen, enter the SQL query to use to retrieve the product information.</span></span> <span data-ttu-id="adbab-172">让我们从原始 DAL 使用与 `Products` TableAdapter 完全相同的 SQL 查询，这将返回所有 `Product` 列以及产品的供应商和类别名称：</span><span class="sxs-lookup"><span data-stu-id="adbab-172">Let's use the exact same SQL query used for the `Products` TableAdapter from our original DAL, which returns all of the `Product` columns along with the product's supplier and category names:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample2.sql)]

<span data-ttu-id="adbab-173">[![使用来自原始 DAL 中的产品 TableAdapter 的相同 SQL 查询](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-173">[![Use the Same SQL Query from the Products TableAdapter in the Original DAL](implementing-optimistic-concurrency-cs/_static/image14.png)](implementing-optimistic-concurrency-cs/_static/image13.png)</span></span>

<span data-ttu-id="adbab-174">**图 5**：使用原始 DAL 中 `Products` TableAdapter 的相同 SQL 查询（[单击以查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-174">**Figure 5**: Use the Same SQL Query from the `Products` TableAdapter in the Original DAL ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image15.png))</span></span>

<span data-ttu-id="adbab-175">在转到下一屏幕之前，请单击 "高级选项" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-175">Before moving onto the next screen, click the Advanced Options button.</span></span> <span data-ttu-id="adbab-176">若要让 TableAdapter 使用乐观并发控制，只需选中 "使用开放式并发" 复选框即可。</span><span class="sxs-lookup"><span data-stu-id="adbab-176">To have this TableAdapter employ optimistic concurrency control, simply check the "Use optimistic concurrency" checkbox.</span></span>

<span data-ttu-id="adbab-177">[![通过选中 "使用开放式并发&quot; &quot;" 复选框来启用乐观并发控制](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-177">[![Enable Optimistic Concurrency Control by Checking the &quot;Use optimistic concurrency&quot; CheckBox](implementing-optimistic-concurrency-cs/_static/image17.png)](implementing-optimistic-concurrency-cs/_static/image16.png)</span></span>

<span data-ttu-id="adbab-178">**图 6**：通过选中 "使用开放式并发" 复选框启用乐观并发控制（[单击以查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-178">**Figure 6**: Enable Optimistic Concurrency Control by Checking the "Use optimistic concurrency" CheckBox ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image18.png))</span></span>

<span data-ttu-id="adbab-179">最后，指示 TableAdapter 应使用既填充 DataTable 还是返回 DataTable 的数据访问模式;还指示应创建 DB 直接方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-179">Lastly, indicate that the TableAdapter should use the data access patterns that both fill a DataTable and return a DataTable; also indicate that the DB direct methods should be created.</span></span> <span data-ttu-id="adbab-180">将的方法名称从 "操作" 更改为 "GetProducts"，以反映我们在原始 DAL 中使用的命名约定。</span><span class="sxs-lookup"><span data-stu-id="adbab-180">Change the method name for the Return a DataTable pattern from GetData to GetProducts, so as to mirror the naming conventions we used in our original DAL.</span></span>

<span data-ttu-id="adbab-181">[![让 TableAdapter 利用所有数据访问模式](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-181">[![Have the TableAdapter Utilize All Data Access Patterns](implementing-optimistic-concurrency-cs/_static/image20.png)](implementing-optimistic-concurrency-cs/_static/image19.png)</span></span>

<span data-ttu-id="adbab-182">**图 7**：让 TableAdapter 利用所有数据访问模式（[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-182">**Figure 7**: Have the TableAdapter Utilize All Data Access Patterns ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image21.png))</span></span>

<span data-ttu-id="adbab-183">完成向导后，数据集设计器将包括强类型 `Products` DataTable 和 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="adbab-183">After completing the wizard, the DataSet Designer will include a strongly-typed `Products` DataTable and TableAdapter.</span></span> <span data-ttu-id="adbab-184">请花点时间将 DataTable 从 `Products` 重命名为 `ProductsOptimisticConcurrency`，可以通过右键单击 DataTable 的标题栏，然后从上下文菜单中选择 "重命名" 来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="adbab-184">Take a moment to rename the DataTable from `Products` to `ProductsOptimisticConcurrency`, which you can do by right-clicking on the DataTable's title bar and choosing Rename from the context menu.</span></span>

<span data-ttu-id="adbab-185">[![DataTable 和 TableAdapter 已添加到类型化数据集](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-185">[![A DataTable and TableAdapter Have Been Added to the Typed DataSet](implementing-optimistic-concurrency-cs/_static/image23.png)](implementing-optimistic-concurrency-cs/_static/image22.png)</span></span>

<span data-ttu-id="adbab-186">**图 8**：已将 DataTable 和 TableAdapter 添加到类型化数据集（[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-186">**Figure 8**: A DataTable and TableAdapter Have Been Added to the Typed DataSet ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image24.png))</span></span>

<span data-ttu-id="adbab-187">若要查看在 `ProductsOptimisticConcurrency` TableAdapter （使用乐观并发）和产品 TableAdapter （不是）之间的 `UPDATE` 和 `DELETE` 查询之间的差异，请单击 TableAdapter 并中转到属性窗口。</span><span class="sxs-lookup"><span data-stu-id="adbab-187">To see the differences between the `UPDATE` and `DELETE` queries between the `ProductsOptimisticConcurrency` TableAdapter (which uses optimistic concurrency) and the Products TableAdapter (which doesn't), click on the TableAdapter and go to the Properties window.</span></span> <span data-ttu-id="adbab-188">在 "`DeleteCommand`" 和 "`UpdateCommand` 属性" `CommandText` 子属性 "子属性中，可以看到调用 DAL 的 update 或 delete 相关方法时发送到数据库的实际 SQL 语法。</span><span class="sxs-lookup"><span data-stu-id="adbab-188">In the `DeleteCommand` and `UpdateCommand` properties' `CommandText` subproperties you can see the actual SQL syntax that is sent to the database when the DAL's update or delete-related methods are invoked.</span></span> <span data-ttu-id="adbab-189">对于 `ProductsOptimisticConcurrency` TableAdapter，使用的 `DELETE` 语句是：</span><span class="sxs-lookup"><span data-stu-id="adbab-189">For the `ProductsOptimisticConcurrency` TableAdapter the `DELETE` statement used is:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample3.sql)]

<span data-ttu-id="adbab-190">而原始 DAL 中产品 TableAdapter 的 `DELETE` 语句则简单得多：</span><span class="sxs-lookup"><span data-stu-id="adbab-190">Whereas the `DELETE` statement for the Product TableAdapter in our original DAL is the much simpler:</span></span>

[!code-sql[Main](implementing-optimistic-concurrency-cs/samples/sample4.sql)]

<span data-ttu-id="adbab-191">正如您所看到的，使用乐观并发的 TableAdapter 的 `DELETE` 语句中的 `WHERE` 子句包括：每个 `Product` 表的现有列值与上次填充 GridView （或 DetailsView 或 FormView）时的原始值之间的比较。</span><span class="sxs-lookup"><span data-stu-id="adbab-191">As you can see, the `WHERE` clause in the `DELETE` statement for the TableAdapter that uses optimistic concurrency includes a comparison between each of the `Product` table's existing column values and the original values at the time the GridView (or DetailsView or FormView) was last populated.</span></span> <span data-ttu-id="adbab-192">由于 `ProductID`、`ProductName`和 `Discontinued` 之外的所有字段都可以具有 `NULL` 值，因此，在 `NULL` 子句中正确比较 `WHERE` 值时将包含附加参数和检查。</span><span class="sxs-lookup"><span data-stu-id="adbab-192">Since all fields other than `ProductID`, `ProductName`, and `Discontinued` can have `NULL` values, additional parameters and checks are included to correctly compare `NULL` values in the `WHERE` clause.</span></span>

<span data-ttu-id="adbab-193">在本教程中，我们不会向启用了开放式并发的数据集添加任何其他数据表，因为我们的 ASP.NET 页将只提供更新和删除产品信息。</span><span class="sxs-lookup"><span data-stu-id="adbab-193">We won't be adding any additional DataTables to the optimistic concurrency-enabled DataSet for this tutorial, as our ASP.NET page will only provide updating and deleting product information.</span></span> <span data-ttu-id="adbab-194">但是，我们仍然需要将 `GetProductByProductID(productID)` 方法添加到 `ProductsOptimisticConcurrency` 的 TableAdapter 中。</span><span class="sxs-lookup"><span data-stu-id="adbab-194">However, we do still need to add the `GetProductByProductID(productID)` method to the `ProductsOptimisticConcurrency` TableAdapter.</span></span>

<span data-ttu-id="adbab-195">为此，请右键单击 TableAdapter 的标题栏（`Fill` 和 `GetProducts` 方法名称上方的区域，然后从上下文菜单中选择 "添加查询"。</span><span class="sxs-lookup"><span data-stu-id="adbab-195">To accomplish this, right-click on the TableAdapter's title bar (the area right above the `Fill` and `GetProducts` method names) and choose Add Query from the context menu.</span></span> <span data-ttu-id="adbab-196">这将启动 "TableAdapter 查询配置向导"。</span><span class="sxs-lookup"><span data-stu-id="adbab-196">This will launch the TableAdapter Query Configuration Wizard.</span></span> <span data-ttu-id="adbab-197">与 TableAdapter 的初始配置一样，选择使用即席 SQL 语句创建 `GetProductByProductID(productID)` 方法（请参阅图4）。</span><span class="sxs-lookup"><span data-stu-id="adbab-197">As with our TableAdapter's initial configuration, opt to create the `GetProductByProductID(productID)` method using an ad-hoc SQL statement (see Figure 4).</span></span> <span data-ttu-id="adbab-198">由于 `GetProductByProductID(productID)` 方法返回有关特定产品的信息，因此表示此查询是返回行的 `SELECT` 查询类型。</span><span class="sxs-lookup"><span data-stu-id="adbab-198">Since the `GetProductByProductID(productID)` method returns information about a particular product, indicate that this query is a `SELECT` query type that returns rows.</span></span>

<span data-ttu-id="adbab-199">[![将查询类型标记为 &quot;选择返回行&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-199">[![Mark the Query Type as a &quot;SELECT which returns rows&quot;](implementing-optimistic-concurrency-cs/_static/image26.png)](implementing-optimistic-concurrency-cs/_static/image25.png)</span></span>

<span data-ttu-id="adbab-200">**图 9**：将查询类型标记为 "`SELECT` 返回行" （[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image27.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-200">**Figure 9**: Mark the Query Type as a "`SELECT` which returns rows" ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image27.png))</span></span>

<span data-ttu-id="adbab-201">在下一个屏幕上，系统将提示你输入要使用的 SQL 查询，并预先加载 TableAdapter 的默认查询。</span><span class="sxs-lookup"><span data-stu-id="adbab-201">On the next screen we're prompted for the SQL query to use, with the TableAdapter's default query pre-loaded.</span></span> <span data-ttu-id="adbab-202">将现有查询扩充为包含子句 `WHERE ProductID = @ProductID`，如图10所示。</span><span class="sxs-lookup"><span data-stu-id="adbab-202">Augment the existing query to include the clause `WHERE ProductID = @ProductID`, as shown in Figure 10.</span></span>

<span data-ttu-id="adbab-203">[![向预先加载的查询添加一个 WHERE 子句以返回特定产品记录](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-203">[![Add a WHERE Clause to the Pre-Loaded Query to Return a Specific Product Record](implementing-optimistic-concurrency-cs/_static/image29.png)](implementing-optimistic-concurrency-cs/_static/image28.png)</span></span>

<span data-ttu-id="adbab-204">**图 10**：将 `WHERE` 子句添加到预先加载的查询以返回特定产品记录（[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image30.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-204">**Figure 10**: Add a `WHERE` Clause to the Pre-Loaded Query to Return a Specific Product Record ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image30.png))</span></span>

<span data-ttu-id="adbab-205">最后，将生成的方法名称更改为 `FillByProductID` 并 `GetProductByProductID`。</span><span class="sxs-lookup"><span data-stu-id="adbab-205">Finally, change the generated method names to `FillByProductID` and `GetProductByProductID`.</span></span>

<span data-ttu-id="adbab-206">[![将方法重命名为 FillByProductID 和 GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-206">[![Rename the Methods to FillByProductID and GetProductByProductID](implementing-optimistic-concurrency-cs/_static/image32.png)](implementing-optimistic-concurrency-cs/_static/image31.png)</span></span>

<span data-ttu-id="adbab-207">**图 11**：将方法重命名为 "`FillByProductID`" 和 "`GetProductByProductID`" （[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image33.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-207">**Figure 11**: Rename the Methods to `FillByProductID` and `GetProductByProductID` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image33.png))</span></span>

<span data-ttu-id="adbab-208">完成此向导后，TableAdapter 现在包含用于检索数据的两个方法： `GetProducts()`，它将返回*所有*产品;和 `GetProductByProductID(productID)`，它返回指定的产品。</span><span class="sxs-lookup"><span data-stu-id="adbab-208">With this wizard complete, the TableAdapter now contains two methods for retrieving data: `GetProducts()`, which returns *all* products; and `GetProductByProductID(productID)`, which returns the specified product.</span></span>

## <a name="step-3-creating-a-business-logic-layer-for-the-optimistic-concurrency-enabled-dal"></a><span data-ttu-id="adbab-209">步骤 3：为启用了开放式并发的 DAL 创建业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="adbab-209">Step 3: Creating a Business Logic Layer for the Optimistic Concurrency-Enabled DAL</span></span>

<span data-ttu-id="adbab-210">我们的现有 `ProductsBLL` 类包含使用批更新和数据库直接模式的示例。</span><span class="sxs-lookup"><span data-stu-id="adbab-210">Our existing `ProductsBLL` class has examples of using both the batch update and DB direct patterns.</span></span> <span data-ttu-id="adbab-211">`AddProduct` 方法和 `UpdateProduct` 重载都使用批处理更新模式，并将 `ProductRow` 实例传入到 TableAdapter 的 Update 方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-211">The `AddProduct` method and `UpdateProduct` overloads both use the batch update pattern, passing in a `ProductRow` instance to the TableAdapter's Update method.</span></span> <span data-ttu-id="adbab-212">另一方面，`DeleteProduct` 方法使用 DB 直接模式，调用 TableAdapter 的 `Delete(productID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-212">The `DeleteProduct` method, on the other hand, uses the DB direct pattern, calling the TableAdapter's `Delete(productID)` method.</span></span>

<span data-ttu-id="adbab-213">利用新的 `ProductsOptimisticConcurrency` TableAdapter，DB 直接方法现在还要求传递原始值。</span><span class="sxs-lookup"><span data-stu-id="adbab-213">With the new `ProductsOptimisticConcurrency` TableAdapter, the DB direct methods now require that the original values also be passed in.</span></span> <span data-ttu-id="adbab-214">例如，`Delete` 方法现在需要10个输入参数：原始 `ProductID`、`ProductName`、`SupplierID`、`CategoryID`、`QuantityPerUnit`、`UnitPrice`、`UnitsInStock`、`UnitsOnOrder`、`ReorderLevel`和 `Discontinued`。</span><span class="sxs-lookup"><span data-stu-id="adbab-214">For example, the `Delete` method now expects ten input parameters: the original `ProductID`, `ProductName`, `SupplierID`, `CategoryID`, `QuantityPerUnit`, `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, `ReorderLevel`, and `Discontinued`.</span></span> <span data-ttu-id="adbab-215">它在发送到数据库的 `DELETE` 语句 `WHERE` 子句中使用这些附加输入参数的值，如果数据库的当前值映射到原始值，则仅删除指定的记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-215">It uses these additional input parameters' values in `WHERE` clause of the `DELETE` statement sent to the database, only deleting the specified record if the database's current values map up to the original ones.</span></span>

<span data-ttu-id="adbab-216">虽然在批处理更新模式中使用的 TableAdapter `Update` 方法的方法签名尚未更改，但记录原始值和新值所需的代码具有。</span><span class="sxs-lookup"><span data-stu-id="adbab-216">While the method signature for the TableAdapter's `Update` method used in the batch update pattern hasn't changed, the code needed to record the original and new values has.</span></span> <span data-ttu-id="adbab-217">因此，请不要使用现有的 `ProductsBLL` 类尝试使用启用了开放式并发的 DAL，而是创建一个新的业务逻辑层类来使用新的 DAL。</span><span class="sxs-lookup"><span data-stu-id="adbab-217">Therefore, rather than attempt to use the optimistic concurrency-enabled DAL with our existing `ProductsBLL` class, let's create a new Business Logic Layer class for working with our new DAL.</span></span>

<span data-ttu-id="adbab-218">将名为 `ProductsOptimisticConcurrencyBLL` 的类添加到 `App_Code` 文件夹内的 `BLL` 文件夹中。</span><span class="sxs-lookup"><span data-stu-id="adbab-218">Add a class named `ProductsOptimisticConcurrencyBLL` to the `BLL` folder within the `App_Code` folder.</span></span>

![将 ProductsOptimisticConcurrencyBLL 类添加到 BLL 文件夹](implementing-optimistic-concurrency-cs/_static/image34.png)

<span data-ttu-id="adbab-220">**图 12**：将 `ProductsOptimisticConcurrencyBLL` 类添加到 BLL 文件夹</span><span class="sxs-lookup"><span data-stu-id="adbab-220">**Figure 12**: Add the `ProductsOptimisticConcurrencyBLL` Class to the BLL Folder</span></span>

<span data-ttu-id="adbab-221">接下来，将以下代码添加到 `ProductsOptimisticConcurrencyBLL` 类：</span><span class="sxs-lookup"><span data-stu-id="adbab-221">Next, add the following code to the `ProductsOptimisticConcurrencyBLL` class:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample5.cs)]

<span data-ttu-id="adbab-222">请注意类声明开头的 using `NorthwindOptimisticConcurrencyTableAdapters` 语句。</span><span class="sxs-lookup"><span data-stu-id="adbab-222">Note the using `NorthwindOptimisticConcurrencyTableAdapters` statement above the start of the class declaration.</span></span> <span data-ttu-id="adbab-223">`NorthwindOptimisticConcurrencyTableAdapters` 命名空间包含 `ProductsOptimisticConcurrencyTableAdapter` 类，该类提供 DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-223">The `NorthwindOptimisticConcurrencyTableAdapters` namespace contains the `ProductsOptimisticConcurrencyTableAdapter` class, which provides the DAL's methods.</span></span> <span data-ttu-id="adbab-224">同样，在类声明之前，你会找到 `System.ComponentModel.DataObject` 特性，该特性指示 Visual Studio 将此类包含在 ObjectDataSource 向导的下拉列表中。</span><span class="sxs-lookup"><span data-stu-id="adbab-224">Also before the class declaration you'll find the `System.ComponentModel.DataObject` attribute, which instructs Visual Studio to include this class in the ObjectDataSource wizard's drop-down list.</span></span>

<span data-ttu-id="adbab-225">`ProductsOptimisticConcurrencyBLL`的 `Adapter` 属性提供对 `ProductsOptimisticConcurrencyTableAdapter` 类的实例的快速访问，并遵循我们的原始 BLL 类（`ProductsBLL`、`CategoriesBLL`等）中使用的模式。</span><span class="sxs-lookup"><span data-stu-id="adbab-225">The `ProductsOptimisticConcurrencyBLL`'s `Adapter` property provides quick access to an instance of the `ProductsOptimisticConcurrencyTableAdapter` class, and follows the pattern used in our original BLL classes (`ProductsBLL`, `CategoriesBLL`, and so on).</span></span> <span data-ttu-id="adbab-226">最后，`GetProducts()` 方法只是向下调用 DAL 的 `GetProducts()` 方法，并返回一个 `ProductsOptimisticConcurrencyDataTable` 对象，该对象使用数据库中每个产品记录的 `ProductsOptimisticConcurrencyRow` 实例进行填充。</span><span class="sxs-lookup"><span data-stu-id="adbab-226">Finally, the `GetProducts()` method simply calls down into the DAL's `GetProducts()` method and returns a `ProductsOptimisticConcurrencyDataTable` object populated with a `ProductsOptimisticConcurrencyRow` instance for each product record in the database.</span></span>

## <a name="deleting-a-product-using-the-db-direct-pattern-with-optimistic-concurrency"></a><span data-ttu-id="adbab-227">使用 DB 直接模式和乐观并发删除产品</span><span class="sxs-lookup"><span data-stu-id="adbab-227">Deleting a Product Using the DB Direct Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="adbab-228">对使用开放式并发的 DAL 使用 DB direct 模式时，必须将这些方法传递给新的和原始值。</span><span class="sxs-lookup"><span data-stu-id="adbab-228">When using the DB direct pattern against a DAL that uses optimistic concurrency, the methods must be passed the new and original values.</span></span> <span data-ttu-id="adbab-229">对于删除，没有新值，因此只需传入原始值。</span><span class="sxs-lookup"><span data-stu-id="adbab-229">For deleting, there are no new values, so only the original values need be passed in.</span></span> <span data-ttu-id="adbab-230">在 BLL 中，必须接受所有原始参数作为输入参数。</span><span class="sxs-lookup"><span data-stu-id="adbab-230">In our BLL, then, we must accept all of the original parameters as input parameters.</span></span> <span data-ttu-id="adbab-231">让我们在 `ProductsOptimisticConcurrencyBLL` 类中拥有 `DeleteProduct` 方法，使用 DB 直接方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-231">Let's have the `DeleteProduct` method in the `ProductsOptimisticConcurrencyBLL` class use the DB direct method.</span></span> <span data-ttu-id="adbab-232">这意味着此方法需要将所有十个产品数据字段作为输入参数，并将其传递给 DAL，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="adbab-232">This means that this method needs to take in all ten product data fields as input parameters, and pass these to the DAL, as shown in the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample6.cs)]

<span data-ttu-id="adbab-233">如果原始值（即，在用户单击 "删除" 按钮时，最后加载到 GridView 中的值）与数据库中的值不同，则 `WHERE` 子句不会与任何数据库记录匹配，也不会影响任何记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-233">If the original values - those values that were last loaded into the GridView (or DetailsView or FormView) - differ from the values in the database when the user clicks the Delete button the `WHERE` clause won't match up with any database record and no records will be affected.</span></span> <span data-ttu-id="adbab-234">因此，TableAdapter 的 `Delete` 方法将返回 `0`，并且 BLL 的 `DeleteProduct` 方法将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="adbab-234">Hence, the TableAdapter's `Delete` method will return `0` and the BLL's `DeleteProduct` method will return `false`.</span></span>

## <a name="updating-a-product-using-the-batch-update-pattern-with-optimistic-concurrency"></a><span data-ttu-id="adbab-235">使用带有乐观并发的批处理更新模式更新产品</span><span class="sxs-lookup"><span data-stu-id="adbab-235">Updating a Product Using the Batch Update Pattern with Optimistic Concurrency</span></span>

<span data-ttu-id="adbab-236">如前文所述，无论是否采用了开放式并发，批处理更新模式的 TableAdapter `Update` 方法都具有相同的方法签名。</span><span class="sxs-lookup"><span data-stu-id="adbab-236">As noted earlier, the TableAdapter's `Update` method for the batch update pattern has the same method signature regardless of whether or not optimistic concurrency is employed.</span></span> <span data-ttu-id="adbab-237">也就是说，`Update` 方法需要 DataRow、Datarow 数组或类型化数据集。</span><span class="sxs-lookup"><span data-stu-id="adbab-237">Namely, the `Update` method expects a DataRow, an array of DataRows, a DataTable, or a Typed DataSet.</span></span> <span data-ttu-id="adbab-238">没有用于指定原始值的其他输入参数。</span><span class="sxs-lookup"><span data-stu-id="adbab-238">There are no additional input parameters for specifying the original values.</span></span> <span data-ttu-id="adbab-239">这是可能的，因为 DataTable 跟踪其 DataRow 的原始值和修改后的值。</span><span class="sxs-lookup"><span data-stu-id="adbab-239">This is possible because the DataTable keeps track of the original and modified values for its DataRow(s).</span></span> <span data-ttu-id="adbab-240">当 DAL 发出其 `UPDATE` 语句时，将用 DataRow 的原始值填充 `@original_ColumnName` 参数，而 `@ColumnName` 参数则用 DataRow 的已修改值填充。</span><span class="sxs-lookup"><span data-stu-id="adbab-240">When the DAL issues its `UPDATE` statement, the `@original_ColumnName` parameters are populated with the DataRow's original values, whereas the `@ColumnName` parameters are populated with the DataRow's modified values.</span></span>

<span data-ttu-id="adbab-241">在 `ProductsBLL` 类（它使用我们的原始非开放式并发 DAL）中，当使用批更新模式更新产品信息时，我们的代码将执行以下一系列事件：</span><span class="sxs-lookup"><span data-stu-id="adbab-241">In the `ProductsBLL` class (which uses our original, non-optimistic concurrency DAL), when using the batch update pattern to update product information our code performs the following sequence of events:</span></span>

1. <span data-ttu-id="adbab-242">使用 TableAdapter 的 `GetProductByProductID(productID)` 方法将当前数据库产品信息读入 `ProductRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-242">Read the current database product information into a `ProductRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="adbab-243">将新值分配到步骤1中的 `ProductRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-243">Assign the new values to the `ProductRow` instance from Step 1</span></span>
3. <span data-ttu-id="adbab-244">调用 TableAdapter 的 `Update` 方法，并传入 `ProductRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-244">Call the TableAdapter's `Update` method, passing in the `ProductRow` instance</span></span>

<span data-ttu-id="adbab-245">但是，这一顺序不能正确支持乐观并发，因为在步骤1中填充的 `ProductRow` 是直接从数据库填充的，这意味着，DataRow 使用的原始值是当前存在于数据库中的值，而不是在编辑过程开始时绑定到 GridView 的值。</span><span class="sxs-lookup"><span data-stu-id="adbab-245">This sequence of steps, however, won't correctly support optimistic concurrency because the `ProductRow` populated in Step 1 is populated directly from the database, meaning that the original values used by the DataRow are those that currently exist in the database, and not those that were bound to the GridView at the start of the editing process.</span></span> <span data-ttu-id="adbab-246">相反，在使用启用了开放式并发的 DAL 时，需要改变 `UpdateProduct` 方法重载才能使用以下步骤：</span><span class="sxs-lookup"><span data-stu-id="adbab-246">Instead, when using an optimistic concurrency-enabled DAL, we need to alter the `UpdateProduct` method overloads to use the following steps:</span></span>

1. <span data-ttu-id="adbab-247">使用 TableAdapter 的 `GetProductByProductID(productID)` 方法将当前数据库产品信息读入 `ProductsOptimisticConcurrencyRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-247">Read the current database product information into a `ProductsOptimisticConcurrencyRow` instance using the TableAdapter's `GetProductByProductID(productID)` method</span></span>
2. <span data-ttu-id="adbab-248">将*原始*值分配给步骤1中的 `ProductsOptimisticConcurrencyRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-248">Assign the *original* values to the `ProductsOptimisticConcurrencyRow` instance from Step 1</span></span>
3. <span data-ttu-id="adbab-249">调用 `ProductsOptimisticConcurrencyRow` 实例的 `AcceptChanges()` 方法，该方法指示 DataRow 当前的值是 "原始" 值</span><span class="sxs-lookup"><span data-stu-id="adbab-249">Call the `ProductsOptimisticConcurrencyRow` instance's `AcceptChanges()` method, which instructs the DataRow that its current values are the "original" ones</span></span>
4. <span data-ttu-id="adbab-250">将*新*值分配给 `ProductsOptimisticConcurrencyRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-250">Assign the *new* values to the `ProductsOptimisticConcurrencyRow` instance</span></span>
5. <span data-ttu-id="adbab-251">调用 TableAdapter 的 `Update` 方法，并传入 `ProductsOptimisticConcurrencyRow` 实例</span><span class="sxs-lookup"><span data-stu-id="adbab-251">Call the TableAdapter's `Update` method, passing in the `ProductsOptimisticConcurrencyRow` instance</span></span>

<span data-ttu-id="adbab-252">步骤1读取指定产品记录的所有当前数据库值。</span><span class="sxs-lookup"><span data-stu-id="adbab-252">Step 1 reads in all of the current database values for the specified product record.</span></span> <span data-ttu-id="adbab-253">此步骤在更新*所有*产品列的 `UpdateProduct` 重载中是多余的（因为在步骤2中覆盖了这些值，但在步骤2中覆盖了这些值），但这对于那些仅作为输入参数传入了列值子集的重载是必需的。</span><span class="sxs-lookup"><span data-stu-id="adbab-253">This step is superfluous in the `UpdateProduct` overload that updates *all* of the product columns (as these values are overwritten in Step 2), but is essential for those overloads where only a subset of the column values are passed in as input parameters.</span></span> <span data-ttu-id="adbab-254">将原始值分配给 `ProductsOptimisticConcurrencyRow` 实例后，将调用 `AcceptChanges()` 方法，该方法将当前 DataRow 值标记为要在 `UPDATE` 语句的 `@original_ColumnName` 参数中使用的原始值。</span><span class="sxs-lookup"><span data-stu-id="adbab-254">Once the original values have been assigned to the `ProductsOptimisticConcurrencyRow` instance, the `AcceptChanges()` method is called, which marks the current DataRow values as the original values to be used in the `@original_ColumnName` parameters in the `UPDATE` statement.</span></span> <span data-ttu-id="adbab-255">接下来，将新参数值分配给 `ProductsOptimisticConcurrencyRow`，最后调用 `Update` 方法，并传入 DataRow。</span><span class="sxs-lookup"><span data-stu-id="adbab-255">Next, the new parameter values are assigned to the `ProductsOptimisticConcurrencyRow` and, finally, the `Update` method is invoked, passing in the DataRow.</span></span>

<span data-ttu-id="adbab-256">下面的代码显示接受所有产品数据字段作为输入参数的 `UpdateProduct` 重载。</span><span class="sxs-lookup"><span data-stu-id="adbab-256">The following code shows the `UpdateProduct` overload that accepts all product data fields as input parameters.</span></span> <span data-ttu-id="adbab-257">尽管此处未显示，但在本教程的下载中包含的 `ProductsOptimisticConcurrencyBLL` 类还包含一个 `UpdateProduct` 重载，该重载只接受产品的名称和价格作为输入参数。</span><span class="sxs-lookup"><span data-stu-id="adbab-257">While not shown here, the `ProductsOptimisticConcurrencyBLL` class included in the download for this tutorial also contains an `UpdateProduct` overload that accepts just the product's name and price as input parameters.</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample7.cs)]

## <a name="step-4-passing-the-original-and-new-values-from-the-aspnet-page-to-the-bll-methods"></a><span data-ttu-id="adbab-258">步骤 4：将 ASP.NET 页中的原始值和新值传递到 BLL 方法</span><span class="sxs-lookup"><span data-stu-id="adbab-258">Step 4: Passing the Original and New Values From the ASP.NET Page to the BLL Methods</span></span>

<span data-ttu-id="adbab-259">DAL 和 BLL 完成后，剩下的就是创建一个可利用内置于系统中的开放式并发逻辑的 ASP.NET 页面。</span><span class="sxs-lookup"><span data-stu-id="adbab-259">With the DAL and BLL complete, all that remains is to create an ASP.NET page that can utilize the optimistic concurrency logic built in to the system.</span></span> <span data-ttu-id="adbab-260">具体而言，数据 Web 控件（GridView、DetailsView 或 FormView）必须记住其原始值，并且 ObjectDataSource 必须将这两组值传递到业务逻辑层。</span><span class="sxs-lookup"><span data-stu-id="adbab-260">Specifically, the data Web control (the GridView, DetailsView, or FormView) must remember its original values and the ObjectDataSource must pass both sets of values to the Business Logic Layer.</span></span> <span data-ttu-id="adbab-261">此外，必须将 ASP.NET 页配置为正常处理并发冲突。</span><span class="sxs-lookup"><span data-stu-id="adbab-261">Furthermore, the ASP.NET page must be configured to gracefully handle concurrency violations.</span></span>

<span data-ttu-id="adbab-262">首先打开 `EditInsertDelete` 文件夹中的 "`OptimisticConcurrency.aspx`" 页，然后将一个 GridView 添加到设计器中，将其 `ID` 属性设置为 "`ProductsGrid`"。</span><span class="sxs-lookup"><span data-stu-id="adbab-262">Start by opening the `OptimisticConcurrency.aspx` page in the `EditInsertDelete` folder and adding a GridView to the Designer, setting its `ID` property to `ProductsGrid`.</span></span> <span data-ttu-id="adbab-263">从 GridView 的智能标记中，选择创建名为 `ProductsOptimisticConcurrencyDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="adbab-263">From the GridView's smart tag, opt to create a new ObjectDataSource named `ProductsOptimisticConcurrencyDataSource`.</span></span> <span data-ttu-id="adbab-264">由于我们希望此 ObjectDataSource 使用支持开放式并发的 DAL，请将其配置为使用 `ProductsOptimisticConcurrencyBLL` 对象。</span><span class="sxs-lookup"><span data-stu-id="adbab-264">Since we want this ObjectDataSource to use the DAL that supports optimistic concurrency, configure it to use the `ProductsOptimisticConcurrencyBLL` object.</span></span>

<span data-ttu-id="adbab-265">[![让 ObjectDataSource 使用 ProductsOptimisticConcurrencyBLL 对象](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-265">[![Have the ObjectDataSource Use the ProductsOptimisticConcurrencyBLL Object](implementing-optimistic-concurrency-cs/_static/image36.png)](implementing-optimistic-concurrency-cs/_static/image35.png)</span></span>

<span data-ttu-id="adbab-266">**图 13**：让 ObjectDataSource 使用 `ProductsOptimisticConcurrencyBLL` 对象（[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image37.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-266">**Figure 13**: Have the ObjectDataSource Use the `ProductsOptimisticConcurrencyBLL` Object ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image37.png))</span></span>

<span data-ttu-id="adbab-267">从向导的下拉列表中选择 `GetProducts`、`UpdateProduct`和 `DeleteProduct` 方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-267">Choose the `GetProducts`, `UpdateProduct`, and `DeleteProduct` methods from drop-down lists in the wizard.</span></span> <span data-ttu-id="adbab-268">对于 UpdateProduct 方法，请使用接受所有产品数据字段的重载。</span><span class="sxs-lookup"><span data-stu-id="adbab-268">For the UpdateProduct method, use the overload that accepts all of the product's data fields.</span></span>

## <a name="configuring-the-objectdatasource-controls-properties"></a><span data-ttu-id="adbab-269">配置 ObjectDataSource 控件的属性</span><span class="sxs-lookup"><span data-stu-id="adbab-269">Configuring the ObjectDataSource Control's Properties</span></span>

<span data-ttu-id="adbab-270">完成向导后，ObjectDataSource 的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="adbab-270">After completing the wizard, the ObjectDataSource's declarative markup should look like the following:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample8.aspx)]

<span data-ttu-id="adbab-271">如您所见，`DeleteParameters` 集合包含 `ProductsOptimisticConcurrencyBLL` 类的 `DeleteProduct` 方法中的10个输入参数的 `Parameter` 实例。</span><span class="sxs-lookup"><span data-stu-id="adbab-271">As you can see, the `DeleteParameters` collection contains a `Parameter` instance for each of the ten input parameters in the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method.</span></span> <span data-ttu-id="adbab-272">同样，`UpdateParameters` 集合包含 `UpdateProduct`中每个输入参数的 `Parameter` 实例。</span><span class="sxs-lookup"><span data-stu-id="adbab-272">Likewise, the `UpdateParameters` collection contains a `Parameter` instance for each of the input parameters in `UpdateProduct`.</span></span>

<span data-ttu-id="adbab-273">对于之前涉及数据修改的这些教程，我们此时将删除该 ObjectDataSource 的 `OldValuesParameterFormatString` 属性，因为此属性指示 BLL 方法应传递旧的（或原始）值以及新的值。</span><span class="sxs-lookup"><span data-stu-id="adbab-273">For those previous tutorials that involved data modification, we'd remove the ObjectDataSource's `OldValuesParameterFormatString` property at this point, since this property indicates that the BLL method expects the old (or original) values to be passed in as well as the new values.</span></span> <span data-ttu-id="adbab-274">此外，此属性值指示原始值的输入参数名称。</span><span class="sxs-lookup"><span data-stu-id="adbab-274">Furthermore, this property value indicates the input parameter names for the original values.</span></span> <span data-ttu-id="adbab-275">由于我们要将原始值传入到 BLL，因此*请勿删除此*属性。</span><span class="sxs-lookup"><span data-stu-id="adbab-275">Since we are passing in the original values into the BLL, do *not* remove this property.</span></span>

> [!NOTE]
> <span data-ttu-id="adbab-276">`OldValuesParameterFormatString` 属性的值必须映射到 BLL 中预期原始值的输入参数名称。</span><span class="sxs-lookup"><span data-stu-id="adbab-276">The value of the `OldValuesParameterFormatString` property must map to the input parameter names in the BLL that expect the original values.</span></span> <span data-ttu-id="adbab-277">由于我们将这些参数命名 `original_productName`、`original_supplierID`等，因此你可以将 `OldValuesParameterFormatString` 属性值保留为 `original_{0}`。</span><span class="sxs-lookup"><span data-stu-id="adbab-277">Since we named these parameters `original_productName`, `original_supplierID`, and so on, you can leave the `OldValuesParameterFormatString` property value as `original_{0}`.</span></span> <span data-ttu-id="adbab-278">然而，如果 BLL 方法的输入参数的名称类似于 `old_productName`、`old_supplierID`等，则需要将 `OldValuesParameterFormatString` 属性更新为 `old_{0}`。</span><span class="sxs-lookup"><span data-stu-id="adbab-278">If, however, the BLL methods' input parameters had names like `old_productName`, `old_supplierID`, and so on, you'd need to update the `OldValuesParameterFormatString` property to `old_{0}`.</span></span>

<span data-ttu-id="adbab-279">为了使 ObjectDataSource 正确地将原始值传递到 BLL 方法，需要进行一个最终的属性设置。</span><span class="sxs-lookup"><span data-stu-id="adbab-279">There's one final property setting that needs to be made in order for the ObjectDataSource to correctly pass the original values to the BLL methods.</span></span> <span data-ttu-id="adbab-280">ObjectDataSource 具有可分配给[以下两个值之一](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx)的[ConflictDetection 属性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx)：</span><span class="sxs-lookup"><span data-stu-id="adbab-280">The ObjectDataSource has a [ConflictDetection property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.conflictdetection.aspx) that can be assigned to [one of two values](https://msdn.microsoft.com/library/system.web.ui.conflictoptions.aspx):</span></span>

- <span data-ttu-id="adbab-281">`OverwriteChanges`-默认值;不向 BLL 方法的原始输入参数发送原始值</span><span class="sxs-lookup"><span data-stu-id="adbab-281">`OverwriteChanges` - the default value; does not send the original values to the BLL methods' original input parameters</span></span>
- <span data-ttu-id="adbab-282">`CompareAllValues`-会将原始值发送到 BLL 方法;使用开放式并发时选择此选项</span><span class="sxs-lookup"><span data-stu-id="adbab-282">`CompareAllValues` - does send the original values to the BLL methods; choose this option when using optimistic concurrency</span></span>

<span data-ttu-id="adbab-283">请花点时间将 `ConflictDetection` 属性设置为 `CompareAllValues`。</span><span class="sxs-lookup"><span data-stu-id="adbab-283">Take a moment to set the `ConflictDetection` property to `CompareAllValues`.</span></span>

## <a name="configuring-the-gridviews-properties-and-fields"></a><span data-ttu-id="adbab-284">配置 GridView 的属性和字段</span><span class="sxs-lookup"><span data-stu-id="adbab-284">Configuring the GridView's Properties and Fields</span></span>

<span data-ttu-id="adbab-285">已正确配置 ObjectDataSource 的属性后，让我们来强调设置 GridView。</span><span class="sxs-lookup"><span data-stu-id="adbab-285">With the ObjectDataSource's properties properly configured, let's turn our attention to setting up the GridView.</span></span> <span data-ttu-id="adbab-286">首先，由于我们希望 GridView 支持编辑和删除，请单击 GridView 智能标记中的 "启用编辑并启用删除" 复选框。</span><span class="sxs-lookup"><span data-stu-id="adbab-286">First, since we want the GridView to support editing and deleting, click the Enable Editing and Enable Deleting checkboxes from the GridView's smart tag.</span></span> <span data-ttu-id="adbab-287">这会添加一个 CommandField，其 `ShowEditButton` 和 `ShowDeleteButton` 均设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="adbab-287">This will add a CommandField whose `ShowEditButton` and `ShowDeleteButton` are both set to `true`.</span></span>

<span data-ttu-id="adbab-288">绑定到 `ProductsOptimisticConcurrencyDataSource` ObjectDataSource 时，GridView 包含产品的每个数据字段的字段。</span><span class="sxs-lookup"><span data-stu-id="adbab-288">When bound to the `ProductsOptimisticConcurrencyDataSource` ObjectDataSource, the GridView contains a field for each of the product's data fields.</span></span> <span data-ttu-id="adbab-289">尽管可以编辑此类 GridView，但用户体验是可接受的。</span><span class="sxs-lookup"><span data-stu-id="adbab-289">While such a GridView can be edited, the user experience is anything but acceptable.</span></span> <span data-ttu-id="adbab-290">`CategoryID` 和 `SupplierID` BoundFields 将呈现为文本框，要求用户输入相应的类别和供应商作为 ID 号。</span><span class="sxs-lookup"><span data-stu-id="adbab-290">The `CategoryID` and `SupplierID` BoundFields will render as TextBoxes, requiring the user to enter the appropriate category and supplier as ID numbers.</span></span> <span data-ttu-id="adbab-291">对于数字字段和无验证控件，都不会有任何格式，以确保已提供产品的名称，并确保单价、库存单位、按顺序排列的单位和重新排序级别值都是正确的数值，并且大于或等于为零。</span><span class="sxs-lookup"><span data-stu-id="adbab-291">There will be no formatting for the numeric fields and no validation controls to ensure that the product's name has been supplied and that the unit price, units in stock, units on order, and reorder level values are both proper numeric values and are greater than or equal to zero.</span></span>

<span data-ttu-id="adbab-292">如我们在向*编辑和插入界面添加验证控件*和*自定义数据修改接口*教程中所述，可以通过将 BoundFields 替换为 templatefield 来自定义用户界面。</span><span class="sxs-lookup"><span data-stu-id="adbab-292">As we discussed in the *Adding Validation Controls to the Editing and Inserting Interfaces* and *Customizing the Data Modification Interface* tutorials, the user interface can be customized by replacing the BoundFields with TemplateFields.</span></span> <span data-ttu-id="adbab-293">我已通过以下方式修改了此 GridView 及其编辑界面：</span><span class="sxs-lookup"><span data-stu-id="adbab-293">I've modified this GridView and its editing interface in the following ways:</span></span>

- <span data-ttu-id="adbab-294">删除 `ProductID`、`SupplierName`和 `CategoryName` BoundFields</span><span class="sxs-lookup"><span data-stu-id="adbab-294">Removed the `ProductID`, `SupplierName`, and `CategoryName` BoundFields</span></span>
- <span data-ttu-id="adbab-295">将 `ProductName` BoundField 转换为 TemplateField 并添加 RequiredFieldValidation 控件。</span><span class="sxs-lookup"><span data-stu-id="adbab-295">Converted the `ProductName` BoundField to a TemplateField and added a RequiredFieldValidation control.</span></span>
- <span data-ttu-id="adbab-296">将 `CategoryID` 和 `SupplierID` BoundFields 转换为 Templatefield，并将编辑界面调整为使用 DropDownLists 而不是文本框。</span><span class="sxs-lookup"><span data-stu-id="adbab-296">Converted the `CategoryID` and `SupplierID` BoundFields to TemplateFields, and adjusted the editing interface to use DropDownLists rather than TextBoxes.</span></span> <span data-ttu-id="adbab-297">在这些 Templatefield 的 "`ItemTemplates`中，将显示 `CategoryName` 和 `SupplierName` 数据字段。</span><span class="sxs-lookup"><span data-stu-id="adbab-297">In these TemplateFields' `ItemTemplates`, the `CategoryName` and `SupplierName` data fields are displayed.</span></span>
- <span data-ttu-id="adbab-298">将 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`和 `ReorderLevel` BoundFields 转换为 Templatefield 并添加 CompareValidator 控件。</span><span class="sxs-lookup"><span data-stu-id="adbab-298">Converted the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` BoundFields to TemplateFields and added CompareValidator controls.</span></span>

<span data-ttu-id="adbab-299">由于我们已经检查了如何在前面的教程中完成这些任务，我只需在此处列出最终的声明性语法，并使实现保持为实践。</span><span class="sxs-lookup"><span data-stu-id="adbab-299">Since we've already examined how to accomplish these tasks in previous tutorials, I'll just list the final declarative syntax here and leave the implementation as practice.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample9.aspx)]

<span data-ttu-id="adbab-300">我们非常接近使用一个完整的示例。</span><span class="sxs-lookup"><span data-stu-id="adbab-300">We're very close to having a fully-working example.</span></span> <span data-ttu-id="adbab-301">不过，有几个微妙之处将会爬出并导致我们的问题。</span><span class="sxs-lookup"><span data-stu-id="adbab-301">However, there are a few subtleties that will creep up and cause us problems.</span></span> <span data-ttu-id="adbab-302">此外，我们还需要一些接口，当发生并发冲突时，它会向用户发出警报。</span><span class="sxs-lookup"><span data-stu-id="adbab-302">Additionally, we still need some interface that alerts the user when a concurrency violation has occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="adbab-303">为了使数据 Web 控件正确地将原始值传递到 ObjectDataSource （随后将这些值传递到 BLL），将 GridView 的 `EnableViewState` 属性设置为 `true` （默认值）是非常重要的。</span><span class="sxs-lookup"><span data-stu-id="adbab-303">In order for a data Web control to correctly pass the original values to the ObjectDataSource (which are then passed to the BLL), it's vital that the GridView's `EnableViewState` property is set to `true` (the default).</span></span> <span data-ttu-id="adbab-304">如果禁用视图状态，则在回发时原始值会丢失。</span><span class="sxs-lookup"><span data-stu-id="adbab-304">If you disable view state, the original values are lost on postback.</span></span>

## <a name="passing-the-correct-original-values-to-the-objectdatasource"></a><span data-ttu-id="adbab-305">将正确的原始值传递到 ObjectDataSource</span><span class="sxs-lookup"><span data-stu-id="adbab-305">Passing the Correct Original Values to the ObjectDataSource</span></span>

<span data-ttu-id="adbab-306">配置 GridView 的方式有几个问题。</span><span class="sxs-lookup"><span data-stu-id="adbab-306">There are a couple of problems with the way the GridView has been configured.</span></span> <span data-ttu-id="adbab-307">如果 ObjectDataSource 的 `ConflictDetection` 属性设置为 `CompareAllValues` （如下所示），则当 GridView （或 DetailsView 或 FormView）调用 ObjectDataSource 的 `Update()` 或 `Delete()` 方法时，ObjectDataSource 会尝试将 GridView 的原始值复制到其相应的 `Parameter` 实例中。</span><span class="sxs-lookup"><span data-stu-id="adbab-307">If the ObjectDataSource's `ConflictDetection` property is set to `CompareAllValues` (as is ours), when the ObjectDataSource's `Update()` or `Delete()` methods are invoked by the GridView (or DetailsView or FormView), the ObjectDataSource attempts to copy the GridView's original values into its appropriate `Parameter` instances.</span></span> <span data-ttu-id="adbab-308">有关此过程的图形表示形式，请参阅图2。</span><span class="sxs-lookup"><span data-stu-id="adbab-308">Refer back to Figure 2 for a graphical representation of this process.</span></span>

<span data-ttu-id="adbab-309">具体而言，每次数据绑定到 GridView 时，将为 GridView 的原始值分配双向数据绑定语句中的值。</span><span class="sxs-lookup"><span data-stu-id="adbab-309">Specifically, the GridView's original values are assigned the values in the two-way databinding statements each time the data is bound to the GridView.</span></span> <span data-ttu-id="adbab-310">因此，必需的原始值全部通过双向数据绑定来捕获，并以可转换格式提供。</span><span class="sxs-lookup"><span data-stu-id="adbab-310">Therefore, it's essential that the required original values all are captured via two-way databinding and that they are provided in a convertible format.</span></span>

<span data-ttu-id="adbab-311">要了解这一点很重要，请花点时间访问浏览器中的页面。</span><span class="sxs-lookup"><span data-stu-id="adbab-311">To see why this is important, take a moment to visit our page in a browser.</span></span> <span data-ttu-id="adbab-312">按照预期，GridView 使用最左侧列中的 "编辑" 和 "删除" 按钮列出了每个产品。</span><span class="sxs-lookup"><span data-stu-id="adbab-312">As expected, the GridView lists each product with an Edit and Delete button in the leftmost column.</span></span>

<span data-ttu-id="adbab-313">[![在 GridView 中列出的产品](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-313">[![The Products are Listed in a GridView](implementing-optimistic-concurrency-cs/_static/image39.png)](implementing-optimistic-concurrency-cs/_static/image38.png)</span></span>

<span data-ttu-id="adbab-314">**图 14**：产品在 GridView 中列出（[单击以查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image40.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-314">**Figure 14**: The Products are Listed in a GridView ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image40.png))</span></span>

<span data-ttu-id="adbab-315">如果单击任何产品的 "删除" 按钮，则会引发 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="adbab-315">If you click the Delete button for any product, a `FormatException` is thrown.</span></span>

<span data-ttu-id="adbab-316">[![尝试删除 FormatException 中的任何产品结果](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-316">[![Attempting to Delete Any Product Results in a FormatException](implementing-optimistic-concurrency-cs/_static/image42.png)](implementing-optimistic-concurrency-cs/_static/image41.png)</span></span>

<span data-ttu-id="adbab-317">**图 15**：尝试删除 `FormatException` 的任何产品结果（[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image43.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-317">**Figure 15**: Attempting to Delete Any Product Results in a `FormatException` ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image43.png))</span></span>

<span data-ttu-id="adbab-318">当 ObjectDataSource 尝试读取原始 `UnitPrice` 值时，将引发 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="adbab-318">The `FormatException` is raised when the ObjectDataSource attempts to read in the original `UnitPrice` value.</span></span> <span data-ttu-id="adbab-319">由于 `ItemTemplate` 的 `UnitPrice` 格式为货币（`<%# Bind("UnitPrice", "{0:C}") %>`），因此它包含货币符号，如 $19.95。</span><span class="sxs-lookup"><span data-stu-id="adbab-319">Since the `ItemTemplate` has the `UnitPrice` formatted as a currency (`<%# Bind("UnitPrice", "{0:C}") %>`), it includes a currency symbol, like $19.95.</span></span> <span data-ttu-id="adbab-320">当 ObjectDataSource 尝试将此字符串转换为 `decimal`时，会发生 `FormatException`。</span><span class="sxs-lookup"><span data-stu-id="adbab-320">The `FormatException` occurs as the ObjectDataSource attempts to convert this string into a `decimal`.</span></span> <span data-ttu-id="adbab-321">若要避免此问题，我们有多种选择：</span><span class="sxs-lookup"><span data-stu-id="adbab-321">To circumvent this problem, we have a number of options:</span></span>

- <span data-ttu-id="adbab-322">从 `ItemTemplate`中删除货币格式。</span><span class="sxs-lookup"><span data-stu-id="adbab-322">Remove the currency formatting from the `ItemTemplate`.</span></span> <span data-ttu-id="adbab-323">也就是说，不使用 `<%# Bind("UnitPrice", "{0:C}") %>`，只需使用 `<%# Bind("UnitPrice") %>`。</span><span class="sxs-lookup"><span data-stu-id="adbab-323">That is, instead of using `<%# Bind("UnitPrice", "{0:C}") %>`, simply use `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="adbab-324">这种情况的缺点是价格不再经过格式化。</span><span class="sxs-lookup"><span data-stu-id="adbab-324">The downside of this is that the price is no longer formatted.</span></span>
- <span data-ttu-id="adbab-325">显示 `UnitPrice` 在 `ItemTemplate`中格式化为货币的格式，但使用 `Eval` 关键字实现此目的。</span><span class="sxs-lookup"><span data-stu-id="adbab-325">Display the `UnitPrice` formatted as a currency in the `ItemTemplate`, but use the `Eval` keyword to accomplish this.</span></span> <span data-ttu-id="adbab-326">请记住，`Eval` 执行单向数据绑定。</span><span class="sxs-lookup"><span data-stu-id="adbab-326">Recall that `Eval` performs one-way databinding.</span></span> <span data-ttu-id="adbab-327">我们仍需要为原始值提供 `UnitPrice` 值，因此，在 `ItemTemplate`中仍需要一个双向 databinding 语句，但这可以放置在 `Visible` 属性设置为 `false`的标签 Web 控件中。</span><span class="sxs-lookup"><span data-stu-id="adbab-327">We still need to provide the `UnitPrice` value for the original values, so we'll still need a two-way databinding statement in the `ItemTemplate`, but this can be placed in a Label Web control whose `Visible` property is set to `false`.</span></span> <span data-ttu-id="adbab-328">可以在 ItemTemplate 中使用以下标记：</span><span class="sxs-lookup"><span data-stu-id="adbab-328">We could use the following markup in the ItemTemplate:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample10.aspx)]

- <span data-ttu-id="adbab-329">使用 `<%# Bind("UnitPrice") %>`从 `ItemTemplate`中删除货币格式。</span><span class="sxs-lookup"><span data-stu-id="adbab-329">Remove the currency formatting from the `ItemTemplate`, using `<%# Bind("UnitPrice") %>`.</span></span> <span data-ttu-id="adbab-330">在 GridView 的 `RowDataBound` 事件处理程序中，以编程方式访问显示 `UnitPrice` 值的标签 Web 控件，并将其 `Text` 属性设置为格式化版本。</span><span class="sxs-lookup"><span data-stu-id="adbab-330">In the GridView's `RowDataBound` event handler, programmatically access the Label Web control within which the `UnitPrice` value is displayed and set its `Text` property to the formatted version.</span></span>
- <span data-ttu-id="adbab-331">将 `UnitPrice` 设置为货币格式。</span><span class="sxs-lookup"><span data-stu-id="adbab-331">Leave the `UnitPrice` formatted as a currency.</span></span> <span data-ttu-id="adbab-332">在 GridView 的 `RowDeleting` 事件处理程序中，用 `Decimal.Parse`将现有的原始 `UnitPrice` 值（$19.95）替换为实际的十进制值。</span><span class="sxs-lookup"><span data-stu-id="adbab-332">In the GridView's `RowDeleting` event handler, replace the existing original `UnitPrice` value ($19.95) with an actual decimal value using `Decimal.Parse`.</span></span> <span data-ttu-id="adbab-333">我们已了解如何在[*ASP.NET 页教程中处理 BLL 和 DAL 级别的异常*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md)中，在 `RowUpdating` 事件处理程序中实现类似的操作。</span><span class="sxs-lookup"><span data-stu-id="adbab-333">We saw how to accomplish something similar in the `RowUpdating` event handler in the [*Handling BLL- and DAL-Level Exceptions in an ASP.NET Page*](handling-bll-and-dal-level-exceptions-in-an-asp-net-page-cs.md) tutorial.</span></span>

<span data-ttu-id="adbab-334">在我的示例中，我选择使用第二种方法，添加一个隐藏的标签 Web 控件，该控件的 `Text` 属性是绑定到未格式化的 `UnitPrice` 值的双向数据。</span><span class="sxs-lookup"><span data-stu-id="adbab-334">For my example I chose to go with the second approach, adding a hidden Label Web control whose `Text` property is two-way data bound to the unformatted `UnitPrice` value.</span></span>

<span data-ttu-id="adbab-335">解决此问题后，请尝试再次单击任何产品的 "删除" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-335">After solving this problem, try clicking the Delete button for any product again.</span></span> <span data-ttu-id="adbab-336">这次，当 ObjectDataSource 尝试调用 BLL 的 `UpdateProduct` 方法时，会收到 `InvalidOperationException`。</span><span class="sxs-lookup"><span data-stu-id="adbab-336">This time you'll get an `InvalidOperationException` when the ObjectDataSource attempts to invoke the BLL's `UpdateProduct` method.</span></span>

<span data-ttu-id="adbab-337">[![ObjectDataSource 找不到具有要发送的输入参数的方法](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-337">[![The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send](implementing-optimistic-concurrency-cs/_static/image45.png)](implementing-optimistic-concurrency-cs/_static/image44.png)</span></span>

<span data-ttu-id="adbab-338">**图 16**：ObjectDataSource 找不到具有要发送的输入参数的方法（[单击查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image46.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-338">**Figure 16**: The ObjectDataSource Cannot Find a Method with the Input Parameters it Wants to Send ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image46.png))</span></span>

<span data-ttu-id="adbab-339">查看异常消息，显然，ObjectDataSource 需要调用包含 `original_CategoryName` 和 `original_SupplierName` 输入参数的 BLL `DeleteProduct` 方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-339">Looking at the exception's message, it's clear that the ObjectDataSource wants to invoke a BLL `DeleteProduct` method that includes `original_CategoryName` and `original_SupplierName` input parameters.</span></span> <span data-ttu-id="adbab-340">这是因为 `CategoryID` 和 `SupplierID` Templatefield 的 `ItemTemplate` 当前包含包含 "`CategoryName`" 和 "`SupplierName`" 数据字段的双向绑定语句。</span><span class="sxs-lookup"><span data-stu-id="adbab-340">This is because the `ItemTemplate` s for the `CategoryID` and `SupplierID` TemplateFields currently contain two-way Bind statements with the `CategoryName` and `SupplierName` data fields.</span></span> <span data-ttu-id="adbab-341">相反，我们需要包含具有 `CategoryID` 和 `SupplierID` 数据字段的 `Bind` 语句。</span><span class="sxs-lookup"><span data-stu-id="adbab-341">Instead, we need to include `Bind` statements with the `CategoryID` and `SupplierID` data fields.</span></span> <span data-ttu-id="adbab-342">若要实现此目的，请将现有 Bind 语句替换为 `Eval` 语句，然后添加隐藏的标签控件，这些控件的 `Text` 属性将绑定到 `CategoryID`，并使用双向数据绑定 `SupplierID` 数据字段，如下所示：</span><span class="sxs-lookup"><span data-stu-id="adbab-342">To accomplish this, replace the existing Bind statements with `Eval` statements, and then add hidden Label controls whose `Text` properties are bound to the `CategoryID` and `SupplierID` data fields using two-way databinding, as shown below:</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample11.aspx)]

<span data-ttu-id="adbab-343">进行这些更改后，我们现在可以成功删除和编辑产品信息！</span><span class="sxs-lookup"><span data-stu-id="adbab-343">With these changes, we are now able to successfully delete and edit product information!</span></span> <span data-ttu-id="adbab-344">在步骤5中，我们将介绍如何验证是否检测到了并发冲突。</span><span class="sxs-lookup"><span data-stu-id="adbab-344">In Step 5 we'll look at how to verify that concurrency violations are being detected.</span></span> <span data-ttu-id="adbab-345">但现在，请花几分钟时间来尝试更新和删除一些记录，以确保单个用户的更新和删除操作按预期运行。</span><span class="sxs-lookup"><span data-stu-id="adbab-345">But for now, take a few minutes to try updating and deleting a few records to ensure that updating and deleting for a single user works as expected.</span></span>

## <a name="step-5-testing-the-optimistic-concurrency-support"></a><span data-ttu-id="adbab-346">步骤 5：测试开放式并发支持</span><span class="sxs-lookup"><span data-stu-id="adbab-346">Step 5: Testing the Optimistic Concurrency Support</span></span>

<span data-ttu-id="adbab-347">为了验证是否检测到并发冲突（而不是导致数据被盲目覆盖），需要在此页上打开两个浏览器窗口。</span><span class="sxs-lookup"><span data-stu-id="adbab-347">In order to verify that concurrency violations are being detected (rather than resulting in data being blindly overwritten), we need to open two browser windows to this page.</span></span> <span data-ttu-id="adbab-348">在两个浏览器实例中，单击 "Chai" 的 "编辑" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-348">In both browser instances, click on the Edit button for Chai.</span></span> <span data-ttu-id="adbab-349">然后，只需在其中一个浏览器中，将名称更改为 "Chai 茶" 并单击 "更新"。</span><span class="sxs-lookup"><span data-stu-id="adbab-349">Then, in just one of the browsers, change the name to "Chai Tea" and click Update.</span></span> <span data-ttu-id="adbab-350">更新应成功并将 GridView 返回到其预编辑状态，并将 "Chai 茶" 作为新产品名称。</span><span class="sxs-lookup"><span data-stu-id="adbab-350">The update should succeed and return the GridView to its pre-editing state, with "Chai Tea" as the new product name.</span></span>

<span data-ttu-id="adbab-351">但在另一个浏览器窗口实例中，"产品名称" 文本框仍显示 "Chai"。</span><span class="sxs-lookup"><span data-stu-id="adbab-351">In the other browser window instance, however, the product name TextBox still shows "Chai".</span></span> <span data-ttu-id="adbab-352">在第二个浏览器窗口中，将 `UnitPrice` 更新为 `25.00`。</span><span class="sxs-lookup"><span data-stu-id="adbab-352">In this second browser window, update the `UnitPrice` to `25.00`.</span></span> <span data-ttu-id="adbab-353">如果不使用乐观并发支持，则在第二个浏览器实例中单击 "更新" 会将产品名称更改回 "Chai"，从而覆盖第一个浏览器实例所做的更改。</span><span class="sxs-lookup"><span data-stu-id="adbab-353">Without optimistic concurrency support, clicking update in the second browser instance would change the product name back to "Chai", thereby overwriting the changes made by the first browser instance.</span></span> <span data-ttu-id="adbab-354">但在使用了开放式并发的情况下，在第二个浏览器实例中单击 "更新" 按钮会导致[system.data.dbconcurrencyexception](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx)。</span><span class="sxs-lookup"><span data-stu-id="adbab-354">With optimistic concurrency employed, however, clicking the Update button in the second browser instance results in a [DBConcurrencyException](https://msdn.microsoft.com/library/system.data.dbconcurrencyexception.aspx).</span></span>

<span data-ttu-id="adbab-355">[![检测到并发冲突时，将引发 System.data.dbconcurrencyexception](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-355">[![When a Concurrency Violation is Detected, a DBConcurrencyException is Thrown](implementing-optimistic-concurrency-cs/_static/image48.png)](implementing-optimistic-concurrency-cs/_static/image47.png)</span></span>

<span data-ttu-id="adbab-356">**图 17**：如果检测到并发冲突，则会引发 `DBConcurrencyException` （[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image49.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-356">**Figure 17**: When a Concurrency Violation is Detected, a `DBConcurrencyException` is Thrown ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image49.png))</span></span>

<span data-ttu-id="adbab-357">仅当使用 DAL 的批处理更新模式时，才会引发 `DBConcurrencyException`。</span><span class="sxs-lookup"><span data-stu-id="adbab-357">The `DBConcurrencyException` is only thrown when the DAL's batch update pattern is utilized.</span></span> <span data-ttu-id="adbab-358">DB 直接模式不会引发异常，它仅指示没有行受到影响。</span><span class="sxs-lookup"><span data-stu-id="adbab-358">The DB direct pattern does not raise an exception, it merely indicates that no rows were affected.</span></span> <span data-ttu-id="adbab-359">为了说明这一点，将浏览器实例的 GridView 返回到其预编辑状态。</span><span class="sxs-lookup"><span data-stu-id="adbab-359">To illustrate this, return both browser instances' GridView to their pre-editing state.</span></span> <span data-ttu-id="adbab-360">接下来，在第一个浏览器实例中单击 "编辑" 按钮，然后将产品名称从 "Chai 茶" 改回 "Chai"，然后单击 "更新"。</span><span class="sxs-lookup"><span data-stu-id="adbab-360">Next, in the first browser instance, click the Edit button and change the product name from "Chai Tea" back to "Chai" and click Update.</span></span> <span data-ttu-id="adbab-361">在第二个浏览器窗口中，单击 "Chai" 的 "删除" 按钮。</span><span class="sxs-lookup"><span data-stu-id="adbab-361">In the second browser window, click the Delete button for Chai.</span></span>

<span data-ttu-id="adbab-362">单击 "删除" 后，该页面回发，GridView 会调用 ObjectDataSource 的 `Delete()` 方法，而 ObjectDataSource 会向下调用 `ProductsOptimisticConcurrencyBLL` 类的 `DeleteProduct` 方法，同时传递原始值。</span><span class="sxs-lookup"><span data-stu-id="adbab-362">Upon clicking Delete, the page posts back, the GridView invokes the ObjectDataSource's `Delete()` method, and the ObjectDataSource calls down into the `ProductsOptimisticConcurrencyBLL` class's `DeleteProduct` method, passing along the original values.</span></span> <span data-ttu-id="adbab-363">第二个浏览器实例的原始 `ProductName` 值为 "Chai 茶"，此值与数据库中的当前 `ProductName` 值不匹配。</span><span class="sxs-lookup"><span data-stu-id="adbab-363">The original `ProductName` value for the second browser instance is "Chai Tea", which doesn't match up with the current `ProductName` value in the database.</span></span> <span data-ttu-id="adbab-364">因此，对数据库发出的 `DELETE` 语句会影响零行，因为 `WHERE` 子句所满足的数据库中不存在任何记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-364">Therefore the `DELETE` statement issued to the database affects zero rows since there's no record in the database that the `WHERE` clause satisfies.</span></span> <span data-ttu-id="adbab-365">`DeleteProduct` 方法返回 `false`，并且 ObjectDataSource 的数据将重新绑定到 GridView。</span><span class="sxs-lookup"><span data-stu-id="adbab-365">The `DeleteProduct` method returns `false` and the ObjectDataSource's data is rebound to the GridView.</span></span>

<span data-ttu-id="adbab-366">从最终用户的角度来看，在第二个浏览器窗口中单击 "Chai 茶" 的 "删除" 按钮会使屏幕闪烁，而在返回后，该产品仍在那里，但现在它作为 "Chai" （第一个浏览器所做的产品名称更改）列出。实例）。</span><span class="sxs-lookup"><span data-stu-id="adbab-366">From the end user's perspective, clicking on the Delete button for Chai Tea in the second browser window caused the screen to flash and, upon coming back, the product is still there, although now it's listed as "Chai" (the product name change made by the first browser instance).</span></span> <span data-ttu-id="adbab-367">如果用户再次单击 "删除" 按钮，则 Delete 将会成功，因为 GridView 的原始 `ProductName` 值（"Chai"）现在与数据库中的值相匹配。</span><span class="sxs-lookup"><span data-stu-id="adbab-367">If the user clicks the Delete button again, the Delete will succeed, as the GridView's original `ProductName` value ("Chai") now matches up with the value in the database.</span></span>

<span data-ttu-id="adbab-368">在这两种情况下，用户体验远远不理想。</span><span class="sxs-lookup"><span data-stu-id="adbab-368">In both of these cases, the user experience is far from ideal.</span></span> <span data-ttu-id="adbab-369">在使用批更新模式时，我们显然不希望向用户显示 `DBConcurrencyException` 异常的本质细节。</span><span class="sxs-lookup"><span data-stu-id="adbab-369">We clearly don't want to show the user the nitty-gritty details of the `DBConcurrencyException` exception when using the batch update pattern.</span></span> <span data-ttu-id="adbab-370">使用 DB 直接模式时的行为有些混乱，因为用户命令失败，但没有确切地指示原因。</span><span class="sxs-lookup"><span data-stu-id="adbab-370">And the behavior when using the DB direct pattern is somewhat confusing as the users command failed, but there was no precise indication of why.</span></span>

<span data-ttu-id="adbab-371">若要解决这两个问题，可以在页面上创建 "标签 Web 控件"，以提供有关更新或删除失败原因的说明。</span><span class="sxs-lookup"><span data-stu-id="adbab-371">To remedy these two issues, we can create Label Web controls on the page that provide an explanation to why an update or delete failed.</span></span> <span data-ttu-id="adbab-372">对于批处理更新模式，我们可以确定 GridView 的后期级别事件处理程序中是否出现 `DBConcurrencyException` 异常，并根据需要显示警告标签。</span><span class="sxs-lookup"><span data-stu-id="adbab-372">For the batch update pattern, we can determine whether or not a `DBConcurrencyException` exception occurred in the GridView's post-level event handler, displaying the warning label as needed.</span></span> <span data-ttu-id="adbab-373">对于 DB 直接方法，我们可以检查 BLL 方法的返回值（如果一行受到影响 `false`，则 `true`），并根据需要显示信息性消息。</span><span class="sxs-lookup"><span data-stu-id="adbab-373">For the DB direct method, we can examine the return value of the BLL method (which is `true` if one row was affected, `false` otherwise) and display an informational message as needed.</span></span>

## <a name="step-6-adding-informational-messages-and-displaying-them-in-the-face-of-a-concurrency-violation"></a><span data-ttu-id="adbab-374">步骤 6：添加信息性消息，并在出现并发冲突时显示这些消息</span><span class="sxs-lookup"><span data-stu-id="adbab-374">Step 6: Adding Informational Messages and Displaying Them in the Face of a Concurrency Violation</span></span>

<span data-ttu-id="adbab-375">发生并发冲突时，表现的行为取决于是否使用了 DAL 的批处理更新或 DB 直接模式。</span><span class="sxs-lookup"><span data-stu-id="adbab-375">When a concurrency violation occurs, the behavior exhibited depends on whether the DAL's batch update or DB direct pattern was used.</span></span> <span data-ttu-id="adbab-376">本教程使用这两种模式，以及用于更新的批更新模式和用于删除的 DB 直接模式。</span><span class="sxs-lookup"><span data-stu-id="adbab-376">Our tutorial uses both patterns, with the batch update pattern being used for updating and the DB direct pattern used for deleting.</span></span> <span data-ttu-id="adbab-377">首先，让我们将两个标签 Web 控件添加到页面，说明在尝试删除或更新数据时出现并发冲突。</span><span class="sxs-lookup"><span data-stu-id="adbab-377">To get started, let's add two Label Web controls to our page that explain that a concurrency violation occurred when attempting to delete or update data.</span></span> <span data-ttu-id="adbab-378">将 "标签" 控件的 `Visible` 和 `EnableViewState` 属性设置为 `false`;这将导致在每个页面上都隐藏它们，但这些特定页面访问除外，其 `Visible` 属性以编程方式设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="adbab-378">Set the Label control's `Visible` and `EnableViewState` properties to `false`; this will cause them to be hidden on each page visit except for those particular page visits where their `Visible` property is programmatically set to `true`.</span></span>

[!code-aspx[Main](implementing-optimistic-concurrency-cs/samples/sample12.aspx)]

<span data-ttu-id="adbab-379">除了设置其 `Visible`、`EnabledViewState`和 `Text` 属性以外，我还将 `CssClass` 属性设置为 `Warning`，这会使标签的显示为大、红色、斜体、粗体。</span><span class="sxs-lookup"><span data-stu-id="adbab-379">In addition to setting their `Visible`, `EnabledViewState`, and `Text` properties, I've also set the `CssClass` property to `Warning`, which causes the Label's to be displayed in a large, red, italic, bold font.</span></span> <span data-ttu-id="adbab-380">已定义此 CSS `Warning` 类并将其添加到了样式。 css 返回了*与插入、更新和删除教程关联的事件*。</span><span class="sxs-lookup"><span data-stu-id="adbab-380">This CSS `Warning` class was defined and added to Styles.css back in the *Examining the Events Associated with Inserting, Updating, and Deleting* tutorial.</span></span>

<span data-ttu-id="adbab-381">添加这些标签后，Visual Studio 中的设计器应类似于图18。</span><span class="sxs-lookup"><span data-stu-id="adbab-381">After adding these Labels, the Designer in Visual Studio should look similar to Figure 18.</span></span>

<span data-ttu-id="adbab-382">[已将两个标签控件添加到页面 ![](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-382">[![Two Label Controls Have Been Added to the Page](implementing-optimistic-concurrency-cs/_static/image51.png)](implementing-optimistic-concurrency-cs/_static/image50.png)</span></span>

<span data-ttu-id="adbab-383">**图 18**：已将两个标签控件添加到页面中（[单击以查看完全大小的图像](implementing-optimistic-concurrency-cs/_static/image52.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-383">**Figure 18**: Two Label Controls Have Been Added to the Page ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image52.png))</span></span>

<span data-ttu-id="adbab-384">使用这些 "标签" Web 控件即可完成检查如何确定发生了并发冲突的时间，此时可以将适当的标签 `Visible` 属性设置为 `true`，显示信息性消息。</span><span class="sxs-lookup"><span data-stu-id="adbab-384">With these Label Web controls in place, we're ready to examine how to determine when a concurrency violation has occurred, at which point the appropriate Label's `Visible` property can be set to `true`, displaying the informational message.</span></span>

## <a name="handling-concurrency-violations-when-updating"></a><span data-ttu-id="adbab-385">在更新时处理并发冲突</span><span class="sxs-lookup"><span data-stu-id="adbab-385">Handling Concurrency Violations When Updating</span></span>

<span data-ttu-id="adbab-386">首先，让我们看看如何在使用批更新模式时处理并发冲突。</span><span class="sxs-lookup"><span data-stu-id="adbab-386">Let's first look at how to handle concurrency violations when using the batch update pattern.</span></span> <span data-ttu-id="adbab-387">由于与批处理更新模式发生的冲突将导致引发 `DBConcurrencyException` 异常，我们需要将代码添加到 ASP.NET 页，以确定在更新过程中是否发生了 `DBConcurrencyException` 异常。</span><span class="sxs-lookup"><span data-stu-id="adbab-387">Since such violations with the batch update pattern cause a `DBConcurrencyException` exception to be thrown, we need to add code to our ASP.NET page to determine whether a `DBConcurrencyException` exception occurred during the update process.</span></span> <span data-ttu-id="adbab-388">如果是这样，则应向用户显示一条消息，说明未保存其更改，因为另一个用户在开始编辑记录和单击 "更新" 按钮之间修改了相同的数据。</span><span class="sxs-lookup"><span data-stu-id="adbab-388">If so, we should display a message to the user explaining that their changes were not saved because another user had modified the same data between when they started editing the record and when they clicked the Update button.</span></span>

<span data-ttu-id="adbab-389">正如我们在*ASP.NET 页教程中处理 BLL 和 DAL 级别的异常*中所述，可以在数据 Web 控件的后期级事件处理程序中检测并取消此类异常。</span><span class="sxs-lookup"><span data-stu-id="adbab-389">As we saw in the *Handling BLL- and DAL-Level Exceptions in an ASP.NET Page* tutorial, such exceptions can be detected and suppressed in the data Web control's post-level event handlers.</span></span> <span data-ttu-id="adbab-390">因此，我们需要为 GridView 的 `RowUpdated` 事件创建事件处理程序，该事件检查是否引发了 `DBConcurrencyException` 异常。</span><span class="sxs-lookup"><span data-stu-id="adbab-390">Therefore, we need to create an event handler for the GridView's `RowUpdated` event that checks if a `DBConcurrencyException` exception has been thrown.</span></span> <span data-ttu-id="adbab-391">此事件处理程序将传递对在更新过程中引发的任何异常的引用，如下面的事件处理程序代码所示：</span><span class="sxs-lookup"><span data-stu-id="adbab-391">This event handler is passed a reference to any exception that was raised during the updating process, as shown in the event handler code below:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample13.cs)]

<span data-ttu-id="adbab-392">在出现 `DBConcurrencyException` 异常的情况下，此事件处理程序会显示 "`UpdateConflictMessage` 标签" 控件，并指示已处理异常。</span><span class="sxs-lookup"><span data-stu-id="adbab-392">In the face of a `DBConcurrencyException` exception, this event handler displays the `UpdateConflictMessage` Label control and indicates that the exception has been handled.</span></span> <span data-ttu-id="adbab-393">使用此代码后，当更新记录发生并发冲突时，用户所做的更改将丢失，因为他们会在同一时间覆盖其他用户的修改。</span><span class="sxs-lookup"><span data-stu-id="adbab-393">With this code in place, when a concurrency violation occurs when updating a record, the user's changes are lost, since they would have overwritten another user's modifications at the same time.</span></span> <span data-ttu-id="adbab-394">特别是，GridView 返回到其预编辑状态并绑定到当前的数据库数据。</span><span class="sxs-lookup"><span data-stu-id="adbab-394">In particular, the GridView is returned to its pre-editing state and bound to the current database data.</span></span> <span data-ttu-id="adbab-395">这会将 GridView 行与其他用户所做的更改（以前不可见）进行更新。</span><span class="sxs-lookup"><span data-stu-id="adbab-395">This will update the GridView row with the other user's changes, which were previously not visible.</span></span> <span data-ttu-id="adbab-396">此外，`UpdateConflictMessage` 的标签控件将向用户解释刚发生的情况。</span><span class="sxs-lookup"><span data-stu-id="adbab-396">Additionally, the `UpdateConflictMessage` Label control will explain to the user what just happened.</span></span> <span data-ttu-id="adbab-397">此事件序列在图19中详细说明。</span><span class="sxs-lookup"><span data-stu-id="adbab-397">This sequence of events is detailed in Figure 19.</span></span>

<span data-ttu-id="adbab-398">[![用户更新在遇到并发冲突时丢失](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-398">[![A User s Updates are Lost in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image54.png)](implementing-optimistic-concurrency-cs/_static/image53.png)</span></span>

<span data-ttu-id="adbab-399">**图 19**：出现并发冲突时，用户的更新会丢失（[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image55.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-399">**Figure 19**: A User s Updates are Lost in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image55.png))</span></span>

> [!NOTE]
> <span data-ttu-id="adbab-400">或者，可以通过将传入的 `GridViewUpdatedEventArgs` 对象的 `KeepInEditMode` 属性设置为 true，而不是将 GridView 返回到预编辑状态。</span><span class="sxs-lookup"><span data-stu-id="adbab-400">Alternatively, rather than returning the GridView to the pre-editing state, we could leave the GridView in its editing state by setting the `KeepInEditMode` property of the passed-in `GridViewUpdatedEventArgs` object to true.</span></span> <span data-ttu-id="adbab-401">不过，如果采用这种方法，请确保将数据重新绑定到 GridView （通过调用其 `DataBind()` 方法），以便将其他用户的值加载到编辑界面。</span><span class="sxs-lookup"><span data-stu-id="adbab-401">If you take this approach, however, be certain to rebind the data to the GridView (by invoking its `DataBind()` method) so that the other user's values are loaded into the editing interface.</span></span> <span data-ttu-id="adbab-402">使用本教程可供下载的代码在 `RowUpdated` 事件处理程序中注释掉了以下两行代码：只需取消注释这些代码行，在发生并发冲突后，GridView 仍处于编辑模式。</span><span class="sxs-lookup"><span data-stu-id="adbab-402">The code available for download with this tutorial has these two lines of code in the `RowUpdated` event handler commented out; simply uncomment these lines of code to have the GridView remain in edit mode after a concurrency violation.</span></span>

## <a name="responding-to-concurrency-violations-when-deleting"></a><span data-ttu-id="adbab-403">删除时响应并发冲突</span><span class="sxs-lookup"><span data-stu-id="adbab-403">Responding to Concurrency Violations When Deleting</span></span>

<span data-ttu-id="adbab-404">使用 DB 直接模式时，不会在出现并发冲突的情况下引发异常。</span><span class="sxs-lookup"><span data-stu-id="adbab-404">With the DB direct pattern, there is no exception raised in the face of a concurrency violation.</span></span> <span data-ttu-id="adbab-405">相反，database 语句不会影响任何记录，因为 WHERE 子句与任何记录都不匹配。</span><span class="sxs-lookup"><span data-stu-id="adbab-405">Instead, the database statement simply affects no records, as the WHERE clause does not match with any record.</span></span> <span data-ttu-id="adbab-406">在 BLL 中创建的所有数据修改方法已经过设计，因此它们将返回一个布尔值，指示它们是否对一个记录进行了精确的影响。</span><span class="sxs-lookup"><span data-stu-id="adbab-406">All of the data modification methods created in the BLL have been designed such that they return a Boolean value indicating whether or not they affected precisely one record.</span></span> <span data-ttu-id="adbab-407">因此，若要确定删除记录时是否发生了并发冲突，可以查看 BLL 的 `DeleteProduct` 方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="adbab-407">Therefore, to determine if a concurrency violation occurred when deleting a record, we can examine the return value of the BLL's `DeleteProduct` method.</span></span>

<span data-ttu-id="adbab-408">可以通过传递到事件处理程序的 `ObjectDataSourceStatusEventArgs` 对象的 `ReturnValue` 属性，在 ObjectDataSource 的后期级别事件处理程序中检查 BLL 方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="adbab-408">The return value for a BLL method can be examined in the ObjectDataSource's post-level event handlers through the `ReturnValue` property of the `ObjectDataSourceStatusEventArgs` object passed into the event handler.</span></span> <span data-ttu-id="adbab-409">由于我们希望确定来自 `DeleteProduct` 方法的返回值，因此我们需要为 ObjectDataSource 的 `Deleted` 事件创建事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="adbab-409">Since we are interested in determining the return value from the `DeleteProduct` method, we need to create an event handler for the ObjectDataSource's `Deleted` event.</span></span> <span data-ttu-id="adbab-410">`ReturnValue` 属性的类型为 `object`，如果引发了异常，并且在该方法返回值之前中断了该方法，则可以 `null`。</span><span class="sxs-lookup"><span data-stu-id="adbab-410">The `ReturnValue` property is of type `object` and can be `null` if an exception was raised and the method was interrupted before it could return a value.</span></span> <span data-ttu-id="adbab-411">因此，应该首先确保 `ReturnValue` 属性没有 `null` 并且是布尔值。</span><span class="sxs-lookup"><span data-stu-id="adbab-411">Therefore, we should first ensure that the `ReturnValue` property is not `null` and is a Boolean value.</span></span> <span data-ttu-id="adbab-412">如果此检查通过，我们将显示 "`DeleteConflictMessage` 标签" 控件（如果 `ReturnValue` `false`）。</span><span class="sxs-lookup"><span data-stu-id="adbab-412">Assuming this check passes, we show the `DeleteConflictMessage` Label control if the `ReturnValue` is `false`.</span></span> <span data-ttu-id="adbab-413">这可以通过使用以下代码来实现：</span><span class="sxs-lookup"><span data-stu-id="adbab-413">This can be accomplished by using the following code:</span></span>

[!code-csharp[Main](implementing-optimistic-concurrency-cs/samples/sample14.cs)]

<span data-ttu-id="adbab-414">出现并发冲突时，将取消用户的删除请求。</span><span class="sxs-lookup"><span data-stu-id="adbab-414">In the face of a concurrency violation, the user's delete request is canceled.</span></span> <span data-ttu-id="adbab-415">将刷新 GridView，并显示该记录在用户加载页面和单击 "删除" 按钮时所发生的更改。</span><span class="sxs-lookup"><span data-stu-id="adbab-415">The GridView is refreshed, showing the changes that occurred for that record between the time the user loaded the page and when he clicked the Delete button.</span></span> <span data-ttu-id="adbab-416">当这种冲突发生时，将显示 `DeleteConflictMessage` 标签，说明刚才发生的情况（请参阅图20）。</span><span class="sxs-lookup"><span data-stu-id="adbab-416">When such a violation transpires, the `DeleteConflictMessage` Label is shown, explaining what just happened (see Figure 20).</span></span>

<span data-ttu-id="adbab-417">[![在遇到并发冲突时取消用户删除](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span><span class="sxs-lookup"><span data-stu-id="adbab-417">[![A User s Delete is Canceled in the Face of a Concurrency Violation](implementing-optimistic-concurrency-cs/_static/image57.png)](implementing-optimistic-concurrency-cs/_static/image56.png)</span></span>

<span data-ttu-id="adbab-418">**图 20**：在出现并发冲突时取消用户删除（[单击查看完全大小的映像](implementing-optimistic-concurrency-cs/_static/image58.png)）</span><span class="sxs-lookup"><span data-stu-id="adbab-418">**Figure 20**: A User s Delete is Canceled in the Face of a Concurrency Violation ([Click to view full-size image](implementing-optimistic-concurrency-cs/_static/image58.png))</span></span>

## <a name="summary"></a><span data-ttu-id="adbab-419">Summary</span><span class="sxs-lookup"><span data-stu-id="adbab-419">Summary</span></span>

<span data-ttu-id="adbab-420">在允许多个并发用户更新或删除数据的每个应用程序中都存在并发冲突的机会。</span><span class="sxs-lookup"><span data-stu-id="adbab-420">Opportunities for concurrency violations exist in every application that allows multiple, concurrent users to update or delete data.</span></span> <span data-ttu-id="adbab-421">如果未考虑此类冲突，则当两个用户同时更新在上一次写入 "wins" 时获取的相同数据时，将覆盖其他用户的更改更改。</span><span class="sxs-lookup"><span data-stu-id="adbab-421">If such violations are not accounted for, when two users simultaneously update the same data whoever gets in the last write "wins," overwriting the other user's changes changes.</span></span> <span data-ttu-id="adbab-422">或者，开发人员可以实现乐观或悲观并发控制。</span><span class="sxs-lookup"><span data-stu-id="adbab-422">Alternatively, developers can implement either optimistic or pessimistic concurrency control.</span></span> <span data-ttu-id="adbab-423">乐观并发控制假定并发冲突不常发生，只是不允许使用导致并发冲突的更新或删除命令。</span><span class="sxs-lookup"><span data-stu-id="adbab-423">Optimistic concurrency control assumes that concurrency violations are infrequent and simply disallows an update or delete command that would constitute a concurrency violation.</span></span> <span data-ttu-id="adbab-424">悲观并发控制假设经常发生并发冲突，只是拒绝一个用户的 update 或 delete 命令是不可接受的。</span><span class="sxs-lookup"><span data-stu-id="adbab-424">Pessimistic concurrency control assumes that concurrency violations are frequent and simply rejecting one user's update or delete command is not acceptable.</span></span> <span data-ttu-id="adbab-425">使用悲观并发控制，更新记录涉及锁定，从而防止任何其他用户在锁定时修改或删除记录。</span><span class="sxs-lookup"><span data-stu-id="adbab-425">With pessimistic concurrency control, updating a record involves locking it, thereby preventing any other users from modifying or deleting the record while it is locked.</span></span>

<span data-ttu-id="adbab-426">.NET 中的类型化数据集提供支持乐观并发控制的功能。</span><span class="sxs-lookup"><span data-stu-id="adbab-426">The Typed DataSet in .NET provides functionality for supporting optimistic concurrency control.</span></span> <span data-ttu-id="adbab-427">具体而言，发送到数据库的 `UPDATE` 和 `DELETE` 语句包含表的所有列，因此，仅当记录的当前数据与用户执行更新或删除时的原始数据匹配时，才会执行更新或删除。</span><span class="sxs-lookup"><span data-stu-id="adbab-427">In particular, the `UPDATE` and `DELETE` statements issued to the database include all of the table's columns, thereby ensuring that the update or delete will only occur if the record's current data matches with the original data the user had when performing their update or delete.</span></span> <span data-ttu-id="adbab-428">将 DAL 配置为支持乐观并发后，需要更新 BLL 方法。</span><span class="sxs-lookup"><span data-stu-id="adbab-428">Once the DAL has been configured to support optimistic concurrency, the BLL methods need to be updated.</span></span> <span data-ttu-id="adbab-429">此外，必须对向下调用到 BLL 的 ASP.NET 页进行配置，以便 ObjectDataSource 从其数据 Web 控件检索原始值并将它们向下传递到 BLL。</span><span class="sxs-lookup"><span data-stu-id="adbab-429">Additionally, the ASP.NET page that calls down into the BLL must be configured such that the ObjectDataSource retrieves the original values from its data Web control and passes them down into the BLL.</span></span>

<span data-ttu-id="adbab-430">正如本教程中所述，在 ASP.NET web 应用程序中实现开放式并发控制涉及更新 DAL 和 BLL，并在 ASP.NET 页中添加支持。</span><span class="sxs-lookup"><span data-stu-id="adbab-430">As we saw in this tutorial, implementing optimistic concurrency control in an ASP.NET web application involves updating the DAL and BLL and adding support in the ASP.NET page.</span></span> <span data-ttu-id="adbab-431">这一增加的工作是否是您的时间和精力的一项投入时间取决于您的应用程序。</span><span class="sxs-lookup"><span data-stu-id="adbab-431">Whether or not this added work is a wise investment of your time and effort depends on your application.</span></span> <span data-ttu-id="adbab-432">如果你不经常有并发用户更新数据，或者更新数据的数据与其他用户不同，则并发控制不是一个关键问题。</span><span class="sxs-lookup"><span data-stu-id="adbab-432">If you infrequently have concurrent users updating data, or the data they are updating is different from one another, then concurrency control is not a key issue.</span></span> <span data-ttu-id="adbab-433">然而，如果您的站点上的多个用户经常处理相同的数据，则并发控制可帮助防止一个用户的更新或删除无意中覆盖了另一个用户。</span><span class="sxs-lookup"><span data-stu-id="adbab-433">If, however, you routinely have multiple users on your site working with the same data, concurrency control can help prevent one user's updates or deletes from unwittingly overwriting another's.</span></span>

<span data-ttu-id="adbab-434">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="adbab-434">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="adbab-435">关于作者</span><span class="sxs-lookup"><span data-stu-id="adbab-435">About the Author</span></span>

<span data-ttu-id="adbab-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="adbab-436">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="adbab-437">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="adbab-437">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="adbab-438">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="adbab-438">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="adbab-439">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="adbab-439">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="adbab-440">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="adbab-440">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="adbab-441">[上一页](customizing-the-data-modification-interface-cs.md)
> [下一页](adding-client-side-confirmation-when-deleting-cs.md)</span><span class="sxs-lookup"><span data-stu-id="adbab-441">[Previous](customizing-the-data-modification-interface-cs.md)
[Next](adding-client-side-confirmation-when-deleting-cs.md)</span></span>

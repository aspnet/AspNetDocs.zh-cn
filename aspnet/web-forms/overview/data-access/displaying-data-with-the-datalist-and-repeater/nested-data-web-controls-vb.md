---
uid: web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
title: 嵌套的数据 Web 控件（VB） |Microsoft Docs
author: rick-anderson
description: 在本教程中，我们将探讨如何使用嵌套在其他中继器内的中继器。 这些示例将演示如何在 d 。
ms.author: riande
ms.date: 09/13/2006
ms.assetid: 8b7fcf7b-722b-498d-a4e4-7c93701e0c95
msc.legacyurl: /web-forms/overview/data-access/displaying-data-with-the-datalist-and-repeater/nested-data-web-controls-vb
msc.type: authoredcontent
ms.openlocfilehash: c3c62ce4293498d3b325031ac9817f8935b183b2
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74629615"
---
# <a name="nested-data-web-controls-vb"></a><span data-ttu-id="18c41-104">嵌套的数据 Web 控件 (VB)</span><span class="sxs-lookup"><span data-stu-id="18c41-104">Nested Data Web Controls (VB)</span></span>

<span data-ttu-id="18c41-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="18c41-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="18c41-106">[下载示例应用](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe)或[下载 PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="18c41-106">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_32_VB.exe) or [Download PDF](nested-data-web-controls-vb/_static/datatutorial32vb1.pdf)</span></span>

> <span data-ttu-id="18c41-107">在本教程中，我们将探讨如何使用嵌套在其他中继器内的中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-107">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="18c41-108">这些示例将演示如何以声明方式和编程方式填充内部中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-108">The examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

## <a name="introduction"></a><span data-ttu-id="18c41-109">简介</span><span class="sxs-lookup"><span data-stu-id="18c41-109">Introduction</span></span>

<span data-ttu-id="18c41-110">除了静态 HTML 和数据绑定语法外，模板还可以包括 Web 控件和用户控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-110">In addition to static HTML and databinding syntax, templates can also include Web controls and User Controls.</span></span> <span data-ttu-id="18c41-111">可以通过声明性的数据绑定语法为这些 Web 控件分配其属性，也可以通过编程方式在相应的服务器端事件处理程序中对其进行访问。</span><span class="sxs-lookup"><span data-stu-id="18c41-111">These Web controls can have their properties assigned via declarative, databinding syntax, or can be accessed programmatically in the appropriate server-side event handlers.</span></span>

<span data-ttu-id="18c41-112">通过在模板中嵌入控件，可以自定义和改进外观和用户体验。</span><span class="sxs-lookup"><span data-stu-id="18c41-112">By embedding controls within a template, the appearance and user experience can be customized and improved upon.</span></span> <span data-ttu-id="18c41-113">例如，在 GridView 控件教程中的 "[使用 templatefield](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) " 教程中，我们看到了如何通过在 TemplateField 中添加 Calendar 控件来自定义 GridView 的显示，以显示雇员的雇佣日期;在向[编辑和插入界面添加验证控件](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)和[自定义数据修改接口](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md)教程中，我们了解了如何通过添加验证控件、文本框、DropDownLists 和其他 Web 控件自定义编辑和插入界面。</span><span class="sxs-lookup"><span data-stu-id="18c41-113">For example, in the [Using TemplateFields in the GridView Control](../custom-formatting/using-templatefields-in-the-gridview-control-vb.md) tutorial, we saw how to customize the GridView s display by adding a Calendar control in a TemplateField to show an employee s hire date; in the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) and [Customizing the Data Modification Interface](../editing-inserting-and-deleting-data/customizing-the-data-modification-interface-vb.md) tutorials, we saw how to customize the editing and inserting interfaces by adding validation controls, TextBoxes, DropDownLists, and other Web controls.</span></span>

<span data-ttu-id="18c41-114">模板还可以包含其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-114">Templates can also contain other data Web controls.</span></span> <span data-ttu-id="18c41-115">也就是说，在模板中，可以有一个 DataList，其中包含另一个 DataList （或 Repeater、GridView 或 DetailsView，等等）。</span><span class="sxs-lookup"><span data-stu-id="18c41-115">That is, we can have a DataList that contains another DataList (or Repeater or GridView or DetailsView, and so on) within its templates.</span></span> <span data-ttu-id="18c41-116">此类接口的难题是将相应的数据绑定到内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-116">The challenge with such an interface is binding the appropriate data to the inner data Web control.</span></span> <span data-ttu-id="18c41-117">有几种不同的方法可用，范围从使用 ObjectDataSource 的声明性选项到编程方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-117">There are a few different approaches available, ranging from declarative options using the ObjectDataSource to programmatic ones.</span></span>

<span data-ttu-id="18c41-118">在本教程中，我们将探讨如何使用嵌套在其他中继器内的中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-118">In this tutorial we will explore how to use a Repeater nested inside another Repeater.</span></span> <span data-ttu-id="18c41-119">外部中继器将为数据库中的每个类别包含一项，并显示类别 "名称" 和 "说明"。</span><span class="sxs-lookup"><span data-stu-id="18c41-119">The outer Repeater will contain an item for each category in the database, displaying the category s name and description.</span></span> <span data-ttu-id="18c41-120">每个类别项的内部中继器都将显示属于该类别的每个产品的信息（参见图1）。</span><span class="sxs-lookup"><span data-stu-id="18c41-120">Each category item s inner Repeater will display information for each product belonging to that category (see Figure 1) in a bulleted list.</span></span> <span data-ttu-id="18c41-121">下面的示例演示如何以声明方式和编程方式填充内部中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-121">Our examples will illustrate how to populate the inner Repeater both declaratively and programmatically.</span></span>

<span data-ttu-id="18c41-122">[列出了每个类别及其产品的 ![](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="18c41-122">[![Each Category, Along with its Products, are Listed](nested-data-web-controls-vb/_static/image2.png)](nested-data-web-controls-vb/_static/image1.png)</span></span>

<span data-ttu-id="18c41-123">**图 1**：列出了每个类别及其产品（[单击以查看完全大小的图像](nested-data-web-controls-vb/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="18c41-123">**Figure 1**: Each Category, Along with its Products, are Listed ([Click to view full-size image](nested-data-web-controls-vb/_static/image3.png))</span></span>

## <a name="step-1-creating-the-category-listing"></a><span data-ttu-id="18c41-124">步骤1：创建类别列表</span><span class="sxs-lookup"><span data-stu-id="18c41-124">Step 1: Creating the Category Listing</span></span>

<span data-ttu-id="18c41-125">在生成使用嵌套数据 Web 控件的页面时，我发现首先设计、创建和测试最外面的数据 Web 控件是非常有帮助的，无需担心内部嵌套控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-125">When building a page that uses nested data Web controls, I find it helpful to design, create, and test the outermost data Web control first, without even worrying about the inner nested control.</span></span> <span data-ttu-id="18c41-126">因此，让我们先完成向页面中添加中继器的必要步骤，其中列出了每个类别的名称和描述。</span><span class="sxs-lookup"><span data-stu-id="18c41-126">Therefore, let s start by walking through the steps necessary to add a Repeater to the page that lists the name and description for each category.</span></span>

<span data-ttu-id="18c41-127">首先打开 `DataListRepeaterBasics` 文件夹中的 "`NestedControls.aspx`" 页，然后将 "Repeater" 控件添加到页面，并将其 `ID` 属性设置为 "`CategoryList`"。</span><span class="sxs-lookup"><span data-stu-id="18c41-127">Start by opening the `NestedControls.aspx` page in the `DataListRepeaterBasics` folder and add a Repeater control to the page, setting its `ID` property to `CategoryList`.</span></span> <span data-ttu-id="18c41-128">从 "Repeater" 智能标记中，选择创建名为 `CategoriesDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="18c41-128">From the Repeater s smart tag, choose to create a new ObjectDataSource named `CategoriesDataSource`.</span></span>

<span data-ttu-id="18c41-129">[![命名新的 ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="18c41-129">[![Name the New ObjectDataSource CategoriesDataSource](nested-data-web-controls-vb/_static/image5.png)](nested-data-web-controls-vb/_static/image4.png)</span></span>

<span data-ttu-id="18c41-130">**图 2**：将新的 ObjectDataSource 命名 `CategoriesDataSource` （[单击以查看完全大小的映像](nested-data-web-controls-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="18c41-130">**Figure 2**: Name the New ObjectDataSource `CategoriesDataSource` ([Click to view full-size image](nested-data-web-controls-vb/_static/image6.png))</span></span>

<span data-ttu-id="18c41-131">配置 ObjectDataSource，使其从 `CategoriesBLL` 类 `GetCategories` 方法拉取其数据。</span><span class="sxs-lookup"><span data-stu-id="18c41-131">Configure the ObjectDataSource so that it pulls its data from the `CategoriesBLL` class s `GetCategories` method.</span></span>

<span data-ttu-id="18c41-132">[![将 ObjectDataSource 配置为使用 CategoriesBLL Class s GetCategories 方法](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="18c41-132">[![Configure the ObjectDataSource to Use the CategoriesBLL Class s GetCategories Method](nested-data-web-controls-vb/_static/image8.png)](nested-data-web-controls-vb/_static/image7.png)</span></span>

<span data-ttu-id="18c41-133">**图 3**：将 ObjectDataSource 配置为使用 `CategoriesBLL` 类 `GetCategories` 方法（[单击以查看完全大小的映像](nested-data-web-controls-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="18c41-133">**Figure 3**: Configure the ObjectDataSource to Use the `CategoriesBLL` Class s `GetCategories` Method ([Click to view full-size image](nested-data-web-controls-vb/_static/image9.png))</span></span>

<span data-ttu-id="18c41-134">若要指定 Repeater 的模板内容，需要先进入源视图，然后手动输入声明性语法。</span><span class="sxs-lookup"><span data-stu-id="18c41-134">To specify the Repeater s template content we need to go to the Source view and manually enter the declarative syntax.</span></span> <span data-ttu-id="18c41-135">添加一个 `ItemTemplate`，该显示 `<h4>` 元素中的类别名称和段落元素（`<p>`）中的类别说明。</span><span class="sxs-lookup"><span data-stu-id="18c41-135">Add an `ItemTemplate` that displays the category s name in an `<h4>` element and the category s description in a paragraph element (`<p>`).</span></span> <span data-ttu-id="18c41-136">此外，让我们用水平标尺（`<hr>`）分隔每个类别。</span><span class="sxs-lookup"><span data-stu-id="18c41-136">Furthermore, let s separate each category with a horizontal rule (`<hr>`).</span></span> <span data-ttu-id="18c41-137">进行这些更改后，页面应包含与以下内容类似的中继器和 ObjectDataSource 的声明性语法：</span><span class="sxs-lookup"><span data-stu-id="18c41-137">After making these changes your page should contain declarative syntax for the Repeater and ObjectDataSource that is similar to the following:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample1.aspx)]

<span data-ttu-id="18c41-138">图4显示了通过浏览器查看时的进度。</span><span class="sxs-lookup"><span data-stu-id="18c41-138">Figure 4 shows our progress when viewed through a browser.</span></span>

<span data-ttu-id="18c41-139">[![列出了每个类别的名称和说明，并以水平规则分隔](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="18c41-139">[![Each Category s Name and Description is Listed, Separated by a Horizontal Rule](nested-data-web-controls-vb/_static/image11.png)](nested-data-web-controls-vb/_static/image10.png)</span></span>

<span data-ttu-id="18c41-140">**图 4**：列出了每个类别的 "名称" 和 "说明"，并以水平规则分隔（[单击以查看完全大小的图像](nested-data-web-controls-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="18c41-140">**Figure 4**: Each Category s Name and Description is Listed, Separated by a Horizontal Rule ([Click to view full-size image](nested-data-web-controls-vb/_static/image12.png))</span></span>

## <a name="step-2-adding-the-nested-product-repeater"></a><span data-ttu-id="18c41-141">步骤2：添加嵌套产品中继器</span><span class="sxs-lookup"><span data-stu-id="18c41-141">Step 2: Adding the Nested Product Repeater</span></span>

<span data-ttu-id="18c41-142">类别列表完成后，接下来的任务是向 `CategoryList` 的 `ItemTemplate` 添加一个中继器，以显示有关属于相应类别的产品的信息。</span><span class="sxs-lookup"><span data-stu-id="18c41-142">With the category listing complete, our next task is to add a Repeater to the `CategoryList` s `ItemTemplate` that displays information about those products belonging to the appropriate category.</span></span> <span data-ttu-id="18c41-143">有多种方法可以检索此内部中继器的数据，其中两种方法将很快进行探讨。</span><span class="sxs-lookup"><span data-stu-id="18c41-143">There are a number of ways we can retrieve the data for this inner Repeater, two of which we'll explore shortly.</span></span> <span data-ttu-id="18c41-144">现在，让我们在 `CategoryList` Repeater `ItemTemplate`中创建产品中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-144">For now, let s just create the products Repeater within the `CategoryList` Repeater s `ItemTemplate`.</span></span> <span data-ttu-id="18c41-145">具体而言，让我们的产品中继器在项目符号列表中显示每个产品，每个列表项包括产品的名称和价格。</span><span class="sxs-lookup"><span data-stu-id="18c41-145">Specifically, let s have the product Repeater display each product in a bulleted list with each list item including the product s name and price.</span></span>

<span data-ttu-id="18c41-146">若要创建此中继站，需要手动将内部中继器声明性语法和模板输入到 `CategoryList` 的 `ItemTemplate`中。</span><span class="sxs-lookup"><span data-stu-id="18c41-146">To create this Repeater we need to manually enter the inner Repeater s declarative syntax and templates into the `CategoryList` s `ItemTemplate`.</span></span> <span data-ttu-id="18c41-147">在 `CategoryList` Repeater `ItemTemplate`中添加以下标记：</span><span class="sxs-lookup"><span data-stu-id="18c41-147">Add the following markup within the `CategoryList` Repeater s `ItemTemplate`:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample2.aspx)]

## <a name="step-3-binding-the-category-specific-products-to-the-productsbycategorylist-repeater"></a><span data-ttu-id="18c41-148">步骤3：将特定于类别的产品绑定到 ProductsByCategoryList 中继器</span><span class="sxs-lookup"><span data-stu-id="18c41-148">Step 3: Binding the Category-Specific Products to the ProductsByCategoryList Repeater</span></span>

<span data-ttu-id="18c41-149">如果此时通过浏览器访问该页，屏幕将与图4中的外观相同，因为我们尚未将任何数据绑定到中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-149">If you visit the page through a browser at this point, your screen will look the same as in Figure 4 because we ve yet to bind any data to the Repeater.</span></span> <span data-ttu-id="18c41-150">可以通过几种方式来获取适当的产品记录，并将它们绑定到中继器，这比其他方式更有效。</span><span class="sxs-lookup"><span data-stu-id="18c41-150">There are a few ways that we can grab the appropriate product records and bind them to the Repeater, some more efficient than others.</span></span> <span data-ttu-id="18c41-151">这里的主要难题是返回指定类别的相应产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-151">The main challenge here is getting back the appropriate products for the specified category.</span></span>

<span data-ttu-id="18c41-152">绑定到内部 Repeater 控件的数据可以通过声明性访问，通过 `CategoryList` Repeater s `ItemTemplate`中的 ObjectDataSource 进行访问，也可以通过编程方式从 ASP.NET 页的代码隐藏页访问。</span><span class="sxs-lookup"><span data-stu-id="18c41-152">The data to bind to the inner Repeater control can either be accessed declaratively, through an ObjectDataSource in the `CategoryList` Repeater s `ItemTemplate`, or programmatically, from the ASP.NET page s code-behind page.</span></span> <span data-ttu-id="18c41-153">同样，可以通过内部中继器 `DataSourceID` 属性或通过声明性的数据绑定语法或以编程方式将此数据绑定到内部中继器，方法是：在 `CategoryList` 中继器 s `ItemDataBound` 事件处理程序中引用内部中继器，以编程方式设置其 `DataSource` 属性，并调用其 `DataBind()` 方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-153">Similarly, this data can be bound to the inner Repeater either declaratively - through the inner Repeater s `DataSourceID` property or through declarative databinding syntax or programmatically by referencing the inner Repeater in the `CategoryList` Repeater s `ItemDataBound` event handler, programmatically setting its `DataSource` property, and calling its `DataBind()` method.</span></span> <span data-ttu-id="18c41-154">让我们来了解一下这些方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-154">Let s explore each of these approaches.</span></span>

## <a name="accessing-the-data-declaratively-with-an-objectdatasource-control-and-theitemdataboundevent-handler"></a><span data-ttu-id="18c41-155">用 ObjectDataSource 控件和`ItemDataBound`事件处理程序以声明方式访问数据</span><span class="sxs-lookup"><span data-stu-id="18c41-155">Accessing the Data Declaratively with an ObjectDataSource Control and the`ItemDataBound`Event Handler</span></span>

<span data-ttu-id="18c41-156">由于我们已在本系列教程中广泛使用了 ObjectDataSource，因此在此示例中访问数据的最自然选择是坚持 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="18c41-156">Since we ve used the ObjectDataSource extensively throughout this tutorial series, the most natural choice for accessing data for this example is to stick with the ObjectDataSource.</span></span> <span data-ttu-id="18c41-157">`ProductsBLL` 类具有一个 `GetProductsByCategoryID(categoryID)` 方法，该方法返回有关属于指定 *`categoryID`* 的产品的信息。</span><span class="sxs-lookup"><span data-stu-id="18c41-157">The `ProductsBLL` class has a `GetProductsByCategoryID(categoryID)` method that returns information about those products that belong to the specified *`categoryID`*.</span></span> <span data-ttu-id="18c41-158">因此，可以将 ObjectDataSource 添加到 `CategoryList` Repeater `ItemTemplate`，并将其配置为从此类方法访问其数据。</span><span class="sxs-lookup"><span data-stu-id="18c41-158">Therefore, we can add an ObjectDataSource to the `CategoryList` Repeater s `ItemTemplate` and configure it to access its data from this class s method.</span></span>

<span data-ttu-id="18c41-159">遗憾的是，Repeater 不允许通过设计视图编辑其模板，因此需要手动为此 ObjectDataSource 控件添加声明性语法。</span><span class="sxs-lookup"><span data-stu-id="18c41-159">Unfortunately, the Repeater doesn t allow its templates to be edited through the Design view so we need to add the declarative syntax for this ObjectDataSource control by hand.</span></span> <span data-ttu-id="18c41-160">下面的语法演示了在添加此新 ObjectDataSource （`ProductsByCategoryDataSource`）之后 `ItemTemplate` `CategoryList` 中继站：</span><span class="sxs-lookup"><span data-stu-id="18c41-160">The following syntax shows the `CategoryList` Repeater s `ItemTemplate` after adding this new ObjectDataSource (`ProductsByCategoryDataSource`):</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample3.aspx)]

<span data-ttu-id="18c41-161">使用 ObjectDataSource 方法时，需要将 `ProductsByCategoryList` Repeater `DataSourceID` 属性设置为 ObjectDataSource （`ProductsByCategoryDataSource`）的 `ID`。</span><span class="sxs-lookup"><span data-stu-id="18c41-161">When using the ObjectDataSource approach we need to set the `ProductsByCategoryList` Repeater s `DataSourceID` property to the `ID` of the ObjectDataSource (`ProductsByCategoryDataSource`).</span></span> <span data-ttu-id="18c41-162">另请注意，我们的 ObjectDataSource 包含一个 `<asp:Parameter>` 元素，该元素指定将传递到 `GetProductsByCategoryID(categoryID)` 方法的 *`categoryID`* 值。</span><span class="sxs-lookup"><span data-stu-id="18c41-162">Also, notice that our ObjectDataSource has an `<asp:Parameter>` element that specifies the *`categoryID`* value that will be passed into the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="18c41-163">但如何指定此值呢？</span><span class="sxs-lookup"><span data-stu-id="18c41-163">But how do we specify this value?</span></span> <span data-ttu-id="18c41-164">理想情况下，我们只需使用数据绑定语法来设置 `<asp:Parameter>` 元素的 `DefaultValue` 属性，如下所示：</span><span class="sxs-lookup"><span data-stu-id="18c41-164">Ideally, we d be able to just set the `DefaultValue` property of the `<asp:Parameter>` element using databinding syntax, like so:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample4.aspx)]

<span data-ttu-id="18c41-165">遗憾的是，数据绑定语法只在具有 `DataBinding` 事件的控件中有效。</span><span class="sxs-lookup"><span data-stu-id="18c41-165">Unfortunately, databinding syntax is only valid in controls that have a `DataBinding` event.</span></span> <span data-ttu-id="18c41-166">`Parameter` 类缺少此类事件，因此上述语法是非法的，将导致运行时错误。</span><span class="sxs-lookup"><span data-stu-id="18c41-166">The `Parameter` class lacks such an event and therefore the above syntax is illegal and will result in a runtime error.</span></span>

<span data-ttu-id="18c41-167">若要设置此值，需要为 `CategoryList` Repeater `ItemDataBound` 事件创建事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="18c41-167">To set this value, we need to create an event handler for the `CategoryList` Repeater s `ItemDataBound` event.</span></span> <span data-ttu-id="18c41-168">请记住，对于绑定到中继器的每个项，`ItemDataBound` 事件将激发一次。</span><span class="sxs-lookup"><span data-stu-id="18c41-168">Recall that the `ItemDataBound` event fires once for each item bound to the Repeater.</span></span> <span data-ttu-id="18c41-169">因此，每次对外部中继器引发此事件时，都可以将当前 `CategoryID` 值分配给 `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` 参数。</span><span class="sxs-lookup"><span data-stu-id="18c41-169">Therefore, each time this event fires for the outer Repeater we can assign the current `CategoryID` value to the `ProductsByCategoryDataSource` ObjectDataSource s `CategoryID` parameter.</span></span>

<span data-ttu-id="18c41-170">使用以下代码为 `CategoryList` Repeater `ItemDataBound` 事件创建事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="18c41-170">Create an event handler for the `CategoryList` Repeater s `ItemDataBound` event with the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample5.vb)]

<span data-ttu-id="18c41-171">此事件处理程序首先确保我们正在处理某个数据项，而不是标头、脚注或分隔符项。</span><span class="sxs-lookup"><span data-stu-id="18c41-171">This event handler starts by ensuring that we re dealing with a data item rather than the header, footer, or separator item.</span></span> <span data-ttu-id="18c41-172">接下来，引用刚刚绑定到当前 `RepeaterItem`的实际 `CategoriesRow` 实例。</span><span class="sxs-lookup"><span data-stu-id="18c41-172">Next, we reference the actual `CategoriesRow` instance that has just been bound to the current `RepeaterItem`.</span></span> <span data-ttu-id="18c41-173">最后，引用 `ItemTemplate` 中的 ObjectDataSource，并将其 `CategoryID` 参数值分配给当前 `RepeaterItem`的 `CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="18c41-173">Finally, we reference the ObjectDataSource in the `ItemTemplate` and assign its `CategoryID` parameter value to the `CategoryID` of the current `RepeaterItem`.</span></span>

<span data-ttu-id="18c41-174">在此事件处理程序中，每个 `RepeaterItem` 中的 `ProductsByCategoryList` 中继器都绑定到 `RepeaterItem` 类别中的那些产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-174">With this event handler, the `ProductsByCategoryList` Repeater in each `RepeaterItem` is bound to those products in the `RepeaterItem` s category.</span></span> <span data-ttu-id="18c41-175">图5显示了生成的输出的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="18c41-175">Figure 5 shows a screen shot of the resulting output.</span></span>

<span data-ttu-id="18c41-176">[![外部中继器列出了每个类别;内部为该类别列出的产品](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="18c41-176">[![The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category](nested-data-web-controls-vb/_static/image14.png)](nested-data-web-controls-vb/_static/image13.png)</span></span>

<span data-ttu-id="18c41-177">**图 5**：外部中继器列出了每个类别;内部列出该类别的产品（[单击以查看完全大小的图像](nested-data-web-controls-vb/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="18c41-177">**Figure 5**: The Outer Repeater Lists Each Category; the Inner One Lists the Products for that Category ([Click to view full-size image](nested-data-web-controls-vb/_static/image15.png))</span></span>

## <a name="accessing-the-products-by-category-data-programmatically"></a><span data-ttu-id="18c41-178">以编程方式访问按类别数据列出的产品</span><span class="sxs-lookup"><span data-stu-id="18c41-178">Accessing the Products by Category Data Programmatically</span></span>

<span data-ttu-id="18c41-179">我们可以在 ASP.NET 页的代码隐藏类（或在 `App_Code` 文件夹中或单独的类库项目中）创建一个方法，该方法在 `CategoryID`时返回适当的一组产品，而不是使用 ObjectDataSource 检索当前类别的产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-179">Instead of using an ObjectDataSource to retrieve the products for the current category, we could create a method in our ASP.NET page s code-behind class (or in the `App_Code` folder or in a separate Class Library project) that returns the appropriate set of products when passed in a `CategoryID`.</span></span> <span data-ttu-id="18c41-180">假设我们在 ASP.NET page s 代码隐藏类中具有此类方法，并将其命名为 `GetProductsInCategory(categoryID)`。</span><span class="sxs-lookup"><span data-stu-id="18c41-180">Imagine that we had such a method in our ASP.NET page s code-behind class and that it was named `GetProductsInCategory(categoryID)`.</span></span> <span data-ttu-id="18c41-181">使用此方法时，我们可以使用以下声明性语法将当前类别的产品绑定到内部中继器：</span><span class="sxs-lookup"><span data-stu-id="18c41-181">With this method in place we could bind the products for the current category to the inner Repeater using the following declarative syntax:</span></span>

[!code-aspx[Main](nested-data-web-controls-vb/samples/sample6.aspx)]

<span data-ttu-id="18c41-182">Repeater `DataSource` 属性使用 databinding 语法来指示它的数据来自 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-182">The Repeater s `DataSource` property uses the databinding syntax to indicate that its data comes from the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="18c41-183">由于 `Eval("CategoryID")` 返回 `Object`类型的值，因此我们将对象强制转换为 `Integer`，然后将其传递到 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-183">Since `Eval("CategoryID")` returns a value of type `Object`, we cast the object to an `Integer` before passing it into the `GetProductsInCategory(categoryID)` method.</span></span> <span data-ttu-id="18c41-184">请注意，此处通过数据绑定语法访问的 `CategoryID` 是*外部*中继器（`CategoryList`）中的 `CategoryID`，它绑定到 `Categories` 表中的记录。</span><span class="sxs-lookup"><span data-stu-id="18c41-184">Note that the `CategoryID` accessed here via the databinding syntax is the `CategoryID` in the *outer* Repeater (`CategoryList`), the one that s bound to the records in the `Categories` table.</span></span> <span data-ttu-id="18c41-185">因此，我们知道 `CategoryID` 不能是数据库 `NULL` 值，这就是我们可以在不检查是否正在处理 `DBNull`的情况下，盲目地强制转换 `Eval` 方法的原因。</span><span class="sxs-lookup"><span data-stu-id="18c41-185">Therefore, we know that `CategoryID` cannot be a database `NULL` value, which is why we can blindly cast the `Eval` method without checking if we re dealing with a `DBNull`.</span></span>

<span data-ttu-id="18c41-186">使用此方法，我们需要创建 `GetProductsInCategory(categoryID)` 方法，并让它在给定提供的 *`categoryID`* 的情况下检索相应的产品集。</span><span class="sxs-lookup"><span data-stu-id="18c41-186">With this approach, we need to create the `GetProductsInCategory(categoryID)` method and have it retrieve the appropriate set of products given the supplied *`categoryID`*.</span></span> <span data-ttu-id="18c41-187">只需返回 `ProductsBLL` 类 `GetProductsByCategoryID(categoryID)` 方法返回的 `ProductsDataTable`，即可实现此目的。</span><span class="sxs-lookup"><span data-stu-id="18c41-187">We can do this by simply returning the `ProductsDataTable` returned by the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="18c41-188">让我们在 `NestedControls.aspx` 页的代码隐藏类中创建 `GetProductsInCategory(categoryID)` 方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-188">Let s create the `GetProductsInCategory(categoryID)` method in the code-behind class for our `NestedControls.aspx` page.</span></span> <span data-ttu-id="18c41-189">使用以下代码执行此操作：</span><span class="sxs-lookup"><span data-stu-id="18c41-189">Do so using the following code:</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample7.vb)]

<span data-ttu-id="18c41-190">此方法只是创建 `ProductsBLL` 方法的实例，并返回 `GetProductsByCategoryID(categoryID)` 方法的结果。</span><span class="sxs-lookup"><span data-stu-id="18c41-190">This method simply creates an instance of the `ProductsBLL` method and returns the results of the `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="18c41-191">请注意，该方法必须标记 `Public` 或 `Protected`;如果该方法被标记为 `Private`，将无法从 ASP.NET 页的声明性标记访问该方法。</span><span class="sxs-lookup"><span data-stu-id="18c41-191">Note that the method must be marked `Public` or `Protected`; if the method is marked `Private`, it will not be accessible from the ASP.NET page s declarative markup.</span></span>

<span data-ttu-id="18c41-192">进行这些更改以使用这一新方法之后，请花点时间查看浏览器中的页面。</span><span class="sxs-lookup"><span data-stu-id="18c41-192">After making these changes to use this new technique, take a moment to view the page through a browser.</span></span> <span data-ttu-id="18c41-193">使用 ObjectDataSource 和 `ItemDataBound` 事件处理程序方法时，输出应与输出相同（请参阅图5以查看屏幕截图）。</span><span class="sxs-lookup"><span data-stu-id="18c41-193">The output should be identical to the output when using the ObjectDataSource and `ItemDataBound` event handler approach (refer back to Figure 5 to see a screen shot).</span></span>

> [!NOTE]
> <span data-ttu-id="18c41-194">在 ASP.NET page s 代码隐藏类中创建 `GetProductsInCategory(categoryID)` 方法可能看起来工作量。</span><span class="sxs-lookup"><span data-stu-id="18c41-194">It may seem like busywork to create the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="18c41-195">毕竟，此方法只是创建 `ProductsBLL` 类的实例并返回其 `GetProductsByCategoryID(categoryID)` 方法的结果。</span><span class="sxs-lookup"><span data-stu-id="18c41-195">After all, this method simply creates an instance of the `ProductsBLL` class and returns the results of its `GetProductsByCategoryID(categoryID)` method.</span></span> <span data-ttu-id="18c41-196">为什么不直接从内部中继器中的数据绑定语法调用此方法，例如： `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`？</span><span class="sxs-lookup"><span data-stu-id="18c41-196">Why not just call this method directly from the databinding syntax in the inner Repeater, like: `DataSource='<%# ProductsBLL.GetProductsByCategoryID(CType(Eval("CategoryID"), Integer)) %>'`?</span></span> <span data-ttu-id="18c41-197">尽管此语法不能与当前的 `ProductsBLL` 类实现一起使用（因为 `GetProductsByCategoryID(categoryID)` 方法是实例方法），但你可以将 `ProductsBLL` 修改为包含静态 `GetProductsByCategoryID(categoryID)` 方法，或让类包含静态 `Instance()` 方法以返回 `ProductsBLL` 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="18c41-197">Although this syntax won't work with our current implementation of the `ProductsBLL` class (since the `GetProductsByCategoryID(categoryID)` method is an instance method), you could modify `ProductsBLL` to include a static `GetProductsByCategoryID(categoryID)` method or have the class include a static `Instance()` method to return a new instance of the `ProductsBLL` class.</span></span>

<span data-ttu-id="18c41-198">尽管此类修改不需要 ASP.NET 页 s 代码隐藏类中的 `GetProductsInCategory(categoryID)` 方法，但代码隐藏类方法使我们能够更灵活地处理检索到的数据。</span><span class="sxs-lookup"><span data-stu-id="18c41-198">While such modifications would eliminate the need for the `GetProductsInCategory(categoryID)` method in the ASP.NET page s code-behind class, the code-behind class method gives us more flexibility in working with the data retrieved, as we'll see shortly.</span></span>

## <a name="retrieving-all-of-the-product-information-at-once"></a><span data-ttu-id="18c41-199">同时检索所有产品信息</span><span class="sxs-lookup"><span data-stu-id="18c41-199">Retrieving All of the Product Information at Once</span></span>

<span data-ttu-id="18c41-200">通过调用 `ProductsBLL` 类 `GetProductsByCategoryID(categoryID)` 方法（第一种方法是通过 ObjectDataSource 进行的，第二种方法是通过代码隐藏类中的 `GetProductsInCategory(categoryID)` 方法实现），我们已检查了两个早期方法，通过调用该方法获取当前类别的产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-200">The two pervious techniques we ve examined grab those products for the current category by making a call to the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method (the first approach did so through an ObjectDataSource, the second through the `GetProductsInCategory(categoryID)` method in the code-behind class).</span></span> <span data-ttu-id="18c41-201">每次调用此方法时，业务逻辑层都向下调用数据访问层，这将使用 SQL 语句查询数据库，该语句将返回 `Products` 表中的行，该语句的 `CategoryID` 字段与提供的输入参数相匹配。</span><span class="sxs-lookup"><span data-stu-id="18c41-201">Each time this method is invoked, the Business Logic Layer calls down to the Data Access Layer, which queries the database with a SQL statement that returns rows from the `Products` table whose `CategoryID` field matches the supplied input parameter.</span></span>

<span data-ttu-id="18c41-202">对于系统中的*n*个类别，此方法网络*n* + 1 调用数据库一个数据库查询以获取所有类别，然后按*N*次调用来获取特定于每个类别的产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-202">Given *N* categories in the system, this approach nets *N* + 1 calls to the database one database query to get all of the categories and then *N* calls to get the products specific to each category.</span></span> <span data-ttu-id="18c41-203">但是，我们可以仅在两个数据库中检索所有所需的数据，调用一次调用来获取所有类别，并将另一调用用于获取所有产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-203">We can, however, retrieve all the needed data in just two database calls one call to get all of the categories and another to get all of the products.</span></span> <span data-ttu-id="18c41-204">完成所有产品后，便可以对这些产品进行筛选，以便仅将与当前 `CategoryID` 匹配的产品绑定到该类别的内部中继器。</span><span class="sxs-lookup"><span data-stu-id="18c41-204">Once we have all of the products, we can filter those products so that only the products matching the current `CategoryID` are bound to that category s inner Repeater.</span></span>

<span data-ttu-id="18c41-205">为了提供此功能，我们只需对 ASP.NET 页 s 代码隐藏类中的 `GetProductsInCategory(categoryID)` 方法进行少许修改。</span><span class="sxs-lookup"><span data-stu-id="18c41-205">To provide this functionality, we only need to make a slight modification to the `GetProductsInCategory(categoryID)` method in our ASP.NET page s code-behind class.</span></span> <span data-ttu-id="18c41-206">我们不会盲目地返回 `ProductsBLL` 类 `GetProductsByCategoryID(categoryID)` 方法的结果，而是先访问*所有*产品（如果尚未对其进行访问），然后基于传入的 `CategoryID`只返回产品的筛选视图。</span><span class="sxs-lookup"><span data-stu-id="18c41-206">Rather than blindly returning the results of the `ProductsBLL` class s `GetProductsByCategoryID(categoryID)` method, we can instead first access *all* of the products (if they haven't been accessed already) and then return just the filtered view of the products based on the passed-in `CategoryID`.</span></span>

[!code-vb[Main](nested-data-web-controls-vb/samples/sample8.vb)]

<span data-ttu-id="18c41-207">请注意，页面级变量的添加 `allProducts`。</span><span class="sxs-lookup"><span data-stu-id="18c41-207">Note the addition of the page-level variable, `allProducts`.</span></span> <span data-ttu-id="18c41-208">这包含所有产品的相关信息，并在第一次调用 `GetProductsInCategory(categoryID)` 方法时填充。</span><span class="sxs-lookup"><span data-stu-id="18c41-208">This holds information about all of the products and is populated the first time the `GetProductsInCategory(categoryID)` method is invoked.</span></span> <span data-ttu-id="18c41-209">在确保已创建并填充 `allProducts` 对象之后，该方法将筛选 DataTable 结果，以便只能访问 `CategoryID` 与指定 `CategoryID` 匹配的行。</span><span class="sxs-lookup"><span data-stu-id="18c41-209">After ensuring that the `allProducts` object has been created and populated, the method filters the DataTable s results such that only those rows whose `CategoryID` matches the specified `CategoryID` are accessible.</span></span> <span data-ttu-id="18c41-210">此方法减少了从*N* + 1 到2访问数据库的次数。</span><span class="sxs-lookup"><span data-stu-id="18c41-210">This approach reduces the number of times the database is accessed from *N* + 1 down to two.</span></span>

<span data-ttu-id="18c41-211">此增强功能不会对页面的呈现标记进行任何更改，也不会像其他方法那样返回更少的记录。</span><span class="sxs-lookup"><span data-stu-id="18c41-211">This enhancement does not introduce any change to the rendered markup of the page, nor does it bring back fewer records than the other approach.</span></span> <span data-ttu-id="18c41-212">它只是减少对数据库的调用次数。</span><span class="sxs-lookup"><span data-stu-id="18c41-212">It simply reduces the number of calls to the database.</span></span>

> [!NOTE]
> <span data-ttu-id="18c41-213">一种可能的原因是减少数据库访问的数量会肯定提高性能。</span><span class="sxs-lookup"><span data-stu-id="18c41-213">One might intuitively reason that reducing the number of database accesses would assuredly improve performance.</span></span> <span data-ttu-id="18c41-214">但这可能不是这样。</span><span class="sxs-lookup"><span data-stu-id="18c41-214">However, this might not be the case.</span></span> <span data-ttu-id="18c41-215">例如，如果有大量的产品 `CategoryID` `NULL`，则对 `GetProducts` 方法的调用将返回一系列从未显示的产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-215">If you have a large number of products whose `CategoryID` is `NULL`, for example, then the call to the `GetProducts` method returns a number of products that are never displayed.</span></span> <span data-ttu-id="18c41-216">而且，如果您只显示了几个类别的子集，则返回所有产品可能会浪费大量的情况。</span><span class="sxs-lookup"><span data-stu-id="18c41-216">Moreover, returning all of the products can be wasteful if you re only showing a subset of the categories, which might be the case if you have implemented paging.</span></span>

<span data-ttu-id="18c41-217">与往常一样，在分析两种方法的性能时，唯一的 surefire 度量值是针对应用程序的常见案例运行受控测试。</span><span class="sxs-lookup"><span data-stu-id="18c41-217">As always, when it comes to analyzing the performance of two techniques, the only surefire measure is to run controlled tests tailored for your application s common case scenarios.</span></span>

## <a name="summary"></a><span data-ttu-id="18c41-218">总结</span><span class="sxs-lookup"><span data-stu-id="18c41-218">Summary</span></span>

<span data-ttu-id="18c41-219">在本教程中，我们介绍了如何将一个数据 Web 控件嵌套在另一个数据控件中，特别是检查如何让外部中继器为每个类别显示一个项，并在列表中列出每个类别的产品。</span><span class="sxs-lookup"><span data-stu-id="18c41-219">In this tutorial we saw how to nest one data Web control within another, specifically examining how to have an outer Repeater display an item for each category with an inner Repeater listing the products for each category in a bulleted list.</span></span> <span data-ttu-id="18c41-220">构建嵌套用户界面的主要难题在于访问和将正确的数据绑定到内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-220">The main challenge in building a nested user interface lies in accessing and binding the correct data to the inner data Web control.</span></span> <span data-ttu-id="18c41-221">有多种方法可供使用，这两个方法在本教程中进行了介绍。</span><span class="sxs-lookup"><span data-stu-id="18c41-221">There are a variety of techniques available, two of which we examined in this tutorial.</span></span> <span data-ttu-id="18c41-222">第一种方法是使用外部数据 Web 控件中的 ObjectDataSource `ItemTemplate` 通过其 `DataSourceID` 属性绑定到内部数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-222">The first approach examined used an ObjectDataSource in the outer data Web control s `ItemTemplate` that was bound to the inner data Web control through its `DataSourceID` property.</span></span> <span data-ttu-id="18c41-223">第二种方法是通过 ASP.NET 页 s 代码隐藏类中的方法访问数据。</span><span class="sxs-lookup"><span data-stu-id="18c41-223">The second technique accessed the data via a method in the ASP.NET page s code-behind class.</span></span> <span data-ttu-id="18c41-224">然后，可以通过数据绑定语法将此方法绑定到内部数据 Web 控件的 `DataSource` 属性。</span><span class="sxs-lookup"><span data-stu-id="18c41-224">This method can then be bound to the inner data Web control s `DataSource` property through databinding syntax.</span></span>

<span data-ttu-id="18c41-225">虽然本教程中所述的嵌套用户界面使用了嵌套在中继器内的中继器，但这些技术可以扩展到其他数据 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="18c41-225">While the nested user interface examined in this tutorial used a Repeater nested within a Repeater, these techniques can be extended to the other data Web controls.</span></span> <span data-ttu-id="18c41-226">可以在 GridView 内或 DataList 内的 GridView 中嵌套中继器，等等。</span><span class="sxs-lookup"><span data-stu-id="18c41-226">You can nest a Repeater within a GridView, or a GridView within a DataList, and so on.</span></span>

<span data-ttu-id="18c41-227">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="18c41-227">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="18c41-228">关于作者</span><span class="sxs-lookup"><span data-stu-id="18c41-228">About the Author</span></span>

<span data-ttu-id="18c41-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="18c41-229">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="18c41-230">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="18c41-230">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="18c41-231">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="18c41-231">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="18c41-232">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="18c41-232">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="18c41-233">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="18c41-233">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="18c41-234">特别感谢</span><span class="sxs-lookup"><span data-stu-id="18c41-234">Special Thanks To</span></span>

<span data-ttu-id="18c41-235">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="18c41-235">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="18c41-236">本教程的领导评审者是 Zack 的 Liz Shulok。</span><span class="sxs-lookup"><span data-stu-id="18c41-236">Lead reviewers for this tutorial were Zack Jones and Liz Shulok.</span></span> <span data-ttu-id="18c41-237">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="18c41-237">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="18c41-238">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="18c41-238">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="18c41-239">上一部分</span><span class="sxs-lookup"><span data-stu-id="18c41-239">Previous</span></span>](showing-multiple-records-per-row-with-the-datalist-control-vb.md)

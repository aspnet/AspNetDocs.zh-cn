---
uid: web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
title: 创建业务逻辑层（C#） |Microsoft Docs
author: rick-anderson
description: 在本教程中，我们将了解如何将业务规则集中到一种业务逻辑层（BLL）中，作为在 t 。
ms.author: riande
ms.date: 03/31/2010
ms.assetid: 85554606-47cb-4e4f-9848-eed9da579056
msc.legacyurl: /web-forms/overview/data-access/introduction/creating-a-business-logic-layer-cs
msc.type: authoredcontent
ms.openlocfilehash: df96f3e7422a0537bf1b003a33fe8d71a671ac33
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78490400"
---
# <a name="creating-a-business-logic-layer-c"></a><span data-ttu-id="5c7ae-103">创建业务逻辑层 (C#)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-103">Creating a Business Logic Layer (C#)</span></span>

<span data-ttu-id="5c7ae-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="5c7ae-105">[下载示例应用](https://download.microsoft.com/download/4/6/3/463cf87c-4724-4cbc-b7b5-3f866f43ba50/ASPNET_Data_Tutorial_2_CS.exe)或[下载 PDF](creating-a-business-logic-layer-cs/_static/datatutorial02cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-105">[Download Sample App](https://download.microsoft.com/download/4/6/3/463cf87c-4724-4cbc-b7b5-3f866f43ba50/ASPNET_Data_Tutorial_2_CS.exe) or [Download PDF](creating-a-business-logic-layer-cs/_static/datatutorial02cs1.pdf)</span></span>

> <span data-ttu-id="5c7ae-106">在本教程中，我们将了解如何将业务规则集中到业务逻辑层（BLL）中，以便作为表示层与 DAL 之间的数据交换中介。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-106">In this tutorial we'll see how to centralize your business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span>

## <a name="introduction"></a><span data-ttu-id="5c7ae-107">简介</span><span class="sxs-lookup"><span data-stu-id="5c7ae-107">Introduction</span></span>

<span data-ttu-id="5c7ae-108">在[第一个教程](creating-a-data-access-layer-cs.md)中创建的数据访问层（DAL）将数据访问逻辑与表示逻辑完全分离。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-108">The Data Access Layer (DAL) created in the [first tutorial](creating-a-data-access-layer-cs.md) cleanly separates the data access logic from the presentation logic.</span></span> <span data-ttu-id="5c7ae-109">但是，当 DAL 将数据访问详细信息与表示层完全分离时，它不会强制实施任何可能适用的业务规则。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-109">However, while the DAL cleanly separates the data access details from the presentation layer, it does not enforce any business rules that may apply.</span></span> <span data-ttu-id="5c7ae-110">例如，对于我们的应用程序，我们可能希望在 "`Discontinued`" 字段设置为1时不允许修改 `Products` 表的 `CategoryID` 或 `SupplierID` 字段，或者建议强制使用资历规则，禁止在员工由他们之后聘用的人员管理的情况。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-110">For example, for our application we may want to disallow the `CategoryID` or `SupplierID` fields of the `Products` table to be modified when the `Discontinued` field is set to 1, or we might want to enforce seniority rules, prohibiting situations in which an employee is managed by someone who was hired after them.</span></span> <span data-ttu-id="5c7ae-111">另一种常见情况是授权，这种情况下，只有特定角色的用户才能删除产品，或者可以更改 `UnitPrice` 值。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-111">Another common scenario is authorization perhaps only users in a particular role can delete products or can change the `UnitPrice` value.</span></span>

<span data-ttu-id="5c7ae-112">在本教程中，我们将了解如何将这些业务规则集中到一种业务逻辑层（BLL）中，作为表示层与 DAL 之间的数据交换中介。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-112">In this tutorial we'll see how to centralize these business rules into a Business Logic Layer (BLL) that serves as an intermediary for data exchange between the presentation layer and the DAL.</span></span> <span data-ttu-id="5c7ae-113">在实际应用程序中，BLL 应作为单独的类库项目实现;但对于这些教程，我们会将 BLL 作为 `App_Code` 文件夹中的一系列类来实现，以便简化项目结构。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-113">In a real-world application, the BLL should be implemented as a separate Class Library project; however, for these tutorials we'll implement the BLL as a series of classes in our `App_Code` folder in order to simplify the project structure.</span></span> <span data-ttu-id="5c7ae-114">图1演示了表示层、BLL 和 DAL 之间的体系结构关系。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-114">Figure 1 illustrates the architectural relationships among the presentation layer, BLL, and DAL.</span></span>

![BLL 将表示层与数据访问层隔开，并施加业务规则](creating-a-business-logic-layer-cs/_static/image1.png)

<span data-ttu-id="5c7ae-116">**图 1**： BLL 将表示层与数据访问层隔开，并施加业务规则</span><span class="sxs-lookup"><span data-stu-id="5c7ae-116">**Figure 1**: The BLL Separates the Presentation Layer from the Data Access Layer and Imposes Business Rules</span></span>

## <a name="step-1-creating-the-bll-classes"></a><span data-ttu-id="5c7ae-117">步骤1：创建 BLL 类</span><span class="sxs-lookup"><span data-stu-id="5c7ae-117">Step 1: Creating the BLL Classes</span></span>

<span data-ttu-id="5c7ae-118">我们的 BLL 由四个类组成，其中一个用于 DAL 中的每个 TableAdapter;其中每个 BLL 类都具有从 DAL 中的相应 TableAdapter 检索、插入、更新和删除的方法，并应用相应的业务规则。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-118">Our BLL will be composed of four classes, one for each TableAdapter in the DAL; each of these BLL classes will have methods for retrieving, inserting, updating, and deleting from the respective TableAdapter in the DAL, applying the appropriate business rules.</span></span>

<span data-ttu-id="5c7ae-119">若要更清晰地分隔 DAL 与 BLL 相关的类，请在 `App_Code` 文件夹中创建两个子文件夹，`DAL` 和 `BLL`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-119">To more cleanly separate the DAL- and BLL-related classes, let's create two subfolders in the `App_Code` folder, `DAL` and `BLL`.</span></span> <span data-ttu-id="5c7ae-120">只需右键单击解决方案资源管理器中的 "`App_Code`" 文件夹，然后选择 "新建文件夹" 即可。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-120">Simply right-click on the `App_Code` folder in the Solution Explorer and choose New Folder.</span></span> <span data-ttu-id="5c7ae-121">创建这两个文件夹后，将在第一个教程中创建的类型化数据集移动到 `DAL` 子文件夹中。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-121">After creating these two folders, move the Typed DataSet created in the first tutorial into the `DAL` subfolder.</span></span>

<span data-ttu-id="5c7ae-122">接下来，在 `BLL` 子文件夹中创建四个 BLL 类文件。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-122">Next, create the four BLL class files in the `BLL` subfolder.</span></span> <span data-ttu-id="5c7ae-123">为此，请右键单击 `BLL` 子文件夹，选择 "添加新项"，然后选择 "类" 模板。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-123">To accomplish this, right-click on the `BLL` subfolder, choose Add a New Item, and choose the Class template.</span></span> <span data-ttu-id="5c7ae-124">将四个类命名为 `ProductsBLL`、`CategoriesBLL`、`SuppliersBLL`和 `EmployeesBLL`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-124">Name the four classes `ProductsBLL`, `CategoriesBLL`, `SuppliersBLL`, and `EmployeesBLL`.</span></span>

![将四个新类添加到 App_Code 文件夹](creating-a-business-logic-layer-cs/_static/image2.png)

<span data-ttu-id="5c7ae-126">**图 2**：将四个新类添加到 `App_Code` 文件夹</span><span class="sxs-lookup"><span data-stu-id="5c7ae-126">**Figure 2**: Add Four New Classes to the `App_Code` Folder</span></span>

<span data-ttu-id="5c7ae-127">接下来，让我们向每个类添加方法，以便在第一个教程中简单地包装为 Tableadapter 定义的方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-127">Next, let's add methods to each of the classes to simply wrap the methods defined for the TableAdapters from the first tutorial.</span></span> <span data-ttu-id="5c7ae-128">现在，这些方法只需直接调用 DAL;稍后我们将返回以添加任何所需的业务逻辑。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-128">For now, these methods will just call directly into the DAL; we'll return later to add any needed business logic.</span></span>

> [!NOTE]
> <span data-ttu-id="5c7ae-129">如果你使用的是 Visual Studio Standard Edition 或更高版本（即，你*不*是使用 Visual Web Developer），则可以选择使用[类设计器](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp)直观地设计你的类。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-129">If you are using Visual Studio Standard Edition or above (that is, you're *not* using Visual Web Developer), you can optionally design your classes visually using the [Class Designer](https://msdn.microsoft.com/library/default.asp?url=/library/dv_vstechart/html/clssdsgnr.asp).</span></span> <span data-ttu-id="5c7ae-130">有关 Visual Studio 中的此新功能的详细信息，请参阅[类设计器博客](https://blogs.msdn.com/classdesigner/default.aspx)。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-130">Refer to the [Class Designer Blog](https://blogs.msdn.com/classdesigner/default.aspx) for more information on this new feature in Visual Studio.</span></span>

<span data-ttu-id="5c7ae-131">对于 `ProductsBLL` 类，我们需要添加全部七个方法：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-131">For the `ProductsBLL` class we need to add a total of seven methods:</span></span>

- <span data-ttu-id="5c7ae-132">`GetProducts()` 返回所有产品</span><span class="sxs-lookup"><span data-stu-id="5c7ae-132">`GetProducts()` returns all products</span></span>
- <span data-ttu-id="5c7ae-133">`GetProductByProductID(productID)` 返回具有指定产品 ID 的产品</span><span class="sxs-lookup"><span data-stu-id="5c7ae-133">`GetProductByProductID(productID)` returns the product with the specified product ID</span></span>
- <span data-ttu-id="5c7ae-134">`GetProductsByCategoryID(categoryID)` 返回指定类别中的所有产品</span><span class="sxs-lookup"><span data-stu-id="5c7ae-134">`GetProductsByCategoryID(categoryID)` returns all products from the specified category</span></span>
- <span data-ttu-id="5c7ae-135">`GetProductsBySupplier(supplierID)` 返回指定供应商的所有产品</span><span class="sxs-lookup"><span data-stu-id="5c7ae-135">`GetProductsBySupplier(supplierID)` returns all products from the specified supplier</span></span>
- <span data-ttu-id="5c7ae-136">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` 使用传入的值将新产品插入到数据库中;返回新插入记录的 `ProductID` 值</span><span class="sxs-lookup"><span data-stu-id="5c7ae-136">`AddProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued)` inserts a new product into the database using the values passed-in; returns the `ProductID` value of the newly inserted record</span></span>
- <span data-ttu-id="5c7ae-137">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` 使用传入的值更新数据库中的现有产品，如果精确更新一行，则返回 `true`，否则返回 `false`</span><span class="sxs-lookup"><span data-stu-id="5c7ae-137">`UpdateProduct(productName, supplierID, categoryID, quantityPerUnit, unitPrice, unitsInStock, unitsOnOrder, reorderLevel, discontinued, productID)` updates an existing product in the database using the passed-in values; returns `true` if precisely one row was updated, `false` otherwise</span></span>
- <span data-ttu-id="5c7ae-138">`DeleteProduct(productID)` 从数据库中删除指定的产品</span><span class="sxs-lookup"><span data-stu-id="5c7ae-138">`DeleteProduct(productID)` deletes the specified product from the database</span></span>

<span data-ttu-id="5c7ae-139">ProductsBLL.cs</span><span class="sxs-lookup"><span data-stu-id="5c7ae-139">ProductsBLL.cs</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample1.cs)]

<span data-ttu-id="5c7ae-140">仅返回数据 `GetProducts`、`GetProductByProductID`、`GetProductsByCategoryID`和 `GetProductBySuppliersID` 的方法非常简单，因为它们只是向下调用 DAL。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-140">The methods that simply return data `GetProducts`, `GetProductByProductID`, `GetProductsByCategoryID`, and `GetProductBySuppliersID` are fairly straightforward as they simply call down into the DAL.</span></span> <span data-ttu-id="5c7ae-141">在某些情况下，可能需要在此级别实现业务规则（例如基于当前登录用户的授权规则或用户所属的角色），只需按原样保留这些方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-141">While in some scenarios there may be business rules that need to be implemented at this level (such as authorization rules based on the currently logged on user or the role to which the user belongs), we'll simply leave these methods as-is.</span></span> <span data-ttu-id="5c7ae-142">对于这些方法，BLL 只充当一个代理，通过该代理，表示层可以访问数据访问层中的基础数据。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-142">For these methods, then, the BLL serves merely as a proxy through which the presentation layer accesses the underlying data from the Data Access Layer.</span></span>

<span data-ttu-id="5c7ae-143">`AddProduct` 和 `UpdateProduct` 方法均将各种产品字段的值作为参数，并分别添加新产品或更新现有产品。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-143">The `AddProduct` and `UpdateProduct` methods both take in as parameters the values for the various product fields and add a new product or update an existing one, respectively.</span></span> <span data-ttu-id="5c7ae-144">由于许多 `Product` 表的列都可以接受 `NULL` 值（`CategoryID`、`SupplierID`和 `UnitPrice`），因此映射到此类列的 `AddProduct` 和 `UpdateProduct` 的输入参数使用[可以为 null 的类型](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx)。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-144">Since many of the `Product` table's columns can accept `NULL` values (`CategoryID`, `SupplierID`, and `UnitPrice`, to name a few), those input parameters for `AddProduct` and `UpdateProduct` that map to such columns use [nullable types](https://msdn.microsoft.com/library/1t3y8s4s(v=vs.80).aspx).</span></span> <span data-ttu-id="5c7ae-145">可以为 null 的类型是 .NET 2.0 的新手，并提供一种方法，用于指示是否应 `null`值类型。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-145">Nullable types are new to .NET 2.0 and provide a technique for indicating whether a value type should, instead, be `null`.</span></span> <span data-ttu-id="5c7ae-146">在C#中，可以通过在类型（如 `int? x;`）之后添加 `?`，将值类型标记为可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-146">In C# you can flag a value type as a nullable type by adding `?` after the type (like `int? x;`).</span></span> <span data-ttu-id="5c7ae-147">有关详细信息，请参阅[ C#编程指南](https://msdn.microsoft.com/library/67ef8sbd%28VS.80%29.aspx)中的[可为 null 的类型](https://msdn.microsoft.com/library/1t3y8s4s.aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-147">Refer to the [Nullable Types](https://msdn.microsoft.com/library/1t3y8s4s.aspx) section in the [C# Programming Guide](https://msdn.microsoft.com/library/67ef8sbd%28VS.80%29.aspx) for more information.</span></span>

<span data-ttu-id="5c7ae-148">所有这三种方法都返回一个布尔值，指示在该操作可能不会导致受影响的行后，是否插入、更新或删除行。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-148">All three methods return a Boolean value indicating whether a row was inserted, updated, or deleted since the operation may not result in an affected row.</span></span> <span data-ttu-id="5c7ae-149">例如，如果页开发人员调用了不存在的产品 `DeleteProduct` 传入 `ProductID`，则向数据库发出的 `DELETE` 语句将不会产生任何影响，因此 `DeleteProduct` 方法将返回 `false`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-149">For example, if the page developer calls `DeleteProduct` passing in a `ProductID` for a non-existent product, the `DELETE` statement issued to the database will have no affect and therefore the `DeleteProduct` method will return `false`.</span></span>

<span data-ttu-id="5c7ae-150">请注意，当添加新的产品或更新现有的产品时，我们会将新的或已修改的产品的字段值作为标量列表，而不是接受 `ProductsRow` 的实例。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-150">Note that when adding a new product or updating an existing one we take in the new or modified product's field values as a list of scalars as opposed to accepting a `ProductsRow` instance.</span></span> <span data-ttu-id="5c7ae-151">之所以选择此方法，是因为 `ProductsRow` 类派生自 ADO.NET `DataRow` 类，该类没有默认的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-151">This approach was chosen because the `ProductsRow` class derives from the ADO.NET `DataRow` class, which doesn't have a default parameterless constructor.</span></span> <span data-ttu-id="5c7ae-152">若要创建新的 `ProductsRow` 实例，必须首先创建一个 `ProductsDataTable` 实例，然后调用其 `NewProductRow()` 方法（在 `AddProduct`中执行此操作）。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-152">In order to create a new `ProductsRow` instance, we must first create a `ProductsDataTable` instance and then invoke its `NewProductRow()` method (which we do in `AddProduct`).</span></span> <span data-ttu-id="5c7ae-153">当我们转而使用 ObjectDataSource 插入和更新产品时，这种缺点会 rears。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-153">This shortcoming rears its head when we turn to inserting and updating products using the ObjectDataSource.</span></span> <span data-ttu-id="5c7ae-154">简而言之，ObjectDataSource 将尝试创建输入参数的实例。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-154">In short, the ObjectDataSource will try to create an instance of the input parameters.</span></span> <span data-ttu-id="5c7ae-155">如果 BLL 方法需要 `ProductsRow` 实例，则 ObjectDataSource 将尝试创建一个实例，但由于缺少默认的无参数构造函数而失败。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-155">If the BLL method expects a `ProductsRow` instance, the ObjectDataSource will try to create one, but fail due to the lack of a default parameterless constructor.</span></span> <span data-ttu-id="5c7ae-156">有关此问题的详细信息，请参阅以下两个 ASP.NET 论坛文章：[用强类型化数据集更新 objectdatasource](https://forums.asp.net/1098630/ShowPost.aspx)，并为[ObjectDataSource 和强类型化数据集提供问题](https://forums.asp.net/1048212/ShowPost.aspx)。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-156">For more information on this problem, refer to the following two ASP.NET Forums posts: [Updating ObjectDataSources with Strongly-Typed DataSets](https://forums.asp.net/1098630/ShowPost.aspx), and [Problem With ObjectDataSource and Strongly-Typed DataSet](https://forums.asp.net/1048212/ShowPost.aspx).</span></span>

<span data-ttu-id="5c7ae-157">接下来，在 `AddProduct` 和 `UpdateProduct`中，代码创建一个 `ProductsRow` 实例，并使用刚刚传入的值填充该实例。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-157">Next, in both `AddProduct` and `UpdateProduct`, the code creates a `ProductsRow` instance and populates it with the values just passed in.</span></span> <span data-ttu-id="5c7ae-158">将值分配到 DataRow 的 Datacolumn 时，可能会发生不同的字段级验证检查。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-158">When assigning values to DataColumns of a DataRow various field-level validation checks can occur.</span></span> <span data-ttu-id="5c7ae-159">因此，手动将传入的值放回 DataRow，有助于确保传递到 BLL 方法的数据的有效性。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-159">Therefore, manually putting the passed in values back into a DataRow helps ensure the validity of the data being passed to the BLL method.</span></span> <span data-ttu-id="5c7ae-160">遗憾的是，Visual Studio 生成的强类型 DataRow 类不使用可以为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-160">Unfortunately the strongly-typed DataRow classes generated by Visual Studio do not use nullable types.</span></span> <span data-ttu-id="5c7ae-161">相反，若要指示 DataRow 中的特定 DataColumn 应对应于 `NULL` 数据库值，则必须使用 `SetColumnNameNull()` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-161">Rather, to indicate that a particular DataColumn in a DataRow should correspond to a `NULL` database value we must use the `SetColumnNameNull()` method.</span></span>

<span data-ttu-id="5c7ae-162">在中 `UpdateProduct` 首先加载要使用 `GetProductByProductID(productID)`进行更新的产品。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-162">In `UpdateProduct` we first load in the product to update using `GetProductByProductID(productID)`.</span></span> <span data-ttu-id="5c7ae-163">尽管这可能是不必要的数据库行程，但在将来探索开放式并发的教程中，这种额外的行程会很有价值。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-163">While this may seem like an unnecessary trip to the database, this extra trip will prove worthwhile in future tutorials that explore optimistic concurrency.</span></span> <span data-ttu-id="5c7ae-164">乐观并发是一项技术，可确保同时处理相同数据的两个用户不会意外覆盖另一个数据更改。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-164">Optimistic concurrency is a technique to ensure that two users who are simultaneously working on the same data don't accidentally overwrite one another's changes.</span></span> <span data-ttu-id="5c7ae-165">通过抓取整个记录，还可以更轻松地在 BLL 中创建仅修改 DataRow 列子集的更新方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-165">Grabbing the entire record also makes it easier to create update methods in the BLL that only modify a subset of the DataRow's columns.</span></span> <span data-ttu-id="5c7ae-166">当我们浏览 `SuppliersBLL` 类时，我们将看到这样一个示例。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-166">When we explore the `SuppliersBLL` class we'll see such an example.</span></span>

<span data-ttu-id="5c7ae-167">最后请注意，`ProductsBLL` 类应用了[DataObject 特性](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx)（在文件顶部附近的类语句之前 `[System.ComponentModel.DataObject]` 语法），并且方法具有[DataObjectMethodAttribute 特性](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx)。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-167">Finally, note that the `ProductsBLL` class has the [DataObject attribute](https://msdn.microsoft.com/library/system.componentmodel.dataobjectattribute.aspx) applied to it (the `[System.ComponentModel.DataObject]` syntax right before the class statement near the top of the file) and the methods have [DataObjectMethodAttribute attributes](https://msdn.microsoft.com/library/system.componentmodel.dataobjectmethodattribute.aspx).</span></span> <span data-ttu-id="5c7ae-168">`DataObject` 特性将该类标记为适合绑定到[ObjectDataSource 控件](https://msdn.microsoft.com/library/9a4kyhcx.aspx)的对象，而 `DataObjectMethodAttribute` 指示该方法的用途。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-168">The `DataObject` attribute marks the class as being an object suitable for binding to an [ObjectDataSource control](https://msdn.microsoft.com/library/9a4kyhcx.aspx), whereas the `DataObjectMethodAttribute` indicates the purpose of the method.</span></span> <span data-ttu-id="5c7ae-169">我们将在将来的教程中看到，ASP.NET 2.0 的 ObjectDataSource 使你可以轻松地从类中轻松地访问数据。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-169">As we'll see in future tutorials, ASP.NET 2.0's ObjectDataSource makes it easy to declaratively access data from a class.</span></span> <span data-ttu-id="5c7ae-170">为了帮助在 ObjectDataSource 的向导中筛选要绑定到的可能类的列表，默认情况下，仅在向导的下拉列表中显示标记为 `DataObjects` 的类。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-170">To help filter the list of possible classes to bind to in the ObjectDataSource's wizard, by default only those classes marked as `DataObjects` are shown in the wizard's drop-down list.</span></span> <span data-ttu-id="5c7ae-171">`ProductsBLL` 类将同样适用于没有这些属性的情况，但添加它们可使其在 ObjectDataSource 的向导中更易于使用。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-171">The `ProductsBLL` class will work just as well without these attributes, but adding them makes it easier to work with in the ObjectDataSource's wizard.</span></span>

## <a name="adding-the-other-classes"></a><span data-ttu-id="5c7ae-172">添加其他类</span><span class="sxs-lookup"><span data-stu-id="5c7ae-172">Adding the Other Classes</span></span>

<span data-ttu-id="5c7ae-173">由于 `ProductsBLL` 类完成，我们仍然需要添加类，以便与类别、供应商和员工一起使用。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-173">With the `ProductsBLL` class complete, we still need to add the classes for working with categories, suppliers, and employees.</span></span> <span data-ttu-id="5c7ae-174">使用上述示例中的概念花点时间创建以下类和方法：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-174">Take a moment to create the following classes and methods using the concepts from the example above:</span></span>

- <span data-ttu-id="5c7ae-175">**CategoriesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="5c7ae-175">**CategoriesBLL.cs**</span></span>

    - `GetCategories()`
    - `GetCategoryByCategoryID(categoryID)`
- <span data-ttu-id="5c7ae-176">**SuppliersBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="5c7ae-176">**SuppliersBLL.cs**</span></span>

    - `GetSuppliers()`
    - `GetSupplierBySupplierID(supplierID)`
    - `GetSuppliersByCountry(country)`
    - `UpdateSupplierAddress(supplierID, address, city, country)`
- <span data-ttu-id="5c7ae-177">**EmployeesBLL.cs**</span><span class="sxs-lookup"><span data-stu-id="5c7ae-177">**EmployeesBLL.cs**</span></span>

    - `GetEmployees()`
    - `GetEmployeeByEmployeeID(employeeID)`
    - `GetEmployeesByManager(managerID)`

<span data-ttu-id="5c7ae-178">需要注意的一种方法是 `SuppliersBLL` 类的 `UpdateSupplierAddress` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-178">The one method worth noting is the `SuppliersBLL` class's `UpdateSupplierAddress` method.</span></span> <span data-ttu-id="5c7ae-179">此方法提供了一个用于仅更新供应商地址信息的接口。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-179">This method provides an interface for updating just the supplier's address information.</span></span> <span data-ttu-id="5c7ae-180">在内部，此方法在指定的 `supplierID` （使用 `GetSupplierBySupplierID`）的 `SupplierDataRow` 对象中读取，设置与地址相关的属性，然后向下调用 `SupplierDataTable`的 `Update` 方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-180">Internally, this method reads in the `SupplierDataRow` object for the specified `supplierID` (using `GetSupplierBySupplierID`), sets its address-related properties, and then calls down into the `SupplierDataTable`'s `Update` method.</span></span> <span data-ttu-id="5c7ae-181">`UpdateSupplierAddress` 方法如下：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-181">The `UpdateSupplierAddress` method follows:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample2.cs)]

<span data-ttu-id="5c7ae-182">请参阅本文的下载内容，了解如何实现 BLL 类的完整实现。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-182">Refer to this article's download for my complete implementation of the BLL classes.</span></span>

## <a name="step-2-accessing-the-typed-datasets-through-the-bll-classes"></a><span data-ttu-id="5c7ae-183">步骤2：通过 BLL 类访问类型化数据集</span><span class="sxs-lookup"><span data-stu-id="5c7ae-183">Step 2: Accessing the Typed DataSets Through the BLL Classes</span></span>

<span data-ttu-id="5c7ae-184">在第一个教程中，我们看到了以编程方式直接使用类型化数据集的示例，但在添加了 BLL 类后，表示层应改为与 BLL 一起工作。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-184">In the first tutorial we saw examples of working directly with the Typed DataSet programmatically, but with the addition of our BLL classes, the presentation tier should work against the BLL instead.</span></span> <span data-ttu-id="5c7ae-185">在第一个教程的 `AllProducts.aspx` 示例中，`ProductsTableAdapter` 用于将产品列表绑定到 GridView，如以下代码所示：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-185">In the `AllProducts.aspx` example from the first tutorial, the `ProductsTableAdapter` was used to bind the list of products to a GridView, as shown in the following code:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample3.cs)]

<span data-ttu-id="5c7ae-186">若要使用新的 BLL 类，所有需要更改的都是代码的第一行，只需将 `ProductsTableAdapter` 对象替换为 `ProductBLL` 对象：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-186">To use the new BLL classes, all that needs to be changed is the first line of code simply replace the `ProductsTableAdapter` object with a `ProductBLL` object:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample4.cs)]

<span data-ttu-id="5c7ae-187">还可以通过使用 ObjectDataSource 以声明方式（如类型化的数据集）访问 BLL 类。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-187">The BLL classes can also be accessed declaratively (as can the Typed DataSet) by using the ObjectDataSource.</span></span> <span data-ttu-id="5c7ae-188">我们将在以下教程中更详细地讨论 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-188">We'll be discussing the ObjectDataSource in greater detail in the following tutorials.</span></span>

<span data-ttu-id="5c7ae-189">[![产品列表显示在 GridView 中](creating-a-business-logic-layer-cs/_static/image4.png)](creating-a-business-logic-layer-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-189">[![The List of Products is Displayed in a GridView](creating-a-business-logic-layer-cs/_static/image4.png)](creating-a-business-logic-layer-cs/_static/image3.png)</span></span>

<span data-ttu-id="5c7ae-190">**图 3**：产品列表显示在 GridView 中（[单击以查看完全大小的图像](creating-a-business-logic-layer-cs/_static/image5.png)）</span><span class="sxs-lookup"><span data-stu-id="5c7ae-190">**Figure 3**: The List of Products is Displayed in a GridView ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image5.png))</span></span>

## <a name="step-3-adding-field-level-validation-to-the-datarow-classes"></a><span data-ttu-id="5c7ae-191">步骤3：向 DataRow 类添加字段级验证</span><span class="sxs-lookup"><span data-stu-id="5c7ae-191">Step 3: Adding Field-Level Validation to the DataRow Classes</span></span>

<span data-ttu-id="5c7ae-192">字段级验证是在插入或更新时与业务对象的属性值有关的检查。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-192">Field-level validation are checks that pertains to the property values of the business objects when inserting or updating.</span></span> <span data-ttu-id="5c7ae-193">某些产品的字段级验证规则包括：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-193">Some field-level validation rules for products include:</span></span>

- <span data-ttu-id="5c7ae-194">`ProductName` 字段长度不能超过40个字符</span><span class="sxs-lookup"><span data-stu-id="5c7ae-194">The `ProductName` field must be 40 characters or less in length</span></span>
- <span data-ttu-id="5c7ae-195">`QuantityPerUnit` 字段长度不能超过20个字符</span><span class="sxs-lookup"><span data-stu-id="5c7ae-195">The `QuantityPerUnit` field must be 20 characters or less in length</span></span>
- <span data-ttu-id="5c7ae-196">`ProductID`、`ProductName`和 `Discontinued` 字段是必需的，但所有其他字段都是可选的</span><span class="sxs-lookup"><span data-stu-id="5c7ae-196">The `ProductID`, `ProductName`, and `Discontinued` fields are required, but all other fields are optional</span></span>
- <span data-ttu-id="5c7ae-197">`UnitPrice`、`UnitsInStock`、`UnitsOnOrder`和 `ReorderLevel` 字段必须大于或等于零</span><span class="sxs-lookup"><span data-stu-id="5c7ae-197">The `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` fields must be greater than or equal to zero</span></span>

<span data-ttu-id="5c7ae-198">这些规则可以和应在数据库级别表示。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-198">These rules can and should be expressed at the database level.</span></span> <span data-ttu-id="5c7ae-199">`ProductName` 和 `QuantityPerUnit` 字段的字符限制由 `Products` 表中这些列的数据类型（分别为`nvarchar(40)` 和 `nvarchar(20)`）捕获。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-199">The character limit on the `ProductName` and `QuantityPerUnit` fields are captured by the data types of those columns in the `Products` table (`nvarchar(40)` and `nvarchar(20)`, respectively).</span></span> <span data-ttu-id="5c7ae-200">如果数据库表列允许 `NULL`，则是否需要字段和可选字段。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-200">Whether fields are required and optional are expressed by if the database table column allows `NULL` s.</span></span> <span data-ttu-id="5c7ae-201">存在四个[检查约束](https://msdn.microsoft.com/library/ms188258.aspx)，以确保只有大于或等于零的值才能使其成为 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`或 `ReorderLevel` 列。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-201">Four [check constraints](https://msdn.microsoft.com/library/ms188258.aspx) exist that ensure that only values greater than or equal to zero can make it into the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, or `ReorderLevel` columns.</span></span>

<span data-ttu-id="5c7ae-202">除了在数据库中实施这些规则外，还应在数据集级别强制执行这些规则。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-202">In addition to enforcing these rules at the database they should also be enforced at the DataSet level.</span></span> <span data-ttu-id="5c7ae-203">事实上，对于每个 DataTable 的 Datacolumn 集，字段长度和值是必需的还是可选的。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-203">In fact, the field length and whether a value is required or optional are already captured for each DataTable's set of DataColumns.</span></span> <span data-ttu-id="5c7ae-204">若要查看自动提供的现有字段级别验证，请在 "数据集设计器" 中选择一个数据表中的字段，然后访问属性窗口。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-204">To see the existing field-level validation automatically provided, go to the DataSet Designer, select a field from one of the DataTables and then go to the Properties window.</span></span> <span data-ttu-id="5c7ae-205">如图4所示，`ProductsDataTable` 中的 `QuantityPerUnit` DataColumn 的最大长度为20个字符，且允许 `NULL` 值。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-205">As Figure 4 shows, the `QuantityPerUnit` DataColumn in the `ProductsDataTable` has a maximum length of 20 characters and does allow `NULL` values.</span></span> <span data-ttu-id="5c7ae-206">如果尝试将 `ProductsDataRow`的 `QuantityPerUnit` 属性设置为长度超过20个字符的字符串值，将会引发 `ArgumentException`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-206">If we attempt to set the `ProductsDataRow`'s `QuantityPerUnit` property to a string value longer than 20 characters an `ArgumentException` will be thrown.</span></span>

<span data-ttu-id="5c7ae-207">[![DataColumn 提供基本的字段级验证](creating-a-business-logic-layer-cs/_static/image7.png)](creating-a-business-logic-layer-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-207">[![The DataColumn Provides Basic Field-Level Validation](creating-a-business-logic-layer-cs/_static/image7.png)](creating-a-business-logic-layer-cs/_static/image6.png)</span></span>

<span data-ttu-id="5c7ae-208">**图 4**： DataColumn 提供基本的字段级验证（[单击查看完全尺寸的图像](creating-a-business-logic-layer-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="5c7ae-208">**Figure 4**: The DataColumn Provides Basic Field-Level Validation ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image8.png))</span></span>

<span data-ttu-id="5c7ae-209">遗憾的是，无法通过属性窗口指定边界检查（如 `UnitPrice` 值必须大于或等于零）。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-209">Unfortunately, we can't specify bounds checks, such as the `UnitPrice` value must be greater than or equal to zero, through the Properties window.</span></span> <span data-ttu-id="5c7ae-210">为了提供此类型的字段级验证，需要为 DataTable 的[ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx)事件创建事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-210">In order to provide this type of field-level validation we need to create an event handler for the DataTable's [ColumnChanging](https://msdn.microsoft.com/library/system.data.datatable.columnchanging%28VS.80%29.aspx) event.</span></span> <span data-ttu-id="5c7ae-211">如[前面的教程](creating-a-data-access-layer-cs.md)中所述，可通过使用分部类扩展由类型化数据集创建的数据集、数据表和 DataRow 对象。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-211">As mentioned in the [preceding tutorial](creating-a-data-access-layer-cs.md), the DataSet, DataTables, and DataRow objects created by the Typed DataSet can be extended through the use of partial classes.</span></span> <span data-ttu-id="5c7ae-212">使用此技术，我们可以为 `ProductsDataTable` 类创建 `ColumnChanging` 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-212">Using this technique we can create a `ColumnChanging` event handler for the `ProductsDataTable` class.</span></span> <span data-ttu-id="5c7ae-213">首先在名为 `ProductsDataTable.ColumnChanging.cs``App_Code` 文件夹中创建一个类。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-213">Start by creating a class in the `App_Code` folder named `ProductsDataTable.ColumnChanging.cs`.</span></span>

<span data-ttu-id="5c7ae-214">[![将新类添加到 App_Code 文件夹](creating-a-business-logic-layer-cs/_static/image10.png)](creating-a-business-logic-layer-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-214">[![Add a New Class to the App_Code Folder](creating-a-business-logic-layer-cs/_static/image10.png)](creating-a-business-logic-layer-cs/_static/image9.png)</span></span>

<span data-ttu-id="5c7ae-215">**图 5**：将新类添加到 `App_Code` 文件夹（[单击查看完全大小的图像](creating-a-business-logic-layer-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="5c7ae-215">**Figure 5**: Add a New Class to the `App_Code` Folder ([Click to view full-size image](creating-a-business-logic-layer-cs/_static/image11.png))</span></span>

<span data-ttu-id="5c7ae-216">接下来，为 `ColumnChanging` 事件创建事件处理程序，该事件可确保 `UnitPrice`、`UnitsInStock`、`UnitsOnOrder`和 `ReorderLevel` 列值（如果不 `NULL`）大于或等于零。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-216">Next, create an event handler for the `ColumnChanging` event that ensures that the `UnitPrice`, `UnitsInStock`, `UnitsOnOrder`, and `ReorderLevel` column values (if not `NULL`) are greater than or equal to zero.</span></span> <span data-ttu-id="5c7ae-217">如果任何这样的列超出范围，则会引发 `ArgumentException`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-217">If any such column is out of range, throw an `ArgumentException`.</span></span>

<span data-ttu-id="5c7ae-218">ProductsDataTable.ColumnChanging.cs</span><span class="sxs-lookup"><span data-stu-id="5c7ae-218">ProductsDataTable.ColumnChanging.cs</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample5.cs)]

## <a name="step-4-adding-custom-business-rules-to-the-blls-classes"></a><span data-ttu-id="5c7ae-219">步骤4：向 BLL 的类添加自定义业务规则</span><span class="sxs-lookup"><span data-stu-id="5c7ae-219">Step 4: Adding Custom Business Rules to the BLL's Classes</span></span>

<span data-ttu-id="5c7ae-220">除了字段级验证外，可能还存在一些高级自定义业务规则，这些规则涉及无法在单列级别表达的不同实体或概念，例如：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-220">In addition to field-level validation, there may be high-level custom business rules that involve different entities or concepts not expressible at the single column level, such as:</span></span>

- <span data-ttu-id="5c7ae-221">如果产品停用，则无法更新其 `UnitPrice`</span><span class="sxs-lookup"><span data-stu-id="5c7ae-221">If a product is discontinued, its `UnitPrice` cannot be updated</span></span>
- <span data-ttu-id="5c7ae-222">员工居住的国家/地区必须与其居住的经理所在国家/地区相同</span><span class="sxs-lookup"><span data-stu-id="5c7ae-222">An employee's country of residence must be the same as their manager's country of residence</span></span>
- <span data-ttu-id="5c7ae-223">如果产品是供应商提供的唯一产品，则无法停产</span><span class="sxs-lookup"><span data-stu-id="5c7ae-223">A product cannot be discontinued if it is the only product provided by the supplier</span></span>

<span data-ttu-id="5c7ae-224">BLL 类应包含检查以确保遵守应用程序的业务规则。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-224">The BLL classes should contain checks to ensure adherence to the application's business rules.</span></span> <span data-ttu-id="5c7ae-225">这些检查可以直接添加到它们所应用到的方法中。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-225">These checks can be added directly to the methods to which they apply.</span></span>

<span data-ttu-id="5c7ae-226">假设我们的业务规则规定，如果产品是来自给定供应商的唯一产品，则不能将其标记为停用。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-226">Imagine that our business rules dictate that a product could not be marked discontinued if it was the only product from a given supplier.</span></span> <span data-ttu-id="5c7ae-227">也就是说，如果 product *X*是我们从供应商*Y*购买的唯一产品，我们无法将*X*标记为已停用;然而，如果供应商*Y*向我们提供了三种产品： *A*、 *B*和*C*，则可以将所有这些都标记为已停用。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-227">That is, if product *X* was the only product we purchased from supplier *Y*, we could not mark *X* as discontinued; if, however, supplier *Y* supplied us with three products, *A*, *B*, and *C*, then we could mark any and all of these as discontinued.</span></span> <span data-ttu-id="5c7ae-228">不是一种很好的业务规则，但业务规则和常见意义并不总是一致！</span><span class="sxs-lookup"><span data-stu-id="5c7ae-228">An odd business rule, but business rules and common sense aren't always aligned!</span></span>

<span data-ttu-id="5c7ae-229">若要在 `UpdateProducts` 方法中强制实施此业务规则，我们首先检查是否已将 `Discontinued` 设置为 `true`，如果是，我们会调用 `GetProductsBySupplierID` 来确定从此产品的供应商那里购买了多少产品。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-229">To enforce this business rule in the `UpdateProducts` method we'd start by checking if `Discontinued` was set to `true` and, if so, we'd call `GetProductsBySupplierID` to determine how many products we purchased from this product's supplier.</span></span> <span data-ttu-id="5c7ae-230">如果仅从此供应商购买一种产品，则会引发 `ApplicationException`。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-230">If only one product is purchased from this supplier, we throw an `ApplicationException`.</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample6.cs)]

## <a name="responding-to-validation-errors-in-the-presentation-tier"></a><span data-ttu-id="5c7ae-231">响应表示层中的验证错误</span><span class="sxs-lookup"><span data-stu-id="5c7ae-231">Responding to Validation Errors in the Presentation Tier</span></span>

<span data-ttu-id="5c7ae-232">从表示层调用 BLL 时，我们可以决定是尝试处理可能引发的任何异常，还是让它们向上冒泡到 ASP.NET （这会引发 `HttpApplication`的 `Error` 事件）。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-232">When calling the BLL from the presentation tier we can decide whether to attempt to handle any exceptions that might be raised or let them bubble up to ASP.NET (which will raise the `HttpApplication`'s `Error` event).</span></span> <span data-ttu-id="5c7ae-233">若要在以编程方式使用 BLL 时处理异常，可以使用[try 。catch](https://msdn.microsoft.com/library/0yd65esw.aspx)块，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="5c7ae-233">To handle an exception when working with the BLL programmatically, we can use a [try...catch](https://msdn.microsoft.com/library/0yd65esw.aspx) block, as the following example shows:</span></span>

[!code-csharp[Main](creating-a-business-logic-layer-cs/samples/sample7.cs)]

<span data-ttu-id="5c7ae-234">正如我们将在将来的教程中看到的那样，在使用数据 Web 控件插入、更新或删除数据时，处理从 BLL 向上冒泡的异常可以直接在事件处理程序中处理，而不必在 `try...catch` 块中包装代码。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-234">As we'll see in future tutorials, handling exceptions that bubble up from the BLL when using a data Web control for inserting, updating, or deleting data can be handled directly in an event handler as opposed to having to wrap code in `try...catch` blocks.</span></span>

## <a name="summary"></a><span data-ttu-id="5c7ae-235">摘要</span><span class="sxs-lookup"><span data-stu-id="5c7ae-235">Summary</span></span>

<span data-ttu-id="5c7ae-236">设计良好的应用程序可在不同的层中进行设计，每个层封装一个特定角色。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-236">A well architected application is crafted into distinct layers, each of which encapsulates a particular role.</span></span> <span data-ttu-id="5c7ae-237">在本文的第一个教程中，我们创建了一个使用类型化数据集的数据访问层;在本教程中，我们构建了一个业务逻辑层作为应用程序 `App_Code` 文件夹中的一系列类，该文件夹向下调用 DAL。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-237">In the first tutorial of this article series we created a Data Access Layer using Typed DataSets; in this tutorial we built a Business Logic Layer as a series of classes in our application's `App_Code` folder that call down into our DAL.</span></span> <span data-ttu-id="5c7ae-238">BLL 实现了应用程序的字段级和业务级逻辑。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-238">The BLL implements the field-level and business-level logic for our application.</span></span> <span data-ttu-id="5c7ae-239">除了创建单独的 BLL 外，与我们在本教程中所做的一样，另一个选项是通过使用分部类来扩展 Tableadapter 的方法。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-239">In addition to creating a separate BLL, as we did in this tutorial, another option is to extend the TableAdapters' methods through the use of partial classes.</span></span> <span data-ttu-id="5c7ae-240">然而，使用这种方法并不允许我们覆盖现有方法，也不能将 DAL 和 BLL 与我们在本文中所采用的方法完全分离。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-240">However, using this technique does not allow us to override existing methods nor does it separate our DAL and our BLL as cleanly as the approach we've taken in this article.</span></span>

<span data-ttu-id="5c7ae-241">当 DAL 和 BLL 完成后，就可以开始在我们的表示层上着手。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-241">With the DAL and BLL complete, we're ready to start on our presentation layer.</span></span> <span data-ttu-id="5c7ae-242">在[下一教程](master-pages-and-site-navigation-cs.md)中，我们将简单 detour 数据访问主题，并定义一致的页面布局，以便在整个教程中使用。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-242">In the [next tutorial](master-pages-and-site-navigation-cs.md) we'll take a brief detour from data access topics and define a consistent page layout for use throughout the tutorials.</span></span>

<span data-ttu-id="5c7ae-243">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="5c7ae-243">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="5c7ae-244">关于作者</span><span class="sxs-lookup"><span data-stu-id="5c7ae-244">About the Author</span></span>

<span data-ttu-id="5c7ae-245">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-245">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="5c7ae-246">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-246">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="5c7ae-247">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-247">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="5c7ae-248">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-248">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="5c7ae-249">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-249">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="5c7ae-250">特别感谢</span><span class="sxs-lookup"><span data-stu-id="5c7ae-250">Special Thanks To</span></span>

<span data-ttu-id="5c7ae-251">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-251">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="5c7ae-252">本教程的主管评审者是 Liz Shulok、Dennis Patterson 将、Carlos Santos 和 Hilton Giesenow。</span><span class="sxs-lookup"><span data-stu-id="5c7ae-252">Lead reviewers for this tutorial were Liz Shulok, Dennis Patterson, Carlos Santos, and Hilton Giesenow.</span></span> <span data-ttu-id="5c7ae-253">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="5c7ae-253">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="5c7ae-254">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-254">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="5c7ae-255">[上一页](creating-a-data-access-layer-cs.md)
> [下一页](master-pages-and-site-navigation-cs.md)</span><span class="sxs-lookup"><span data-stu-id="5c7ae-255">[Previous](creating-a-data-access-layer-cs.md)
[Next](master-pages-and-site-navigation-cs.md)</span></span>

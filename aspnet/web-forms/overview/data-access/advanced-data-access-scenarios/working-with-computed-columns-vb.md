---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
title: 处理计算列 (VB) |Microsoft Docs
author: rick-anderson
description: Microsoft SQL Server 创建数据库表时，允许您定义计算的列由表达式计算其值，通常 referen...
ms.author: riande
ms.date: 08/03/2007
ms.assetid: 5811b8ff-ed56-40fc-9397-6b69ae09a8f6
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
msc.type: authoredcontent
ms.openlocfilehash: 136e4a07422d9f71ed56ac132d93f5eade273ca2
ms.sourcegitcommit: 289e051cc8a90e8f7127e239fda73047bde4de12
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/25/2019
ms.locfileid: "58423164"
---
<a name="working-with-computed-columns-vb"></a><span data-ttu-id="418fb-103">处理计算列 (VB)</span><span class="sxs-lookup"><span data-stu-id="418fb-103">Working with Computed Columns (VB)</span></span>
====================
<span data-ttu-id="418fb-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="418fb-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="418fb-105">[下载代码](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip)或[下载 PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="418fb-105">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip) or [Download PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span></span>

> <span data-ttu-id="418fb-106">创建数据库表时，Microsoft SQL Server 可以定义计算的列的通常引用同一条数据库记录中的其他值的表达式计算其值。</span><span class="sxs-lookup"><span data-stu-id="418fb-106">When creating a database table, Microsoft SQL Server allows you to define a computed column whose value is calculated from an expression that usually references other values in the same database record.</span></span> <span data-ttu-id="418fb-107">此类的值为只读数据库，使用 Tableadapter 时需要特别注意的事项。</span><span class="sxs-lookup"><span data-stu-id="418fb-107">Such values are read-only at the database, which requires special considerations when working with TableAdapters.</span></span> <span data-ttu-id="418fb-108">在本教程中我们将了解如何满足由计算列所带来的挑战。</span><span class="sxs-lookup"><span data-stu-id="418fb-108">In this tutorial we learn how to meet the challenges posed by computed columns.</span></span>


## <a name="introduction"></a><span data-ttu-id="418fb-109">介绍</span><span class="sxs-lookup"><span data-stu-id="418fb-109">Introduction</span></span>

<span data-ttu-id="418fb-110">Microsoft SQL Server 允许*[计算所得的列](https://msdn.microsoft.com/library/ms191250.aspx)*，从通常引用同一个表中的其他列的值的表达式计算其值的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-110">Microsoft SQL Server allows for *[computed columns](https://msdn.microsoft.com/library/ms191250.aspx)*, which are columns whose values are calculated from an expression that usually references the values from other columns in the same table.</span></span> <span data-ttu-id="418fb-111">例如，时间跟踪数据模型可能有一个名为的表`ServiceLog`列包括与`ServicePerformed`， `EmployeeID`， `Rate`，和`Duration`，等等。</span><span class="sxs-lookup"><span data-stu-id="418fb-111">As an example, a time tracking data model might have a table named `ServiceLog` with columns including `ServicePerformed`, `EmployeeID`, `Rate`, and `Duration`, among others.</span></span> <span data-ttu-id="418fb-112">尽管到期金额每个服务项 （正在持续时间的乘积的速率） 可以计算通过 web 页或其他编程接口，它可能会比较方便包括中的列`ServiceLog`名为表`AmountDue`报告这信息。</span><span class="sxs-lookup"><span data-stu-id="418fb-112">While the amount due per service item (being the rate multiplied by the duration) could be calculated through a web page or other programmatic interface, it might be handy to include a column in the `ServiceLog` table named `AmountDue` that reported this information.</span></span> <span data-ttu-id="418fb-113">此列可以创建为普通的列，但它需要随时更新`Rate`或`Duration`更改列的值。</span><span class="sxs-lookup"><span data-stu-id="418fb-113">This column could be created as a normal column, but it would need to be updated anytime the `Rate` or `Duration` column values changed.</span></span> <span data-ttu-id="418fb-114">更好的方法是建立`AmountDue`列使用表达式的计算列`Rate * Duration`。</span><span class="sxs-lookup"><span data-stu-id="418fb-114">A better approach would be to make the `AmountDue` column a computed column using the expression `Rate * Duration`.</span></span> <span data-ttu-id="418fb-115">执行此操作会导致 SQL Server 自动计算`AmountDue`只要它在查询中引用列的值。</span><span class="sxs-lookup"><span data-stu-id="418fb-115">Doing so would cause SQL Server to automatically calculate the `AmountDue` column value whenever it was referenced in a query.</span></span>

<span data-ttu-id="418fb-116">由于计算的列的值由一个表达式，此类列是只读的因此不能具有值分配给他们中`INSERT`或`UPDATE`语句。</span><span class="sxs-lookup"><span data-stu-id="418fb-116">Since a computed column s value is determined by an expression, such columns are read-only and therefore cannot have values assigned to them in `INSERT` or `UPDATE` statements.</span></span> <span data-ttu-id="418fb-117">但是，当计算的列使用的临时 SQL 语句的 TableAdapter 的主查询的一部分时，它们将自动包含在自动生成`INSERT`和`UPDATE`语句。</span><span class="sxs-lookup"><span data-stu-id="418fb-117">However, when computed columns are part of the main query for a TableAdapter that uses ad-hoc SQL statements, they are automatically included in the auto-generated `INSERT` and `UPDATE` statements.</span></span> <span data-ttu-id="418fb-118">因此，TableAdapter s`INSERT`并`UPDATE`查询和`InsertCommand`和`UpdateCommand`属性必须更新以删除对任何计算列的引用。</span><span class="sxs-lookup"><span data-stu-id="418fb-118">Consequently, the TableAdapter s `INSERT` and `UPDATE` queries and `InsertCommand` and `UpdateCommand` properties must be updated to remove references to any computed columns.</span></span>

<span data-ttu-id="418fb-119">使用的难题之一的计算列使用 TableAdapter 使用的临时 SQL 语句是，TableAdapter s`INSERT`和`UPDATE`查询自动重新生成任何 TableAdapter 配置向导已完成的时间。</span><span class="sxs-lookup"><span data-stu-id="418fb-119">One challenge of using computed columns with a TableAdapter that uses ad-hoc SQL statements is that the TableAdapter s `INSERT` and `UPDATE` queries are automatically regenerated any time the TableAdapter Configuration wizard is completed.</span></span> <span data-ttu-id="418fb-120">因此，计算的列中手动删除从`INSERT`和`UPDATE`重新运行该向导时，查询将重新出现。</span><span class="sxs-lookup"><span data-stu-id="418fb-120">Therefore, the computed columns manually removed from the `INSERT` and `UPDATE` queries will reappear if the wizard is re-run.</span></span> <span data-ttu-id="418fb-121">尽管使用存储的过程的 Tableadapter 不会受到此受到攻击，它们具有其自己的我们将在步骤 3 中解决的异常。</span><span class="sxs-lookup"><span data-stu-id="418fb-121">Although TableAdapters that use stored procedures don t suffer from this brittleness, they do have their own quirks that we will address in Step 3.</span></span>

<span data-ttu-id="418fb-122">在本教程中，我们将添加到计算的列`Suppliers`Northwind 数据库中表，然后创建相应的 TableAdapter 以使用此表，其计算所得的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-122">In this tutorial we will add a computed column to the `Suppliers` table in the Northwind database and then create a corresponding TableAdapter to work with this table and its computed column.</span></span> <span data-ttu-id="418fb-123">我们将使用存储的过程而不是临时 SQL 语句，以便使用 TableAdapter 配置向导时，我们自定义项不会丢失我们 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="418fb-123">We will have our TableAdapter use stored procedures instead of ad-hoc SQL statements so that our customizations aren't lost when the TableAdapter Configuration wizard is used.</span></span>

<span data-ttu-id="418fb-124">让我们来开始 ！</span><span class="sxs-lookup"><span data-stu-id="418fb-124">Let s get started!</span></span>

## <a name="step-1-adding-a-computed-column-to-thesupplierstable"></a><span data-ttu-id="418fb-125">步骤 1：添加到计算的列`Suppliers`表</span><span class="sxs-lookup"><span data-stu-id="418fb-125">Step 1: Adding a Computed Column to the`Suppliers`Table</span></span>

<span data-ttu-id="418fb-126">Northwind 数据库不具有任何计算的列，因此我们需要添加一个自己。</span><span class="sxs-lookup"><span data-stu-id="418fb-126">The Northwind database does not have any computed columns so we will need to add one ourselves.</span></span> <span data-ttu-id="418fb-127">对于本教程让我们来添加到计算的列`Suppliers`名为表`FullContactName`采用以下格式返回联系人的名称、 标题和它们工作的公司： `ContactName` (`ContactTitle`， `CompanyName`)。</span><span class="sxs-lookup"><span data-stu-id="418fb-127">For this tutorial let s add a computed column to the `Suppliers` table called `FullContactName` that returns the contact s name, title, and the company they work for in the following format: `ContactName` (`ContactTitle`, `CompanyName`).</span></span> <span data-ttu-id="418fb-128">此计算显示有关供应商的信息时，可能会在报表中使用列。</span><span class="sxs-lookup"><span data-stu-id="418fb-128">This computed column might be used in reports when displaying information about suppliers.</span></span>

<span data-ttu-id="418fb-129">首先打开`Suppliers`通过右键单击表定义`Suppliers`表在服务器资源管理器中，从上下文菜单中选择打开表定义。</span><span class="sxs-lookup"><span data-stu-id="418fb-129">Start by opening the `Suppliers` table definition by right-clicking on the `Suppliers` table in the Server Explorer and choosing Open Table Definition from the context-menu.</span></span> <span data-ttu-id="418fb-130">这将显示表及其属性，其数据类型，例如的列是否允许`NULL`s，等等。</span><span class="sxs-lookup"><span data-stu-id="418fb-130">This will display the columns of the table and their properties, such as their data type, whether they allow `NULL` s, and so forth.</span></span> <span data-ttu-id="418fb-131">若要添加计算的列，请先键入列的名称表定义。</span><span class="sxs-lookup"><span data-stu-id="418fb-131">To add a computed column, start by typing in the name of the column into the table definition.</span></span> <span data-ttu-id="418fb-132">接下来，在列属性窗口中的计算所得的列规范部分下 （公式） 文本框中输入它的表达式 （参见图 1）。</span><span class="sxs-lookup"><span data-stu-id="418fb-132">Next, enter its expression into the (Formula) textbox under the Computed Column Specification section in the Column Properties window (see Figure 1).</span></span> <span data-ttu-id="418fb-133">命名计算的列`FullContactName`，并使用以下表达式：</span><span class="sxs-lookup"><span data-stu-id="418fb-133">Name the computed column `FullContactName` and use the following expression:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample1.sql)]

<span data-ttu-id="418fb-134">请注意，可以在 SQL 连接字符串使用`+`运算符。</span><span class="sxs-lookup"><span data-stu-id="418fb-134">Note that strings can be concatenated in SQL using the `+` operator.</span></span> <span data-ttu-id="418fb-135">`CASE`语句可以用作在传统编程语言中的条件。</span><span class="sxs-lookup"><span data-stu-id="418fb-135">The `CASE` statement can be used like a conditional in a traditional programming language.</span></span> <span data-ttu-id="418fb-136">在上述表达式中`CASE`语句可以读取为：如果`ContactTitle`不是`NULL`然后输出`ContactTitle`串联的用逗号分隔，否则为发出执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="418fb-136">In the above expression the `CASE` statement can be read as: If `ContactTitle` is not `NULL` then output the `ContactTitle` value concatenated with a comma, otherwise emit nothing.</span></span> <span data-ttu-id="418fb-137">有关详细信息的有用性`CASE`语句，请参阅[的 SQL Power`CASE`语句](http://www.4guysfromrolla.com/webtech/102704-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="418fb-137">For more on the usefulness of the `CASE` statement, see [The Power of SQL `CASE` Statements](http://www.4guysfromrolla.com/webtech/102704-1.shtml).</span></span>

> [!NOTE]
> <span data-ttu-id="418fb-138">而不是使用`CASE`以下语句中，我们也可以或者使用`ISNULL(ContactTitle, '')`。</span><span class="sxs-lookup"><span data-stu-id="418fb-138">Instead of using a `CASE` statement here, we could have alternatively used `ISNULL(ContactTitle, '')`.</span></span> <span data-ttu-id="418fb-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx) 返回*checkExpression*如果，则为非 NULL，否则它将返回*replacementValue*。</span><span class="sxs-lookup"><span data-stu-id="418fb-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx) returns *checkExpression* if it is non-NULL, otherwise it returns *replacementValue*.</span></span> <span data-ttu-id="418fb-140">尽管可以`ISNULL`或`CASE`将工作在本例中，有更多复杂方案其中的灵活性`CASE`语句不能由匹配`ISNULL`。</span><span class="sxs-lookup"><span data-stu-id="418fb-140">While either `ISNULL` or `CASE` will work in this instance, there are more intricate scenarios where the flexibility of the `CASE` statement cannot be matched by `ISNULL`.</span></span>


<span data-ttu-id="418fb-141">添加此计算的列后您的屏幕应如下所示屏幕快照中图 1。</span><span class="sxs-lookup"><span data-stu-id="418fb-141">After adding this computed column your screen should look like the screen shot in Figure 1.</span></span>


<span data-ttu-id="418fb-142">[![添加一个名为 FullContactName 到供应商表的计算的列](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-142">[![Add a Computed Column Named FullContactName to the Suppliers Table](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span></span>

<span data-ttu-id="418fb-143">**图 1**:添加计算列命名`FullContactName`到`Suppliers`表 ([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-143">**Figure 1**: Add a Computed Column Named `FullContactName` to the `Suppliers` Table ([Click to view full-size image](working-with-computed-columns-vb/_static/image3.png))</span></span>


<span data-ttu-id="418fb-144">在命名计算的列并输入其表达式之后, 将所做的更改保存到表通过单击工具栏中的保存图标，通过按 Ctrl + S，或通过转到文件菜单并选择保存`Suppliers`。</span><span class="sxs-lookup"><span data-stu-id="418fb-144">After naming the computed column and entering its expression, save the changes to the table by clicking the Save icon in the toolbar, by hitting Ctrl+S, or by going to the File menu and choosing Save `Suppliers`.</span></span>

<span data-ttu-id="418fb-145">正在保存表应刷新在服务器资源管理器，其中包括在刚添加的列`Suppliers`表的列列表。</span><span class="sxs-lookup"><span data-stu-id="418fb-145">Saving the table should refresh the Server Explorer, including the just-added column in the `Suppliers` table s column list.</span></span> <span data-ttu-id="418fb-146">此外，（公式） 文本框中输入的表达式将自动调整为去除不必要的空格，环绕列名称带括号的等效表达式 (`[]`)，并包含括号来更明确显示操作的顺序：</span><span class="sxs-lookup"><span data-stu-id="418fb-146">Furthermore, the expression entered into the (Formula) textbox will automatically adjust to an equivalent expression that strips unnecessary whitespace, surrounds column names with brackets (`[]`), and includes parentheses to more explicitly show the order of operations:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample2.sql)]

<span data-ttu-id="418fb-147">有关 Microsoft SQL Server 中的计算列的详细信息，请参阅[技术文档](https://msdn.microsoft.com/library/ms191250.aspx)。</span><span class="sxs-lookup"><span data-stu-id="418fb-147">For more information on computed columns in Microsoft SQL Server, refer to the [technical documentation](https://msdn.microsoft.com/library/ms191250.aspx).</span></span> <span data-ttu-id="418fb-148">另请参阅[如何：指定计算列](https://msdn.microsoft.com/library/ms188300.aspx)有关创建计算的列的分步演练。</span><span class="sxs-lookup"><span data-stu-id="418fb-148">Also check out the [How to: Specify Computed Columns](https://msdn.microsoft.com/library/ms188300.aspx) for a step-by-step walkthrough of creating computed columns.</span></span>

> [!NOTE]
> <span data-ttu-id="418fb-149">默认情况下，计算的列不以物理方式存储在表中，但会改为重新计算每次在查询中引用它们。</span><span class="sxs-lookup"><span data-stu-id="418fb-149">By default, computed columns are not physically stored in the table but are instead recalculated each time they are referenced in a query.</span></span> <span data-ttu-id="418fb-150">通过选中保留复选框，但是，您可以指示 SQL Server 以物理方式存储在表中的计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-150">By checking the Is Persisted checkbox, however, you can instruct SQL Server to physically store the computed column in the table.</span></span> <span data-ttu-id="418fb-151">这样做使索引可以提高使用计算的列的值中的查询性能的计算列上创建其`WHERE`子句。</span><span class="sxs-lookup"><span data-stu-id="418fb-151">Doing so allows an index to be created on the computed column, which can improve the performance of queries that use the computed column value in their `WHERE` clauses.</span></span> <span data-ttu-id="418fb-152">请参阅[对计算列创建索引](https://msdn.microsoft.com/library/ms189292.aspx)有关详细信息。</span><span class="sxs-lookup"><span data-stu-id="418fb-152">See [Creating Indexes on Computed Columns](https://msdn.microsoft.com/library/ms189292.aspx) for more information.</span></span>


## <a name="step-2-viewing-the-computed-column-s-values"></a><span data-ttu-id="418fb-153">步骤 2：查看计算所得的列值 s</span><span class="sxs-lookup"><span data-stu-id="418fb-153">Step 2: Viewing the Computed Column s Values</span></span>

<span data-ttu-id="418fb-154">数据访问层上开始工作之前，让 s 花点时间查看`FullContactName`值。</span><span class="sxs-lookup"><span data-stu-id="418fb-154">Before we start work on the Data Access Layer, let s take a minute to view the `FullContactName` values.</span></span> <span data-ttu-id="418fb-155">从服务器资源管理器，右键单击`Suppliers`表名称，并从上下文菜单中选择新查询。</span><span class="sxs-lookup"><span data-stu-id="418fb-155">From the Server Explorer, right-click on the `Suppliers` table name and choose New Query from the context-menu.</span></span> <span data-ttu-id="418fb-156">此时会弹出提示我们选择要在查询中包括的表的查询窗口。</span><span class="sxs-lookup"><span data-stu-id="418fb-156">This will bring up a Query window that prompts us to choose what tables to include in the query.</span></span> <span data-ttu-id="418fb-157">添加`Suppliers`表，然后单击关闭。</span><span class="sxs-lookup"><span data-stu-id="418fb-157">Add the `Suppliers` table and click Close.</span></span> <span data-ttu-id="418fb-158">接下来，检查`CompanyName`， `ContactName`， `ContactTitle`，和`FullContactName`供应商表中的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-158">Next, check the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` columns from the Suppliers table.</span></span> <span data-ttu-id="418fb-159">最后，单击执行查询并查看结果工具栏中的红色感叹号图标。</span><span class="sxs-lookup"><span data-stu-id="418fb-159">Finally, click the red exclamation point icon in the Toolbar to execute the query and view the results.</span></span>

<span data-ttu-id="418fb-160">结果如图 2 所示，包括`FullContactName`，其中列出`CompanyName`， `ContactName`，和`ContactTitle`使用的格式的列`ContactName`(`ContactTitle`， `CompanyName`)。</span><span class="sxs-lookup"><span data-stu-id="418fb-160">As Figure 2 shows, the results include `FullContactName`, which lists the `CompanyName`, `ContactName`, and `ContactTitle` columns using the format `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>


<span data-ttu-id="418fb-161">[![FullContactName 使用格式 ContactName （联系人职务、 公司名称）](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-161">[![The FullContactName Uses the Format ContactName (ContactTitle, CompanyName)](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span></span>

<span data-ttu-id="418fb-162">**图 2**:`FullContactName`使用格式`ContactName`(`ContactTitle`， `CompanyName`) ([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-162">**Figure 2**: The `FullContactName` Uses the Format `ContactName` (`ContactTitle`, `CompanyName`) ([Click to view full-size image](working-with-computed-columns-vb/_static/image6.png))</span></span>


## <a name="step-3-adding-thesupplierstableadapterto-the-data-access-layer"></a><span data-ttu-id="418fb-163">步骤 3：添加`SuppliersTableAdapter`到数据访问层</span><span class="sxs-lookup"><span data-stu-id="418fb-163">Step 3: Adding the`SuppliersTableAdapter`to the Data Access Layer</span></span>

<span data-ttu-id="418fb-164">若要使用我们的应用程序中的供应商信息，我们需要首先在 DAL 中创建的 TableAdapter 和 DataTable。</span><span class="sxs-lookup"><span data-stu-id="418fb-164">In order to work with the supplier information in our application we need to first create a TableAdapter and DataTable in our DAL.</span></span> <span data-ttu-id="418fb-165">理想情况下，这将使用完成相同的简单步骤检查在之前的教程。</span><span class="sxs-lookup"><span data-stu-id="418fb-165">Ideally, this would be accomplished using the same straightforward steps examined in earlier tutorials.</span></span> <span data-ttu-id="418fb-166">但是，使用计算列引入了几个值得讨论的褶皱。</span><span class="sxs-lookup"><span data-stu-id="418fb-166">However, working with computed columns introduces a few wrinkles that merit discussion.</span></span>

<span data-ttu-id="418fb-167">如果使用 TableAdapter 使用的临时 SQL 语句，则只需可以 TableAdapter s 通过 TableAdapter 配置向导的主查询中包含计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-167">If you are using a TableAdapter that uses ad-hoc SQL statements, you can simply include the computed column in the TableAdapter s main query via the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="418fb-168">此操作，但是，将自动生成`INSERT`和`UPDATE`包含计算的列的语句。</span><span class="sxs-lookup"><span data-stu-id="418fb-168">This, however, will auto-generate `INSERT` and `UPDATE` statements that include the computed column.</span></span> <span data-ttu-id="418fb-169">如果您尝试执行这些方法之一`SqlException`消息列*ColumnName*无法修改，因为它是计算的列或者是 UNION 运算符的结果将会引发。</span><span class="sxs-lookup"><span data-stu-id="418fb-169">If you attempt to execute one of these methods, a `SqlException` with the message The column *ColumnName* cannot be modified because it is either a computed column or is the result of a UNION operator will be thrown.</span></span> <span data-ttu-id="418fb-170">虽然`INSERT`并`UPDATE`语句可以手动将其调整到的 TableAdapter`InsertCommand`和`UpdateCommand`属性，这些自定义项将会丢失，重新运行 TableAdapter 配置向导时。</span><span class="sxs-lookup"><span data-stu-id="418fb-170">While the `INSERT` and `UPDATE` statement can be manually adjusted through the TableAdapter s `InsertCommand` and `UpdateCommand` properties, these customizations will be lost whenever the TableAdapter Configuration wizard is re-run.</span></span>

<span data-ttu-id="418fb-171">由于使用的临时 SQL 语句的 Tableadapter 脆弱性，建议我们使用计算列时使用的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="418fb-171">Due to the brittleness of TableAdapters that use ad-hoc SQL statements, it is recommended that we use stored procedures when working with computed columns.</span></span> <span data-ttu-id="418fb-172">如果使用现有的存储的过程，只需配置 TableAdapter 中所述[使用现有存储过程的类型化数据集 s Tableadapter](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)教程。</span><span class="sxs-lookup"><span data-stu-id="418fb-172">If you are using existing stored procedures, simply configure the TableAdapter as discussed in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span> <span data-ttu-id="418fb-173">但是，如果您有 TableAdapter 向导为你创建的存储的过程，是重要最初忽略主查询中的任何计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-173">If you have the TableAdapter wizard create the stored procedures for you, however, it is important to initially omit any computed columns from the main query.</span></span> <span data-ttu-id="418fb-174">如果主查询中包含计算的列，TableAdapter 配置向导将通知你，完成后，它不能创建相应的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="418fb-174">If you include a computed column in the main query, the TableAdapter Configuration wizard will inform you, upon completion, that it cannot create the corresponding stored procedures.</span></span> <span data-ttu-id="418fb-175">简单地说，我们需要最初配置 TableAdapter 使用计算的列释放主查询，然后手动更新相应的存储的过程和 TableAdapter 的`SelectCommand`包括计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-175">In short, we need to initially configure the TableAdapter using a computed column-free main query and then manually update the corresponding stored procedure and the TableAdapter s `SelectCommand` to include the computed column.</span></span> <span data-ttu-id="418fb-176">这种方法是类似于所用[更新 TableAdapter 以使用](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s*教程。</span><span class="sxs-lookup"><span data-stu-id="418fb-176">This approach is similar to the one used in the [Updating the TableAdapter to Use](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s* tutorial.</span></span>

<span data-ttu-id="418fb-177">对于本教程，让我们来添加新的 TableAdapter，并将其自动为我们创建的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="418fb-177">For this tutorial, let s add a new TableAdapter and have it automatically create the stored procedures for us.</span></span> <span data-ttu-id="418fb-178">因此，我们将需要最初省略`FullContactName`主查询中的计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-178">Consequently, we will need to initially omit the `FullContactName` computed column from the main query.</span></span>

<span data-ttu-id="418fb-179">首先打开`NorthwindWithSprocs`中的数据集`~/App_Code/DAL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="418fb-179">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="418fb-180">在设计器中右键单击并从上下文菜单上，选择要添加新的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="418fb-180">Right-click in the Designer and, from the context-menu, choose to add a new TableAdapter.</span></span> <span data-ttu-id="418fb-181">这将启动 TableAdapter 配置向导。</span><span class="sxs-lookup"><span data-stu-id="418fb-181">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="418fb-182">查询数据从指定的数据库 (`NORTHWNDConnectionString`从`Web.config`) 并单击下一步。</span><span class="sxs-lookup"><span data-stu-id="418fb-182">Specify the database to query data from (`NORTHWNDConnectionString` from `Web.config`) and click Next.</span></span> <span data-ttu-id="418fb-183">由于我们尚未创建任何存储的过程的查询或修改`Suppliers`表中，选择的创建新的存储的过程选项，因此该向导将为我们创建它们，并单击下一步。</span><span class="sxs-lookup"><span data-stu-id="418fb-183">Since we have not yet created any stored procedures for querying or modifying the `Suppliers` table, select the Create new stored procedures option so that the wizard will create them for us and click Next.</span></span>


<span data-ttu-id="418fb-184">[![选择创建新存储的过程选项](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-184">[![Choose the Create new stored procedures Option](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span></span>

<span data-ttu-id="418fb-185">**图 3**:选择创建新存储的过程选项 ([单击此项可查看原尺寸图像](working-with-computed-columns-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-185">**Figure 3**: Choose the Create new stored procedures Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image9.png))</span></span>


<span data-ttu-id="418fb-186">后续步骤会提示我们主查询。</span><span class="sxs-lookup"><span data-stu-id="418fb-186">The subsequent step prompts us for the main query.</span></span> <span data-ttu-id="418fb-187">输入以下查询，返回`SupplierID`， `CompanyName`， `ContactName`，和`ContactTitle`每个供应商的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-187">Enter the following query, which returns the `SupplierID`, `CompanyName`, `ContactName`, and `ContactTitle` columns for each supplier.</span></span> <span data-ttu-id="418fb-188">请注意此查询有意省略了计算的列 (`FullContactName`); 我们将更新相应的存储的过程为在步骤 4 中包括此列。</span><span class="sxs-lookup"><span data-stu-id="418fb-188">Note that this query purposefully omits the computed column (`FullContactName`); we will update the corresponding stored procedure to include this column in Step 4.</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample3.sql)]

<span data-ttu-id="418fb-189">输入主查询，并单击下一步之后, 该向导将允许我们命名它将生成的四个存储的过程。</span><span class="sxs-lookup"><span data-stu-id="418fb-189">After entering the main query and clicking Next, the wizard allows us to name the four stored procedures it will generate.</span></span> <span data-ttu-id="418fb-190">命名这些存储的过程`Suppliers_Select`， `Suppliers_Insert`， `Suppliers_Update`，和`Suppliers_Delete`，如图 4 所示。</span><span class="sxs-lookup"><span data-stu-id="418fb-190">Name these stored procedures `Suppliers_Select`, `Suppliers_Insert`, `Suppliers_Update`, and `Suppliers_Delete`, as Figure 4 illustrates.</span></span>


<span data-ttu-id="418fb-191">[![自定义自动生成的存储过程的名称](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-191">[![Customize the Names of the Auto-Generated Stored Procedures](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span></span>

<span data-ttu-id="418fb-192">**图 4**:自定义 Auto-Generated 存储过程的名称 ([单击此项可查看原尺寸图像](working-with-computed-columns-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-192">**Figure 4**: Customize the Names of the Auto-Generated Stored Procedures ([Click to view full-size image](working-with-computed-columns-vb/_static/image12.png))</span></span>


<span data-ttu-id="418fb-193">下一步的向导步骤可用于名称的 TableAdapter 的方法，并指定用于访问和更新数据的模式。</span><span class="sxs-lookup"><span data-stu-id="418fb-193">The next wizard step allows us to name the TableAdapter s methods and specify the patterns used to access and update data.</span></span> <span data-ttu-id="418fb-194">保留所有三个复选框选中状态，但重命名`GetData`方法`GetSuppliers`。</span><span class="sxs-lookup"><span data-stu-id="418fb-194">Leave all three checkboxes checked, but rename the `GetData` method to `GetSuppliers`.</span></span> <span data-ttu-id="418fb-195">单击完成以完成向导。</span><span class="sxs-lookup"><span data-stu-id="418fb-195">Click Finish to complete the wizard.</span></span>


<span data-ttu-id="418fb-196">[![将 GetData 方法重命名为 GetSuppliers](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-196">[![Rename the GetData Method to GetSuppliers](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span></span>

<span data-ttu-id="418fb-197">**图 5**:重命名`GetData`方法`GetSuppliers`([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-197">**Figure 5**: Rename the `GetData` Method to `GetSuppliers` ([Click to view full-size image](working-with-computed-columns-vb/_static/image15.png))</span></span>


<span data-ttu-id="418fb-198">单击完成，向导将创建四个存储的过程，并将 TableAdapter 和相应的 DataTable 添加到类型化数据集。</span><span class="sxs-lookup"><span data-stu-id="418fb-198">Upon clicking Finish, the wizard will create the four stored procedures and add the TableAdapter and corresponding DataTable to the Typed DataSet.</span></span>

## <a name="step-4-including-the-computed-column-in-the-tableadapter-s-main-query"></a><span data-ttu-id="418fb-199">步骤 4：在 TableAdapter s 主查询中包含计算的列</span><span class="sxs-lookup"><span data-stu-id="418fb-199">Step 4: Including the Computed Column in the TableAdapter s Main Query</span></span>

<span data-ttu-id="418fb-200">现在，我们需要更新 TableAdapter 和步骤 3 以包括中创建的 DataTable`FullContactName`计算所得的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-200">We now need to update the TableAdapter and DataTable created in Step 3 to include the `FullContactName` computed column.</span></span> <span data-ttu-id="418fb-201">这涉及到两个步骤：</span><span class="sxs-lookup"><span data-stu-id="418fb-201">This involves two steps:</span></span>

1. <span data-ttu-id="418fb-202">正在更新`Suppliers_Select`存储过程返回`FullContactName`计算的列和</span><span class="sxs-lookup"><span data-stu-id="418fb-202">Updating the `Suppliers_Select` stored procedure to return the `FullContactName` computed column, and</span></span>
2. <span data-ttu-id="418fb-203">更新以包括相应的 DataTable`FullContactName`列。</span><span class="sxs-lookup"><span data-stu-id="418fb-203">Updating the DataTable to include a corresponding `FullContactName` column.</span></span>

<span data-ttu-id="418fb-204">首先，导航到服务器资源管理器并向下钻取到存储过程文件夹。</span><span class="sxs-lookup"><span data-stu-id="418fb-204">Start by navigating to the Server Explorer and drilling down into the Stored Procedures folder.</span></span> <span data-ttu-id="418fb-205">打开`Suppliers_Select`存储过程并更新`SELECT`查询，以便包括`FullContactName`计算所得的列：</span><span class="sxs-lookup"><span data-stu-id="418fb-205">Open the `Suppliers_Select` stored procedure and update the `SELECT` query to include the `FullContactName` computed column:</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample4.sql)]

<span data-ttu-id="418fb-206">将所做的更改保存到存储过程，通过单击工具栏中的保存图标，通过按 Ctrl + S，或通过选择保存`Suppliers_Select`从文件菜单选项。</span><span class="sxs-lookup"><span data-stu-id="418fb-206">Save the changes to the stored procedure by clicking the Save icon in the Toolbar, by hitting Ctrl+S, or by choosing the Save `Suppliers_Select` option from the File menu.</span></span>

<span data-ttu-id="418fb-207">接下来，返回到数据集设计器，右键单击`SuppliersTableAdapter`，然后从上下文菜单中选择配置。</span><span class="sxs-lookup"><span data-stu-id="418fb-207">Next, return to the DataSet Designer, right-click on the `SuppliersTableAdapter`, and choose Configure from the context-menu.</span></span> <span data-ttu-id="418fb-208">请注意，`Suppliers_Select`列现在包括`FullContactName`其的数据列集合中的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-208">Note that the `Suppliers_Select` column now includes the `FullContactName` column in its Data Columns collection.</span></span>


<span data-ttu-id="418fb-209">[![运行 TableAdapter 的配置向导以更新数据表的列](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-209">[![Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span></span>

<span data-ttu-id="418fb-210">**图 6**:运行 TableAdapter 的配置向导以更新 DataTable 的列 ([单击此项可查看原尺寸图像](working-with-computed-columns-vb/_static/image18.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-210">**Figure 6**: Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns ([Click to view full-size image](working-with-computed-columns-vb/_static/image18.png))</span></span>


<span data-ttu-id="418fb-211">单击完成以完成向导。</span><span class="sxs-lookup"><span data-stu-id="418fb-211">Click Finish to complete the wizard.</span></span> <span data-ttu-id="418fb-212">这将自动添加到相应的列`SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="418fb-212">This will automatically add a corresponding column to the `SuppliersDataTable`.</span></span> <span data-ttu-id="418fb-213">TableAdapter 向导非常智能，可检测的`FullContactName`列是计算的列，因此它是只读的。</span><span class="sxs-lookup"><span data-stu-id="418fb-213">The TableAdapter wizard is smart enough to detect that the `FullContactName` column is a computed column and therefore read-only.</span></span> <span data-ttu-id="418fb-214">因此，它将设置列 s`ReadOnly`属性设置为`true`。</span><span class="sxs-lookup"><span data-stu-id="418fb-214">Consequently, it sets the column s `ReadOnly` property to `true`.</span></span> <span data-ttu-id="418fb-215">若要验证这一点，选择从列`SuppliersDataTable`，然后转到属性窗口 （请参阅图 7）。</span><span class="sxs-lookup"><span data-stu-id="418fb-215">To verify this, select the column from the `SuppliersDataTable` and then go to the Properties window (see Figure 7).</span></span> <span data-ttu-id="418fb-216">请注意，`FullContactName`列 s`DataType`和`MaxLength`属性也会相应地设置。</span><span class="sxs-lookup"><span data-stu-id="418fb-216">Note that the `FullContactName` column s `DataType` and `MaxLength` properties are also set accordingly.</span></span>


<span data-ttu-id="418fb-217">[![FullContactName 列被标记为只读的](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-217">[![The FullContactName Column is Marked as Read-Only](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span></span>

<span data-ttu-id="418fb-218">**图 7**:`FullContactName`列被标记为只读的 ([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image21.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-218">**Figure 7**: The `FullContactName` Column is Marked as Read-Only ([Click to view full-size image](working-with-computed-columns-vb/_static/image21.png))</span></span>


## <a name="step-5-adding-agetsupplierbysupplieridmethod-to-the-tableadapter"></a><span data-ttu-id="418fb-219">步骤 5：添加`GetSupplierBySupplierID`到 TableAdapter 方法</span><span class="sxs-lookup"><span data-stu-id="418fb-219">Step 5: Adding a`GetSupplierBySupplierID`Method to the TableAdapter</span></span>

<span data-ttu-id="418fb-220">对于本教程中，我们将创建可更新网格中显示供应商的 ASP.NET 页。</span><span class="sxs-lookup"><span data-stu-id="418fb-220">For this tutorial we will create an ASP.NET page that displays the suppliers in an updateable grid.</span></span> <span data-ttu-id="418fb-221">在过去的教程我们已更新业务逻辑层中的单个记录通过检索特定记录从作为强类型化 DataTable，更新其属性，并将发送更新的 DataTable DAL 回 DAL 将更改传播到在数据库中。</span><span class="sxs-lookup"><span data-stu-id="418fb-221">In past tutorials we have updated a single record from the Business Logic Layer by retrieving that particular record from the DAL as a strongly-typed DataTable, updating its properties, and then sending the updated DataTable back to the DAL to propagate the changes to the database.</span></span> <span data-ttu-id="418fb-222">若要完成-检索将 DAL 从更新的记录的此第一步我们需要首先添加`GetSupplierBySupplierID(supplierID)`对 DAL 的方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-222">To accomplish this first step - retrieving the record being updated from the DAL - we need to first add a `GetSupplierBySupplierID(supplierID)` method to the DAL.</span></span>

<span data-ttu-id="418fb-223">右键单击`SuppliersTableAdapter`数据集设计中，然后从上下文菜单选择添加查询选项。</span><span class="sxs-lookup"><span data-stu-id="418fb-223">Right-click on the `SuppliersTableAdapter` in the DataSet Design and choose the Add Query option from the context-menu.</span></span> <span data-ttu-id="418fb-224">与我们在步骤 3 中，让向导为我们生成新的存储的过程，通过选择创建新存储的过程选项 （请参阅回图 3 用于此向导步骤的屏幕截图）。</span><span class="sxs-lookup"><span data-stu-id="418fb-224">As we did in Step 3, let the wizard generate a new stored procedure for us by selecting the Create new stored procedure option (refer back to Figure 3 for a screenshot of this wizard step).</span></span> <span data-ttu-id="418fb-225">由于此方法将返回具有多个列的记录，则表示我们想要使用 SQL 查询的 select 语句返回的行并单击下一步。</span><span class="sxs-lookup"><span data-stu-id="418fb-225">Since this method will return a record with multiple columns, indicate that we want to use a SQL query that is a SELECT which returns rows and click Next.</span></span>


<span data-ttu-id="418fb-226">[![选择它返回行选项](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-226">[![Choose the SELECT which returns rows Option](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span></span>

<span data-ttu-id="418fb-227">**图 8**:选择它返回行选项 ([单击此项可查看原尺寸图像](working-with-computed-columns-vb/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-227">**Figure 8**: Choose the SELECT which returns rows Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image24.png))</span></span>


<span data-ttu-id="418fb-228">后续步骤会提示我们要使用此方法的查询。</span><span class="sxs-lookup"><span data-stu-id="418fb-228">The subsequent step prompts us for the query to use for this method.</span></span> <span data-ttu-id="418fb-229">输入以下内容，它将返回相同的数据字段作为主查询，但特定供应商。</span><span class="sxs-lookup"><span data-stu-id="418fb-229">Enter the following, which returns the same data fields as the main query but for a particular supplier.</span></span>


[!code-sql[Main](working-with-computed-columns-vb/samples/sample5.sql)]

<span data-ttu-id="418fb-230">下一个屏幕询问我们命名将会自动生成的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="418fb-230">The next screen asks us to name the stored procedure that will be auto-generated.</span></span> <span data-ttu-id="418fb-231">命名此存储的过程`Suppliers_SelectBySupplierID`单击下一步。</span><span class="sxs-lookup"><span data-stu-id="418fb-231">Name this stored procedure `Suppliers_SelectBySupplierID` and click Next.</span></span>


<span data-ttu-id="418fb-232">[![命名存储的过程 Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-232">[![Name the Stored Procedure Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span></span>

<span data-ttu-id="418fb-233">**图 9**:命名存储过程`Suppliers_SelectBySupplierID`([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image27.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-233">**Figure 9**: Name the Stored Procedure `Suppliers_SelectBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image27.png))</span></span>


<span data-ttu-id="418fb-234">最后，向导提示操作，我们的数据访问模式和方法名称要用于 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="418fb-234">Lastly, the wizard prompts us for the data access patterns and method names to use for the TableAdapter.</span></span> <span data-ttu-id="418fb-235">保留选中状态，这两个复选框，但重命名`FillBy`并`GetDataBy`方法添加到`FillBySupplierID`和`GetSupplierBySupplierID`分别。</span><span class="sxs-lookup"><span data-stu-id="418fb-235">Leave both checkboxes checked, but rename the `FillBy` and `GetDataBy` methods to `FillBySupplierID` and `GetSupplierBySupplierID`, respectively.</span></span>


<span data-ttu-id="418fb-236">[![名称 TableAdapter 方法 FillBySupplierID 和 GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-236">[![Name the TableAdapter Methods FillBySupplierID and GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span></span>

<span data-ttu-id="418fb-237">**图 10**:命名 TableAdapter 方法`FillBySupplierID`并`GetSupplierBySupplierID`([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image30.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-237">**Figure 10**: Name the TableAdapter Methods `FillBySupplierID` and `GetSupplierBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image30.png))</span></span>


<span data-ttu-id="418fb-238">单击完成以完成向导。</span><span class="sxs-lookup"><span data-stu-id="418fb-238">Click Finish to complete the wizard.</span></span>

## <a name="step-6-creating-the-business-logic-layer"></a><span data-ttu-id="418fb-239">步骤 6：创建业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="418fb-239">Step 6: Creating the Business Logic Layer</span></span>

<span data-ttu-id="418fb-240">我们创建的 ASP.NET 页的使用步骤 1 中创建计算的列之前，我们首先需要在 BLL 中添加相应的方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-240">Before we create an ASP.NET page that uses the computed column created in Step 1, we first need to add the corresponding methods in the BLL.</span></span> <span data-ttu-id="418fb-241">我们 ASP.NET 页中，我们将创建在步骤 7 中，将允许用户查看和编辑供应商。</span><span class="sxs-lookup"><span data-stu-id="418fb-241">Our ASP.NET page, which we will create in Step 7, will allow users to view and edit suppliers.</span></span> <span data-ttu-id="418fb-242">因此，我们需要我们 BLL，若要提供，最小值，若要获取的所有供应商和另一个要更新的特定供应商提供的方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-242">Therefore, we need our BLL to provide, at minimum, a method to get all of the suppliers and another to update a particular supplier.</span></span>

<span data-ttu-id="418fb-243">创建名为的新类文件`SuppliersBLLWithSprocs`在`~/App_Code/BLL`文件夹并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="418fb-243">Create a new class file named `SuppliersBLLWithSprocs` in the `~/App_Code/BLL` folder and add the following code:</span></span>


[!code-vb[Main](working-with-computed-columns-vb/samples/sample6.vb)]

<span data-ttu-id="418fb-244">一样; 与其他 BLL 类`SuppliersBLLWithSprocs`已`Protected``Adapter`返回的实例的属性`SuppliersTableAdapter`类，以及两个`Public`方法：`GetSuppliers`和`UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="418fb-244">Like the other BLL classes, `SuppliersBLLWithSprocs` has a `Protected` `Adapter` property that returns an instance of the `SuppliersTableAdapter` class along with two `Public` methods: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="418fb-245">`GetSuppliers`方法调用，并返回`SuppliersDataTable`返回的相应`GetSupplier`数据访问层中的方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-245">The `GetSuppliers` method calls and returns the `SuppliersDataTable` returned by the corresponding `GetSupplier` method in the Data Access Layer.</span></span> <span data-ttu-id="418fb-246">`UpdateSupplier`方法检索有关特定供应商正在通过调用 DAL s 更新的信息`GetSupplierBySupplierID(supplierID)`方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-246">The `UpdateSupplier` method retrieves information about the particular supplier being updated via a call to the DAL s `GetSupplierBySupplierID(supplierID)` method.</span></span> <span data-ttu-id="418fb-247">然后更新`CategoryName`， `ContactName`，并`ContactTitle`属性并提交到数据库的这些更改，通过调用数据访问层 s`Update`方法，传入已修改`SuppliersRow`对象。</span><span class="sxs-lookup"><span data-stu-id="418fb-247">It then updates the `CategoryName`, `ContactName`, and `ContactTitle` properties and commits these changes to the database by calling the Data Access Layer s `Update` method, passing in the modified `SuppliersRow` object.</span></span>

> [!NOTE]
> <span data-ttu-id="418fb-248">除`SupplierID`并`CompanyName`，供应商表中的所有列都允许`NULL`值。</span><span class="sxs-lookup"><span data-stu-id="418fb-248">Except for `SupplierID` and `CompanyName`, all columns in the Suppliers table allow `NULL` values.</span></span> <span data-ttu-id="418fb-249">因此，如果传入的`contactName`或`contactTitle`参数是`Nothing`我们需要设置相应`ContactName`并`ContactTitle`属性设置为`NULL`数据库值使用`SetContactNameNull`和`SetContactTitleNull`方法，分别。</span><span class="sxs-lookup"><span data-stu-id="418fb-249">Therefore, if the passed-in `contactName` or `contactTitle` parameters are `Nothing` we need to set the corresponding `ContactName` and `ContactTitle` properties to a `NULL` database value using the `SetContactNameNull` and `SetContactTitleNull` methods, respectively.</span></span>


## <a name="step-7-working-with-the-computed-column-from-the-presentation-layer"></a><span data-ttu-id="418fb-250">步骤 7：使用从表示层的计算列</span><span class="sxs-lookup"><span data-stu-id="418fb-250">Step 7: Working with the Computed Column from the Presentation Layer</span></span>

<span data-ttu-id="418fb-251">使用计算列添加到`Suppliers`表的 DAL 和 BLL 相应地更新，我们已准备好生成适用于 ASP.NET 页`FullContactName`计算所得的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-251">With the computed column added to the `Suppliers` table and the DAL and BLL updated accordingly, we are ready to build an ASP.NET page that works with the `FullContactName` computed column.</span></span> <span data-ttu-id="418fb-252">首先打开`ComputedColumns.aspx`页中`AdvancedDAL`文件夹，然后拖动 GridView 从工具箱拖到设计器。</span><span class="sxs-lookup"><span data-stu-id="418fb-252">Start by opening the `ComputedColumns.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="418fb-253">设置 GridView s`ID`属性设置为`Suppliers`并从其智能标记，请将其绑定到名为新 ObjectDataSource `SuppliersDataSource`。</span><span class="sxs-lookup"><span data-stu-id="418fb-253">Set the GridView s `ID` property to `Suppliers` and, from its smart tag, bind it to a new ObjectDataSource named `SuppliersDataSource`.</span></span> <span data-ttu-id="418fb-254">配置要使用 ObjectDataSource`SuppliersBLLWithSprocs`类添加了备份在步骤 6 中，并单击下一步。</span><span class="sxs-lookup"><span data-stu-id="418fb-254">Configure the ObjectDataSource to use the `SuppliersBLLWithSprocs` class we added back in Step 6 and click Next.</span></span>


<span data-ttu-id="418fb-255">[![配置对象数据源以使用 SuppliersBLLWithSprocs 类](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-255">[![Configure the ObjectDataSource to Use the SuppliersBLLWithSprocs Class](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span></span>

<span data-ttu-id="418fb-256">**图 11**:配置为使用 ObjectDataSource`SuppliersBLLWithSprocs`类 ([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image33.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-256">**Figure 11**: Configure the ObjectDataSource to Use the `SuppliersBLLWithSprocs` Class ([Click to view full-size image](working-with-computed-columns-vb/_static/image33.png))</span></span>


<span data-ttu-id="418fb-257">只有两种方法中定义`SuppliersBLLWithSprocs`类：`GetSuppliers`和`UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="418fb-257">There are only two methods defined in the `SuppliersBLLWithSprocs` class: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="418fb-258">请确保这两种方法在 SELECT 中指定和分别更新选项卡，并单击完成以完成 ObjectDataSource 的配置。</span><span class="sxs-lookup"><span data-stu-id="418fb-258">Ensure that these two methods are specified in the SELECT and UPDATE tabs, respectively, and click Finish to complete the configuration of the ObjectDataSource.</span></span>

<span data-ttu-id="418fb-259">在数据源配置向导完成后，Visual Studio 将为每个返回的数据字段添加 BoundField。</span><span class="sxs-lookup"><span data-stu-id="418fb-259">Upon completion of the Data Source Configuration wizard, Visual Studio will add a BoundField for each of the data fields returned.</span></span> <span data-ttu-id="418fb-260">删除`SupplierID`BoundField 和更改`HeaderText`的属性`CompanyName`， `ContactName`， `ContactTitle`，并`FullContactName`BoundFields 到公司、 联系人姓名、 标题和完整的联系人名称，分别。</span><span class="sxs-lookup"><span data-stu-id="418fb-260">Remove the `SupplierID` BoundField and change the `HeaderText` properties of the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` BoundFields to Company, Contact Name, Title, and Full Contact Name, respectively.</span></span> <span data-ttu-id="418fb-261">从智能标记中，选中启用编辑复选框可启用 GridView s 内置编辑功能。</span><span class="sxs-lookup"><span data-stu-id="418fb-261">From the smart tag, check the Enable Editing checkbox to turn on the GridView s built-in editing capabilities.</span></span>

<span data-ttu-id="418fb-262">除了将 BoundFields 添加到 GridView，完成数据源向导还会导致 Visual Studio 设置 ObjectDataSource s`OldValuesParameterFormatString`属性设置为原始\_{0}。</span><span class="sxs-lookup"><span data-stu-id="418fb-262">In addition to adding BoundFields to the GridView, completion of the Data Source Wizard also causes Visual Studio to set the ObjectDataSource s `OldValuesParameterFormatString` property to original\_{0}.</span></span> <span data-ttu-id="418fb-263">还原此设置改回为其默认值， {0} 。</span><span class="sxs-lookup"><span data-stu-id="418fb-263">Revert this setting back to its default value, {0} .</span></span>

<span data-ttu-id="418fb-264">以后对 GridView 和 ObjectDataSource 中进行这些编辑，其声明性标记看起来应类似于下面：</span><span class="sxs-lookup"><span data-stu-id="418fb-264">After making these edits to the GridView and ObjectDataSource, their declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](working-with-computed-columns-vb/samples/sample7.aspx)]

<span data-ttu-id="418fb-265">接下来，请访问此页上的通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="418fb-265">Next, visit this page through a browser.</span></span> <span data-ttu-id="418fb-266">如图 12 所示，在一个网格，其中包括列出每个供应商`FullContactName`列中，其值是只需其他三个列的串联，格式为`ContactName`(`ContactTitle`， `CompanyName`)。</span><span class="sxs-lookup"><span data-stu-id="418fb-266">As Figure 12 shows, each supplier is listed in a grid that includes the `FullContactName` column, whose value is simply the concatenation of the other three columns formatted as `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>


<span data-ttu-id="418fb-267">[![在网格中列出每个供应商](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-267">[![Each Supplier is Listed in the Grid](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span></span>

<span data-ttu-id="418fb-268">**图 12**:在网格中列出每个供应商 ([单击此项可查看原尺寸图像](working-with-computed-columns-vb/_static/image36.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-268">**Figure 12**: Each Supplier is Listed in the Grid ([Click to view full-size image](working-with-computed-columns-vb/_static/image36.png))</span></span>


<span data-ttu-id="418fb-269">单击编辑按钮，为特定供应商导致回发和中呈现该行其编辑界面 （见图 13）。</span><span class="sxs-lookup"><span data-stu-id="418fb-269">Clicking the Edit button for a particular supplier causes a postback and has that row rendered in its editing interface (see Figure 13).</span></span> <span data-ttu-id="418fb-270">在其默认的编辑界面中呈现的前三个列-TextBox 控件`Text`属性设置为数据字段的值。</span><span class="sxs-lookup"><span data-stu-id="418fb-270">The first three columns render in their default editing interface - a TextBox control whose `Text` property is set to the value of the data field.</span></span> <span data-ttu-id="418fb-271">`FullContactName`列，但是，仍然是以文本形式。</span><span class="sxs-lookup"><span data-stu-id="418fb-271">The `FullContactName` column, however, remains as text.</span></span> <span data-ttu-id="418fb-272">当 BoundFields 已添加到在数据源配置向导，完成 GridView `FullContactName` BoundField s`ReadOnly`属性设置为`True`因为相应`FullContactName`中的列`SuppliersDataTable`具有其`ReadOnly`属性设置为`True`。</span><span class="sxs-lookup"><span data-stu-id="418fb-272">When the BoundFields were added to the GridView at the completion of the Data Source Configuration wizard, the `FullContactName` BoundField s `ReadOnly` property was set to `True` because the corresponding `FullContactName` column in the `SuppliersDataTable` has its `ReadOnly` property set to `True`.</span></span> <span data-ttu-id="418fb-273">步骤 4 中所述`FullContactName`s`ReadOnly`属性设置为`True`因为 TableAdapter 检测到的列是计算所得的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-273">As noted in Step 4, the `FullContactName` s `ReadOnly` property was set to `True` because the TableAdapter detected that the column was a computed column.</span></span>


<span data-ttu-id="418fb-274">[![FullContactName 列是不可编辑](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="418fb-274">[![The FullContactName Column is Not Editable](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span></span>

<span data-ttu-id="418fb-275">**图 13**:`FullContactName`列是不可编辑 ([单击以查看实际尺寸的图像](working-with-computed-columns-vb/_static/image39.png))</span><span class="sxs-lookup"><span data-stu-id="418fb-275">**Figure 13**: The `FullContactName` Column is Not Editable ([Click to view full-size image](working-with-computed-columns-vb/_static/image39.png))</span></span>


<span data-ttu-id="418fb-276">继续更新一个或多个可编辑列的值，单击更新。</span><span class="sxs-lookup"><span data-stu-id="418fb-276">Go ahead and update the value of one or more of the editable columns and click Update.</span></span> <span data-ttu-id="418fb-277">请注意如何`FullContactName`的值自动更新以反映更改。</span><span class="sxs-lookup"><span data-stu-id="418fb-277">Note how the `FullContactName` s value is automatically updated to reflect the change.</span></span>

> [!NOTE]
> <span data-ttu-id="418fb-278">GridView 目前使用 BoundFields 对于可编辑字段，从而导致其默认的编辑界面。</span><span class="sxs-lookup"><span data-stu-id="418fb-278">The GridView currently uses BoundFields for the editable fields, resulting in the default editing interface.</span></span> <span data-ttu-id="418fb-279">由于`CompanyName`字段是必需的它应转换为 TemplateField 包括一个 RequiredFieldValidator。</span><span class="sxs-lookup"><span data-stu-id="418fb-279">Since the `CompanyName` field is required, it should be converted into a TemplateField that includes a RequiredFieldValidator.</span></span> <span data-ttu-id="418fb-280">我将此作为练习留给感读取器。</span><span class="sxs-lookup"><span data-stu-id="418fb-280">I leave this as an exercise for the interested reader.</span></span> <span data-ttu-id="418fb-281">请查阅[向编辑和插入界面添加验证控件](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)教程，了解将 BoundField 转换为 TemplateField 和添加验证控件的分步说明。</span><span class="sxs-lookup"><span data-stu-id="418fb-281">Consult the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) tutorial for step-by-step instructions on converting a BoundField to a TemplateField and adding validation controls.</span></span>


## <a name="summary"></a><span data-ttu-id="418fb-282">总结</span><span class="sxs-lookup"><span data-stu-id="418fb-282">Summary</span></span>

<span data-ttu-id="418fb-283">在定义表的架构时，Microsoft SQL Server 允许包含的计算列。</span><span class="sxs-lookup"><span data-stu-id="418fb-283">When defining the schema for a table, Microsoft SQL Server allows the inclusion of computed columns.</span></span> <span data-ttu-id="418fb-284">下面是从通常引用同一条记录中的其他列的值的表达式计算其值的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-284">These are columns whose values are calculated from an expression that usually references the values from other columns in the same record.</span></span> <span data-ttu-id="418fb-285">值的计算的列基于表达式，它们是只读的、 之后不能分配中的值`INSERT`或`UPDATE`语句。</span><span class="sxs-lookup"><span data-stu-id="418fb-285">Since the values for computed columns are based on an expression, they are read-only and cannot be assigned a value in an `INSERT` or `UPDATE` statement.</span></span> <span data-ttu-id="418fb-286">将尝试自动生成对应的 TableAdapter 的主查询中使用计算的列时，这会带来的挑战`INSERT`， `UPDATE`，和`DELETE`语句。</span><span class="sxs-lookup"><span data-stu-id="418fb-286">This introduces challenges when using a computed column in the main query of a TableAdapter that tries to automatically generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span>

<span data-ttu-id="418fb-287">在本教程中我们讨论了绕过由计算列所带来的挑战的方法。</span><span class="sxs-lookup"><span data-stu-id="418fb-287">In this tutorial we discussed techniques for circumventing the challenges posed by computed columns.</span></span> <span data-ttu-id="418fb-288">具体而言，我们使用存储的过程中我们 TableAdapter 克服中使用的临时 SQL 语句的 Tableadapter 的固有受到攻击。</span><span class="sxs-lookup"><span data-stu-id="418fb-288">In particular, we used stored procedures in our TableAdapter to overcome the brittleness inherent in TableAdapters that use ad-hoc SQL statements.</span></span> <span data-ttu-id="418fb-289">使用 TableAdapter 向导创建新存储过程时，很重要，我们具有最初省略任何计算的列，因为它们的存在会阻止数据修改存储过程正在生成的主查询。</span><span class="sxs-lookup"><span data-stu-id="418fb-289">When having the TableAdapter wizard create new stored procedures, it is important that we have the main query initially omit any computed columns because their presence prevents the data modification stored procedures from being generated.</span></span> <span data-ttu-id="418fb-290">最初配置 TableAdapter 后，其`SelectCommand`可以进行重组存储的过程，以包含任何计算的列。</span><span class="sxs-lookup"><span data-stu-id="418fb-290">After the TableAdapter has been initially configured, its `SelectCommand` stored procedure can be retooled to include any computed columns.</span></span>

<span data-ttu-id="418fb-291">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="418fb-291">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="418fb-292">关于作者</span><span class="sxs-lookup"><span data-stu-id="418fb-292">About the Author</span></span>

<span data-ttu-id="418fb-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="418fb-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="418fb-294">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="418fb-294">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="418fb-295">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="418fb-295">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="418fb-296">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="418fb-296">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="418fb-297">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="418fb-297">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="418fb-298">特别感谢</span><span class="sxs-lookup"><span data-stu-id="418fb-298">Special Thanks To</span></span>

<span data-ttu-id="418fb-299">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="418fb-299">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="418fb-300">本教程中的潜在顾客审阅者是 Hilton Geisenow 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="418fb-300">Lead reviewers for this tutorial were Hilton Geisenow and Teresa Murphy.</span></span> <span data-ttu-id="418fb-301">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="418fb-301">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="418fb-302">如果是这样，给我在行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="418fb-302">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="418fb-303">[上一页](adding-additional-datatable-columns-vb.md)
> [下一页](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span><span class="sxs-lookup"><span data-stu-id="418fb-303">[Previous](adding-additional-datatable-columns-vb.md)
[Next](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span></span>

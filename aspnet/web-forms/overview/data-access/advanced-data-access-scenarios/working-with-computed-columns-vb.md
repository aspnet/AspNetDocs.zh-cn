---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
title: 使用计算列（VB） |Microsoft Docs
author: rick-anderson
description: 创建数据库表时，Microsoft SQL Server 允许您定义计算列，该列的值是从通常 referen 的表达式计算得出的。
ms.author: riande
ms.date: 08/03/2007
ms.assetid: 5811b8ff-ed56-40fc-9397-6b69ae09a8f6
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/working-with-computed-columns-vb
msc.type: authoredcontent
ms.openlocfilehash: e425d7363c2cdea6efb0ba51f3fc2b6a5330bf2a
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74602827"
---
# <a name="working-with-computed-columns-vb"></a><span data-ttu-id="767ae-103">处理计算列 (VB)</span><span class="sxs-lookup"><span data-stu-id="767ae-103">Working with Computed Columns (VB)</span></span>

<span data-ttu-id="767ae-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="767ae-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="767ae-105">[下载代码](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip)或[下载 PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="767ae-105">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_71_VB.zip) or [Download PDF](working-with-computed-columns-vb/_static/datatutorial71vb1.pdf)</span></span>

> <span data-ttu-id="767ae-106">创建数据库表时，Microsoft SQL Server 允许您定义计算列，该列的值是由通常引用同一数据库记录中其他值的表达式计算得出的。</span><span class="sxs-lookup"><span data-stu-id="767ae-106">When creating a database table, Microsoft SQL Server allows you to define a computed column whose value is calculated from an expression that usually references other values in the same database record.</span></span> <span data-ttu-id="767ae-107">此类值在数据库中是只读的，在使用 Tableadapter 时需要特别注意。</span><span class="sxs-lookup"><span data-stu-id="767ae-107">Such values are read-only at the database, which requires special considerations when working with TableAdapters.</span></span> <span data-ttu-id="767ae-108">在本教程中，我们将了解如何满足计算列所带来的挑战。</span><span class="sxs-lookup"><span data-stu-id="767ae-108">In this tutorial we learn how to meet the challenges posed by computed columns.</span></span>

## <a name="introduction"></a><span data-ttu-id="767ae-109">简介</span><span class="sxs-lookup"><span data-stu-id="767ae-109">Introduction</span></span>

<span data-ttu-id="767ae-110">Microsoft SQL Server 允许使用 *[计算列](https://msdn.microsoft.com/library/ms191250.aspx)* ，这些列的值是从通常引用同一表中其他列的值的表达式计算得出的。</span><span class="sxs-lookup"><span data-stu-id="767ae-110">Microsoft SQL Server allows for *[computed columns](https://msdn.microsoft.com/library/ms191250.aspx)*, which are columns whose values are calculated from an expression that usually references the values from other columns in the same table.</span></span> <span data-ttu-id="767ae-111">例如，时间跟踪数据模型可能有一个名为 `ServiceLog` 的表，其中的列包括 `ServicePerformed`、`EmployeeID`、`Rate`和 `Duration`等。</span><span class="sxs-lookup"><span data-stu-id="767ae-111">As an example, a time tracking data model might have a table named `ServiceLog` with columns including `ServicePerformed`, `EmployeeID`, `Rate`, and `Duration`, among others.</span></span> <span data-ttu-id="767ae-112">尽管可以通过网页或其他编程界面来计算每个服务项目的应付金额（速率乘以持续时间），但在报告此信息的名为 `AmountDue` `ServiceLog` 表中加入列可能会很方便。</span><span class="sxs-lookup"><span data-stu-id="767ae-112">While the amount due per service item (being the rate multiplied by the duration) could be calculated through a web page or other programmatic interface, it might be handy to include a column in the `ServiceLog` table named `AmountDue` that reported this information.</span></span> <span data-ttu-id="767ae-113">此列可以作为普通列创建，但需要在 `Rate` 或 `Duration` 列值更改时进行更新。</span><span class="sxs-lookup"><span data-stu-id="767ae-113">This column could be created as a normal column, but it would need to be updated anytime the `Rate` or `Duration` column values changed.</span></span> <span data-ttu-id="767ae-114">更好的方法是使用表达式 `Rate * Duration`使 `AmountDue` 列成为计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-114">A better approach would be to make the `AmountDue` column a computed column using the expression `Rate * Duration`.</span></span> <span data-ttu-id="767ae-115">这样做会导致 SQL Server 在查询中引用时自动计算 `AmountDue` 列值。</span><span class="sxs-lookup"><span data-stu-id="767ae-115">Doing so would cause SQL Server to automatically calculate the `AmountDue` column value whenever it was referenced in a query.</span></span>

<span data-ttu-id="767ae-116">由于计算列的值是由表达式确定的，因此，此类列是只读的，因此不能在 `INSERT` 或 `UPDATE` 语句中为它们分配值。</span><span class="sxs-lookup"><span data-stu-id="767ae-116">Since a computed column s value is determined by an expression, such columns are read-only and therefore cannot have values assigned to them in `INSERT` or `UPDATE` statements.</span></span> <span data-ttu-id="767ae-117">但是，当计算列是使用即席 SQL 语句的 TableAdapter 的主要查询的一部分时，它们将自动包含在自动生成的 `INSERT` 和 `UPDATE` 语句中。</span><span class="sxs-lookup"><span data-stu-id="767ae-117">However, when computed columns are part of the main query for a TableAdapter that uses ad-hoc SQL statements, they are automatically included in the auto-generated `INSERT` and `UPDATE` statements.</span></span> <span data-ttu-id="767ae-118">因此，必须更新 TableAdapter s `INSERT` 和 `UPDATE` 查询以及 `InsertCommand` 和 `UpdateCommand` 属性才能删除对所有计算列的引用。</span><span class="sxs-lookup"><span data-stu-id="767ae-118">Consequently, the TableAdapter s `INSERT` and `UPDATE` queries and `InsertCommand` and `UpdateCommand` properties must be updated to remove references to any computed columns.</span></span>

<span data-ttu-id="767ae-119">将计算列与使用即席 SQL 语句的 TableAdapter 结合使用的一个挑战是，在完成 TableAdapter 配置向导时，将自动重新生成 TableAdapter s `INSERT` 和 `UPDATE` 查询。</span><span class="sxs-lookup"><span data-stu-id="767ae-119">One challenge of using computed columns with a TableAdapter that uses ad-hoc SQL statements is that the TableAdapter s `INSERT` and `UPDATE` queries are automatically regenerated any time the TableAdapter Configuration wizard is completed.</span></span> <span data-ttu-id="767ae-120">因此，如果重新运行该向导，则从 `UPDATE` `INSERT` 中手动删除的计算列将重新出现。</span><span class="sxs-lookup"><span data-stu-id="767ae-120">Therefore, the computed columns manually removed from the `INSERT` and `UPDATE` queries will reappear if the wizard is re-run.</span></span> <span data-ttu-id="767ae-121">尽管使用存储过程的 Tableadapter 不受此易受攻击的影响，但它们确实有其自己的不相关，我们将在步骤3中进行解决。</span><span class="sxs-lookup"><span data-stu-id="767ae-121">Although TableAdapters that use stored procedures don t suffer from this brittleness, they do have their own quirks that we will address in Step 3.</span></span>

<span data-ttu-id="767ae-122">在本教程中，我们会将计算列添加到 Northwind 数据库中的 `Suppliers` 表，然后创建相应的 TableAdapter 以便使用此表及其计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-122">In this tutorial we will add a computed column to the `Suppliers` table in the Northwind database and then create a corresponding TableAdapter to work with this table and its computed column.</span></span> <span data-ttu-id="767ae-123">我们会让 TableAdapter 使用存储过程而不是即席 SQL 语句，以便在使用 TableAdapter 配置向导时，自定义设置不会丢失。</span><span class="sxs-lookup"><span data-stu-id="767ae-123">We will have our TableAdapter use stored procedures instead of ad-hoc SQL statements so that our customizations aren't lost when the TableAdapter Configuration wizard is used.</span></span>

<span data-ttu-id="767ae-124">让我们开始吧！</span><span class="sxs-lookup"><span data-stu-id="767ae-124">Let s get started!</span></span>

## <a name="step-1-adding-a-computed-column-to-thesupplierstable"></a><span data-ttu-id="767ae-125">步骤1：将计算列添加到`Suppliers`表</span><span class="sxs-lookup"><span data-stu-id="767ae-125">Step 1: Adding a Computed Column to the`Suppliers`Table</span></span>

<span data-ttu-id="767ae-126">Northwind 数据库没有任何计算列，因此我们需要添加一个。</span><span class="sxs-lookup"><span data-stu-id="767ae-126">The Northwind database does not have any computed columns so we will need to add one ourselves.</span></span> <span data-ttu-id="767ae-127">在本教程中，我们将计算列添加到名为 `FullContactName` 的 `Suppliers` 表中，该表返回按以下格式使用的联系人姓名、职务和公司： `ContactName` （`ContactTitle`，`CompanyName`）。</span><span class="sxs-lookup"><span data-stu-id="767ae-127">For this tutorial let s add a computed column to the `Suppliers` table called `FullContactName` that returns the contact s name, title, and the company they work for in the following format: `ContactName` (`ContactTitle`, `CompanyName`).</span></span> <span data-ttu-id="767ae-128">显示与供应商有关的信息时，可以在报表中使用此计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-128">This computed column might be used in reports when displaying information about suppliers.</span></span>

<span data-ttu-id="767ae-129">首先，在服务器资源管理器中右键单击 `Suppliers` 表，然后从上下文菜单中选择 "打开表定义"，以打开 `Suppliers` 表定义。</span><span class="sxs-lookup"><span data-stu-id="767ae-129">Start by opening the `Suppliers` table definition by right-clicking on the `Suppliers` table in the Server Explorer and choosing Open Table Definition from the context-menu.</span></span> <span data-ttu-id="767ae-130">这将显示表的列及其属性（如数据类型），无论它们是否允许 `NULL` 等。</span><span class="sxs-lookup"><span data-stu-id="767ae-130">This will display the columns of the table and their properties, such as their data type, whether they allow `NULL` s, and so forth.</span></span> <span data-ttu-id="767ae-131">若要添加计算列，请首先在列名称中键入表定义。</span><span class="sxs-lookup"><span data-stu-id="767ae-131">To add a computed column, start by typing in the name of the column into the table definition.</span></span> <span data-ttu-id="767ae-132">接下来，在属性窗口列的 "计算列规范" 部分下的 "（公式）" 文本框中输入其表达式（请参阅图1）。</span><span class="sxs-lookup"><span data-stu-id="767ae-132">Next, enter its expression into the (Formula) textbox under the Computed Column Specification section in the Column Properties window (see Figure 1).</span></span> <span data-ttu-id="767ae-133">将计算列 `FullContactName` 命名，并使用以下表达式：</span><span class="sxs-lookup"><span data-stu-id="767ae-133">Name the computed column `FullContactName` and use the following expression:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample1.sql)]

<span data-ttu-id="767ae-134">请注意，可以使用 `+` 运算符将字符串连接到 SQL 中。</span><span class="sxs-lookup"><span data-stu-id="767ae-134">Note that strings can be concatenated in SQL using the `+` operator.</span></span> <span data-ttu-id="767ae-135">`CASE` 语句的使用方式类似于传统编程语言中的条件。</span><span class="sxs-lookup"><span data-stu-id="767ae-135">The `CASE` statement can be used like a conditional in a traditional programming language.</span></span> <span data-ttu-id="767ae-136">在上面的表达式中，`CASE` 语句可以读取为：如果 `ContactTitle` 不 `NULL`，则输出用逗号连接的 `ContactTitle` 值，否则不发出任何内容。</span><span class="sxs-lookup"><span data-stu-id="767ae-136">In the above expression the `CASE` statement can be read as: If `ContactTitle` is not `NULL` then output the `ContactTitle` value concatenated with a comma, otherwise emit nothing.</span></span> <span data-ttu-id="767ae-137">有关 `CASE` 语句有用性的详细信息，请参阅[SQL `CASE` 语句的强大功能](http://www.4guysfromrolla.com/webtech/102704-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="767ae-137">For more on the usefulness of the `CASE` statement, see [The Power of SQL `CASE` Statements](http://www.4guysfromrolla.com/webtech/102704-1.shtml).</span></span>

> [!NOTE]
> <span data-ttu-id="767ae-138">可以使用其他 `ISNULL(ContactTitle, '')`，而不是使用 `CASE` 语句。</span><span class="sxs-lookup"><span data-stu-id="767ae-138">Instead of using a `CASE` statement here, we could have alternatively used `ISNULL(ContactTitle, '')`.</span></span> <span data-ttu-id="767ae-139">如果 CheckExpression 为非 NULL，则返回 ，否则返回*replacementValue*。 [`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx)</span><span class="sxs-lookup"><span data-stu-id="767ae-139">[`ISNULL(checkExpression, replacementValue)`](https://msdn.microsoft.com/library/ms184325.aspx) returns *checkExpression* if it is non-NULL, otherwise it returns *replacementValue*.</span></span> <span data-ttu-id="767ae-140">尽管 `ISNULL` 或 `CASE` 在此实例中都有效，但仍有更复杂的方案，`ISNULL`不能匹配 `CASE` 语句的灵活性。</span><span class="sxs-lookup"><span data-stu-id="767ae-140">While either `ISNULL` or `CASE` will work in this instance, there are more intricate scenarios where the flexibility of the `CASE` statement cannot be matched by `ISNULL`.</span></span>

<span data-ttu-id="767ae-141">添加此计算列后，你的屏幕应类似于图1中的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="767ae-141">After adding this computed column your screen should look like the screen shot in Figure 1.</span></span>

<span data-ttu-id="767ae-142">[![将名为 FullContactName 的计算列添加到供应商表](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-142">[![Add a Computed Column Named FullContactName to the Suppliers Table](working-with-computed-columns-vb/_static/image2.png)](working-with-computed-columns-vb/_static/image1.png)</span></span>

<span data-ttu-id="767ae-143">**图 1**：将名为 `FullContactName` 的计算列添加到 `Suppliers` 表（[单击查看完全大小的图像](working-with-computed-columns-vb/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-143">**Figure 1**: Add a Computed Column Named `FullContactName` to the `Suppliers` Table ([Click to view full-size image](working-with-computed-columns-vb/_static/image3.png))</span></span>

<span data-ttu-id="767ae-144">命名计算列并输入其表达式后，通过单击工具栏中的 "保存" 图标，通过按 Ctrl + S 或通过转到 "文件" 菜单并选择 "保存 `Suppliers`来保存对表所做的更改。</span><span class="sxs-lookup"><span data-stu-id="767ae-144">After naming the computed column and entering its expression, save the changes to the table by clicking the Save icon in the toolbar, by hitting Ctrl+S, or by going to the File menu and choosing Save `Suppliers`.</span></span>

<span data-ttu-id="767ae-145">保存表应刷新服务器资源管理器，包括 `Suppliers` 表 s 列列表中只添加的列。</span><span class="sxs-lookup"><span data-stu-id="767ae-145">Saving the table should refresh the Server Explorer, including the just-added column in the `Suppliers` table s column list.</span></span> <span data-ttu-id="767ae-146">而且，输入到 "（公式）" 文本框中的表达式将自动调整为一个等效的表达式，该表达式包含不必要的空格，将列名称括在方括号（`[]`）中，并包含括号来更明确地显示运算顺序：</span><span class="sxs-lookup"><span data-stu-id="767ae-146">Furthermore, the expression entered into the (Formula) textbox will automatically adjust to an equivalent expression that strips unnecessary whitespace, surrounds column names with brackets (`[]`), and includes parentheses to more explicitly show the order of operations:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample2.sql)]

<span data-ttu-id="767ae-147">有关 Microsoft SQL Server 中计算列的详细信息，请参阅[技术文档](https://msdn.microsoft.com/library/ms191250.aspx)。</span><span class="sxs-lookup"><span data-stu-id="767ae-147">For more information on computed columns in Microsoft SQL Server, refer to the [technical documentation](https://msdn.microsoft.com/library/ms191250.aspx).</span></span> <span data-ttu-id="767ae-148">另外，请参阅[如何：指定计算列](https://msdn.microsoft.com/library/ms188300.aspx)以获取创建计算列的分步演练。</span><span class="sxs-lookup"><span data-stu-id="767ae-148">Also check out the [How to: Specify Computed Columns](https://msdn.microsoft.com/library/ms188300.aspx) for a step-by-step walkthrough of creating computed columns.</span></span>

> [!NOTE]
> <span data-ttu-id="767ae-149">默认情况下，计算列不会以物理方式存储在表中，而是在每次在查询中引用它们时重新计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-149">By default, computed columns are not physically stored in the table but are instead recalculated each time they are referenced in a query.</span></span> <span data-ttu-id="767ae-150">不过，通过选中 "持久保存" 复选框，您可以指示 SQL Server 将计算列实际存储在表中。</span><span class="sxs-lookup"><span data-stu-id="767ae-150">By checking the Is Persisted checkbox, however, you can instruct SQL Server to physically store the computed column in the table.</span></span> <span data-ttu-id="767ae-151">这样做允许在计算列上创建索引，这可以提高在其 `WHERE` 子句中使用计算列值的查询的性能。</span><span class="sxs-lookup"><span data-stu-id="767ae-151">Doing so allows an index to be created on the computed column, which can improve the performance of queries that use the computed column value in their `WHERE` clauses.</span></span> <span data-ttu-id="767ae-152">有关详细信息，请参阅为[计算列创建索引](https://msdn.microsoft.com/library/ms189292.aspx)。</span><span class="sxs-lookup"><span data-stu-id="767ae-152">See [Creating Indexes on Computed Columns](https://msdn.microsoft.com/library/ms189292.aspx) for more information.</span></span>

## <a name="step-2-viewing-the-computed-column-s-values"></a><span data-ttu-id="767ae-153">步骤2：查看计算列的值</span><span class="sxs-lookup"><span data-stu-id="767ae-153">Step 2: Viewing the Computed Column s Values</span></span>

<span data-ttu-id="767ae-154">开始在数据访问层上工作之前，让我们花点时间查看 `FullContactName` 值。</span><span class="sxs-lookup"><span data-stu-id="767ae-154">Before we start work on the Data Access Layer, let s take a minute to view the `FullContactName` values.</span></span> <span data-ttu-id="767ae-155">在服务器资源管理器中，右键单击 `Suppliers` 表名称，然后从上下文菜单中选择 "新建查询"。</span><span class="sxs-lookup"><span data-stu-id="767ae-155">From the Server Explorer, right-click on the `Suppliers` table name and choose New Query from the context-menu.</span></span> <span data-ttu-id="767ae-156">这会打开一个查询窗口，提示我们选择要在查询中包含的表。</span><span class="sxs-lookup"><span data-stu-id="767ae-156">This will bring up a Query window that prompts us to choose what tables to include in the query.</span></span> <span data-ttu-id="767ae-157">添加 `Suppliers` 表，然后单击 "关闭"。</span><span class="sxs-lookup"><span data-stu-id="767ae-157">Add the `Suppliers` table and click Close.</span></span> <span data-ttu-id="767ae-158">接下来，检查供应商表中的 `CompanyName`、`ContactName`、`ContactTitle`和 `FullContactName` 列。</span><span class="sxs-lookup"><span data-stu-id="767ae-158">Next, check the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` columns from the Suppliers table.</span></span> <span data-ttu-id="767ae-159">最后，单击工具栏中的红色感叹号图标来执行查询并查看结果。</span><span class="sxs-lookup"><span data-stu-id="767ae-159">Finally, click the red exclamation point icon in the Toolbar to execute the query and view the results.</span></span>

<span data-ttu-id="767ae-160">如图2所示，结果包括 `FullContactName`，其中使用格式 `ContactName` （`ContactTitle`、`CompanyName`）列出 `CompanyName`、`ContactName`和 `ContactTitle` 列。</span><span class="sxs-lookup"><span data-stu-id="767ae-160">As Figure 2 shows, the results include `FullContactName`, which lists the `CompanyName`, `ContactName`, and `ContactTitle` columns using the format `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>

<span data-ttu-id="767ae-161">[![FullContactName 使用格式名称（ContactTitle，公司名称）](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-161">[![The FullContactName Uses the Format ContactName (ContactTitle, CompanyName)](working-with-computed-columns-vb/_static/image5.png)](working-with-computed-columns-vb/_static/image4.png)</span></span>

<span data-ttu-id="767ae-162">**图 2**： `FullContactName` 使用格式 `ContactName` （`ContactTitle`，`CompanyName`）（[单击查看完全大小的图像](working-with-computed-columns-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-162">**Figure 2**: The `FullContactName` Uses the Format `ContactName` (`ContactTitle`, `CompanyName`) ([Click to view full-size image](working-with-computed-columns-vb/_static/image6.png))</span></span>

## <a name="step-3-adding-thesupplierstableadapterto-the-data-access-layer"></a><span data-ttu-id="767ae-163">步骤3：将`SuppliersTableAdapter`添加到数据访问层</span><span class="sxs-lookup"><span data-stu-id="767ae-163">Step 3: Adding the`SuppliersTableAdapter`to the Data Access Layer</span></span>

<span data-ttu-id="767ae-164">为了在应用程序中使用供应商信息，我们需要首先在 DAL 中创建一个 TableAdapter 和 DataTable。</span><span class="sxs-lookup"><span data-stu-id="767ae-164">In order to work with the supplier information in our application we need to first create a TableAdapter and DataTable in our DAL.</span></span> <span data-ttu-id="767ae-165">理想情况下，可以使用前面教程中所述的相同步骤来完成此操作。</span><span class="sxs-lookup"><span data-stu-id="767ae-165">Ideally, this would be accomplished using the same straightforward steps examined in earlier tutorials.</span></span> <span data-ttu-id="767ae-166">但是，使用计算列会引入几个 wrinkles，用于提供讨论。</span><span class="sxs-lookup"><span data-stu-id="767ae-166">However, working with computed columns introduces a few wrinkles that merit discussion.</span></span>

<span data-ttu-id="767ae-167">如果使用的是使用即席 SQL 语句的 TableAdapter，只需通过 TableAdapter 配置向导将计算列包含在 TableAdapter 主查询中。</span><span class="sxs-lookup"><span data-stu-id="767ae-167">If you are using a TableAdapter that uses ad-hoc SQL statements, you can simply include the computed column in the TableAdapter s main query via the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="767ae-168">但是，这将自动生成 `INSERT` 和包含计算列的 `UPDATE` 语句。</span><span class="sxs-lookup"><span data-stu-id="767ae-168">This, however, will auto-generate `INSERT` and `UPDATE` statements that include the computed column.</span></span> <span data-ttu-id="767ae-169">如果尝试执行其中一种方法，则会出现 `SqlException` 一条消息，其中包含列 ColumnName，因此无法修改列*ColumnName* ，因为它是计算列，或者是将引发 UNION 运算符的结果。</span><span class="sxs-lookup"><span data-stu-id="767ae-169">If you attempt to execute one of these methods, a `SqlException` with the message The column *ColumnName* cannot be modified because it is either a computed column or is the result of a UNION operator will be thrown.</span></span> <span data-ttu-id="767ae-170">尽管可以通过 TableAdapter s `InsertCommand` 和 `UpdateCommand` 属性手动调整 `INSERT` 和 `UPDATE` 语句，但每当重新运行 TableAdapter 配置向导时，这些自定义项都将丢失。</span><span class="sxs-lookup"><span data-stu-id="767ae-170">While the `INSERT` and `UPDATE` statement can be manually adjusted through the TableAdapter s `InsertCommand` and `UpdateCommand` properties, these customizations will be lost whenever the TableAdapter Configuration wizard is re-run.</span></span>

<span data-ttu-id="767ae-171">由于使用即席 SQL 语句的 Tableadapter 的易受攻击，因此建议在使用计算列时使用存储过程。</span><span class="sxs-lookup"><span data-stu-id="767ae-171">Due to the brittleness of TableAdapters that use ad-hoc SQL statements, it is recommended that we use stored procedures when working with computed columns.</span></span> <span data-ttu-id="767ae-172">如果使用的是现有存储过程，只需按[使用类型化数据集的 tableadapter 教程的现有存储过程](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md)中所述配置 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="767ae-172">If you are using existing stored procedures, simply configure the TableAdapter as discussed in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-vb.md) tutorial.</span></span> <span data-ttu-id="767ae-173">但是，如果您具有使用 TableAdapter 向导来创建存储过程，则必须最初从主查询中省略所有计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-173">If you have the TableAdapter wizard create the stored procedures for you, however, it is important to initially omit any computed columns from the main query.</span></span> <span data-ttu-id="767ae-174">如果在主查询中包含计算列，则 TableAdapter 配置向导将在完成时通知你无法创建相应的存储过程。</span><span class="sxs-lookup"><span data-stu-id="767ae-174">If you include a computed column in the main query, the TableAdapter Configuration wizard will inform you, upon completion, that it cannot create the corresponding stored procedures.</span></span> <span data-ttu-id="767ae-175">简而言之，我们需要使用计算的无列主查询来初始配置 TableAdapter，然后手动更新相应的存储过程，并 `SelectCommand`，以包括计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-175">In short, we need to initially configure the TableAdapter using a computed column-free main query and then manually update the corresponding stored procedure and the TableAdapter s `SelectCommand` to include the computed column.</span></span> <span data-ttu-id="767ae-176">此方法类似于 "[更新 TableAdapter 以使用](updating-the-tableadapter-to-use-joins-vb.md) *`JOIN`教程*" 中使用的方法。</span><span class="sxs-lookup"><span data-stu-id="767ae-176">This approach is similar to the one used in the [Updating the TableAdapter to Use](updating-the-tableadapter-to-use-joins-vb.md)`JOIN`*s* tutorial.</span></span>

<span data-ttu-id="767ae-177">对于本教程，让我们添加一个新的 TableAdapter，并让它自动创建存储过程。</span><span class="sxs-lookup"><span data-stu-id="767ae-177">For this tutorial, let s add a new TableAdapter and have it automatically create the stored procedures for us.</span></span> <span data-ttu-id="767ae-178">因此，我们首先需要从主查询中省略 `FullContactName` 计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-178">Consequently, we will need to initially omit the `FullContactName` computed column from the main query.</span></span>

<span data-ttu-id="767ae-179">首先打开 `~/App_Code/DAL` 文件夹中的 `NorthwindWithSprocs` 数据集。</span><span class="sxs-lookup"><span data-stu-id="767ae-179">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="767ae-180">在设计器中单击右键，然后从上下文菜单中选择添加新的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="767ae-180">Right-click in the Designer and, from the context-menu, choose to add a new TableAdapter.</span></span> <span data-ttu-id="767ae-181">这将启动 TableAdapter 配置向导。</span><span class="sxs-lookup"><span data-stu-id="767ae-181">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="767ae-182">指定要查询数据的数据库（从 `Web.config``NORTHWNDConnectionString`），然后单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="767ae-182">Specify the database to query data from (`NORTHWNDConnectionString` from `Web.config`) and click Next.</span></span> <span data-ttu-id="767ae-183">由于尚未创建用于查询或修改 `Suppliers` 表的任何存储过程，因此请选择 "创建新存储过程" 选项，以便向导将为我们创建并单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="767ae-183">Since we have not yet created any stored procedures for querying or modifying the `Suppliers` table, select the Create new stored procedures option so that the wizard will create them for us and click Next.</span></span>

<span data-ttu-id="767ae-184">[![选择 "创建新存储过程" 选项](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-184">[![Choose the Create new stored procedures Option](working-with-computed-columns-vb/_static/image8.png)](working-with-computed-columns-vb/_static/image7.png)</span></span>

<span data-ttu-id="767ae-185">**图 3**：选择 "创建新存储过程" 选项（[单击以查看完全大小的映像](working-with-computed-columns-vb/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-185">**Figure 3**: Choose the Create new stored procedures Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image9.png))</span></span>

<span data-ttu-id="767ae-186">后续步骤会提示我们进行主查询。</span><span class="sxs-lookup"><span data-stu-id="767ae-186">The subsequent step prompts us for the main query.</span></span> <span data-ttu-id="767ae-187">输入以下查询，该查询将返回每个供应商的 `SupplierID`、`CompanyName`、`ContactName`和 `ContactTitle` 列。</span><span class="sxs-lookup"><span data-stu-id="767ae-187">Enter the following query, which returns the `SupplierID`, `CompanyName`, `ContactName`, and `ContactTitle` columns for each supplier.</span></span> <span data-ttu-id="767ae-188">请注意，此查询有意省略了计算列（`FullContactName`）;我们将更新相应的存储过程，以在步骤4中包括此列。</span><span class="sxs-lookup"><span data-stu-id="767ae-188">Note that this query purposefully omits the computed column (`FullContactName`); we will update the corresponding stored procedure to include this column in Step 4.</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample3.sql)]

<span data-ttu-id="767ae-189">在输入主查询并单击 "下一步" 后，向导将允许您命名将生成的四个存储过程。</span><span class="sxs-lookup"><span data-stu-id="767ae-189">After entering the main query and clicking Next, the wizard allows us to name the four stored procedures it will generate.</span></span> <span data-ttu-id="767ae-190">将这些存储过程命名 `Suppliers_Select`、`Suppliers_Insert`、`Suppliers_Update`和 `Suppliers_Delete`，如图4所示。</span><span class="sxs-lookup"><span data-stu-id="767ae-190">Name these stored procedures `Suppliers_Select`, `Suppliers_Insert`, `Suppliers_Update`, and `Suppliers_Delete`, as Figure 4 illustrates.</span></span>

<span data-ttu-id="767ae-191">[![自定义自动生成的存储过程的名称](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-191">[![Customize the Names of the Auto-Generated Stored Procedures](working-with-computed-columns-vb/_static/image11.png)](working-with-computed-columns-vb/_static/image10.png)</span></span>

<span data-ttu-id="767ae-192">**图 4**：自定义自动生成的存储过程的名称（[单击以查看完全大小的映像](working-with-computed-columns-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-192">**Figure 4**: Customize the Names of the Auto-Generated Stored Procedures ([Click to view full-size image](working-with-computed-columns-vb/_static/image12.png))</span></span>

<span data-ttu-id="767ae-193">下一个向导步骤允许我们命名 TableAdapter 方法，并指定访问和更新数据所用的模式。</span><span class="sxs-lookup"><span data-stu-id="767ae-193">The next wizard step allows us to name the TableAdapter s methods and specify the patterns used to access and update data.</span></span> <span data-ttu-id="767ae-194">选中所有三个复选框，但将 `GetData` 方法重命名为 `GetSuppliers`。</span><span class="sxs-lookup"><span data-stu-id="767ae-194">Leave all three checkboxes checked, but rename the `GetData` method to `GetSuppliers`.</span></span> <span data-ttu-id="767ae-195">单击“完成”按钮以完成向导。</span><span class="sxs-lookup"><span data-stu-id="767ae-195">Click Finish to complete the wizard.</span></span>

<span data-ttu-id="767ae-196">[![将 GetSuppliers 的方法重命名为 ""](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-196">[![Rename the GetData Method to GetSuppliers](working-with-computed-columns-vb/_static/image14.png)](working-with-computed-columns-vb/_static/image13.png)</span></span>

<span data-ttu-id="767ae-197">**图 5**：将 `GetData` 方法重命名为 `GetSuppliers` （[单击查看完全大小的图像](working-with-computed-columns-vb/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-197">**Figure 5**: Rename the `GetData` Method to `GetSuppliers` ([Click to view full-size image](working-with-computed-columns-vb/_static/image15.png))</span></span>

<span data-ttu-id="767ae-198">单击 "完成" 后，向导将创建四个存储过程，并将 TableAdapter 和相应的 DataTable 添加到类型化数据集。</span><span class="sxs-lookup"><span data-stu-id="767ae-198">Upon clicking Finish, the wizard will create the four stored procedures and add the TableAdapter and corresponding DataTable to the Typed DataSet.</span></span>

## <a name="step-4-including-the-computed-column-in-the-tableadapter-s-main-query"></a><span data-ttu-id="767ae-199">步骤4：在 TableAdapter s 主查询中包括计算列</span><span class="sxs-lookup"><span data-stu-id="767ae-199">Step 4: Including the Computed Column in the TableAdapter s Main Query</span></span>

<span data-ttu-id="767ae-200">现在，我们需要更新在步骤3中创建的 TableAdapter 和 DataTable，以包含 `FullContactName` 计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-200">We now need to update the TableAdapter and DataTable created in Step 3 to include the `FullContactName` computed column.</span></span> <span data-ttu-id="767ae-201">此操作包括两个步骤：</span><span class="sxs-lookup"><span data-stu-id="767ae-201">This involves two steps:</span></span>

1. <span data-ttu-id="767ae-202">更新 `Suppliers_Select` 存储过程以返回 `FullContactName` 计算列，并</span><span class="sxs-lookup"><span data-stu-id="767ae-202">Updating the `Suppliers_Select` stored procedure to return the `FullContactName` computed column, and</span></span>
2. <span data-ttu-id="767ae-203">更新 DataTable 以包含相应的 `FullContactName` 列。</span><span class="sxs-lookup"><span data-stu-id="767ae-203">Updating the DataTable to include a corresponding `FullContactName` column.</span></span>

<span data-ttu-id="767ae-204">首先导航到服务器资源管理器并向下钻取到 "存储过程" 文件夹。</span><span class="sxs-lookup"><span data-stu-id="767ae-204">Start by navigating to the Server Explorer and drilling down into the Stored Procedures folder.</span></span> <span data-ttu-id="767ae-205">打开 `Suppliers_Select` 存储过程并更新 `SELECT` 查询，使之包含 `FullContactName` 计算列：</span><span class="sxs-lookup"><span data-stu-id="767ae-205">Open the `Suppliers_Select` stored procedure and update the `SELECT` query to include the `FullContactName` computed column:</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample4.sql)]

<span data-ttu-id="767ae-206">通过单击工具栏中的 "保存" 图标，通过按 Ctrl + S 或从 "文件" 菜单中选择 "保存 `Suppliers_Select`" 选项，保存对存储过程所做的更改。</span><span class="sxs-lookup"><span data-stu-id="767ae-206">Save the changes to the stored procedure by clicking the Save icon in the Toolbar, by hitting Ctrl+S, or by choosing the Save `Suppliers_Select` option from the File menu.</span></span>

<span data-ttu-id="767ae-207">接下来，返回到 "数据集设计器"，右键单击 "`SuppliersTableAdapter`"，然后从上下文菜单中选择 "配置"。</span><span class="sxs-lookup"><span data-stu-id="767ae-207">Next, return to the DataSet Designer, right-click on the `SuppliersTableAdapter`, and choose Configure from the context-menu.</span></span> <span data-ttu-id="767ae-208">请注意，`Suppliers_Select` 列现在包含其数据列集合中的 `FullContactName` 列。</span><span class="sxs-lookup"><span data-stu-id="767ae-208">Note that the `Suppliers_Select` column now includes the `FullContactName` column in its Data Columns collection.</span></span>

<span data-ttu-id="767ae-209">[![运行 TableAdapter s 配置向导以更新 DataTable 列](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-209">[![Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns](working-with-computed-columns-vb/_static/image17.png)](working-with-computed-columns-vb/_static/image16.png)</span></span>

<span data-ttu-id="767ae-210">**图 6**：运行 TableAdapter s 配置向导以更新 DataTable 的列（[单击以查看完全大小的映像](working-with-computed-columns-vb/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-210">**Figure 6**: Run the TableAdapter s Configuration Wizard to Update the DataTable s Columns ([Click to view full-size image](working-with-computed-columns-vb/_static/image18.png))</span></span>

<span data-ttu-id="767ae-211">单击“完成”按钮以完成向导。</span><span class="sxs-lookup"><span data-stu-id="767ae-211">Click Finish to complete the wizard.</span></span> <span data-ttu-id="767ae-212">这会将相应的列自动添加到 `SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="767ae-212">This will automatically add a corresponding column to the `SuppliersDataTable`.</span></span> <span data-ttu-id="767ae-213">TableAdapter 向导的智能足以检测 `FullContactName` 列是否为计算列，因此为只读。</span><span class="sxs-lookup"><span data-stu-id="767ae-213">The TableAdapter wizard is smart enough to detect that the `FullContactName` column is a computed column and therefore read-only.</span></span> <span data-ttu-id="767ae-214">因此，它将 `ReadOnly` 的列属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="767ae-214">Consequently, it sets the column s `ReadOnly` property to `true`.</span></span> <span data-ttu-id="767ae-215">若要验证这一点，请从 `SuppliersDataTable` 中选择列，然后访问属性窗口（请参阅图7）。</span><span class="sxs-lookup"><span data-stu-id="767ae-215">To verify this, select the column from the `SuppliersDataTable` and then go to the Properties window (see Figure 7).</span></span> <span data-ttu-id="767ae-216">请注意，也会相应地设置 `FullContactName` 列 s `DataType` 和 `MaxLength` 属性。</span><span class="sxs-lookup"><span data-stu-id="767ae-216">Note that the `FullContactName` column s `DataType` and `MaxLength` properties are also set accordingly.</span></span>

<span data-ttu-id="767ae-217">[![FullContactName 列被标记为只读](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-217">[![The FullContactName Column is Marked as Read-Only](working-with-computed-columns-vb/_static/image20.png)](working-with-computed-columns-vb/_static/image19.png)</span></span>

<span data-ttu-id="767ae-218">**图 7**： `FullContactName` 列被标记为只读（[单击以查看完全大小的图像](working-with-computed-columns-vb/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-218">**Figure 7**: The `FullContactName` Column is Marked as Read-Only ([Click to view full-size image](working-with-computed-columns-vb/_static/image21.png))</span></span>

## <a name="step-5-adding-agetsupplierbysupplieridmethod-to-the-tableadapter"></a><span data-ttu-id="767ae-219">步骤5：将`GetSupplierBySupplierID`方法添加到 TableAdapter</span><span class="sxs-lookup"><span data-stu-id="767ae-219">Step 5: Adding a`GetSupplierBySupplierID`Method to the TableAdapter</span></span>

<span data-ttu-id="767ae-220">对于本教程，我们将创建一个在可更新的网格中显示供应商的 ASP.NET 页面。</span><span class="sxs-lookup"><span data-stu-id="767ae-220">For this tutorial we will create an ASP.NET page that displays the suppliers in an updateable grid.</span></span> <span data-ttu-id="767ae-221">在过去的教程中，我们通过将 DAL 中的特定记录作为强类型 DataTable 检索来更新业务逻辑层中的单个记录，更新其属性，然后将更新后的 DataTable 发送回 DAL，以将更改传播到数据库。</span><span class="sxs-lookup"><span data-stu-id="767ae-221">In past tutorials we have updated a single record from the Business Logic Layer by retrieving that particular record from the DAL as a strongly-typed DataTable, updating its properties, and then sending the updated DataTable back to the DAL to propagate the changes to the database.</span></span> <span data-ttu-id="767ae-222">若要完成此第一步-从 DAL 检索要更新的记录，我们需要首先将 `GetSupplierBySupplierID(supplierID)` 方法添加到 DAL。</span><span class="sxs-lookup"><span data-stu-id="767ae-222">To accomplish this first step - retrieving the record being updated from the DAL - we need to first add a `GetSupplierBySupplierID(supplierID)` method to the DAL.</span></span>

<span data-ttu-id="767ae-223">右键单击数据集设计中的 `SuppliersTableAdapter`，然后从上下文菜单中选择 "添加查询" 选项。</span><span class="sxs-lookup"><span data-stu-id="767ae-223">Right-click on the `SuppliersTableAdapter` in the DataSet Design and choose the Add Query option from the context-menu.</span></span> <span data-ttu-id="767ae-224">如步骤3中所述，通过选择 "创建新存储过程" 选项，让向导为我们生成新的存储过程（有关此向导步骤的屏幕截图，请参阅图3）。</span><span class="sxs-lookup"><span data-stu-id="767ae-224">As we did in Step 3, let the wizard generate a new stored procedure for us by selecting the Create new stored procedure option (refer back to Figure 3 for a screenshot of this wizard step).</span></span> <span data-ttu-id="767ae-225">由于此方法将返回包含多个列的记录，因此，指示要使用的 SQL 查询是返回行的 SELECT，然后单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="767ae-225">Since this method will return a record with multiple columns, indicate that we want to use a SQL query that is a SELECT which returns rows and click Next.</span></span>

<span data-ttu-id="767ae-226">[![选择 "选择返回行" 选项](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-226">[![Choose the SELECT which returns rows Option](working-with-computed-columns-vb/_static/image23.png)](working-with-computed-columns-vb/_static/image22.png)</span></span>

<span data-ttu-id="767ae-227">**图 8**：选择 "选择返回行" 选项（[单击以查看完全大小的图像](working-with-computed-columns-vb/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-227">**Figure 8**: Choose the SELECT which returns rows Option ([Click to view full-size image](working-with-computed-columns-vb/_static/image24.png))</span></span>

<span data-ttu-id="767ae-228">后续步骤会提示我们输入用于此方法的查询。</span><span class="sxs-lookup"><span data-stu-id="767ae-228">The subsequent step prompts us for the query to use for this method.</span></span> <span data-ttu-id="767ae-229">输入以下，这将返回与主查询相同的数据字段，但对于特定的供应商。</span><span class="sxs-lookup"><span data-stu-id="767ae-229">Enter the following, which returns the same data fields as the main query but for a particular supplier.</span></span>

[!code-sql[Main](working-with-computed-columns-vb/samples/sample5.sql)]

<span data-ttu-id="767ae-230">下一个屏幕会要求我们命名将自动生成的存储过程。</span><span class="sxs-lookup"><span data-stu-id="767ae-230">The next screen asks us to name the stored procedure that will be auto-generated.</span></span> <span data-ttu-id="767ae-231">为此存储过程命名 `Suppliers_SelectBySupplierID` 然后单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="767ae-231">Name this stored procedure `Suppliers_SelectBySupplierID` and click Next.</span></span>

<span data-ttu-id="767ae-232">[![命名存储过程 Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-232">[![Name the Stored Procedure Suppliers_SelectBySupplierID](working-with-computed-columns-vb/_static/image26.png)](working-with-computed-columns-vb/_static/image25.png)</span></span>

<span data-ttu-id="767ae-233">**图 9**：将存储过程命名 `Suppliers_SelectBySupplierID` （[单击以查看完全大小的图像](working-with-computed-columns-vb/_static/image27.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-233">**Figure 9**: Name the Stored Procedure `Suppliers_SelectBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image27.png))</span></span>

<span data-ttu-id="767ae-234">最后，向导提示我们输入用于 TableAdapter 的数据访问模式和方法名称。</span><span class="sxs-lookup"><span data-stu-id="767ae-234">Lastly, the wizard prompts us for the data access patterns and method names to use for the TableAdapter.</span></span> <span data-ttu-id="767ae-235">选中这两个复选框，但将 `FillBy` 和 `GetDataBy` 方法分别重命名为 `FillBySupplierID` 和 `GetSupplierBySupplierID`。</span><span class="sxs-lookup"><span data-stu-id="767ae-235">Leave both checkboxes checked, but rename the `FillBy` and `GetDataBy` methods to `FillBySupplierID` and `GetSupplierBySupplierID`, respectively.</span></span>

<span data-ttu-id="767ae-236">[![命名 TableAdapter 方法 FillBySupplierID 和 GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-236">[![Name the TableAdapter Methods FillBySupplierID and GetSupplierBySupplierID](working-with-computed-columns-vb/_static/image29.png)](working-with-computed-columns-vb/_static/image28.png)</span></span>

<span data-ttu-id="767ae-237">**图 10**：将 TableAdapter 方法命名 `FillBySupplierID` 和 `GetSupplierBySupplierID` （[单击以查看完全大小的映像](working-with-computed-columns-vb/_static/image30.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-237">**Figure 10**: Name the TableAdapter Methods `FillBySupplierID` and `GetSupplierBySupplierID` ([Click to view full-size image](working-with-computed-columns-vb/_static/image30.png))</span></span>

<span data-ttu-id="767ae-238">单击“完成”按钮以完成向导。</span><span class="sxs-lookup"><span data-stu-id="767ae-238">Click Finish to complete the wizard.</span></span>

## <a name="step-6-creating-the-business-logic-layer"></a><span data-ttu-id="767ae-239">步骤6：创建业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="767ae-239">Step 6: Creating the Business Logic Layer</span></span>

<span data-ttu-id="767ae-240">在创建使用在步骤1中创建的计算列的 ASP.NET 页面之前，首先需要在 BLL 中添加相应的方法。</span><span class="sxs-lookup"><span data-stu-id="767ae-240">Before we create an ASP.NET page that uses the computed column created in Step 1, we first need to add the corresponding methods in the BLL.</span></span> <span data-ttu-id="767ae-241">我们将在步骤7中创建的 ASP.NET 页允许用户查看和编辑供应商。</span><span class="sxs-lookup"><span data-stu-id="767ae-241">Our ASP.NET page, which we will create in Step 7, will allow users to view and edit suppliers.</span></span> <span data-ttu-id="767ae-242">因此，我们需要 BLL 至少提供一个方法来获取所有供应商，并使用另一个方法来更新特定的供应商。</span><span class="sxs-lookup"><span data-stu-id="767ae-242">Therefore, we need our BLL to provide, at minimum, a method to get all of the suppliers and another to update a particular supplier.</span></span>

<span data-ttu-id="767ae-243">在 `~/App_Code/BLL` 文件夹中创建一个名为 `SuppliersBLLWithSprocs` 的新类文件，并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="767ae-243">Create a new class file named `SuppliersBLLWithSprocs` in the `~/App_Code/BLL` folder and add the following code:</span></span>

[!code-vb[Main](working-with-computed-columns-vb/samples/sample6.vb)]

<span data-ttu-id="767ae-244">与其他 BLL 类一样，`SuppliersBLLWithSprocs` 具有一个 `Protected` `Adapter` 属性，该属性返回 `SuppliersTableAdapter` 类的实例以及两个 `Public` 方法： `GetSuppliers` 和 `UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="767ae-244">Like the other BLL classes, `SuppliersBLLWithSprocs` has a `Protected` `Adapter` property that returns an instance of the `SuppliersTableAdapter` class along with two `Public` methods: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="767ae-245">`GetSuppliers` 方法调用并返回由数据访问层中的相应 `GetSupplier` 方法返回的 `SuppliersDataTable`。</span><span class="sxs-lookup"><span data-stu-id="767ae-245">The `GetSuppliers` method calls and returns the `SuppliersDataTable` returned by the corresponding `GetSupplier` method in the Data Access Layer.</span></span> <span data-ttu-id="767ae-246">`UpdateSupplier` 方法检索有关通过调用 DAL s `GetSupplierBySupplierID(supplierID)` 方法更新的特定供应商的信息。</span><span class="sxs-lookup"><span data-stu-id="767ae-246">The `UpdateSupplier` method retrieves information about the particular supplier being updated via a call to the DAL s `GetSupplierBySupplierID(supplierID)` method.</span></span> <span data-ttu-id="767ae-247">然后，它会更新 `CategoryName`、`ContactName`和 `ContactTitle` 属性，并通过调用数据访问层的 `Update` 方法并传入经过修改的 `SuppliersRow` 对象，将这些更改提交到数据库。</span><span class="sxs-lookup"><span data-stu-id="767ae-247">It then updates the `CategoryName`, `ContactName`, and `ContactTitle` properties and commits these changes to the database by calling the Data Access Layer s `Update` method, passing in the modified `SuppliersRow` object.</span></span>

> [!NOTE]
> <span data-ttu-id="767ae-248">除了 `SupplierID` 和 `CompanyName`之外，"供应商" 表中的所有列都允许 `NULL` 值。</span><span class="sxs-lookup"><span data-stu-id="767ae-248">Except for `SupplierID` and `CompanyName`, all columns in the Suppliers table allow `NULL` values.</span></span> <span data-ttu-id="767ae-249">因此，如果传入的 `contactName` 或 `contactTitle` 参数是 `Nothing`，我们需要分别使用 `ContactTitle` 和 `NULL` 方法将相应的 `ContactName` 和 `SetContactNameNull` 属性分别设置为 `SetContactTitleNull` 数据库值。</span><span class="sxs-lookup"><span data-stu-id="767ae-249">Therefore, if the passed-in `contactName` or `contactTitle` parameters are `Nothing` we need to set the corresponding `ContactName` and `ContactTitle` properties to a `NULL` database value using the `SetContactNameNull` and `SetContactTitleNull` methods, respectively.</span></span>

## <a name="step-7-working-with-the-computed-column-from-the-presentation-layer"></a><span data-ttu-id="767ae-250">步骤7：使用表示层中的计算列</span><span class="sxs-lookup"><span data-stu-id="767ae-250">Step 7: Working with the Computed Column from the Presentation Layer</span></span>

<span data-ttu-id="767ae-251">将计算列添加到 `Suppliers` 表并且 DAL 和 BLL 进行了相应更新后，便可以生成可与 `FullContactName` 计算列一起使用的 ASP.NET 页。</span><span class="sxs-lookup"><span data-stu-id="767ae-251">With the computed column added to the `Suppliers` table and the DAL and BLL updated accordingly, we are ready to build an ASP.NET page that works with the `FullContactName` computed column.</span></span> <span data-ttu-id="767ae-252">首先打开 `AdvancedDAL` 文件夹中的 "`ComputedColumns.aspx`" 页，然后从 "工具箱" 拖动到设计器上。</span><span class="sxs-lookup"><span data-stu-id="767ae-252">Start by opening the `ComputedColumns.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="767ae-253">将 GridView `ID` 属性设置为 `Suppliers`，并从其智能标记将其绑定到名为 `SuppliersDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="767ae-253">Set the GridView s `ID` property to `Suppliers` and, from its smart tag, bind it to a new ObjectDataSource named `SuppliersDataSource`.</span></span> <span data-ttu-id="767ae-254">将 ObjectDataSource 配置为使用我们在步骤6中添加的 `SuppliersBLLWithSprocs` 类，然后单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="767ae-254">Configure the ObjectDataSource to use the `SuppliersBLLWithSprocs` class we added back in Step 6 and click Next.</span></span>

<span data-ttu-id="767ae-255">[![将 ObjectDataSource 配置为使用 SuppliersBLLWithSprocs 类](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-255">[![Configure the ObjectDataSource to Use the SuppliersBLLWithSprocs Class](working-with-computed-columns-vb/_static/image32.png)](working-with-computed-columns-vb/_static/image31.png)</span></span>

<span data-ttu-id="767ae-256">**图 11**：将 ObjectDataSource 配置为使用 `SuppliersBLLWithSprocs` 类（[单击以查看完全大小的映像](working-with-computed-columns-vb/_static/image33.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-256">**Figure 11**: Configure the ObjectDataSource to Use the `SuppliersBLLWithSprocs` Class ([Click to view full-size image](working-with-computed-columns-vb/_static/image33.png))</span></span>

<span data-ttu-id="767ae-257">`SuppliersBLLWithSprocs` 类中仅定义了两个方法： `GetSuppliers` 和 `UpdateSupplier`。</span><span class="sxs-lookup"><span data-stu-id="767ae-257">There are only two methods defined in the `SuppliersBLLWithSprocs` class: `GetSuppliers` and `UpdateSupplier`.</span></span> <span data-ttu-id="767ae-258">确保在 "选择" 和 "更新" 选项卡中分别指定这两种方法，然后单击 "完成" 完成 ObjectDataSource 的配置。</span><span class="sxs-lookup"><span data-stu-id="767ae-258">Ensure that these two methods are specified in the SELECT and UPDATE tabs, respectively, and click Finish to complete the configuration of the ObjectDataSource.</span></span>

<span data-ttu-id="767ae-259">完成 "数据源配置向导" 后，Visual Studio 将为返回的每个数据字段添加 BoundField。</span><span class="sxs-lookup"><span data-stu-id="767ae-259">Upon completion of the Data Source Configuration wizard, Visual Studio will add a BoundField for each of the data fields returned.</span></span> <span data-ttu-id="767ae-260">删除 `SupplierID` BoundField，并分别将 `CompanyName`、`ContactName`、`ContactTitle`和 `FullContactName` BoundFields 的 `HeaderText` 属性分别更改为 "公司"、"联系人姓名"、"职务" 和 "完整联系人姓名"。</span><span class="sxs-lookup"><span data-stu-id="767ae-260">Remove the `SupplierID` BoundField and change the `HeaderText` properties of the `CompanyName`, `ContactName`, `ContactTitle`, and `FullContactName` BoundFields to Company, Contact Name, Title, and Full Contact Name, respectively.</span></span> <span data-ttu-id="767ae-261">从智能标记中，选中 "启用编辑" 复选框以启用 GridView 的内置编辑功能。</span><span class="sxs-lookup"><span data-stu-id="767ae-261">From the smart tag, check the Enable Editing checkbox to turn on the GridView s built-in editing capabilities.</span></span>

<span data-ttu-id="767ae-262">除了将 BoundFields 添加到 GridView 外，完成数据源向导还会导致 Visual Studio 将 ObjectDataSource `OldValuesParameterFormatString` 属性设置为原始\_{0}。</span><span class="sxs-lookup"><span data-stu-id="767ae-262">In addition to adding BoundFields to the GridView, completion of the Data Source Wizard also causes Visual Studio to set the ObjectDataSource s `OldValuesParameterFormatString` property to original\_{0}.</span></span> <span data-ttu-id="767ae-263">将此设置恢复为其默认值 {0}。</span><span class="sxs-lookup"><span data-stu-id="767ae-263">Revert this setting back to its default value, {0} .</span></span>

<span data-ttu-id="767ae-264">对 GridView 和 ObjectDataSource 进行这些编辑后，其声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="767ae-264">After making these edits to the GridView and ObjectDataSource, their declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](working-with-computed-columns-vb/samples/sample7.aspx)]

<span data-ttu-id="767ae-265">接下来，通过浏览器访问此页。</span><span class="sxs-lookup"><span data-stu-id="767ae-265">Next, visit this page through a browser.</span></span> <span data-ttu-id="767ae-266">如图12所示，每个供应商都在包含 `FullContactName` 列的网格中列出，其值只是与 `ContactName` （`ContactTitle`，`CompanyName`）格式设置的其他三个列的连接。</span><span class="sxs-lookup"><span data-stu-id="767ae-266">As Figure 12 shows, each supplier is listed in a grid that includes the `FullContactName` column, whose value is simply the concatenation of the other three columns formatted as `ContactName` (`ContactTitle`, `CompanyName`) .</span></span>

<span data-ttu-id="767ae-267">[网格中列出了每个供应商 ![](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-267">[![Each Supplier is Listed in the Grid](working-with-computed-columns-vb/_static/image35.png)](working-with-computed-columns-vb/_static/image34.png)</span></span>

<span data-ttu-id="767ae-268">**图 12**：每个供应商在网格中列出（[单击以查看完全大小的图像](working-with-computed-columns-vb/_static/image36.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-268">**Figure 12**: Each Supplier is Listed in the Grid ([Click to view full-size image](working-with-computed-columns-vb/_static/image36.png))</span></span>

<span data-ttu-id="767ae-269">单击特定供应商的 "编辑" 按钮会导致回发，并使该行呈现在其编辑界面中（参见图13）。</span><span class="sxs-lookup"><span data-stu-id="767ae-269">Clicking the Edit button for a particular supplier causes a postback and has that row rendered in its editing interface (see Figure 13).</span></span> <span data-ttu-id="767ae-270">前三列呈现在其默认编辑界面中（`Text` 属性设置为数据字段的值）的 TextBox 控件。</span><span class="sxs-lookup"><span data-stu-id="767ae-270">The first three columns render in their default editing interface - a TextBox control whose `Text` property is set to the value of the data field.</span></span> <span data-ttu-id="767ae-271">但 `FullContactName` 列仍保留为文本。</span><span class="sxs-lookup"><span data-stu-id="767ae-271">The `FullContactName` column, however, remains as text.</span></span> <span data-ttu-id="767ae-272">如果在数据源配置向导完成时将 BoundFields 添加到 GridView，则 `FullContactName` BoundField s `ReadOnly` 属性设置为 `True`，因为 `SuppliersDataTable` 中的相应 `FullContactName` 列的 `ReadOnly` 属性设置为 `True`。</span><span class="sxs-lookup"><span data-stu-id="767ae-272">When the BoundFields were added to the GridView at the completion of the Data Source Configuration wizard, the `FullContactName` BoundField s `ReadOnly` property was set to `True` because the corresponding `FullContactName` column in the `SuppliersDataTable` has its `ReadOnly` property set to `True`.</span></span> <span data-ttu-id="767ae-273">如步骤4所述，`FullContactName` s `ReadOnly` 属性设置为 `True`，因为 TableAdapter 检测到该列为计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-273">As noted in Step 4, the `FullContactName` s `ReadOnly` property was set to `True` because the TableAdapter detected that the column was a computed column.</span></span>

<span data-ttu-id="767ae-274">[![FullContactName 列不可编辑](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="767ae-274">[![The FullContactName Column is Not Editable](working-with-computed-columns-vb/_static/image38.png)](working-with-computed-columns-vb/_static/image37.png)</span></span>

<span data-ttu-id="767ae-275">**图 13**：无法编辑 `FullContactName` 列（[单击以查看完全大小的图像](working-with-computed-columns-vb/_static/image39.png)）</span><span class="sxs-lookup"><span data-stu-id="767ae-275">**Figure 13**: The `FullContactName` Column is Not Editable ([Click to view full-size image](working-with-computed-columns-vb/_static/image39.png))</span></span>

<span data-ttu-id="767ae-276">继续并更新一个或多个可编辑列的值，然后单击 "更新"。</span><span class="sxs-lookup"><span data-stu-id="767ae-276">Go ahead and update the value of one or more of the editable columns and click Update.</span></span> <span data-ttu-id="767ae-277">请注意如何自动更新 `FullContactName` 的值以反映所做的更改。</span><span class="sxs-lookup"><span data-stu-id="767ae-277">Note how the `FullContactName` s value is automatically updated to reflect the change.</span></span>

> [!NOTE]
> <span data-ttu-id="767ae-278">GridView 当前对可编辑字段使用 BoundFields，从而导致默认编辑界面。</span><span class="sxs-lookup"><span data-stu-id="767ae-278">The GridView currently uses BoundFields for the editable fields, resulting in the default editing interface.</span></span> <span data-ttu-id="767ae-279">由于 `CompanyName` 字段是必需的，因此应将其转换为包含 RequiredFieldValidator 的 TemplateField。</span><span class="sxs-lookup"><span data-stu-id="767ae-279">Since the `CompanyName` field is required, it should be converted into a TemplateField that includes a RequiredFieldValidator.</span></span> <span data-ttu-id="767ae-280">对于感兴趣的读者来说，我将其作为练习。</span><span class="sxs-lookup"><span data-stu-id="767ae-280">I leave this as an exercise for the interested reader.</span></span> <span data-ttu-id="767ae-281">有关将 BoundField 转换为 TemplateField 并添加验证控件的分步说明，请参阅向[编辑和插入界面添加验证控件](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md)教程。</span><span class="sxs-lookup"><span data-stu-id="767ae-281">Consult the [Adding Validation Controls to the Editing and Inserting Interfaces](../editing-inserting-and-deleting-data/adding-validation-controls-to-the-editing-and-inserting-interfaces-vb.md) tutorial for step-by-step instructions on converting a BoundField to a TemplateField and adding validation controls.</span></span>

## <a name="summary"></a><span data-ttu-id="767ae-282">总结</span><span class="sxs-lookup"><span data-stu-id="767ae-282">Summary</span></span>

<span data-ttu-id="767ae-283">在定义表的架构时，Microsoft SQL Server 允许包含计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-283">When defining the schema for a table, Microsoft SQL Server allows the inclusion of computed columns.</span></span> <span data-ttu-id="767ae-284">这些列的值是从通常引用同一记录中其他列中的值的表达式计算得出的。</span><span class="sxs-lookup"><span data-stu-id="767ae-284">These are columns whose values are calculated from an expression that usually references the values from other columns in the same record.</span></span> <span data-ttu-id="767ae-285">由于计算列的值基于表达式，因此它们是只读的，不能在 `INSERT` 或 `UPDATE` 语句中为其赋值。</span><span class="sxs-lookup"><span data-stu-id="767ae-285">Since the values for computed columns are based on an expression, they are read-only and cannot be assigned a value in an `INSERT` or `UPDATE` statement.</span></span> <span data-ttu-id="767ae-286">这会在使用尝试自动生成相应的 `INSERT`、`UPDATE`和 `DELETE` 语句的 TableAdapter 的主查询中使用计算列时带来挑战。</span><span class="sxs-lookup"><span data-stu-id="767ae-286">This introduces challenges when using a computed column in the main query of a TableAdapter that tries to automatically generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span>

<span data-ttu-id="767ae-287">在本教程中，我们讨论了规避计算列所带来的挑战的方法。</span><span class="sxs-lookup"><span data-stu-id="767ae-287">In this tutorial we discussed techniques for circumventing the challenges posed by computed columns.</span></span> <span data-ttu-id="767ae-288">具体而言，我们在 TableAdapter 中使用存储过程来克服使用即席 SQL 语句的 Tableadapter 中的易受攻击。</span><span class="sxs-lookup"><span data-stu-id="767ae-288">In particular, we used stored procedures in our TableAdapter to overcome the brittleness inherent in TableAdapters that use ad-hoc SQL statements.</span></span> <span data-ttu-id="767ae-289">当使用 TableAdapter 向导创建新的存储过程时，主要查询最初省略所有计算列，这一点很重要，因为它们存在会阻止数据修改存储过程的生成。</span><span class="sxs-lookup"><span data-stu-id="767ae-289">When having the TableAdapter wizard create new stored procedures, it is important that we have the main query initially omit any computed columns because their presence prevents the data modification stored procedures from being generated.</span></span> <span data-ttu-id="767ae-290">最初配置 TableAdapter 后，可以重组其 `SelectCommand` 存储过程以包含所有计算列。</span><span class="sxs-lookup"><span data-stu-id="767ae-290">After the TableAdapter has been initially configured, its `SelectCommand` stored procedure can be retooled to include any computed columns.</span></span>

<span data-ttu-id="767ae-291">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="767ae-291">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="767ae-292">关于作者</span><span class="sxs-lookup"><span data-stu-id="767ae-292">About the Author</span></span>

<span data-ttu-id="767ae-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="767ae-293">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="767ae-294">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="767ae-294">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="767ae-295">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="767ae-295">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="767ae-296">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="767ae-296">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="767ae-297">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="767ae-297">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="767ae-298">特别感谢</span><span class="sxs-lookup"><span data-stu-id="767ae-298">Special Thanks To</span></span>

<span data-ttu-id="767ae-299">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="767ae-299">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="767ae-300">本教程的主管评审者是 Hilton Geisenow 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="767ae-300">Lead reviewers for this tutorial were Hilton Geisenow and Teresa Murphy.</span></span> <span data-ttu-id="767ae-301">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="767ae-301">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="767ae-302">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="767ae-302">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="767ae-303">[上一页](adding-additional-datatable-columns-vb.md)
> [下一页](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span><span class="sxs-lookup"><span data-stu-id="767ae-303">[Previous](adding-additional-datatable-columns-vb.md)
[Next](configuring-the-data-access-layer-s-connection-and-command-level-settings-vb.md)</span></span>

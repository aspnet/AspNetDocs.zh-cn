---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
title: 更新 TableAdapter 以使用 Join (C#) |Microsoft Docs
author: rick-anderson
description: 使用数据库时，共有分布在多个表的请求数据。 若要从两个不同表中检索数据我们可以使用...
ms.author: riande
ms.date: 07/18/2007
ms.assetid: 675531a7-cb54-4dd6-89ac-2636e4c285a5
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
msc.type: authoredcontent
ms.openlocfilehash: d5b69b502cf650a477b2841c25ad3f1ab5f8da93
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/01/2019
ms.locfileid: "57050624"
---
<a name="updating-the-tableadapter-to-use-joins-c"></a><span data-ttu-id="dfef9-104">更新 TableAdapter 以使用 JOIN (C#)</span><span class="sxs-lookup"><span data-stu-id="dfef9-104">Updating the TableAdapter to Use JOINs (C#)</span></span>
====================
<span data-ttu-id="dfef9-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="dfef9-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="dfef9-106">[下载代码](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip)或[下载 PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="dfef9-106">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip) or [Download PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span></span>

> <span data-ttu-id="dfef9-107">使用数据库时，共有分布在多个表的请求数据。</span><span class="sxs-lookup"><span data-stu-id="dfef9-107">When working with a database it is common to request data that is spread across multiple tables.</span></span> <span data-ttu-id="dfef9-108">若要从两个不同表中检索数据我们可以使用相关子查询或联接操作。</span><span class="sxs-lookup"><span data-stu-id="dfef9-108">To retrieve data from two different tables we can use either a correlated subquery or a JOIN operation.</span></span> <span data-ttu-id="dfef9-109">在本教程中我们比较相关子查询和联接语法之前看一下如何创建包含在其主查询中联接的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="dfef9-109">In this tutorial we compare correlated subqueries and the JOIN syntax before looking at how to create a TableAdapter that includes a JOIN in its main query.</span></span>


## <a name="introduction"></a><span data-ttu-id="dfef9-110">介绍</span><span class="sxs-lookup"><span data-stu-id="dfef9-110">Introduction</span></span>

<span data-ttu-id="dfef9-111">关系数据库与我们感兴趣使用的数据通常分布在多个表中。</span><span class="sxs-lookup"><span data-stu-id="dfef9-111">With relational databases the data we are interested in working with is often spread across multiple tables.</span></span> <span data-ttu-id="dfef9-112">例如，显示产品信息时我们可能想要列出每个产品 s 相应类别和供应商 s 的名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-112">For example, when displaying product information we likely want to list each product s corresponding category and supplier s names.</span></span> <span data-ttu-id="dfef9-113">`Products`表中有`CategoryID`并`SupplierID`值，但实际的类别和供应商名称位于`Categories`和`Suppliers`表，分别。</span><span class="sxs-lookup"><span data-stu-id="dfef9-113">The `Products` table has `CategoryID` and `SupplierID` values, but the actual category and supplier names are in the `Categories` and `Suppliers` tables, respectively.</span></span>

<span data-ttu-id="dfef9-114">若要从另一个、 相关表中检索信息，我们可以使用*相关子查询*或`JOIN` *s*。</span><span class="sxs-lookup"><span data-stu-id="dfef9-114">To retrieve information from another, related table, we can either use *correlated subqueries* or `JOIN`*s*.</span></span> <span data-ttu-id="dfef9-115">相关子查询是嵌套`SELECT`引用外部查询中的列的查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-115">A correlated subquery is a nested `SELECT` query that references columns in the outer query.</span></span> <span data-ttu-id="dfef9-116">例如，在[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)教程中的两个相关子查询，我们使用`ProductsTableAdapter`s 主查询以返回的每个产品类别和供应商名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-116">For example, in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) tutorial we used two correlated subqueries in the `ProductsTableAdapter` s main query to return the category and supplier names for each product.</span></span> <span data-ttu-id="dfef9-117">一个`JOIN`是合并来自两个不同表的相关的行的 SQL 构造。</span><span class="sxs-lookup"><span data-stu-id="dfef9-117">A `JOIN` is a SQL construct that merges related rows from two different tables.</span></span> <span data-ttu-id="dfef9-118">我们使用了`JOIN`中[使用 SqlDataSource 控件查询数据](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md)教程，以显示与每个产品类别信息。</span><span class="sxs-lookup"><span data-stu-id="dfef9-118">We used a `JOIN` in the [Querying Data with the SqlDataSource Control](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md) tutorial to display category information alongside each product.</span></span>

<span data-ttu-id="dfef9-119">我们已从使用 abstained 的原因`JOIN`与 Tableadapter 是由于在 TableAdapter 的向导自动生成的相应限制`INSERT`， `UPDATE`，和`DELETE`语句。</span><span class="sxs-lookup"><span data-stu-id="dfef9-119">The reason we have abstained from using `JOIN` s with the TableAdapters is because of limitations in the TableAdapter s wizard to auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span> <span data-ttu-id="dfef9-120">具体而言，如果 TableAdapter s 主查询包含任何`JOIN`s，TableAdapter 不能自动创建的临时 SQL 语句或存储的过程，以其`InsertCommand`， `UpdateCommand`，和`DeleteCommand`属性。</span><span class="sxs-lookup"><span data-stu-id="dfef9-120">More specifically, if the TableAdapter s main query contains any `JOIN` s, the TableAdapter cannot auto-create the ad-hoc SQL statements or stored procedures for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span>

<span data-ttu-id="dfef9-121">在本教程中我们将简要比较和对比相关子查询和`JOIN`s 之前探索如何创建包括的 TableAdapter`JOIN`中其主查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-121">In this tutorial we will briefly compare and contrast correlated subqueries and `JOIN` s before exploring how to create a TableAdapter that includes `JOIN` s in its main query.</span></span>

## <a name="comparing-and-contrasting-correlated-subqueries-andjoin-s"></a><span data-ttu-id="dfef9-122">比较和对比相关子查询和`JOIN`s</span><span class="sxs-lookup"><span data-stu-id="dfef9-122">Comparing and Contrasting Correlated Subqueries and`JOIN` s</span></span>

<span data-ttu-id="dfef9-123">请记住，`ProductsTableAdapter`中的第一个教程中创建`Northwind`数据集使用相关子查询将返回每个产品 s 相应类别和供应商名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-123">Recall that the `ProductsTableAdapter` created in the first tutorial in the `Northwind` DataSet uses correlated subqueries to bring back each product s corresponding category and supplier name.</span></span> <span data-ttu-id="dfef9-124">`ProductsTableAdapter` S 主查询如下所示。</span><span class="sxs-lookup"><span data-stu-id="dfef9-124">The `ProductsTableAdapter` s main query is shown below.</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample1.sql)]

<span data-ttu-id="dfef9-125">这两个相关子查询-`(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)`并`(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)`-是`SELECT`作为中的外部的其他列返回每个产品的单个值的查询`SELECT`语句的列列表。</span><span class="sxs-lookup"><span data-stu-id="dfef9-125">The two correlated subqueries - `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` and `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` - are `SELECT` queries that return a single value per product as an additional column in the outer `SELECT` statement s column list.</span></span>

<span data-ttu-id="dfef9-126">或者，`JOIN`可以用于返回每个产品 s 供应商和类别名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-126">Alternatively, a `JOIN` can be used to return each product s supplier and category name.</span></span> <span data-ttu-id="dfef9-127">以下查询返回与上述相同的输出，但使用`JOIN`s 取代子查询：</span><span class="sxs-lookup"><span data-stu-id="dfef9-127">The following query returns the same output as the above one, but uses `JOIN` s in place of subqueries:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample2.sql)]

<span data-ttu-id="dfef9-128">一个`JOIN`合并从一个表记录与根据某些条件的另一个表中的记录。</span><span class="sxs-lookup"><span data-stu-id="dfef9-128">A `JOIN` merges the records from one table with records from another table based on some criteria.</span></span> <span data-ttu-id="dfef9-129">在上面的查询中，例如，`LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID`指示 SQL Server 合并每个类别的产品记录记录`CategoryID`值与匹配产品的`CategoryID`值。</span><span class="sxs-lookup"><span data-stu-id="dfef9-129">In the above query, for example, the `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` instructs SQL Server to merge each product record with the category record whose `CategoryID` value matches the product s `CategoryID` value.</span></span> <span data-ttu-id="dfef9-130">合并的结果使我们可以使用相应的类别字段的每个产品 (如`CategoryName`)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-130">The merged result allows us to work with the corresponding category fields for each product (such as `CategoryName`).</span></span>

> [!NOTE]
> <span data-ttu-id="dfef9-131">`JOIN` 查询关系数据库中的数据时，通常使用 s。</span><span class="sxs-lookup"><span data-stu-id="dfef9-131">`JOIN` s are commonly used when querying data from relational databases.</span></span> <span data-ttu-id="dfef9-132">如果您不熟悉`JOIN`语法或需复习有点其使用情况，我建议[SQL Join 教程](http://www.w3schools.com/sql/sql_join.asp)处[W3 学校](http://www.w3schools.com/)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-132">If you are new to the `JOIN` syntax or need to brush up a bit on its usage, I d recommend the [SQL Join tutorial](http://www.w3schools.com/sql/sql_join.asp) at [W3 Schools](http://www.w3schools.com/).</span></span> <span data-ttu-id="dfef9-133">此外值得一读都[`JOIN`基础知识](https://msdn.microsoft.com/library/ms191517.aspx)并[子查询基础知识](https://msdn.microsoft.com/library/ms189575.aspx)的部分[SQL 联机丛书](https://msdn.microsoft.com/library/ms130214.aspx)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-133">Also worth reading are the [`JOIN` Fundamentals](https://msdn.microsoft.com/library/ms191517.aspx) and [Subquery Fundamentals](https://msdn.microsoft.com/library/ms189575.aspx) sections of the [SQL Books Online](https://msdn.microsoft.com/library/ms130214.aspx).</span></span>


<span data-ttu-id="dfef9-134">由于`JOIN`s 和相关子查询可同时用于从其他表中检索相关的数据，许多开发人员保持着头说到，并想知道要使用的方法。</span><span class="sxs-lookup"><span data-stu-id="dfef9-134">Since `JOIN` s and correlated subqueries can both be used to retrieve related data from other tables, many developers are left scratching their heads and wondering which approach to use.</span></span> <span data-ttu-id="dfef9-135">所有 SQL 专家我已讨论了都说大致相同的操作，它不真正重要性能方面为 SQL Server 将生成的大致相同的执行计划。</span><span class="sxs-lookup"><span data-stu-id="dfef9-135">All of the SQL gurus I ve talked to have said roughly the same thing, that it doesn t really matter performance-wise as SQL Server will produce roughly identical execution plans.</span></span> <span data-ttu-id="dfef9-136">然后，他们的建议，是使用您和您的团队有最熟悉的技术。</span><span class="sxs-lookup"><span data-stu-id="dfef9-136">Their advice, then, is to use the technique that you and your team are most comfortable with.</span></span> <span data-ttu-id="dfef9-137">它值得注意的，为某物赋与这一建议后这些专家立即会 express 其首选项的`JOIN`随着相关子查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-137">It merits noting that after imparting this advice these experts immediately express their preference of `JOIN` s over correlated subqueries.</span></span>

<span data-ttu-id="dfef9-138">在生成时使用类型化数据集的数据访问层，这些工具更好地工作，使用子查询时。</span><span class="sxs-lookup"><span data-stu-id="dfef9-138">When building a Data Access Layer using Typed DataSets, the tools work better when using subqueries.</span></span> <span data-ttu-id="dfef9-139">特别是，TableAdapter 的向导将不自动生成对应`INSERT`， `UPDATE`，并`DELETE`语句，如果主查询包含任何`JOIN`s，但将自动生成这些语句时相关子查询使用。</span><span class="sxs-lookup"><span data-stu-id="dfef9-139">In particular, the TableAdapter s wizard will not auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements if the main query contains any `JOIN` s, but will auto-generate these statements when correlated subqueries are used.</span></span>

<span data-ttu-id="dfef9-140">若要了解这种缺陷，创建临时类型中的数据集`~/App_Code/DAL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="dfef9-140">To explore this shortcoming, create a temporary Typed DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="dfef9-141">在 TableAdapter 配置向导过程中选择要使用的临时 SQL 语句，然后输入以下`SELECT`查询 （参见图 1）：</span><span class="sxs-lookup"><span data-stu-id="dfef9-141">During the TableAdapter Configuration wizard, choose to use ad-hoc SQL statements and enter the following `SELECT` query (see Figure 1):</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample3.sql)]


<span data-ttu-id="dfef9-142">[![输入包含联接的主查询](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-142">[![Enter a Main Query that Contains JOINs](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span></span>

<span data-ttu-id="dfef9-143">**图 1**:输入包含的主查询`JOIN`s ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-143">**Figure 1**: Enter a Main Query that Contains `JOIN` s ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image3.png))</span></span>


<span data-ttu-id="dfef9-144">默认情况下，将自动创建 TableAdapter `INSERT`， `UPDATE`，和`DELETE`语句基于主查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-144">By default, the TableAdapter will automatically create `INSERT`, `UPDATE`, and `DELETE` statements based on the main query.</span></span> <span data-ttu-id="dfef9-145">如果单击高级按钮可以看到，启用此功能。</span><span class="sxs-lookup"><span data-stu-id="dfef9-145">If you click the Advanced button you can see that this feature is enabled.</span></span> <span data-ttu-id="dfef9-146">尽管此设置，将无法再创建 TableAdapter `INSERT`， `UPDATE`，并`DELETE`语句因为主查询中包含`JOIN`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-146">Despite this setting, the TableAdapter will not be able to create the `INSERT`, `UPDATE`, and `DELETE` statements because the main query contains a `JOIN`.</span></span>


![输入包含联接的主查询](updating-the-tableadapter-to-use-joins-cs/_static/image4.png)

<span data-ttu-id="dfef9-148">**图 2**:输入包含的主要查询`JOIN`s</span><span class="sxs-lookup"><span data-stu-id="dfef9-148">**Figure 2**: Enter a Main Query that Contains `JOIN` s</span></span>


<span data-ttu-id="dfef9-149">单击完成以完成向导。</span><span class="sxs-lookup"><span data-stu-id="dfef9-149">Click Finish to complete the wizard.</span></span> <span data-ttu-id="dfef9-150">此时在数据集设计器将包括到单个 TableAdapter 的 DataTable 与列中返回的字段的每个`SELECT`查询的列列表。</span><span class="sxs-lookup"><span data-stu-id="dfef9-150">At this point your DataSet s Designer will include a single TableAdapter with a DataTable with columns for each of the fields returned in the `SELECT` query s column list.</span></span> <span data-ttu-id="dfef9-151">这包括`CategoryName`和`SupplierName`，如图 3 所示。</span><span class="sxs-lookup"><span data-stu-id="dfef9-151">This includes the `CategoryName` and `SupplierName`, as Figure 3 shows.</span></span>


![DataTable 包含一个列对于每个字段中的列列表返回](updating-the-tableadapter-to-use-joins-cs/_static/image5.png)

<span data-ttu-id="dfef9-153">**图 3**:DataTable 包含一个列对于每个字段中的列列表返回</span><span class="sxs-lookup"><span data-stu-id="dfef9-153">**Figure 3**: The DataTable Includes a Column for Each Field Returned in the Column List</span></span>


<span data-ttu-id="dfef9-154">TableAdapter 而 DataTable 有相应的列，缺少的值及其`InsertCommand`， `UpdateCommand`，和`DeleteCommand`属性。</span><span class="sxs-lookup"><span data-stu-id="dfef9-154">While the DataTable has the appropriate columns, the TableAdapter lacks values for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span> <span data-ttu-id="dfef9-155">若要确认这一点，单击设计器中对 tableadapter，然后转到属性窗口。</span><span class="sxs-lookup"><span data-stu-id="dfef9-155">To confirm this, click on the TableAdapter in the Designer and then go to the Properties window.</span></span> <span data-ttu-id="dfef9-156">那里，你将看到`InsertCommand`， `UpdateCommand`，和`DeleteCommand`属性设置为 （无）。</span><span class="sxs-lookup"><span data-stu-id="dfef9-156">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are set to (None) .</span></span>


<span data-ttu-id="dfef9-157">[![InsertCommand、 UpdateCommand 和 DeleteCommand 属性设置为 （无）](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-157">[![The InsertCommand, UpdateCommand, and DeleteCommand Properties are Set to (None)](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span></span>

<span data-ttu-id="dfef9-158">**图 4**:`InsertCommand`， `UpdateCommand`，并`DeleteCommand`属性设置为 （无） ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-158">**Figure 4**: The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` Properties are Set to (None) ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image8.png))</span></span>


<span data-ttu-id="dfef9-159">若要解决这种缺陷，我们可以手动提供的 SQL 语句和参数`InsertCommand`， `UpdateCommand`，和`DeleteCommand`通过属性窗口的属性。</span><span class="sxs-lookup"><span data-stu-id="dfef9-159">To work around this shortcoming, we can manually provide the SQL statements and parameters for the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties via the Properties window.</span></span> <span data-ttu-id="dfef9-160">或者，我们可以通过配置 TableAdapter s 主查询到启动*不*包括任何`JOIN`s。</span><span class="sxs-lookup"><span data-stu-id="dfef9-160">Alternatively, we could start by configuring the TableAdapter s main query to *not* include any `JOIN` s.</span></span> <span data-ttu-id="dfef9-161">这将允许`INSERT`， `UPDATE`，和`DELETE`要为我们自动生成语句。</span><span class="sxs-lookup"><span data-stu-id="dfef9-161">This will allow the `INSERT`, `UPDATE`, and `DELETE` statements to be auto-generated for us.</span></span> <span data-ttu-id="dfef9-162">完成向导后，我们无法再手动更新 TableAdapter s`SelectCommand`从属性窗口使其包含`JOIN`语法。</span><span class="sxs-lookup"><span data-stu-id="dfef9-162">After completing the wizard, we could then manually update the TableAdapter s `SelectCommand` from the Properties window so that it includes the `JOIN` syntax.</span></span>

<span data-ttu-id="dfef9-163">虽然这种方法可行，很容易出错时使用的即席 SQL 查询，因为任何时候，只要 TableAdapter s 主查询是自动生成的向导通过重新配置`INSERT`， `UPDATE`，和`DELETE`语句会重新创建。</span><span class="sxs-lookup"><span data-stu-id="dfef9-163">While this approach works, it is very brittle when using ad-hoc SQL queries because any time the TableAdapter s main query is re-configured through the wizard, the auto-generated `INSERT`, `UPDATE`, and `DELETE` statements are recreated.</span></span> <span data-ttu-id="dfef9-164">这意味着如果我们右键单击 TableAdapter，从上下文菜单中，选择配置并再次完成该向导可能丢失的更高版本所做的自定义。</span><span class="sxs-lookup"><span data-stu-id="dfef9-164">That means all of the customizations we later made would be lost if we right-clicked on the TableAdapter, chose Configure from the context menu, and completed the wizard again.</span></span>

<span data-ttu-id="dfef9-165">自动生成的 TableAdapter s 脆弱性`INSERT`， `UPDATE`，和`DELETE`语句幸运的是，限制为临时 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="dfef9-165">The brittleness of the TableAdapter s auto-generated `INSERT`, `UPDATE`, and `DELETE` statements is, fortunately, limited to ad-hoc SQL statements.</span></span> <span data-ttu-id="dfef9-166">如果你 TableAdapter 使用存储的过程，您可以自定义`SelectCommand`， `InsertCommand`， `UpdateCommand`，或`DeleteCommand`存储过程和重新运行而无需担心存储的过程将 TableAdapter 配置向导修改。</span><span class="sxs-lookup"><span data-stu-id="dfef9-166">If your TableAdapter uses stored procedures, you can customize the `SelectCommand`, `InsertCommand`, `UpdateCommand`, or `DeleteCommand` stored procedures and re-run the TableAdapter Configuration wizard without having to fear that the stored procedures will be modified.</span></span>

<span data-ttu-id="dfef9-167">在接下来我们将创建的 TableAdapter，最初的几个步骤使用省略任何主查询`JOIN`s，以便相应插入、 更新和删除存储过程将会自动生成。</span><span class="sxs-lookup"><span data-stu-id="dfef9-167">Over the next several steps we will create a TableAdapter that, initially, uses a main query that omits any `JOIN` s so that the corresponding insert, update, and delete stored procedures will be auto-generated.</span></span> <span data-ttu-id="dfef9-168">然后，我们将更新`SelectCommand`因此，它使用`JOIN`从相关表返回其他列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-168">We will then update the `SelectCommand` so that uses a `JOIN` that returns additional columns from related tables.</span></span> <span data-ttu-id="dfef9-169">最后，我们将创建一个相应的业务逻辑层类，并演示如何使用 ASP.NET web 页面中的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="dfef9-169">Finally, we'll create a corresponding Business Logic Layer class and demonstrate using the TableAdapter in an ASP.NET web page.</span></span>

## <a name="step-1-creating-the-tableadapter-using-a-simplified-main-query"></a><span data-ttu-id="dfef9-170">步骤 1：创建使用简化的主查询的 TableAdapter</span><span class="sxs-lookup"><span data-stu-id="dfef9-170">Step 1: Creating the TableAdapter Using a Simplified Main Query</span></span>

<span data-ttu-id="dfef9-171">对于本教程中我们将添加 TableAdapter 和为强类型化 DataTable`Employees`表中`NorthwindWithSprocs`数据集。</span><span class="sxs-lookup"><span data-stu-id="dfef9-171">For this tutorial we will add a TableAdapter and strongly-typed DataTable for the `Employees` table in the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="dfef9-172">`Employees`表包含`ReportsTo`字段指定`EmployeeID`员工 s 管理器。</span><span class="sxs-lookup"><span data-stu-id="dfef9-172">The `Employees` table contains a `ReportsTo` field that specified the `EmployeeID` of the employee s manager.</span></span> <span data-ttu-id="dfef9-173">例如，员工具有 Anne 刘天妮`ReportTo`值为 5，即`EmployeeID`Steven Buchanan。</span><span class="sxs-lookup"><span data-stu-id="dfef9-173">For example, employee Anne Dodsworth has a `ReportTo` value of 5, which is the `EmployeeID` of Steven Buchanan.</span></span> <span data-ttu-id="dfef9-174">因此，Anne Steven，她的经理向报告。</span><span class="sxs-lookup"><span data-stu-id="dfef9-174">Consequently, Anne reports to Steven, her manager.</span></span> <span data-ttu-id="dfef9-175">以及报告每个雇员的`ReportsTo`值，我们可能还想要检索其管理器的名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-175">Along with reporting each employee s `ReportsTo` value, we might also want to retrieve the name of their manager.</span></span> <span data-ttu-id="dfef9-176">这可以使用`JOIN`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-176">This can be accomplished using a `JOIN`.</span></span> <span data-ttu-id="dfef9-177">不过，使用`JOIN`时最初创建 TableAdapter 可阻止该向导自动生成相应的插入、 更新和删除功能。</span><span class="sxs-lookup"><span data-stu-id="dfef9-177">But using a `JOIN` when initially creating the TableAdapter precludes the wizard from automatically generating the corresponding insert, update, and delete capabilities.</span></span> <span data-ttu-id="dfef9-178">因此，我们将首先创建它的主要查询不包含任何 TableAdapter `JOIN` s。</span><span class="sxs-lookup"><span data-stu-id="dfef9-178">Therefore, we will start by creating a TableAdapter whose main query does not contain any `JOIN` s.</span></span> <span data-ttu-id="dfef9-179">然后，在步骤 2 中，我们将更新的主查询存储过程来检索通过管理器的名称`JOIN`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-179">Then, in Step 2, we will update the main query stored procedure to retrieve the manager s name via a `JOIN`.</span></span>

<span data-ttu-id="dfef9-180">首先打开`NorthwindWithSprocs`中的数据集`~/App_Code/DAL`文件夹。</span><span class="sxs-lookup"><span data-stu-id="dfef9-180">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="dfef9-181">右键单击设计器上，从上下文菜单中，选择添加选项并选取 TableAdapter 菜单项。</span><span class="sxs-lookup"><span data-stu-id="dfef9-181">Right-click on the Designer, select the Add option from the context menu, and pick the TableAdapter menu item.</span></span> <span data-ttu-id="dfef9-182">这将启动 TableAdapter 配置向导。</span><span class="sxs-lookup"><span data-stu-id="dfef9-182">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="dfef9-183">如图 5 所示，让向导创建新的存储的过程，并单击下一步。</span><span class="sxs-lookup"><span data-stu-id="dfef9-183">As Figure 5 depicts, have the wizard create new stored procedures and click Next.</span></span> <span data-ttu-id="dfef9-184">有关创建新刷新器存储过程从 TableAdapter 的向导，请查阅[创建新存储过程的类型化数据集 s Tableadapter](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)教程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-184">For a refresher on creating new stored procedures from the TableAdapter s wizard, consult the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>


<span data-ttu-id="dfef9-185">[![选择创建新存储的过程选项](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-185">[![Select the Create new stored procedures Option](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span></span>

<span data-ttu-id="dfef9-186">**图 5**:选择创建新存储过程选项 ([单击此项可查看原尺寸图像](updating-the-tableadapter-to-use-joins-cs/_static/image11.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-186">**Figure 5**: Select the Create new stored procedures Option ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image11.png))</span></span>


<span data-ttu-id="dfef9-187">使用以下`SELECT`TableAdapter s 主查询的语句：</span><span class="sxs-lookup"><span data-stu-id="dfef9-187">Use the following `SELECT` statement for the TableAdapter s main query:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample4.sql)]

<span data-ttu-id="dfef9-188">由于此查询不包含任何`JOIN`s，TableAdapter 向导自动将创建具有相对应的存储的过程`INSERT`， `UPDATE`，和`DELETE`语句，以及用于执行主存储的过程查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-188">Since this query does not include any `JOIN` s, the TableAdapter wizard will automatically create stored procedures with corresponding `INSERT`, `UPDATE`, and `DELETE` statements, as well as a stored procedure for executing the main query.</span></span>

<span data-ttu-id="dfef9-189">以下步骤可用于命名的 TableAdapter 的存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-189">The following step allows us to name the TableAdapter s stored procedures.</span></span> <span data-ttu-id="dfef9-190">使用名称`Employees_Select`， `Employees_Insert`， `Employees_Update`，和`Employees_Delete`，如图 6 中所示。</span><span class="sxs-lookup"><span data-stu-id="dfef9-190">Use the names `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`, as shown in Figure 6.</span></span>


<span data-ttu-id="dfef9-191">[![名称的 TableAdapter 的存储过程](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-191">[![Name the TableAdapter s Stored Procedures](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span></span>

<span data-ttu-id="dfef9-192">**图 6**:命名 TableAdapter s 存储过程 ([单击此项可查看原尺寸图像](updating-the-tableadapter-to-use-joins-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-192">**Figure 6**: Name the TableAdapter s Stored Procedures ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image14.png))</span></span>


<span data-ttu-id="dfef9-193">最后一步会提示我们命名为 TableAdapter 的方法。</span><span class="sxs-lookup"><span data-stu-id="dfef9-193">The final step prompts us to name the TableAdapter s methods.</span></span> <span data-ttu-id="dfef9-194">使用`Fill`和`GetEmployees`为方法名称。</span><span class="sxs-lookup"><span data-stu-id="dfef9-194">Use `Fill` and `GetEmployees` as the method names.</span></span> <span data-ttu-id="dfef9-195">此外请务必保留创建方法以更新将直接发送到数据库 (GenerateDBDirectMethods) 复选框已选中。</span><span class="sxs-lookup"><span data-stu-id="dfef9-195">Also be sure to leave the Create methods to send updates directly to the database (GenerateDBDirectMethods) checkbox checked.</span></span>


<span data-ttu-id="dfef9-196">[![名称的 TableAdapter 的方法填充和 GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-196">[![Name the TableAdapter s Methods Fill and GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span></span>

<span data-ttu-id="dfef9-197">**图 7**:命名的 TableAdapter s 方法`Fill`并`GetEmployees`([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image17.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-197">**Figure 7**: Name the TableAdapter s Methods `Fill` and `GetEmployees` ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image17.png))</span></span>


<span data-ttu-id="dfef9-198">完成向导后，请花费片刻时间来检查数据库中的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-198">After completing the wizard, take a moment to examine the stored procedures in the database.</span></span> <span data-ttu-id="dfef9-199">应会看到四个新的： `Employees_Select`， `Employees_Insert`， `Employees_Update`，和`Employees_Delete`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-199">You should see four new ones: `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`.</span></span> <span data-ttu-id="dfef9-200">接下来，检查`EmployeesDataTable`和`EmployeesTableAdapter`刚刚创建。</span><span class="sxs-lookup"><span data-stu-id="dfef9-200">Next, inspect the `EmployeesDataTable` and `EmployeesTableAdapter` just created.</span></span> <span data-ttu-id="dfef9-201">数据表中的主查询所返回的每个字段的列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-201">The DataTable contains a column for each field returned by the main query.</span></span> <span data-ttu-id="dfef9-202">单击 TableAdapter，然后转到属性窗口。</span><span class="sxs-lookup"><span data-stu-id="dfef9-202">Click on the TableAdapter and then go to the Properties window.</span></span> <span data-ttu-id="dfef9-203">那里，你将看到`InsertCommand`， `UpdateCommand`，和`DeleteCommand`属性正确配置为调用相应的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-203">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are correctly configured to call the corresponding stored procedures.</span></span>


<span data-ttu-id="dfef9-204">[![TableAdapter 包括插入、 更新和删除功能](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-204">[![The TableAdapter Includes Insert, Update, and Delete Capabilities](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span></span>

<span data-ttu-id="dfef9-205">**图 8**:TableAdapter 包括插入、 更新和删除功能 ([单击此项可查看原尺寸图像](updating-the-tableadapter-to-use-joins-cs/_static/image20.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-205">**Figure 8**: The TableAdapter Includes Insert, Update, and Delete Capabilities ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image20.png))</span></span>


<span data-ttu-id="dfef9-206">使用插入、 更新和删除自动创建的存储的过程和`InsertCommand`， `UpdateCommand`，并`DeleteCommand`正确配置的属性，我们已准备好自定义`SelectCommand`s 存储过程返回其他每个员工 s manager 有关的信息。</span><span class="sxs-lookup"><span data-stu-id="dfef9-206">With the insert, update, and delete stored procedures automatically created and the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties correctly configured, we are ready to customize the `SelectCommand` s stored procedure to return additional information about each employee s manager.</span></span> <span data-ttu-id="dfef9-207">具体而言，我们需要更新`Employees_Select`存储过程来使用`JOIN`，并返回 manager s`FirstName`和`LastName`值。</span><span class="sxs-lookup"><span data-stu-id="dfef9-207">Specifically, we need to update the `Employees_Select` stored procedure to use a `JOIN` and return the manager s `FirstName` and `LastName` values.</span></span> <span data-ttu-id="dfef9-208">更新存储的过程后，我们将需要更新 DataTable，使其包括这些额外的列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-208">After the stored procedure has been updated, we will need to update the DataTable so that it includes these additional columns.</span></span> <span data-ttu-id="dfef9-209">我们将解决这两项任务中的步骤 2 和 3。</span><span class="sxs-lookup"><span data-stu-id="dfef9-209">We'll tackle these two tasks in Steps 2 and 3.</span></span>

## <a name="step-2-customizing-the-stored-procedure-to-include-ajoin"></a><span data-ttu-id="dfef9-210">步骤 2：自定义要包括的存储的过程`JOIN`</span><span class="sxs-lookup"><span data-stu-id="dfef9-210">Step 2: Customizing the Stored Procedure to Include a`JOIN`</span></span>

<span data-ttu-id="dfef9-211">首先转到服务器资源管理器，向下钻取到 Northwind 数据库 s 存储过程文件夹，并打开`Employees_Select`存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-211">Start by going to the Server Explorer, drilling down into the Northwind database s Stored Procedures folder, and opening the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="dfef9-212">如果看不到此存储的过程，在存储过程文件夹上右键单击并选择刷新。</span><span class="sxs-lookup"><span data-stu-id="dfef9-212">If you do not see this stored procedure, right-click on the Stored Procedures folder and choose Refresh.</span></span> <span data-ttu-id="dfef9-213">更新存储的过程，以便它使用`LEFT JOIN`首先返回 manager s 和姓氏：</span><span class="sxs-lookup"><span data-stu-id="dfef9-213">Update the stored procedure so that it uses a `LEFT JOIN` to return the manager s first and last name:</span></span>


[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample5.sql)]

<span data-ttu-id="dfef9-214">更新后`SELECT`语句，通过转到文件菜单并选择保存的更改保存`Employees_Select`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-214">After updating the `SELECT` statement, save the changes by going to the File menu and choosing Save `Employees_Select`.</span></span> <span data-ttu-id="dfef9-215">或者，可以单击工具栏中的保存图标或按 Ctrl + S。</span><span class="sxs-lookup"><span data-stu-id="dfef9-215">Alternatively, you can click the Save icon in the toolbar or hit Ctrl+S.</span></span> <span data-ttu-id="dfef9-216">保存后所做的更改，请右键单击`Employees_Select`在服务器资源管理器存储过程，并选择执行。</span><span class="sxs-lookup"><span data-stu-id="dfef9-216">After saving your changes, right-click on the `Employees_Select` stored procedure in the Server Explorer and choose Execute.</span></span> <span data-ttu-id="dfef9-217">这将运行存储的过程并在输出窗口中显示其结果 （请参阅图 9）。</span><span class="sxs-lookup"><span data-stu-id="dfef9-217">This will run the stored procedure and show its results in the Output window (see Figure 9).</span></span>


<span data-ttu-id="dfef9-218">[![在输出窗口中显示存储过程结果](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-218">[![The Stored Procedures Results are Displayed in the Output Window](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span></span>

<span data-ttu-id="dfef9-219">**图 9**:在输出窗口中显示存储过程结果 ([单击此项可查看原尺寸图像](updating-the-tableadapter-to-use-joins-cs/_static/image23.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-219">**Figure 9**: The Stored Procedures Results are Displayed in the Output Window ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image23.png))</span></span>


## <a name="step-3-updating-the-datatable-s-columns"></a><span data-ttu-id="dfef9-220">步骤 3：更新数据表的列</span><span class="sxs-lookup"><span data-stu-id="dfef9-220">Step 3: Updating the DataTable s Columns</span></span>

<span data-ttu-id="dfef9-221">在此情况下，`Employees_Select`存储过程返回`ManagerFirstName`并`ManagerLastName`值，但`EmployeesDataTable`缺少这些列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-221">At this point, the `Employees_Select` stored procedure returns `ManagerFirstName` and `ManagerLastName` values, but the `EmployeesDataTable` is missing these columns.</span></span> <span data-ttu-id="dfef9-222">可以将这些缺少的列添加到 DataTable 中有两种：</span><span class="sxs-lookup"><span data-stu-id="dfef9-222">These missing columns can be added to the DataTable in one of two ways:</span></span>

- <span data-ttu-id="dfef9-223">**手动**-DataTable 数据集设计器中右键单击并从添加菜单中，选择列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-223">**Manually** - right-click on the DataTable in the DataSet Designer and, from the Add menu, choose Column.</span></span> <span data-ttu-id="dfef9-224">然后可以命名的列，并相应地设置其属性。</span><span class="sxs-lookup"><span data-stu-id="dfef9-224">You can then name the column and set its properties accordingly.</span></span>
- <span data-ttu-id="dfef9-225">**自动**-TableAdapter 配置向导将更新以反映返回的字段的 DataTable 的列`SelectCommand`存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-225">**Automatically** - the TableAdapter Configuration wizard will update the DataTable s columns to reflect the fields returned by the `SelectCommand` stored procedure.</span></span> <span data-ttu-id="dfef9-226">在使用临时 SQL 语句，该向导还将删除`InsertCommand`， `UpdateCommand`，并`DeleteCommand`属性，因为`SelectCommand`现在包含`JOIN`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-226">When using ad-hoc SQL statements, the wizard will also remove the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties since the `SelectCommand` now contains a `JOIN`.</span></span> <span data-ttu-id="dfef9-227">但在使用存储的过程时，这些命令属性保持不变。</span><span class="sxs-lookup"><span data-stu-id="dfef9-227">But when using stored procedures, these command properties remain intact.</span></span>

<span data-ttu-id="dfef9-228">我们已经学习了如何手动添加数据表列在前面的教程，包括[母版/详细信息的详细信息 DataList 使用母版记录项目符号列表](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md)并[将文件上载](../working-with-binary-files/uploading-files-cs.md)，我们会将在我们的下一教程中，请查看此过程再次的更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="dfef9-228">We have explored manually adding DataTable columns in previous tutorials, including [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) and [Uploading Files](../working-with-binary-files/uploading-files-cs.md), and we will look at this process again in more detail in our next tutorial.</span></span> <span data-ttu-id="dfef9-229">对于本教程，但是，让我们来使用 TableAdapter 配置向导通过自动的方法。</span><span class="sxs-lookup"><span data-stu-id="dfef9-229">For this tutorial, however, let s use the automatic approach via the TableAdapter Configuration wizard.</span></span>

<span data-ttu-id="dfef9-230">通过右键单击启动`EmployeesTableAdapter`并从上下文菜单中选择配置。</span><span class="sxs-lookup"><span data-stu-id="dfef9-230">Start by right-clicking on the `EmployeesTableAdapter` and selecting Configure from the context menu.</span></span> <span data-ttu-id="dfef9-231">这将打开 TableAdapter 配置向导，其中列出了用于选择、 插入、 更新和删除，以及它们的返回值和参数 （如果有） 的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-231">This brings up the TableAdapter Configuration wizard, which lists the stored procedures used for selecting, inserting, updating, and deleting, along with their return values and parameters (if any).</span></span> <span data-ttu-id="dfef9-232">图 10 显示了此向导。</span><span class="sxs-lookup"><span data-stu-id="dfef9-232">Figure 10 shows this wizard.</span></span> <span data-ttu-id="dfef9-233">这里我们可以看到`Employees_Select`存储过程现在返回`ManagerFirstName`和`ManagerLastName`字段。</span><span class="sxs-lookup"><span data-stu-id="dfef9-233">Here we can see that the `Employees_Select` stored procedure now returns the `ManagerFirstName` and `ManagerLastName` fields.</span></span>


<span data-ttu-id="dfef9-234">[![该向导显示 Employees_Select 的更新的列列表存储过程](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-234">[![The Wizard Shows the Updated Column List for the Employees_Select Stored Procedure](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span></span>

<span data-ttu-id="dfef9-235">**图 10**:向导将显示为更新列列表`Employees_Select`存储过程 ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image26.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-235">**Figure 10**: The Wizard Shows the Updated Column List for the `Employees_Select` Stored Procedure ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image26.png))</span></span>


<span data-ttu-id="dfef9-236">单击完成完成向导。</span><span class="sxs-lookup"><span data-stu-id="dfef9-236">Complete the wizard by clicking Finish.</span></span> <span data-ttu-id="dfef9-237">在数据集设计器中，返回时`EmployeesDataTable`包含两个附加列：`ManagerFirstName`和`ManagerLastName`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-237">Upon returning to the DataSet Designer, the `EmployeesDataTable` includes two additional columns: `ManagerFirstName` and `ManagerLastName`.</span></span>


<span data-ttu-id="dfef9-238">[![EmployeesDataTable 包含两个新列](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-238">[![The EmployeesDataTable Contains Two New Columns](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span></span>

<span data-ttu-id="dfef9-239">**图 11**:`EmployeesDataTable`包含两个新列 ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image29.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-239">**Figure 11**: The `EmployeesDataTable` Contains Two New Columns ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image29.png))</span></span>


<span data-ttu-id="dfef9-240">为了说明这一点已更新`Employees_Select`实际上是存储的过程和插入、 更新和删除的 TableAdapter 的功能仍然正常工作，让我们来创建允许用户查看和删除员工的网页。</span><span class="sxs-lookup"><span data-stu-id="dfef9-240">To illustrate that the updated `Employees_Select` stored procedure is in effect and that the insert, update, and delete capabilities of the TableAdapter are still functional, let s create a web page that allows users to view and delete employees.</span></span> <span data-ttu-id="dfef9-241">在创建此类页面之前，但是，我们需要首先创建一个新类，用于处理从员工的业务逻辑层`NorthwindWithSprocs`数据集。</span><span class="sxs-lookup"><span data-stu-id="dfef9-241">Before we create such a page, however, we need to first create a new class in the Business Logic Layer for working with employees from the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="dfef9-242">在步骤 4 中，我们将创建`EmployeesBLLWithSprocs`类。</span><span class="sxs-lookup"><span data-stu-id="dfef9-242">In Step 4, we will create an `EmployeesBLLWithSprocs` class.</span></span> <span data-ttu-id="dfef9-243">在步骤 5 中，我们将使用此类的 ASP.NET 页中。</span><span class="sxs-lookup"><span data-stu-id="dfef9-243">In Step 5, we will use this class from an ASP.NET page.</span></span>

## <a name="step-4-implementing-the-business-logic-layer"></a><span data-ttu-id="dfef9-244">步骤 4：实现业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="dfef9-244">Step 4: Implementing the Business Logic Layer</span></span>

<span data-ttu-id="dfef9-245">创建新的类文件中`~/App_Code/BLL`文件夹名为`EmployeesBLLWithSprocs.cs`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-245">Create a new class file in the `~/App_Code/BLL` folder named `EmployeesBLLWithSprocs.cs`.</span></span> <span data-ttu-id="dfef9-246">此类模拟现有的语义`EmployeesBLL`类，仅这一新其中一个提供较少的方法，并使用`NorthwindWithSprocs`数据集 (而不是`Northwind`数据集)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-246">This class mimics the semantics of the existing `EmployeesBLL` class, only this new one provides fewer methods and uses the `NorthwindWithSprocs` DataSet (instead of the `Northwind` DataSet).</span></span> <span data-ttu-id="dfef9-247">向 `EmployeesBLLWithSprocs` 类添加下面的代码。</span><span class="sxs-lookup"><span data-stu-id="dfef9-247">Add the following code to the `EmployeesBLLWithSprocs` class.</span></span>


[!code-csharp[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample6.cs)]

<span data-ttu-id="dfef9-248">`EmployeesBLLWithSprocs`类 s`Adapter`属性返回的实例`NorthwindWithSprocs`数据集的`EmployeesTableAdapter`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-248">The `EmployeesBLLWithSprocs` class s `Adapter` property returns an instance of the `NorthwindWithSprocs` DataSet s `EmployeesTableAdapter`.</span></span> <span data-ttu-id="dfef9-249">这由类 s`GetEmployees`和`DeleteEmployee`方法。</span><span class="sxs-lookup"><span data-stu-id="dfef9-249">This is used by the class s `GetEmployees` and `DeleteEmployee` methods.</span></span> <span data-ttu-id="dfef9-250">`GetEmployees`方法调用`EmployeesTableAdapter`s 对应`GetEmployees`方法，调用`Employees_Select`存储过程，并填充其结果`EmployeeDataTable`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-250">The `GetEmployees` method calls the `EmployeesTableAdapter` s corresponding `GetEmployees` method, which invokes the `Employees_Select` stored procedure and populates its results in an `EmployeeDataTable`.</span></span> <span data-ttu-id="dfef9-251">`DeleteEmployee`同样调用方法`EmployeesTableAdapter`s`Delete`方法，调用`Employees_Delete`存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-251">The `DeleteEmployee` method similarly calls the `EmployeesTableAdapter` s `Delete` method, which invokes the `Employees_Delete` stored procedure.</span></span>

## <a name="step-5-working-with-the-data-in-the-presentation-layer"></a><span data-ttu-id="dfef9-252">步骤 5：使用表示层中的数据</span><span class="sxs-lookup"><span data-stu-id="dfef9-252">Step 5: Working with the Data in the Presentation Layer</span></span>

<span data-ttu-id="dfef9-253">使用`EmployeesBLLWithSprocs`类完成后，我们准备就绪后，可以使用通过 ASP.NET 页面的员工数据。</span><span class="sxs-lookup"><span data-stu-id="dfef9-253">With the `EmployeesBLLWithSprocs` class complete, we re ready to work with employee data through an ASP.NET page.</span></span> <span data-ttu-id="dfef9-254">打开`JOINs.aspx`页中`AdvancedDAL`文件夹，然后拖动 GridView 从工具箱拖到设计器中，设置其`ID`属性设置为`Employees`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-254">Open the `JOINs.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Employees`.</span></span> <span data-ttu-id="dfef9-255">接下来，从 GridView s 智能标记，将网格绑定到名为的新 ObjectDataSource 控件`EmployeesDataSource`。</span><span class="sxs-lookup"><span data-stu-id="dfef9-255">Next, from the GridView s smart tag, bind the grid to a new ObjectDataSource control named `EmployeesDataSource`.</span></span>

<span data-ttu-id="dfef9-256">配置要使用 ObjectDataSource`EmployeesBLLWithSprocs`类，并从选择和删除选项卡，确保`GetEmployees`和`DeleteEmployee`方法从下拉列表中选择。</span><span class="sxs-lookup"><span data-stu-id="dfef9-256">Configure the ObjectDataSource to use the `EmployeesBLLWithSprocs` class and, from the SELECT and DELETE tabs, ensure that the `GetEmployees` and `DeleteEmployee` methods are selected from the drop-down lists.</span></span> <span data-ttu-id="dfef9-257">单击完成以完成 ObjectDataSource 的配置。</span><span class="sxs-lookup"><span data-stu-id="dfef9-257">Click Finish to complete the ObjectDataSource s configuration.</span></span>


<span data-ttu-id="dfef9-258">[![配置对象数据源以使用 EmployeesBLLWithSprocs 类](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-258">[![Configure the ObjectDataSource to Use the EmployeesBLLWithSprocs Class](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span></span>

<span data-ttu-id="dfef9-259">**图 12**:配置为使用 ObjectDataSource`EmployeesBLLWithSprocs`类 ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image32.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-259">**Figure 12**: Configure the ObjectDataSource to Use the `EmployeesBLLWithSprocs` Class ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image32.png))</span></span>


<span data-ttu-id="dfef9-260">[![具有 ObjectDataSource 使用 GetEmployees 和 DeleteEmployee 方法](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-260">[![Have the ObjectDataSource Use the GetEmployees and DeleteEmployee Methods](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span></span>

<span data-ttu-id="dfef9-261">**图 13**:拥有 ObjectDataSource`GetEmployees`并`DeleteEmployee`方法 ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image35.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-261">**Figure 13**: Have the ObjectDataSource Use the `GetEmployees` and `DeleteEmployee` Methods ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image35.png))</span></span>


<span data-ttu-id="dfef9-262">Visual Studio 将为每个到 GridView 添加 BoundField`EmployeesDataTable`的列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-262">Visual Studio will add a BoundField to the GridView for each of the `EmployeesDataTable` s columns.</span></span> <span data-ttu-id="dfef9-263">删除所有这些 BoundFields 除外`Title`， `LastName`， `FirstName`， `ManagerFirstName`，并`ManagerLastName`重命名和`HeaderText`姓氏、 名字、 Manager s 的第一个名称，最后四个 BoundFields 属性和管理器 s 姓氏，分别。</span><span class="sxs-lookup"><span data-stu-id="dfef9-263">Remove all of these BoundFields except for `Title`, `LastName`, `FirstName`, `ManagerFirstName`, and `ManagerLastName` and rename the `HeaderText` properties for the last four BoundFields to Last Name, First Name, Manager s First Name, and Manager s Last Name, respectively.</span></span>

<span data-ttu-id="dfef9-264">若要允许用户从此页删除员工，我们需要做两件事。</span><span class="sxs-lookup"><span data-stu-id="dfef9-264">To allow users to delete employees from this page we need to do two things.</span></span> <span data-ttu-id="dfef9-265">首先，指示 GridView，通过检查其智能标记中的启用删除选项提供删除功能。</span><span class="sxs-lookup"><span data-stu-id="dfef9-265">First, instruct the GridView to provide deleting capabilities by checking the Enable Deleting option from its smart tag.</span></span> <span data-ttu-id="dfef9-266">其次，更改 ObjectDataSource s`OldValuesParameterFormatString`属性的值设置的对象数据源向导 (`original_{0}`) 为其默认值 (`{0}`)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-266">Second, change the ObjectDataSource s `OldValuesParameterFormatString` property from the value set by the ObjectDataSource wizard (`original_{0}`) to its default value (`{0}`).</span></span> <span data-ttu-id="dfef9-267">进行这些更改后，您 GridView 和 ObjectDataSource s 的声明性标记应类似于以下：</span><span class="sxs-lookup"><span data-stu-id="dfef9-267">After making these changes, your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample7.aspx)]

<span data-ttu-id="dfef9-268">通过浏览器访问测试页。</span><span class="sxs-lookup"><span data-stu-id="dfef9-268">Test out the page by visiting it through a browser.</span></span> <span data-ttu-id="dfef9-269">如图 14 所示，此页将列出每个雇员和他或她 manager s 名称 （假定他们具有一个）。</span><span class="sxs-lookup"><span data-stu-id="dfef9-269">As Figure 14 shows, the page will list each employee and his or her manager s name (assuming they have one).</span></span>


<span data-ttu-id="dfef9-270">[![在 Employees_Select 联接存储过程返回的管理器的名称](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-270">[![The JOIN in the Employees_Select Stored Procedure Returns the Manager s Name](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span></span>

<span data-ttu-id="dfef9-271">**图 14**:`JOIN`中`Employees_Select`存储过程返回的管理器名称 ([单击以查看实际尺寸的图像](updating-the-tableadapter-to-use-joins-cs/_static/image38.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-271">**Figure 14**: The `JOIN` in the `Employees_Select` Stored Procedure Returns the Manager s Name ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image38.png))</span></span>


<span data-ttu-id="dfef9-272">单击删除按钮启动删除工作流，最终会执行`Employees_Delete`存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-272">Clicking the Delete button starts the deleting workflow, which culminates in the execution of the `Employees_Delete` stored procedure.</span></span> <span data-ttu-id="dfef9-273">但是，尝试`DELETE`存储过程中的语句将因外键约束冲突而失败 （请参阅图 15）。</span><span class="sxs-lookup"><span data-stu-id="dfef9-273">However, the attempted `DELETE` statement in the stored procedure fails because of a foreign key constraint violation (see Figure 15).</span></span> <span data-ttu-id="dfef9-274">具体而言，每个雇员中具有一个或多个记录`Orders`表，导致删除失败。</span><span class="sxs-lookup"><span data-stu-id="dfef9-274">Specifically, each employee has one or more records in the `Orders` table, causing the delete to fail.</span></span>


<span data-ttu-id="dfef9-275">[![删除外键约束冲突中具有相应的订单结果的员工](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="dfef9-275">[![Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span></span>

<span data-ttu-id="dfef9-276">**图 15**:删除外键约束冲突中具有相应的订单结果的员工 ([单击此项可查看原尺寸图像](updating-the-tableadapter-to-use-joins-cs/_static/image41.png))</span><span class="sxs-lookup"><span data-stu-id="dfef9-276">**Figure 15**: Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image41.png))</span></span>


<span data-ttu-id="dfef9-277">若要允许员工要删除你可以：</span><span class="sxs-lookup"><span data-stu-id="dfef9-277">To allow an employee to be deleted you could:</span></span>

- <span data-ttu-id="dfef9-278">更新外键约束进行级联删除操作，</span><span class="sxs-lookup"><span data-stu-id="dfef9-278">Update the foreign key constraint to cascade deletes,</span></span>
- <span data-ttu-id="dfef9-279">从记录中手动删除`Orders`名员工想要删除的表或</span><span class="sxs-lookup"><span data-stu-id="dfef9-279">Manually delete the records from the `Orders` table for the employee(s) you want to delete, or</span></span>
- <span data-ttu-id="dfef9-280">更新`Employees_Delete`存储过程来首先删除相关的记录从`Orders`表，然后删除`Employees`记录。</span><span class="sxs-lookup"><span data-stu-id="dfef9-280">Update the `Employees_Delete` stored procedure to first delete the related records from the `Orders` table before deleting the `Employees` record.</span></span> <span data-ttu-id="dfef9-281">我们讨论了这一方法[使用现有存储过程的类型化数据集 s Tableadapter](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)教程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-281">We discussed this technique in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>

<span data-ttu-id="dfef9-282">我将此当作练习留给读者。</span><span class="sxs-lookup"><span data-stu-id="dfef9-282">I leave this as an exercise for the reader.</span></span>

## <a name="summary"></a><span data-ttu-id="dfef9-283">总结</span><span class="sxs-lookup"><span data-stu-id="dfef9-283">Summary</span></span>

<span data-ttu-id="dfef9-284">使用关系数据库时, 很常见的查询来提取其数据从多个相关的表。</span><span class="sxs-lookup"><span data-stu-id="dfef9-284">When working with relational databases, it is common for queries to pull their data from multiple, related tables.</span></span> <span data-ttu-id="dfef9-285">相关子查询和`JOIN`s 提供数据访问的查询中的相关表中的两个不同的技术。</span><span class="sxs-lookup"><span data-stu-id="dfef9-285">Correlated subqueries and `JOIN` s provide two different techniques for accessing data from related tables in a query.</span></span> <span data-ttu-id="dfef9-286">在前面的教程中我们最常进行使用的相关子查询，因为 TableAdapter 无法自动生成`INSERT`， `UPDATE`，并`DELETE`语句的查询涉及`JOIN`s。</span><span class="sxs-lookup"><span data-stu-id="dfef9-286">In previous tutorials we most commonly made use of correlated subqueries because the TableAdapter cannot auto-generate `INSERT`, `UPDATE`, and `DELETE` statements for queries involving `JOIN` s.</span></span> <span data-ttu-id="dfef9-287">虽然使用 TableAdapter 配置向导完成时，将覆盖任何自定义的临时 SQL 语句时，可以手动提供这些值。</span><span class="sxs-lookup"><span data-stu-id="dfef9-287">While these values can be provided manually, when using ad-hoc SQL statements any customizations will be overwritten when the TableAdapter Configuration wizard is completed.</span></span>

<span data-ttu-id="dfef9-288">幸运的是，Tableadapter 创建使用存储的过程不会遇到与使用临时 SQL 语句创建相同的受到攻击。</span><span class="sxs-lookup"><span data-stu-id="dfef9-288">Fortunately, TableAdapters created using stored procedures do not suffer from the same brittleness as those created using ad-hoc SQL statements.</span></span> <span data-ttu-id="dfef9-289">因此，则可创建使用其主查询的 TableAdapter`JOIN`时使用存储的过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-289">Therefore, it is feasible to create a TableAdapter whose main query uses a `JOIN` when using stored procedures.</span></span> <span data-ttu-id="dfef9-290">在本教程中我们已了解如何创建此类的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="dfef9-290">In this tutorial we saw how to create such a TableAdapter.</span></span> <span data-ttu-id="dfef9-291">我们通过使用启动`JOIN`-较少`SELECT`，以便相应的插入、 更新和删除存储过程会自动创建查询的 TableAdapter s 主查询。</span><span class="sxs-lookup"><span data-stu-id="dfef9-291">We started by using a `JOIN`-less `SELECT` query for the TableAdapter s main query so that the corresponding insert, update, and delete stored procedures would be auto-created.</span></span> <span data-ttu-id="dfef9-292">TableAdapter s 初始完成配置后，我们扩充`SelectCommand`存储过程来使用`JOIN`并重新运行 TableAdapter 配置向导以更新`EmployeesDataTable`的列。</span><span class="sxs-lookup"><span data-stu-id="dfef9-292">With the TableAdapter s initial configuration complete, we augmented the `SelectCommand` stored procedure to use a `JOIN` and re-ran the TableAdapter Configuration wizard to update the `EmployeesDataTable` s columns.</span></span>

<span data-ttu-id="dfef9-293">重新运行 TableAdapter 配置向导自动更新`EmployeesDataTable`列以反映返回的数据字段`Employees_Select`存储过程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-293">Re-running the TableAdapter Configuration wizard automatically updated the `EmployeesDataTable` columns to reflect the data fields returned by the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="dfef9-294">或者，我们可能具有这些列手动添加到 DataTable。</span><span class="sxs-lookup"><span data-stu-id="dfef9-294">Alternatively, we could have added these columns manually to the DataTable.</span></span> <span data-ttu-id="dfef9-295">我们将探索手动将列添加到 DataTable 中的下一步的教程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-295">We will explore manually adding columns to the DataTable in the next tutorial.</span></span>

<span data-ttu-id="dfef9-296">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="dfef9-296">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="dfef9-297">关于作者</span><span class="sxs-lookup"><span data-stu-id="dfef9-297">About the Author</span></span>

<span data-ttu-id="dfef9-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="dfef9-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="dfef9-299">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="dfef9-299">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="dfef9-300">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-300">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="dfef9-301">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="dfef9-301">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="dfef9-302">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="dfef9-302">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="dfef9-303">特别感谢</span><span class="sxs-lookup"><span data-stu-id="dfef9-303">Special Thanks To</span></span>

<span data-ttu-id="dfef9-304">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="dfef9-304">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="dfef9-305">本教程中的潜在顾客审阅者是 Hilton Geisenow、 David Suru 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="dfef9-305">Lead reviewers for this tutorial were Hilton Geisenow, David Suru, and Teresa Murphy.</span></span> <span data-ttu-id="dfef9-306">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="dfef9-306">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="dfef9-307">如果是这样，给我在行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="dfef9-307">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="dfef9-308">[上一页](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
> [下一页](adding-additional-datatable-columns-cs.md)</span><span class="sxs-lookup"><span data-stu-id="dfef9-308">[Previous](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
[Next](adding-additional-datatable-columns-cs.md)</span></span>

---
uid: web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
title: 更新 TableAdapter 以使用 Join （C#） |Microsoft Docs
author: rick-anderson
description: 使用数据库时，通常会请求分散在多个表中的数据。 若要从两个不同的表中检索数据，可以使用 。
ms.author: riande
ms.date: 07/18/2007
ms.assetid: 675531a7-cb54-4dd6-89ac-2636e4c285a5
msc.legacyurl: /web-forms/overview/data-access/advanced-data-access-scenarios/updating-the-tableadapter-to-use-joins-cs
msc.type: authoredcontent
ms.openlocfilehash: 24ff3645783dabfcdef5ac313a2d4833e4998efc
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74607890"
---
# <a name="updating-the-tableadapter-to-use-joins-c"></a><span data-ttu-id="017a5-104">更新 TableAdapter 以使用 JOIN (C#)</span><span class="sxs-lookup"><span data-stu-id="017a5-104">Updating the TableAdapter to Use JOINs (C#)</span></span>

<span data-ttu-id="017a5-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="017a5-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="017a5-106">[下载代码](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip)或[下载 PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="017a5-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_69_CS.zip) or [Download PDF](updating-the-tableadapter-to-use-joins-cs/_static/datatutorial69cs1.pdf)</span></span>

> <span data-ttu-id="017a5-107">使用数据库时，通常会请求分散在多个表中的数据。</span><span class="sxs-lookup"><span data-stu-id="017a5-107">When working with a database it is common to request data that is spread across multiple tables.</span></span> <span data-ttu-id="017a5-108">若要从两个不同的表中检索数据，可以使用相关子查询或联接运算。</span><span class="sxs-lookup"><span data-stu-id="017a5-108">To retrieve data from two different tables we can use either a correlated subquery or a JOIN operation.</span></span> <span data-ttu-id="017a5-109">在本教程中，我们将比较相关子查询和联接语法，然后查看如何创建在其主查询中包含联接的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-109">In this tutorial we compare correlated subqueries and the JOIN syntax before looking at how to create a TableAdapter that includes a JOIN in its main query.</span></span>

## <a name="introduction"></a><span data-ttu-id="017a5-110">简介</span><span class="sxs-lookup"><span data-stu-id="017a5-110">Introduction</span></span>

<span data-ttu-id="017a5-111">使用关系数据库时，我们感兴趣的数据通常分布在多个表中。</span><span class="sxs-lookup"><span data-stu-id="017a5-111">With relational databases the data we are interested in working with is often spread across multiple tables.</span></span> <span data-ttu-id="017a5-112">例如，在显示产品信息时，我们可能希望列出每个产品对应的类别和供应商的名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-112">For example, when displaying product information we likely want to list each product s corresponding category and supplier s names.</span></span> <span data-ttu-id="017a5-113">`Products` 表具有 `CategoryID` 和 `SupplierID` 值，但实际类别和供应商名称分别位于 `Categories` 表和 `Suppliers` 表中。</span><span class="sxs-lookup"><span data-stu-id="017a5-113">The `Products` table has `CategoryID` and `SupplierID` values, but the actual category and supplier names are in the `Categories` and `Suppliers` tables, respectively.</span></span>

<span data-ttu-id="017a5-114">若要从另一个相关表中检索信息，可以使用*相关子查询*或 *`JOIN`。*</span><span class="sxs-lookup"><span data-stu-id="017a5-114">To retrieve information from another, related table, we can either use *correlated subqueries* or `JOIN`*s*.</span></span> <span data-ttu-id="017a5-115">相关子查询是一个嵌套的 `SELECT` 查询，用于引用外部查询中的列。</span><span class="sxs-lookup"><span data-stu-id="017a5-115">A correlated subquery is a nested `SELECT` query that references columns in the outer query.</span></span> <span data-ttu-id="017a5-116">例如，在[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)教程中，我们在 `ProductsTableAdapter` s 主查询中使用两个相关子查询来返回每个产品的类别和供应商名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-116">For example, in the [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) tutorial we used two correlated subqueries in the `ProductsTableAdapter` s main query to return the category and supplier names for each product.</span></span> <span data-ttu-id="017a5-117">`JOIN` 是将两个不同表中的相关行合并在一起的 SQL 构造。</span><span class="sxs-lookup"><span data-stu-id="017a5-117">A `JOIN` is a SQL construct that merges related rows from two different tables.</span></span> <span data-ttu-id="017a5-118">我们在使用[SqlDataSource 控件查询数据](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md)中使用了 `JOIN`，以显示每个产品的类别信息。</span><span class="sxs-lookup"><span data-stu-id="017a5-118">We used a `JOIN` in the [Querying Data with the SqlDataSource Control](../accessing-the-database-directly-from-an-aspnet-page/querying-data-with-the-sqldatasource-control-cs.md) tutorial to display category information alongside each product.</span></span>

<span data-ttu-id="017a5-119">由于 TableAdapter s 向导中有一些用于自动生成相应 `INSERT`、`UPDATE`和 `DELETE` 语句的限制，我们 abstained 了与 Tableadapter 结合 `JOIN` 使用的原因。</span><span class="sxs-lookup"><span data-stu-id="017a5-119">The reason we have abstained from using `JOIN` s with the TableAdapters is because of limitations in the TableAdapter s wizard to auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements.</span></span> <span data-ttu-id="017a5-120">更具体地说，如果 TableAdapter 的主查询包含任何 `JOIN`，则 TableAdapter 无法自动为其 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性创建即席 SQL 语句或存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-120">More specifically, if the TableAdapter s main query contains any `JOIN` s, the TableAdapter cannot auto-create the ad-hoc SQL statements or stored procedures for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span>

<span data-ttu-id="017a5-121">在本教程中，我们将先比较并对比相关的子查询和 `JOIN`，然后再研究如何创建在其主查询中包含 `JOIN` 的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-121">In this tutorial we will briefly compare and contrast correlated subqueries and `JOIN` s before exploring how to create a TableAdapter that includes `JOIN` s in its main query.</span></span>

## <a name="comparing-and-contrasting-correlated-subqueries-andjoin-s"></a><span data-ttu-id="017a5-122">比较和对比相关子查询和`JOIN`</span><span class="sxs-lookup"><span data-stu-id="017a5-122">Comparing and Contrasting Correlated Subqueries and`JOIN` s</span></span>

<span data-ttu-id="017a5-123">请记住，在 `Northwind` 数据集的第一个教程中创建的 `ProductsTableAdapter` 使用相关子查询来返回每个产品的对应类别和供应商名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-123">Recall that the `ProductsTableAdapter` created in the first tutorial in the `Northwind` DataSet uses correlated subqueries to bring back each product s corresponding category and supplier name.</span></span> <span data-ttu-id="017a5-124">`ProductsTableAdapter` 的主查询如下所示。</span><span class="sxs-lookup"><span data-stu-id="017a5-124">The `ProductsTableAdapter` s main query is shown below.</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample1.sql)]

<span data-ttu-id="017a5-125">这两个相关子查询-`(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` 和 `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` `SELECT` 查询将每个产品返回单个值作为外部 `SELECT` 语句的列列表中的额外列。</span><span class="sxs-lookup"><span data-stu-id="017a5-125">The two correlated subqueries - `(SELECT CategoryName FROM Categories WHERE Categories.CategoryID = Products.CategoryID)` and `(SELECT CompanyName FROM Suppliers WHERE Suppliers.SupplierID = Products.SupplierID)` - are `SELECT` queries that return a single value per product as an additional column in the outer `SELECT` statement s column list.</span></span>

<span data-ttu-id="017a5-126">或者，可以使用 `JOIN` 返回每个产品的供应商和类别名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-126">Alternatively, a `JOIN` can be used to return each product s supplier and category name.</span></span> <span data-ttu-id="017a5-127">下面的查询返回与上述输出相同的输出，但使用 `JOIN` s 来代替子查询：</span><span class="sxs-lookup"><span data-stu-id="017a5-127">The following query returns the same output as the above one, but uses `JOIN` s in place of subqueries:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample2.sql)]

<span data-ttu-id="017a5-128">`JOIN` 根据某些条件将一个表中的记录与另一个表中的记录合并在一起。</span><span class="sxs-lookup"><span data-stu-id="017a5-128">A `JOIN` merges the records from one table with records from another table based on some criteria.</span></span> <span data-ttu-id="017a5-129">例如，在上面的查询中，`LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` 指示 SQL Server 将每个产品记录与类别记录合并，其 `CategoryID` 值与产品 `CategoryID` 值匹配。</span><span class="sxs-lookup"><span data-stu-id="017a5-129">In the above query, for example, the `LEFT JOIN Categories ON Categories.CategoryID = Products.CategoryID` instructs SQL Server to merge each product record with the category record whose `CategoryID` value matches the product s `CategoryID` value.</span></span> <span data-ttu-id="017a5-130">合并的结果允许我们处理每个产品（如 `CategoryName`）对应的类别字段。</span><span class="sxs-lookup"><span data-stu-id="017a5-130">The merged result allows us to work with the corresponding category fields for each product (such as `CategoryName`).</span></span>

> [!NOTE]
> <span data-ttu-id="017a5-131">在从关系数据库查询数据时，通常使用 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="017a5-131">`JOIN` s are commonly used when querying data from relational databases.</span></span> <span data-ttu-id="017a5-132">如果你不熟悉 `JOIN` 语法，或者需要在其使用时进行一次工作，我将在[W3 学校](http://www.w3schools.com/)上建议使用[SQL Join 教程](http://www.w3schools.com/sql/sql_join.asp)。</span><span class="sxs-lookup"><span data-stu-id="017a5-132">If you are new to the `JOIN` syntax or need to brush up a bit on its usage, I d recommend the [SQL Join tutorial](http://www.w3schools.com/sql/sql_join.asp) at [W3 Schools](http://www.w3schools.com/).</span></span> <span data-ttu-id="017a5-133">另请参阅[SQL 联机丛书](https://msdn.microsoft.com/library/ms130214.aspx)的[`JOIN` 基础知识](https://msdn.microsoft.com/library/ms191517.aspx)和[子查询基础](https://msdn.microsoft.com/library/ms189575.aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="017a5-133">Also worth reading are the [`JOIN` Fundamentals](https://msdn.microsoft.com/library/ms191517.aspx) and [Subquery Fundamentals](https://msdn.microsoft.com/library/ms189575.aspx) sections of the [SQL Books Online](https://msdn.microsoft.com/library/ms130214.aspx).</span></span>

<span data-ttu-id="017a5-134">由于 `JOIN` s 和相关子查询都可用于检索其他表中的相关数据，因此许多开发人员会将其外在优势，知道使用哪种方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-134">Since `JOIN` s and correlated subqueries can both be used to retrieve related data from other tables, many developers are left scratching their heads and wondering which approach to use.</span></span> <span data-ttu-id="017a5-135">我以前提到过的所有 SQL 专家都大致相同，因为 SQL Server 将产生大致完全相同的执行计划。</span><span class="sxs-lookup"><span data-stu-id="017a5-135">All of the SQL gurus I ve talked to have said roughly the same thing, that it doesn t really matter performance-wise as SQL Server will produce roughly identical execution plans.</span></span> <span data-ttu-id="017a5-136">他们的建议是使用您和您的团队最熟悉的方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-136">Their advice, then, is to use the technique that you and your team are most comfortable with.</span></span> <span data-ttu-id="017a5-137">值得一提的是，在 imparting 这一建议之后，这些专家会立即通过相关子查询表达 `JOIN` s 的首选项。</span><span class="sxs-lookup"><span data-stu-id="017a5-137">It merits noting that after imparting this advice these experts immediately express their preference of `JOIN` s over correlated subqueries.</span></span>

<span data-ttu-id="017a5-138">使用类型化数据集生成数据访问层时，这些工具在使用子查询时效果更佳。</span><span class="sxs-lookup"><span data-stu-id="017a5-138">When building a Data Access Layer using Typed DataSets, the tools work better when using subqueries.</span></span> <span data-ttu-id="017a5-139">特别是，当主查询包含任何 `JOIN` 时，TableAdapter s 向导不会自动生成相应的 `INSERT`、`UPDATE`和 `DELETE` 语句，但在使用相关子查询时将自动生成这些语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-139">In particular, the TableAdapter s wizard will not auto-generate corresponding `INSERT`, `UPDATE`, and `DELETE` statements if the main query contains any `JOIN` s, but will auto-generate these statements when correlated subqueries are used.</span></span>

<span data-ttu-id="017a5-140">若要探索这种缺点，请在 `~/App_Code/DAL` 文件夹中创建临时类型化数据集。</span><span class="sxs-lookup"><span data-stu-id="017a5-140">To explore this shortcoming, create a temporary Typed DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="017a5-141">在 "TableAdapter 配置向导" 中，选择使用即席 SQL 语句，并输入以下 `SELECT` 查询（请参阅图1）：</span><span class="sxs-lookup"><span data-stu-id="017a5-141">During the TableAdapter Configuration wizard, choose to use ad-hoc SQL statements and enter the following `SELECT` query (see Figure 1):</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample3.sql)]

<span data-ttu-id="017a5-142">[![输入包含联接的主查询](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-142">[![Enter a Main Query that Contains JOINs](updating-the-tableadapter-to-use-joins-cs/_static/image2.png)](updating-the-tableadapter-to-use-joins-cs/_static/image1.png)</span></span>

<span data-ttu-id="017a5-143">**图 1**：输入包含 `JOIN` s 的主查询（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-143">**Figure 1**: Enter a Main Query that Contains `JOIN` s ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image3.png))</span></span>

<span data-ttu-id="017a5-144">默认情况下，TableAdapter 会根据主查询自动创建 `INSERT`、`UPDATE`和 `DELETE` 语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-144">By default, the TableAdapter will automatically create `INSERT`, `UPDATE`, and `DELETE` statements based on the main query.</span></span> <span data-ttu-id="017a5-145">如果单击 "高级" 按钮，可以看到已启用此功能。</span><span class="sxs-lookup"><span data-stu-id="017a5-145">If you click the Advanced button you can see that this feature is enabled.</span></span> <span data-ttu-id="017a5-146">尽管有此设置，但 TableAdapter 将无法创建 `INSERT`、`UPDATE`和 `DELETE` 语句，因为主查询包含 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="017a5-146">Despite this setting, the TableAdapter will not be able to create the `INSERT`, `UPDATE`, and `DELETE` statements because the main query contains a `JOIN`.</span></span>

![输入包含联接的主查询](updating-the-tableadapter-to-use-joins-cs/_static/image4.png)

<span data-ttu-id="017a5-148">**图 2**：输入包含 `JOIN` s 的主查询</span><span class="sxs-lookup"><span data-stu-id="017a5-148">**Figure 2**: Enter a Main Query that Contains `JOIN` s</span></span>

<span data-ttu-id="017a5-149">单击“完成”按钮以完成向导。</span><span class="sxs-lookup"><span data-stu-id="017a5-149">Click Finish to complete the wizard.</span></span> <span data-ttu-id="017a5-150">此时，您的数据集设计器将包含单个 TableAdapter，其中每个字段对应于在 `SELECT` 查询的列列表中返回的每个字段。</span><span class="sxs-lookup"><span data-stu-id="017a5-150">At this point your DataSet s Designer will include a single TableAdapter with a DataTable with columns for each of the fields returned in the `SELECT` query s column list.</span></span> <span data-ttu-id="017a5-151">这包括 `CategoryName` 和 `SupplierName`，如图3所示。</span><span class="sxs-lookup"><span data-stu-id="017a5-151">This includes the `CategoryName` and `SupplierName`, as Figure 3 shows.</span></span>

![DataTable 包含列列表中返回的每个字段的列](updating-the-tableadapter-to-use-joins-cs/_static/image5.png)

<span data-ttu-id="017a5-153">**图 3**： DataTable 包含列列表中返回的每个字段的列</span><span class="sxs-lookup"><span data-stu-id="017a5-153">**Figure 3**: The DataTable Includes a Column for Each Field Returned in the Column List</span></span>

<span data-ttu-id="017a5-154">虽然 DataTable 具有相应的列，但 TableAdapter 缺少 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性的值。</span><span class="sxs-lookup"><span data-stu-id="017a5-154">While the DataTable has the appropriate columns, the TableAdapter lacks values for its `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties.</span></span> <span data-ttu-id="017a5-155">若要确认这一点，请在设计器中单击 TableAdapter，然后前往属性窗口。</span><span class="sxs-lookup"><span data-stu-id="017a5-155">To confirm this, click on the TableAdapter in the Designer and then go to the Properties window.</span></span> <span data-ttu-id="017a5-156">在这里，你将看到 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性设置为 "（无）"。</span><span class="sxs-lookup"><span data-stu-id="017a5-156">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are set to (None) .</span></span>

<span data-ttu-id="017a5-157">[![将 InsertCommand、UpdateCommand 和 DeleteCommand 属性设置为 "（无）"](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-157">[![The InsertCommand, UpdateCommand, and DeleteCommand Properties are Set to (None)](updating-the-tableadapter-to-use-joins-cs/_static/image7.png)](updating-the-tableadapter-to-use-joins-cs/_static/image6.png)</span></span>

<span data-ttu-id="017a5-158">**图 4**： "`InsertCommand`"、"`UpdateCommand`" 和 "`DeleteCommand`" 属性均设置为 "（无）" （[单击查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-158">**Figure 4**: The `InsertCommand`, `UpdateCommand`, and `DeleteCommand` Properties are Set to (None) ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image8.png))</span></span>

<span data-ttu-id="017a5-159">若要解决这种缺点，可以通过属性窗口为 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性手动提供 SQL 语句和参数。</span><span class="sxs-lookup"><span data-stu-id="017a5-159">To work around this shortcoming, we can manually provide the SQL statements and parameters for the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties via the Properties window.</span></span> <span data-ttu-id="017a5-160">或者，我们可以首先将 TableAdapter s 主查询配置为*不*包括任何 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="017a5-160">Alternatively, we could start by configuring the TableAdapter s main query to *not* include any `JOIN` s.</span></span> <span data-ttu-id="017a5-161">这将允许为我们自动生成 `INSERT`、`UPDATE`和 `DELETE` 语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-161">This will allow the `INSERT`, `UPDATE`, and `DELETE` statements to be auto-generated for us.</span></span> <span data-ttu-id="017a5-162">完成向导后，可以手动从属性窗口中更新 TableAdapter `SelectCommand`，使其包含 `JOIN` 语法。</span><span class="sxs-lookup"><span data-stu-id="017a5-162">After completing the wizard, we could then manually update the TableAdapter s `SelectCommand` from the Properties window so that it includes the `JOIN` syntax.</span></span>

<span data-ttu-id="017a5-163">虽然这种方法有效，但在使用即席 SQL 查询时非常脆弱，因为无论何时通过向导重新配置 TableAdapter s 主查询，都将重新创建自动生成的 `INSERT`、`UPDATE`和 `DELETE` 语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-163">While this approach works, it is very brittle when using ad-hoc SQL queries because any time the TableAdapter s main query is re-configured through the wizard, the auto-generated `INSERT`, `UPDATE`, and `DELETE` statements are recreated.</span></span> <span data-ttu-id="017a5-164">这意味着，如果右键单击 TableAdapter，从上下文菜单中选择 "配置"，则会丢失以后进行的所有自定义，并再次完成向导。</span><span class="sxs-lookup"><span data-stu-id="017a5-164">That means all of the customizations we later made would be lost if we right-clicked on the TableAdapter, chose Configure from the context menu, and completed the wizard again.</span></span>

<span data-ttu-id="017a5-165">TableAdapter 自动生成的 `INSERT`、`UPDATE`和 `DELETE` 语句的易受攻击，只限于即席 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-165">The brittleness of the TableAdapter s auto-generated `INSERT`, `UPDATE`, and `DELETE` statements is, fortunately, limited to ad-hoc SQL statements.</span></span> <span data-ttu-id="017a5-166">如果 TableAdapter 使用存储过程，则可以自定义 `SelectCommand`、`InsertCommand`、`UpdateCommand`或 `DeleteCommand` 存储过程，并重新运行 TableAdapter 配置向导，而不必担心将会修改存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-166">If your TableAdapter uses stored procedures, you can customize the `SelectCommand`, `InsertCommand`, `UpdateCommand`, or `DeleteCommand` stored procedures and re-run the TableAdapter Configuration wizard without having to fear that the stored procedures will be modified.</span></span>

<span data-ttu-id="017a5-167">在接下来的几个步骤中，我们将创建一个 TableAdapter，该 TableAdapter 最初使用省略任何 `JOIN` 的主查询，以便自动生成相应的 insert、update 和 delete 存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-167">Over the next several steps we will create a TableAdapter that, initially, uses a main query that omits any `JOIN` s so that the corresponding insert, update, and delete stored procedures will be auto-generated.</span></span> <span data-ttu-id="017a5-168">然后，将更新 `SelectCommand`，以便使用从相关表返回其他列的 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="017a5-168">We will then update the `SelectCommand` so that uses a `JOIN` that returns additional columns from related tables.</span></span> <span data-ttu-id="017a5-169">最后，我们将创建一个相应的业务逻辑层类，并演示如何在 ASP.NET 网页中使用 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-169">Finally, we'll create a corresponding Business Logic Layer class and demonstrate using the TableAdapter in an ASP.NET web page.</span></span>

## <a name="step-1-creating-the-tableadapter-using-a-simplified-main-query"></a><span data-ttu-id="017a5-170">步骤1：使用简化的主查询创建 TableAdapter</span><span class="sxs-lookup"><span data-stu-id="017a5-170">Step 1: Creating the TableAdapter Using a Simplified Main Query</span></span>

<span data-ttu-id="017a5-171">对于本教程，我们将为 `NorthwindWithSprocs` 数据集中的 `Employees` 表添加 TableAdapter 和强类型的 DataTable。</span><span class="sxs-lookup"><span data-stu-id="017a5-171">For this tutorial we will add a TableAdapter and strongly-typed DataTable for the `Employees` table in the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="017a5-172">`Employees` 表包含一个 `ReportsTo` 字段，该字段指定了员工经理 `EmployeeID`。</span><span class="sxs-lookup"><span data-stu-id="017a5-172">The `Employees` table contains a `ReportsTo` field that specified the `EmployeeID` of the employee s manager.</span></span> <span data-ttu-id="017a5-173">例如，employee Anne 刘天妮的 `ReportTo` 值为5，这是 Steven 的 `EmployeeID`。</span><span class="sxs-lookup"><span data-stu-id="017a5-173">For example, employee Anne Dodsworth has a `ReportTo` value of 5, which is the `EmployeeID` of Steven Buchanan.</span></span> <span data-ttu-id="017a5-174">因此，Anne 向 Steven （经理）报告。</span><span class="sxs-lookup"><span data-stu-id="017a5-174">Consequently, Anne reports to Steven, her manager.</span></span> <span data-ttu-id="017a5-175">除了报告每个员工 `ReportsTo` 值，我们可能还想要检索其经理的姓名。</span><span class="sxs-lookup"><span data-stu-id="017a5-175">Along with reporting each employee s `ReportsTo` value, we might also want to retrieve the name of their manager.</span></span> <span data-ttu-id="017a5-176">这可以使用 `JOIN`来实现。</span><span class="sxs-lookup"><span data-stu-id="017a5-176">This can be accomplished using a `JOIN`.</span></span> <span data-ttu-id="017a5-177">但在最初创建 TableAdapter 时使用 `JOIN` 会阻止向导自动生成相应的插入、更新和删除功能。</span><span class="sxs-lookup"><span data-stu-id="017a5-177">But using a `JOIN` when initially creating the TableAdapter precludes the wizard from automatically generating the corresponding insert, update, and delete capabilities.</span></span> <span data-ttu-id="017a5-178">因此，我们首先创建一个不包含任何 `JOIN` 的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-178">Therefore, we will start by creating a TableAdapter whose main query does not contain any `JOIN` s.</span></span> <span data-ttu-id="017a5-179">然后，在步骤2中，我们将更新主查询存储过程，以通过 `JOIN`检索管理器的名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-179">Then, in Step 2, we will update the main query stored procedure to retrieve the manager s name via a `JOIN`.</span></span>

<span data-ttu-id="017a5-180">首先打开 `~/App_Code/DAL` 文件夹中的 `NorthwindWithSprocs` 数据集。</span><span class="sxs-lookup"><span data-stu-id="017a5-180">Start by opening the `NorthwindWithSprocs` DataSet in the `~/App_Code/DAL` folder.</span></span> <span data-ttu-id="017a5-181">右键单击设计器，从上下文菜单中选择 "添加" 选项，然后选择 "TableAdapter" 菜单项。</span><span class="sxs-lookup"><span data-stu-id="017a5-181">Right-click on the Designer, select the Add option from the context menu, and pick the TableAdapter menu item.</span></span> <span data-ttu-id="017a5-182">这将启动 TableAdapter 配置向导。</span><span class="sxs-lookup"><span data-stu-id="017a5-182">This will launch the TableAdapter Configuration wizard.</span></span> <span data-ttu-id="017a5-183">如图5所示，让向导创建新的存储过程，然后单击 "下一步"。</span><span class="sxs-lookup"><span data-stu-id="017a5-183">As Figure 5 depicts, have the wizard create new stored procedures and click Next.</span></span> <span data-ttu-id="017a5-184">有关使用 TableAdapter s 向导创建新存储过程的复习，请参阅为[类型化数据集 tableadapter 教程创建新的存储过程](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)。</span><span class="sxs-lookup"><span data-stu-id="017a5-184">For a refresher on creating new stored procedures from the TableAdapter s wizard, consult the [Creating New Stored Procedures for the Typed DataSet s TableAdapters](creating-new-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>

<span data-ttu-id="017a5-185">[![选择 "创建新存储过程" 选项](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-185">[![Select the Create new stored procedures Option](updating-the-tableadapter-to-use-joins-cs/_static/image10.png)](updating-the-tableadapter-to-use-joins-cs/_static/image9.png)</span></span>

<span data-ttu-id="017a5-186">**图 5**：选择 "创建新存储过程" 选项（[单击以查看完全大小的映像](updating-the-tableadapter-to-use-joins-cs/_static/image11.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-186">**Figure 5**: Select the Create new stored procedures Option ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image11.png))</span></span>

<span data-ttu-id="017a5-187">对于 TableAdapter s 主查询使用以下 `SELECT` 语句：</span><span class="sxs-lookup"><span data-stu-id="017a5-187">Use the following `SELECT` statement for the TableAdapter s main query:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample4.sql)]

<span data-ttu-id="017a5-188">由于此查询不包含任何 `JOIN`，因此，TableAdapter 向导会自动创建具有相应 `INSERT`、`UPDATE`和 `DELETE` 语句的存储过程，以及用于执行主查询的存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-188">Since this query does not include any `JOIN` s, the TableAdapter wizard will automatically create stored procedures with corresponding `INSERT`, `UPDATE`, and `DELETE` statements, as well as a stored procedure for executing the main query.</span></span>

<span data-ttu-id="017a5-189">以下步骤使我们能够命名 TableAdapter 的存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-189">The following step allows us to name the TableAdapter s stored procedures.</span></span> <span data-ttu-id="017a5-190">使用名称 `Employees_Select`、`Employees_Insert`、`Employees_Update`和 `Employees_Delete`，如图6所示。</span><span class="sxs-lookup"><span data-stu-id="017a5-190">Use the names `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`, as shown in Figure 6.</span></span>

<span data-ttu-id="017a5-191">[![命名 TableAdapter 的存储过程](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-191">[![Name the TableAdapter s Stored Procedures](updating-the-tableadapter-to-use-joins-cs/_static/image13.png)](updating-the-tableadapter-to-use-joins-cs/_static/image12.png)</span></span>

<span data-ttu-id="017a5-192">**图 6**：命名 TableAdapter 的存储过程（[单击以查看完全大小的映像](updating-the-tableadapter-to-use-joins-cs/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-192">**Figure 6**: Name the TableAdapter s Stored Procedures ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image14.png))</span></span>

<span data-ttu-id="017a5-193">最后一个步骤提示我们命名 TableAdapter 的方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-193">The final step prompts us to name the TableAdapter s methods.</span></span> <span data-ttu-id="017a5-194">使用 `Fill` 和 `GetEmployees` 作为方法名称。</span><span class="sxs-lookup"><span data-stu-id="017a5-194">Use `Fill` and `GetEmployees` as the method names.</span></span> <span data-ttu-id="017a5-195">另外，请确保选中 "创建方法以将更新直接发送到数据库（GenerateDBDirectMethods）" 复选框。</span><span class="sxs-lookup"><span data-stu-id="017a5-195">Also be sure to leave the Create methods to send updates directly to the database (GenerateDBDirectMethods) checkbox checked.</span></span>

<span data-ttu-id="017a5-196">[![命名 TableAdapter s 方法 Fill 和 GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-196">[![Name the TableAdapter s Methods Fill and GetEmployees](updating-the-tableadapter-to-use-joins-cs/_static/image16.png)](updating-the-tableadapter-to-use-joins-cs/_static/image15.png)</span></span>

<span data-ttu-id="017a5-197">**图 7**：将 TableAdapter s 方法命名 `Fill` 和 `GetEmployees` （[单击以查看完全大小的映像](updating-the-tableadapter-to-use-joins-cs/_static/image17.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-197">**Figure 7**: Name the TableAdapter s Methods `Fill` and `GetEmployees` ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image17.png))</span></span>

<span data-ttu-id="017a5-198">完成向导后，请花点时间检查数据库中的存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-198">After completing the wizard, take a moment to examine the stored procedures in the database.</span></span> <span data-ttu-id="017a5-199">应该会看到四个新的文件： `Employees_Select`、`Employees_Insert`、`Employees_Update`和 `Employees_Delete`。</span><span class="sxs-lookup"><span data-stu-id="017a5-199">You should see four new ones: `Employees_Select`, `Employees_Insert`, `Employees_Update`, and `Employees_Delete`.</span></span> <span data-ttu-id="017a5-200">接下来，检查刚刚创建的 `EmployeesDataTable` 和 `EmployeesTableAdapter`。</span><span class="sxs-lookup"><span data-stu-id="017a5-200">Next, inspect the `EmployeesDataTable` and `EmployeesTableAdapter` just created.</span></span> <span data-ttu-id="017a5-201">对于主查询返回的每个字段，DataTable 都包含一个列。</span><span class="sxs-lookup"><span data-stu-id="017a5-201">The DataTable contains a column for each field returned by the main query.</span></span> <span data-ttu-id="017a5-202">单击 TableAdapter，然后中转到属性窗口。</span><span class="sxs-lookup"><span data-stu-id="017a5-202">Click on the TableAdapter and then go to the Properties window.</span></span> <span data-ttu-id="017a5-203">在这里，你将看到 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性正确配置为调用相应的存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-203">There you will see that the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties are correctly configured to call the corresponding stored procedures.</span></span>

<span data-ttu-id="017a5-204">[![TableAdapter 包含插入、更新和删除功能](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-204">[![The TableAdapter Includes Insert, Update, and Delete Capabilities](updating-the-tableadapter-to-use-joins-cs/_static/image19.png)](updating-the-tableadapter-to-use-joins-cs/_static/image18.png)</span></span>

<span data-ttu-id="017a5-205">**图 8**： TableAdapter 包含插入、更新和删除功能（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image20.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-205">**Figure 8**: The TableAdapter Includes Insert, Update, and Delete Capabilities ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image20.png))</span></span>

<span data-ttu-id="017a5-206">自动创建 insert、update 和 delete 存储过程并正确配置 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性后，我们就可以自定义 `SelectCommand` 的存储过程，以返回有关每个员工经理的其他信息。</span><span class="sxs-lookup"><span data-stu-id="017a5-206">With the insert, update, and delete stored procedures automatically created and the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties correctly configured, we are ready to customize the `SelectCommand` s stored procedure to return additional information about each employee s manager.</span></span> <span data-ttu-id="017a5-207">具体而言，我们需要更新 `Employees_Select` 存储过程以使用 `JOIN` 并返回 manager `FirstName` 和 `LastName` 值。</span><span class="sxs-lookup"><span data-stu-id="017a5-207">Specifically, we need to update the `Employees_Select` stored procedure to use a `JOIN` and return the manager s `FirstName` and `LastName` values.</span></span> <span data-ttu-id="017a5-208">在更新了存储过程后，我们将需要更新 DataTable，使其包含这些其他列。</span><span class="sxs-lookup"><span data-stu-id="017a5-208">After the stored procedure has been updated, we will need to update the DataTable so that it includes these additional columns.</span></span> <span data-ttu-id="017a5-209">我们将在步骤2和步骤3中处理这两个任务。</span><span class="sxs-lookup"><span data-stu-id="017a5-209">We'll tackle these two tasks in Steps 2 and 3.</span></span>

## <a name="step-2-customizing-the-stored-procedure-to-include-ajoin"></a><span data-ttu-id="017a5-210">步骤2：自定义存储过程以包含`JOIN`</span><span class="sxs-lookup"><span data-stu-id="017a5-210">Step 2: Customizing the Stored Procedure to Include a`JOIN`</span></span>

<span data-ttu-id="017a5-211">首先转到服务器资源管理器，向下钻取 Northwind 数据库的 "存储过程" 文件夹，并打开 `Employees_Select` 存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-211">Start by going to the Server Explorer, drilling down into the Northwind database s Stored Procedures folder, and opening the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="017a5-212">如果看不到此存储过程，请右键单击 "存储过程" 文件夹，然后选择 "刷新"。</span><span class="sxs-lookup"><span data-stu-id="017a5-212">If you do not see this stored procedure, right-click on the Stored Procedures folder and choose Refresh.</span></span> <span data-ttu-id="017a5-213">更新存储过程，使其使用 `LEFT JOIN` 返回经理的名字和姓氏：</span><span class="sxs-lookup"><span data-stu-id="017a5-213">Update the stored procedure so that it uses a `LEFT JOIN` to return the manager s first and last name:</span></span>

[!code-sql[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample5.sql)]

<span data-ttu-id="017a5-214">更新 `SELECT` 语句后，请转到 "文件" 菜单，然后选择 "保存 `Employees_Select`来保存更改。</span><span class="sxs-lookup"><span data-stu-id="017a5-214">After updating the `SELECT` statement, save the changes by going to the File menu and choosing Save `Employees_Select`.</span></span> <span data-ttu-id="017a5-215">此外，也可以单击工具栏中的 "保存" 图标或按 Ctrl + S。</span><span class="sxs-lookup"><span data-stu-id="017a5-215">Alternatively, you can click the Save icon in the toolbar or hit Ctrl+S.</span></span> <span data-ttu-id="017a5-216">保存更改后，右键单击服务器资源管理器中的 `Employees_Select` 存储过程，然后选择 "执行"。</span><span class="sxs-lookup"><span data-stu-id="017a5-216">After saving your changes, right-click on the `Employees_Select` stored procedure in the Server Explorer and choose Execute.</span></span> <span data-ttu-id="017a5-217">这将运行存储过程，并在输出窗口中显示其结果（参见图9）。</span><span class="sxs-lookup"><span data-stu-id="017a5-217">This will run the stored procedure and show its results in the Output window (see Figure 9).</span></span>

<span data-ttu-id="017a5-218">[![存储过程结果将显示在输出窗口](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-218">[![The Stored Procedures Results are Displayed in the Output Window](updating-the-tableadapter-to-use-joins-cs/_static/image22.png)](updating-the-tableadapter-to-use-joins-cs/_static/image21.png)</span></span>

<span data-ttu-id="017a5-219">**图 9**：存储过程结果显示在输出窗口中（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image23.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-219">**Figure 9**: The Stored Procedures Results are Displayed in the Output Window ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image23.png))</span></span>

## <a name="step-3-updating-the-datatable-s-columns"></a><span data-ttu-id="017a5-220">步骤3：更新 DataTable 列</span><span class="sxs-lookup"><span data-stu-id="017a5-220">Step 3: Updating the DataTable s Columns</span></span>

<span data-ttu-id="017a5-221">此时，`Employees_Select` 存储过程返回 `ManagerFirstName` 和 `ManagerLastName` 值，但 `EmployeesDataTable` 缺少这些列。</span><span class="sxs-lookup"><span data-stu-id="017a5-221">At this point, the `Employees_Select` stored procedure returns `ManagerFirstName` and `ManagerLastName` values, but the `EmployeesDataTable` is missing these columns.</span></span> <span data-ttu-id="017a5-222">可以通过以下两种方式之一将这些缺失列添加到 DataTable：</span><span class="sxs-lookup"><span data-stu-id="017a5-222">These missing columns can be added to the DataTable in one of two ways:</span></span>

- <span data-ttu-id="017a5-223">**手动**-在数据集设计器中右键单击 DataTable，然后从 "添加" 菜单中选择 "列"。</span><span class="sxs-lookup"><span data-stu-id="017a5-223">**Manually** - right-click on the DataTable in the DataSet Designer and, from the Add menu, choose Column.</span></span> <span data-ttu-id="017a5-224">然后，可以对该列命名并相应地设置其属性。</span><span class="sxs-lookup"><span data-stu-id="017a5-224">You can then name the column and set its properties accordingly.</span></span>
- <span data-ttu-id="017a5-225">**自动**-TableAdapter 配置向导将更新 DataTable 列以反映 `SelectCommand` 存储过程返回的字段。</span><span class="sxs-lookup"><span data-stu-id="017a5-225">**Automatically** - the TableAdapter Configuration wizard will update the DataTable s columns to reflect the fields returned by the `SelectCommand` stored procedure.</span></span> <span data-ttu-id="017a5-226">使用即席 SQL 语句时，向导还会删除 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 属性，因为 `SelectCommand` 现在包含 `JOIN`。</span><span class="sxs-lookup"><span data-stu-id="017a5-226">When using ad-hoc SQL statements, the wizard will also remove the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` properties since the `SelectCommand` now contains a `JOIN`.</span></span> <span data-ttu-id="017a5-227">但在使用存储过程时，这些命令属性会保持不变。</span><span class="sxs-lookup"><span data-stu-id="017a5-227">But when using stored procedures, these command properties remain intact.</span></span>

<span data-ttu-id="017a5-228">我们已经探讨了如何在前面的教程中手动添加 DataTable 列，包括使用带有详细信息 DataList 和[上传文件](../working-with-binary-files/uploading-files-cs.md)[的主记录的项目符号列表的母版/详细](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md)信息，我们将在下一教程中更详细地介绍此过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-228">We have explored manually adding DataTable columns in previous tutorials, including [Master/Detail Using a Bulleted List of Master Records with a Details DataList](../filtering-scenarios-with-the-datalist-and-repeater/master-detail-using-a-bulleted-list-of-master-records-with-a-details-datalist-cs.md) and [Uploading Files](../working-with-binary-files/uploading-files-cs.md), and we will look at this process again in more detail in our next tutorial.</span></span> <span data-ttu-id="017a5-229">但对于本教程，让我们通过 TableAdapter 配置向导使用自动方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-229">For this tutorial, however, let s use the automatic approach via the TableAdapter Configuration wizard.</span></span>

<span data-ttu-id="017a5-230">首先右键单击 "`EmployeesTableAdapter`"，然后从上下文菜单中选择 "配置"。</span><span class="sxs-lookup"><span data-stu-id="017a5-230">Start by right-clicking on the `EmployeesTableAdapter` and selecting Configure from the context menu.</span></span> <span data-ttu-id="017a5-231">这将打开 "TableAdapter 配置向导"，其中列出了用于选择、插入、更新和删除的存储过程，以及它们的返回值和参数（如果有）。</span><span class="sxs-lookup"><span data-stu-id="017a5-231">This brings up the TableAdapter Configuration wizard, which lists the stored procedures used for selecting, inserting, updating, and deleting, along with their return values and parameters (if any).</span></span> <span data-ttu-id="017a5-232">图10显示了此向导。</span><span class="sxs-lookup"><span data-stu-id="017a5-232">Figure 10 shows this wizard.</span></span> <span data-ttu-id="017a5-233">这里，我们可以看到 `Employees_Select` 存储过程现在返回 `ManagerFirstName` 和 `ManagerLastName` 字段。</span><span class="sxs-lookup"><span data-stu-id="017a5-233">Here we can see that the `Employees_Select` stored procedure now returns the `ManagerFirstName` and `ManagerLastName` fields.</span></span>

<span data-ttu-id="017a5-234">[![向导显示 Employees_Select 存储过程的已更新列列表](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-234">[![The Wizard Shows the Updated Column List for the Employees_Select Stored Procedure](updating-the-tableadapter-to-use-joins-cs/_static/image25.png)](updating-the-tableadapter-to-use-joins-cs/_static/image24.png)</span></span>

<span data-ttu-id="017a5-235">**图 10**：向导显示 `Employees_Select` 存储过程的已更新列列表（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image26.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-235">**Figure 10**: The Wizard Shows the Updated Column List for the `Employees_Select` Stored Procedure ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image26.png))</span></span>

<span data-ttu-id="017a5-236">单击 "完成" 完成向导。</span><span class="sxs-lookup"><span data-stu-id="017a5-236">Complete the wizard by clicking Finish.</span></span> <span data-ttu-id="017a5-237">返回到数据集设计器后，`EmployeesDataTable` 包括另外两列： `ManagerFirstName` 和 `ManagerLastName`。</span><span class="sxs-lookup"><span data-stu-id="017a5-237">Upon returning to the DataSet Designer, the `EmployeesDataTable` includes two additional columns: `ManagerFirstName` and `ManagerLastName`.</span></span>

<span data-ttu-id="017a5-238">[![EmployeesDataTable 包含两个新列](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-238">[![The EmployeesDataTable Contains Two New Columns](updating-the-tableadapter-to-use-joins-cs/_static/image28.png)](updating-the-tableadapter-to-use-joins-cs/_static/image27.png)</span></span>

<span data-ttu-id="017a5-239">**图 11**： `EmployeesDataTable` 包含两个新列（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image29.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-239">**Figure 11**: The `EmployeesDataTable` Contains Two New Columns ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image29.png))</span></span>

<span data-ttu-id="017a5-240">为了说明更新后的 `Employees_Select` 存储过程是否有效，并且 TableAdapter 的插入、更新和删除功能仍可正常工作，让我们创建一个允许用户查看和删除员工的网页。</span><span class="sxs-lookup"><span data-stu-id="017a5-240">To illustrate that the updated `Employees_Select` stored procedure is in effect and that the insert, update, and delete capabilities of the TableAdapter are still functional, let s create a web page that allows users to view and delete employees.</span></span> <span data-ttu-id="017a5-241">但在创建此类页面之前，我们需要先在业务逻辑层中创建一个新类，以便与 `NorthwindWithSprocs` 数据集中的员工合作。</span><span class="sxs-lookup"><span data-stu-id="017a5-241">Before we create such a page, however, we need to first create a new class in the Business Logic Layer for working with employees from the `NorthwindWithSprocs` DataSet.</span></span> <span data-ttu-id="017a5-242">在步骤4中，我们将创建一个 `EmployeesBLLWithSprocs` 类。</span><span class="sxs-lookup"><span data-stu-id="017a5-242">In Step 4, we will create an `EmployeesBLLWithSprocs` class.</span></span> <span data-ttu-id="017a5-243">在步骤5中，我们将从 ASP.NET 页面使用此类。</span><span class="sxs-lookup"><span data-stu-id="017a5-243">In Step 5, we will use this class from an ASP.NET page.</span></span>

## <a name="step-4-implementing-the-business-logic-layer"></a><span data-ttu-id="017a5-244">步骤4：实现业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="017a5-244">Step 4: Implementing the Business Logic Layer</span></span>

<span data-ttu-id="017a5-245">在名为 `EmployeesBLLWithSprocs.cs`的 `~/App_Code/BLL` 文件夹中创建一个新的类文件。</span><span class="sxs-lookup"><span data-stu-id="017a5-245">Create a new class file in the `~/App_Code/BLL` folder named `EmployeesBLLWithSprocs.cs`.</span></span> <span data-ttu-id="017a5-246">此类模仿现有 `EmployeesBLL` 类的语义，只有这一新的类提供的方法更少，并使用 `NorthwindWithSprocs` 数据集（而不是 `Northwind` 数据集）。</span><span class="sxs-lookup"><span data-stu-id="017a5-246">This class mimics the semantics of the existing `EmployeesBLL` class, only this new one provides fewer methods and uses the `NorthwindWithSprocs` DataSet (instead of the `Northwind` DataSet).</span></span> <span data-ttu-id="017a5-247">向 `EmployeesBLLWithSprocs` 类添加下面的代码。</span><span class="sxs-lookup"><span data-stu-id="017a5-247">Add the following code to the `EmployeesBLLWithSprocs` class.</span></span>

[!code-csharp[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample6.cs)]

<span data-ttu-id="017a5-248">`EmployeesBLLWithSprocs` 类 `Adapter` 属性返回 `NorthwindWithSprocs` 数据集 `EmployeesTableAdapter`的实例。</span><span class="sxs-lookup"><span data-stu-id="017a5-248">The `EmployeesBLLWithSprocs` class s `Adapter` property returns an instance of the `NorthwindWithSprocs` DataSet s `EmployeesTableAdapter`.</span></span> <span data-ttu-id="017a5-249">该类 `GetEmployees` 和 `DeleteEmployee` 方法使用此方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-249">This is used by the class s `GetEmployees` and `DeleteEmployee` methods.</span></span> <span data-ttu-id="017a5-250">`GetEmployees` 方法调用对应于 `EmployeesTableAdapter` s 的 `GetEmployees` 方法，该方法调用 `Employees_Select` 存储过程，并在 `EmployeeDataTable`中填充其结果。</span><span class="sxs-lookup"><span data-stu-id="017a5-250">The `GetEmployees` method calls the `EmployeesTableAdapter` s corresponding `GetEmployees` method, which invokes the `Employees_Select` stored procedure and populates its results in an `EmployeeDataTable`.</span></span> <span data-ttu-id="017a5-251">`DeleteEmployee` 方法类似地调用 `EmployeesTableAdapter` s `Delete` 方法，该方法调用 `Employees_Delete` 存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-251">The `DeleteEmployee` method similarly calls the `EmployeesTableAdapter` s `Delete` method, which invokes the `Employees_Delete` stored procedure.</span></span>

## <a name="step-5-working-with-the-data-in-the-presentation-layer"></a><span data-ttu-id="017a5-252">步骤5：使用表示层中的数据</span><span class="sxs-lookup"><span data-stu-id="017a5-252">Step 5: Working with the Data in the Presentation Layer</span></span>

<span data-ttu-id="017a5-253">`EmployeesBLLWithSprocs` 类完成后，我们就可以通过 ASP.NET 页面来处理员工数据。</span><span class="sxs-lookup"><span data-stu-id="017a5-253">With the `EmployeesBLLWithSprocs` class complete, we re ready to work with employee data through an ASP.NET page.</span></span> <span data-ttu-id="017a5-254">打开 `AdvancedDAL` 文件夹中的 "`JOINs.aspx`" 页，然后将 GridView 从工具箱拖动到设计器上，并将其 `ID` 属性设置为 "`Employees`"。</span><span class="sxs-lookup"><span data-stu-id="017a5-254">Open the `JOINs.aspx` page in the `AdvancedDAL` folder and drag a GridView from the Toolbox onto the Designer, setting its `ID` property to `Employees`.</span></span> <span data-ttu-id="017a5-255">接下来，从 GridView s 智能标记将网格绑定到名为 `EmployeesDataSource`的新 ObjectDataSource 控件。</span><span class="sxs-lookup"><span data-stu-id="017a5-255">Next, from the GridView s smart tag, bind the grid to a new ObjectDataSource control named `EmployeesDataSource`.</span></span>

<span data-ttu-id="017a5-256">将 ObjectDataSource 配置为使用 `EmployeesBLLWithSprocs` 类，并从 "选择" 和 "删除" 选项卡中，确保从下拉列表中选择 `GetEmployees` 和 `DeleteEmployee` 方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-256">Configure the ObjectDataSource to use the `EmployeesBLLWithSprocs` class and, from the SELECT and DELETE tabs, ensure that the `GetEmployees` and `DeleteEmployee` methods are selected from the drop-down lists.</span></span> <span data-ttu-id="017a5-257">单击 "完成" 以完成 ObjectDataSource 配置。</span><span class="sxs-lookup"><span data-stu-id="017a5-257">Click Finish to complete the ObjectDataSource s configuration.</span></span>

<span data-ttu-id="017a5-258">[![将 ObjectDataSource 配置为使用 EmployeesBLLWithSprocs 类](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-258">[![Configure the ObjectDataSource to Use the EmployeesBLLWithSprocs Class](updating-the-tableadapter-to-use-joins-cs/_static/image31.png)](updating-the-tableadapter-to-use-joins-cs/_static/image30.png)</span></span>

<span data-ttu-id="017a5-259">**图 12**：将 ObjectDataSource 配置为使用 `EmployeesBLLWithSprocs` 类（[单击以查看完全大小的映像](updating-the-tableadapter-to-use-joins-cs/_static/image32.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-259">**Figure 12**: Configure the ObjectDataSource to Use the `EmployeesBLLWithSprocs` Class ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image32.png))</span></span>

<span data-ttu-id="017a5-260">[![让 ObjectDataSource 使用 GetEmployees 和 DeleteEmployee 方法](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-260">[![Have the ObjectDataSource Use the GetEmployees and DeleteEmployee Methods](updating-the-tableadapter-to-use-joins-cs/_static/image34.png)](updating-the-tableadapter-to-use-joins-cs/_static/image33.png)</span></span>

<span data-ttu-id="017a5-261">**图 13**：使 ObjectDataSource 使用 `GetEmployees` 和 `DeleteEmployee` 方法（[单击查看完全大小的映像](updating-the-tableadapter-to-use-joins-cs/_static/image35.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-261">**Figure 13**: Have the ObjectDataSource Use the `GetEmployees` and `DeleteEmployee` Methods ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image35.png))</span></span>

<span data-ttu-id="017a5-262">对于每个 `EmployeesDataTable` s 列，Visual Studio 会将 BoundField 添加到 GridView。</span><span class="sxs-lookup"><span data-stu-id="017a5-262">Visual Studio will add a BoundField to the GridView for each of the `EmployeesDataTable` s columns.</span></span> <span data-ttu-id="017a5-263">删除所有这些 BoundFields （`Title`、`LastName`、`FirstName`、`ManagerFirstName`和 `ManagerLastName` 除外），并分别重命名最后四个 BoundFields 到 "姓"、"名字"、"经理"、"名字" 和 "经理姓氏" 的 `HeaderText` 属性。</span><span class="sxs-lookup"><span data-stu-id="017a5-263">Remove all of these BoundFields except for `Title`, `LastName`, `FirstName`, `ManagerFirstName`, and `ManagerLastName` and rename the `HeaderText` properties for the last four BoundFields to Last Name, First Name, Manager s First Name, and Manager s Last Name, respectively.</span></span>

<span data-ttu-id="017a5-264">若要允许用户从此页中删除员工，需要执行两项操作。</span><span class="sxs-lookup"><span data-stu-id="017a5-264">To allow users to delete employees from this page we need to do two things.</span></span> <span data-ttu-id="017a5-265">首先，通过选中 "启用从其智能标记中删除" 选项来指示 GridView 提供删除功能。</span><span class="sxs-lookup"><span data-stu-id="017a5-265">First, instruct the GridView to provide deleting capabilities by checking the Enable Deleting option from its smart tag.</span></span> <span data-ttu-id="017a5-266">其次，将 ObjectDataSource `OldValuesParameterFormatString` 属性从 ObjectDataSource 向导（`original_{0}`）设置的值更改为其默认值（`{0}`）。</span><span class="sxs-lookup"><span data-stu-id="017a5-266">Second, change the ObjectDataSource s `OldValuesParameterFormatString` property from the value set by the ObjectDataSource wizard (`original_{0}`) to its default value (`{0}`).</span></span> <span data-ttu-id="017a5-267">进行这些更改后，GridView 和 ObjectDataSource 的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="017a5-267">After making these changes, your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](updating-the-tableadapter-to-use-joins-cs/samples/sample7.aspx)]

<span data-ttu-id="017a5-268">通过浏览器访问页面，对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="017a5-268">Test out the page by visiting it through a browser.</span></span> <span data-ttu-id="017a5-269">如图14所示，此页将列出每个员工及其经理的姓名（假设他们有一个）。</span><span class="sxs-lookup"><span data-stu-id="017a5-269">As Figure 14 shows, the page will list each employee and his or her manager s name (assuming they have one).</span></span>

<span data-ttu-id="017a5-270">[![Employees_Select 存储过程中的联接返回管理器的名称](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-270">[![The JOIN in the Employees_Select Stored Procedure Returns the Manager s Name](updating-the-tableadapter-to-use-joins-cs/_static/image37.png)](updating-the-tableadapter-to-use-joins-cs/_static/image36.png)</span></span>

<span data-ttu-id="017a5-271">**图 14**： `Employees_Select` 存储过程中的 `JOIN` 返回经理的名称（[单击查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image38.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-271">**Figure 14**: The `JOIN` in the `Employees_Select` Stored Procedure Returns the Manager s Name ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image38.png))</span></span>

<span data-ttu-id="017a5-272">单击 "删除" 按钮将启动删除工作流，该工作流落执行 `Employees_Delete` 存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-272">Clicking the Delete button starts the deleting workflow, which culminates in the execution of the `Employees_Delete` stored procedure.</span></span> <span data-ttu-id="017a5-273">但是，由于外键约束冲突，存储过程中尝试的 `DELETE` 语句将失败（请参见图15）。</span><span class="sxs-lookup"><span data-stu-id="017a5-273">However, the attempted `DELETE` statement in the stored procedure fails because of a foreign key constraint violation (see Figure 15).</span></span> <span data-ttu-id="017a5-274">具体而言，每个员工都有 `Orders` 表中的一条或多条记录，导致删除失败。</span><span class="sxs-lookup"><span data-stu-id="017a5-274">Specifically, each employee has one or more records in the `Orders` table, causing the delete to fail.</span></span>

<span data-ttu-id="017a5-275">[删除具有相应订单的员工将导致外键约束冲突 ![](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span><span class="sxs-lookup"><span data-stu-id="017a5-275">[![Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation](updating-the-tableadapter-to-use-joins-cs/_static/image40.png)](updating-the-tableadapter-to-use-joins-cs/_static/image39.png)</span></span>

<span data-ttu-id="017a5-276">**图 15**：删除具有相应订单的员工将导致外键约束冲突（[单击以查看完全大小的图像](updating-the-tableadapter-to-use-joins-cs/_static/image41.png)）</span><span class="sxs-lookup"><span data-stu-id="017a5-276">**Figure 15**: Deleting an Employee That has Corresponding Orders Results in a Foreign Key Constraint Violation ([Click to view full-size image](updating-the-tableadapter-to-use-joins-cs/_static/image41.png))</span></span>

<span data-ttu-id="017a5-277">若要允许删除员工，可以执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="017a5-277">To allow an employee to be deleted you could:</span></span>

- <span data-ttu-id="017a5-278">将 foreign key 约束更新为级联删除，</span><span class="sxs-lookup"><span data-stu-id="017a5-278">Update the foreign key constraint to cascade deletes,</span></span>
- <span data-ttu-id="017a5-279">对于要删除的员工，请从 `Orders` 表中手动删除记录，或</span><span class="sxs-lookup"><span data-stu-id="017a5-279">Manually delete the records from the `Orders` table for the employee(s) you want to delete, or</span></span>
- <span data-ttu-id="017a5-280">更新 `Employees_Delete` 存储过程，以先删除 `Orders` 表中的相关记录，然后再删除 `Employees` 记录。</span><span class="sxs-lookup"><span data-stu-id="017a5-280">Update the `Employees_Delete` stored procedure to first delete the related records from the `Orders` table before deleting the `Employees` record.</span></span> <span data-ttu-id="017a5-281">我们在[使用类型化数据集 s tableadapter 教程的现有存储过程](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)中讨论了这一方法。</span><span class="sxs-lookup"><span data-stu-id="017a5-281">We discussed this technique in the [Using Existing Stored Procedures for the Typed DataSet s TableAdapters](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md) tutorial.</span></span>

<span data-ttu-id="017a5-282">我将此留给读者的练习。</span><span class="sxs-lookup"><span data-stu-id="017a5-282">I leave this as an exercise for the reader.</span></span>

## <a name="summary"></a><span data-ttu-id="017a5-283">总结</span><span class="sxs-lookup"><span data-stu-id="017a5-283">Summary</span></span>

<span data-ttu-id="017a5-284">使用关系数据库时，查询通常会从多个相关表中提取数据。</span><span class="sxs-lookup"><span data-stu-id="017a5-284">When working with relational databases, it is common for queries to pull their data from multiple, related tables.</span></span> <span data-ttu-id="017a5-285">相关子查询和 `JOIN` 提供了两种不同的方法，可用于从查询中的相关表访问数据。</span><span class="sxs-lookup"><span data-stu-id="017a5-285">Correlated subqueries and `JOIN` s provide two different techniques for accessing data from related tables in a query.</span></span> <span data-ttu-id="017a5-286">在前面的教程中，我们最常使用相关子查询，因为 TableAdapter 无法自动生成涉及 `JOIN` 的查询 `INSERT`、`UPDATE`和 `DELETE` 语句。</span><span class="sxs-lookup"><span data-stu-id="017a5-286">In previous tutorials we most commonly made use of correlated subqueries because the TableAdapter cannot auto-generate `INSERT`, `UPDATE`, and `DELETE` statements for queries involving `JOIN` s.</span></span> <span data-ttu-id="017a5-287">尽管可以手动提供这些值，但使用即席 SQL 语句时，在完成 TableAdapter 配置向导时，将覆盖任何自定义项。</span><span class="sxs-lookup"><span data-stu-id="017a5-287">While these values can be provided manually, when using ad-hoc SQL statements any customizations will be overwritten when the TableAdapter Configuration wizard is completed.</span></span>

<span data-ttu-id="017a5-288">幸运的是，使用存储过程创建的 Tableadapter 不会受到使用即席 SQL 语句创建的易受攻击。</span><span class="sxs-lookup"><span data-stu-id="017a5-288">Fortunately, TableAdapters created using stored procedures do not suffer from the same brittleness as those created using ad-hoc SQL statements.</span></span> <span data-ttu-id="017a5-289">因此，在使用存储过程时，可以创建一个其主查询使用 `JOIN` 的 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-289">Therefore, it is feasible to create a TableAdapter whose main query uses a `JOIN` when using stored procedures.</span></span> <span data-ttu-id="017a5-290">在本教程中，我们介绍了如何创建此类 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="017a5-290">In this tutorial we saw how to create such a TableAdapter.</span></span> <span data-ttu-id="017a5-291">我们开始使用用于 TableAdapter s 查询的无 `JOIN``SELECT` 查询，以便自动创建相应的 insert、update 和 delete 存储过程。</span><span class="sxs-lookup"><span data-stu-id="017a5-291">We started by using a `JOIN`-less `SELECT` query for the TableAdapter s main query so that the corresponding insert, update, and delete stored procedures would be auto-created.</span></span> <span data-ttu-id="017a5-292">完成 TableAdapter 的初始配置后，我们增加了 `SelectCommand` 存储过程以使用 `JOIN`，并重新运行了 TableAdapter 配置向导来更新 `EmployeesDataTable` 的列。</span><span class="sxs-lookup"><span data-stu-id="017a5-292">With the TableAdapter s initial configuration complete, we augmented the `SelectCommand` stored procedure to use a `JOIN` and re-ran the TableAdapter Configuration wizard to update the `EmployeesDataTable` s columns.</span></span>

<span data-ttu-id="017a5-293">重新运行 TableAdapter 配置向导会自动更新 `EmployeesDataTable` 列，以反映 `Employees_Select` 存储过程返回的数据字段。</span><span class="sxs-lookup"><span data-stu-id="017a5-293">Re-running the TableAdapter Configuration wizard automatically updated the `EmployeesDataTable` columns to reflect the data fields returned by the `Employees_Select` stored procedure.</span></span> <span data-ttu-id="017a5-294">另外，我们还可以将这些列手动添加到 DataTable。</span><span class="sxs-lookup"><span data-stu-id="017a5-294">Alternatively, we could have added these columns manually to the DataTable.</span></span> <span data-ttu-id="017a5-295">在下一教程中，我们将探讨如何手动将列添加到 DataTable。</span><span class="sxs-lookup"><span data-stu-id="017a5-295">We will explore manually adding columns to the DataTable in the next tutorial.</span></span>

<span data-ttu-id="017a5-296">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="017a5-296">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="017a5-297">关于作者</span><span class="sxs-lookup"><span data-stu-id="017a5-297">About the Author</span></span>

<span data-ttu-id="017a5-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="017a5-298">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="017a5-299">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="017a5-299">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="017a5-300">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="017a5-300">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="017a5-301">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="017a5-301">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="017a5-302">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="017a5-302">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="017a5-303">特别感谢</span><span class="sxs-lookup"><span data-stu-id="017a5-303">Special Thanks To</span></span>

<span data-ttu-id="017a5-304">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="017a5-304">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="017a5-305">本教程的领导评审者是 Hilton Geisenow、David Suru 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="017a5-305">Lead reviewers for this tutorial were Hilton Geisenow, David Suru, and Teresa Murphy.</span></span> <span data-ttu-id="017a5-306">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="017a5-306">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="017a5-307">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="017a5-307">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="017a5-308">[上一页](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
> [下一页](adding-additional-datatable-columns-cs.md)</span><span class="sxs-lookup"><span data-stu-id="017a5-308">[Previous](using-existing-stored-procedures-for-the-typed-dataset-s-tableadapters-cs.md)
[Next](adding-additional-datatable-columns-cs.md)</span></span>

---
uid: web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
title: 包装事务 (C#) 内的数据库修改 |Microsoft Docs
author: rick-anderson
description: 本教程是四个查看更新、 删除和插入数据的批处理的第一个。 在本教程中我们了解如何允许数据库事务...
ms.author: riande
ms.date: 06/26/2007
ms.assetid: b45fede3-c53a-4ea1-824b-20200808dbae
msc.legacyurl: /web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-cs
msc.type: authoredcontent
ms.openlocfilehash: ab1ffa147545ab0d4fa0a3cce6f7dca91dfe3ffb
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/01/2019
ms.locfileid: "57026524"
---
<a name="wrapping-database-modifications-within-a-transaction-c"></a><span data-ttu-id="8d5d3-104">包装事务内的数据库修改 (C#)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-104">Wrapping Database Modifications within a Transaction (C#)</span></span>
====================
<span data-ttu-id="8d5d3-105">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="8d5d3-106">[下载代码](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_CS.zip)或[下载 PDF](wrapping-database-modifications-within-a-transaction-cs/_static/datatutorial63cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-106">[Download Code](http://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_CS.zip) or [Download PDF](wrapping-database-modifications-within-a-transaction-cs/_static/datatutorial63cs1.pdf)</span></span>

> <span data-ttu-id="8d5d3-107">本教程是四个查看更新、 删除和插入数据的批处理的第一个。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-107">This tutorial is the first of four that looks at updating, deleting, and inserting batches of data.</span></span> <span data-ttu-id="8d5d3-108">在本教程中我们了解如何数据库事务允许批处理的修改来执行作为一个原子操作，以确保所有步骤都成功或失败的所有步骤。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-108">In this tutorial we learn how database transactions allow batch modifications to be carried out as an atomic operation, which ensures that either all steps succeed or all steps fail.</span></span>


## <a name="introduction"></a><span data-ttu-id="8d5d3-109">介绍</span><span class="sxs-lookup"><span data-stu-id="8d5d3-109">Introduction</span></span>

<span data-ttu-id="8d5d3-110">正如我们看到的开头[概述的插入、 更新和删除数据](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md)教程中，GridView 提供内置支持用于行级编辑和删除。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-110">As we saw starting with the [An Overview of Inserting, Updating, and Deleting Data](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-cs.md) tutorial, the GridView provides built-in support for row-level editing and deleting.</span></span> <span data-ttu-id="8d5d3-111">只需单击几下鼠标就可以，只要你是具有编辑和删除基于每个行的内容，而无需编写一行代码，创建丰富的数据修改界面。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-111">With a few clicks of the mouse it is possible to create a rich data modification interface without writing a line of code, so long as you are content with editing and deleting on a per-row basis.</span></span> <span data-ttu-id="8d5d3-112">但是，在某些情况下，此时间不够，并且我们需要向用户提供编辑或删除一批记录的能力。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-112">However, in certain scenarios this is insufficient and we need to provide users with the ability to edit or delete a batch of records.</span></span>

<span data-ttu-id="8d5d3-113">例如，最基于 web 的电子邮件客户端使用一个网格，列出每个消息其中每个行包含电子邮件的信息 （主题、 发件人，等） 以及一个复选框。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-113">For example, most web-based email clients use a grid to list each message where each row includes a checkbox along with the email s information (subject, sender, and so forth).</span></span> <span data-ttu-id="8d5d3-114">此接口允许用户通过检查它们，然后单击删除所选消息按钮删除多个消息。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-114">This interface permits the user to delete multiple messages by checking them and then clicking a Delete Selected Messages button.</span></span> <span data-ttu-id="8d5d3-115">编辑界面批处理非常适合在用户通常编辑许多不同的记录的情况下。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-115">A batch editing interface is ideal in situations where users commonly edit many different records.</span></span> <span data-ttu-id="8d5d3-116">而不强制用户通过单击编辑、 其更改，然后单击更新为每个需要对其进行修改的记录，编辑界面一批呈现具有其编辑界面的每个行。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-116">Rather than forcing the user to click Edit, make their change, and then click Update for each record that needs to be modified, a batch editing interface renders each row with its editing interface.</span></span> <span data-ttu-id="8d5d3-117">用户可以快速修改的需要进行更改的行集，并通过单击全部更新按钮保存这些更改。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-117">The user can quickly modify the set of rows that need to be changed and then save these changes by clicking an Update All button.</span></span> <span data-ttu-id="8d5d3-118">在此系列教程中我们将介绍如何创建用于插入、 编辑和删除数据的批处理的接口。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-118">In this set of tutorials we'll examine how to create interfaces for inserting, editing, and deleting batches of data.</span></span>

<span data-ttu-id="8d5d3-119">执行批处理操作时它非常重要，以确定是否应该可以为一些成功的批处理中的操作，而有些失败。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-119">When performing batch operations it s important to determine whether it should be possible for some of the operations in the batch to succeed while others fail.</span></span> <span data-ttu-id="8d5d3-120">请考虑一批删除接口-如果已成功，删除所选的第一个记录，但第二个失败，例如，由于外键约束冲突而应发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="8d5d3-120">Consider a batch deleting interface - what should happen if the first selected record is deleted successfully, but the second one fails, say, because of a foreign key constraint violation?</span></span> <span data-ttu-id="8d5d3-121">应第一个记录的删除回滚或是可以接受的第一条记录要保留已删除？</span><span class="sxs-lookup"><span data-stu-id="8d5d3-121">Should the first record s delete be rolled back or is it acceptable for the first record to remain deleted?</span></span>

<span data-ttu-id="8d5d3-122">如果所需的批处理操作被视为[原子操作](http://en.wikipedia.org/wiki/Atomic_operation)，其中一个是其中的所有步骤成功或失败的所有步骤，则需要进行扩充以支持的数据访问层[数据库事务](http://en.wikipedia.org/wiki/Database_transaction)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-122">If you want the batch operation to be treated as an [atomic operation](http://en.wikipedia.org/wiki/Atomic_operation), one where either all of the steps succeed or all of the steps fail, then the Data Access Layer needs to be augmented to include support for [database transactions](http://en.wikipedia.org/wiki/Database_transaction).</span></span> <span data-ttu-id="8d5d3-123">数据库事务保证原子性的一套`INSERT`， `UPDATE`，和`DELETE`语句在事务的保护伞下执行，并且是所有的大多数现代数据库系统所支持的功能。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-123">Database transactions guarantee atomicity for the set of `INSERT`, `UPDATE`, and `DELETE` statements executed under the umbrella of the transaction and are a feature supported by most all modern database systems.</span></span>

<span data-ttu-id="8d5d3-124">在本教程中我们将介绍如何扩展 DAL 使用数据库事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-124">In this tutorial we'll look at how to extend the DAL to use database transactions.</span></span> <span data-ttu-id="8d5d3-125">后续教程中将检查批处理插入、 更新和删除接口的实现 web 页。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-125">Subsequent tutorials will examine implementing web pages for batch inserting, updating, and deleting interfaces.</span></span> <span data-ttu-id="8d5d3-126">让我们来开始 ！</span><span class="sxs-lookup"><span data-stu-id="8d5d3-126">Let s get started!</span></span>

> [!NOTE]
> <span data-ttu-id="8d5d3-127">当修改批事务中的数据时，原子性并不总是需要。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-127">When modifying data in a batch transaction, atomicity is not always needed.</span></span> <span data-ttu-id="8d5d3-128">在某些情况下，这可能是可以接受的一些成功的数据修改，在同一个批处理中的其他人失败，例如当从基于 web 的电子邮件客户端中删除一组电子邮件。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-128">In some scenarios, it may be acceptable to have some data modifications succeed and others in the same batch fail, such as when deleting a set of emails from a web-based email client.</span></span> <span data-ttu-id="8d5d3-129">如果有 s 数据库错误会中途删除处理，它可能可接受的没有错误处理这些记录将保留已删除的 s。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-129">If there s a database error midway through the deletion process, it s probably acceptable that those records processed without error remain deleted.</span></span> <span data-ttu-id="8d5d3-130">在这种情况下，不需要进行修改，以支持数据库事务 DAL。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-130">In such cases, the DAL does not need to be modified to support database transactions.</span></span> <span data-ttu-id="8d5d3-131">还有其他批处理操作方案，但是，原子性至关重要。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-131">There are other batch operation scenarios, however, where atomicity is vital.</span></span> <span data-ttu-id="8d5d3-132">当客户将她资金从一个银行帐户移到另一个时，必须执行两项操作： 将资金必须要从第一个帐户并添加到第二个。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-132">When a customer moves her funds from one bank account to another, two operations must be performed: the funds must be deducted from the first account and then added to the second.</span></span> <span data-ttu-id="8d5d3-133">虽然银行可能不介意具有成功的第一步，但第二个步骤失败，其客户将可以理解的是感到不安。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-133">While the bank may not mind having the first step succeed but the second step fail, its customers would understandably be upset.</span></span> <span data-ttu-id="8d5d3-134">我鼓励您在学习本教程并实现与 DAL 来支持数据库事务，即使您不打算将其用在批插入、 更新和删除我们将生成以下三个教程中的接口的增强功能。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-134">I encourage you to work through this tutorial and implement the enhancements to the DAL to support database transactions even if you do not plan on using them in the batch inserting, updating, and deleting interfaces we'll be building in the following three tutorials.</span></span>


## <a name="an-overview-of-transactions"></a><span data-ttu-id="8d5d3-135">事务的概述</span><span class="sxs-lookup"><span data-stu-id="8d5d3-135">An Overview of Transactions</span></span>

<span data-ttu-id="8d5d3-136">大多数数据库包括对支持*事务*，它实现了多个数据库命令，分组到单个逻辑工作单元。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-136">Most databases include support for *transactions*, which enable multiple database commands to be grouped into a single logical unit of work.</span></span> <span data-ttu-id="8d5d3-137">构成事务的数据库命令都保证是原子的这意味着所有命令将都失败或所有将会成功。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-137">The database commands that comprise a transaction are guaranteed to be atomic, meaning that either all commands will fail or all will succeed.</span></span>

<span data-ttu-id="8d5d3-138">一般情况下，通过使用以下模式的 SQL 语句实现事务：</span><span class="sxs-lookup"><span data-stu-id="8d5d3-138">In general, transactions are implemented through SQL statements using the following pattern:</span></span>

1. <span data-ttu-id="8d5d3-139">指示事务的开始。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-139">Indicate the start of a transaction.</span></span>
2. <span data-ttu-id="8d5d3-140">执行构成事务的 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-140">Execute the SQL statements that comprise the transaction.</span></span>
3. <span data-ttu-id="8d5d3-141">如果在步骤 2，回滚事务中的语句之一时出错。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-141">If there is an error in one of the statements from Step 2, rollback the transaction.</span></span>
4. <span data-ttu-id="8d5d3-142">如果没有错误完成所有步骤 2 中的语句，则提交事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-142">If all of the statements from Step 2 complete without error, commit the transaction.</span></span>

<span data-ttu-id="8d5d3-143">SQL 语句用于创建、 提交和回滚事务时，可以输入手动编写 SQL 脚本或创建存储过程，或通过以编程方式意味着要使用 ADO.NET 或中的类[ `System.Transactions`命名空间](https://msdn.microsoft.com/library/system.transactions.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-143">The SQL statements used to create, commit, and roll back the transaction can be entered manually when writing SQL scripts or creating stored procedures, or through programmatic means using either ADO.NET or the classes in the [`System.Transactions` namespace](https://msdn.microsoft.com/library/system.transactions.aspx).</span></span> <span data-ttu-id="8d5d3-144">在本教程中我们将仅检查管理使用 ADO.NET 的事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-144">In this tutorial we will only examine managing transactions using ADO.NET.</span></span> <span data-ttu-id="8d5d3-145">在将来的教程中我们将探讨如何在数据访问层，此时我们将探讨用于创建、 回滚和提交事务的 SQL 语句中使用存储的过程。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-145">In a future tutorial we will look at how to use stored procedures in the Data Access Layer, at which time we'll explore the SQL statements for creating, rolling back, and committing transactions.</span></span> <span data-ttu-id="8d5d3-146">在此期间，请查阅[在 SQL Server 存储过程中管理事务](http://www.4guysfromrolla.com/webtech/080305-1.shtml)有关详细信息。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-146">In the meantime, consult [Managing Transactions in SQL Server Stored Procedures](http://www.4guysfromrolla.com/webtech/080305-1.shtml) for more information.</span></span>

> [!NOTE]
> <span data-ttu-id="8d5d3-147">[ `TransactionScope`类](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx)中`System.Transactions`命名空间使开发人员能够以编程方式将一系列语句包装在事务范围内，并且包括对涉及多个复杂事务的支持两个不同的数据库或甚至不同类型的数据存储，如 Microsoft SQL Server 数据库、 Oracle 数据库和 Web 服务等源。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-147">The [`TransactionScope` class](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx) in the `System.Transactions` namespace enables developers to programmatically wrap a series of statements within the scope of a transaction and includes support for complex transactions that involve multiple sources, such as two different databases or even heterogeneous types of data stores, such as a Microsoft SQL Server database, an Oracle database, and a Web service.</span></span> <span data-ttu-id="8d5d3-148">我已决定而不是在本教程使用 ADO.NET 事务`TransactionScope`类，因为 ADO.NET 是更具体的数据库事务，并在许多情况下，是要少得多占用大量资源。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-148">I ve decided to use ADO.NET transactions for this tutorial instead of the `TransactionScope` class because ADO.NET is more specific for database transactions and, in many cases, is far less resource intensive.</span></span> <span data-ttu-id="8d5d3-149">此外，在某些情况下`TransactionScope`类使用 Microsoft 分布式事务处理协调器 (MSDTC)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-149">In addition, under certain scenarios the `TransactionScope` class uses the Microsoft Distributed Transaction Coordinator (MSDTC).</span></span> <span data-ttu-id="8d5d3-150">配置、 实现和性能问题周围 MSDTC 使它而不是专用的和高级主题和这些教程的范围之外。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-150">The configuration, implementation, and performance issues surrounding MSDTC makes it a rather specialized and advanced topic and beyond the scope of these tutorials.</span></span>


<span data-ttu-id="8d5d3-151">在使用 SqlClient 提供程序在 ADO.NET 中，通过调用启动的事务[`SqlConnection`类](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx)s [ `BeginTransaction`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx)，它将返回[ `SqlTransaction`对象](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-151">When working with the SqlClient provider in ADO.NET, transactions are initiated through a call to the [`SqlConnection` class](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) s [`BeginTransaction` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx), which returns a [`SqlTransaction` object](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx).</span></span> <span data-ttu-id="8d5d3-152">中放入了构成事务的数据修改语句`try...catch`块。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-152">The data modification statements that makeup the transaction are placed within a `try...catch` block.</span></span> <span data-ttu-id="8d5d3-153">如果在语句中出现错误`try`阻止执行传输到`catch`块，可以回滚事务通过`SqlTransaction`对象 s [ `Rollback`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-153">If an error occurs in a statement in the `try` block, execution transfers to the `catch` block where the transaction can be rolled back via the `SqlTransaction` object s [`Rollback` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx).</span></span> <span data-ttu-id="8d5d3-154">如果所有的语句会成功完成，调用`SqlTransaction`对象 s [ `Commit`方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx)末尾`try`块提交事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-154">If all of the statements complete successfully, a call to the `SqlTransaction` object s [`Commit` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx) at the end of the `try` block commits the transaction.</span></span> <span data-ttu-id="8d5d3-155">以下代码片段演示此模式。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-155">The following code snippet illustrates this pattern.</span></span> <span data-ttu-id="8d5d3-156">请参阅[维护与事务的数据库一致性](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)有关 ADO.NET 中使用事务的附加语法和示例。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-156">See [Maintaining Database Consistency with Transactions](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx) for additional syntax and examples of using transactions with ADO.NET.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample1.cs)]

<span data-ttu-id="8d5d3-157">默认情况下，在类型化数据集中 Tableadapter 不使用事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-157">By default, the TableAdapters in a Typed DataSet do not use transactions.</span></span> <span data-ttu-id="8d5d3-158">若要为事务提供支持，我们需要增加 TableAdapter 类以包括使用上面的模式来执行一系列的范围内的事务数据修改语句的其他方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-158">To provide support for transactions we need to augment the TableAdapter classes to include additional methods that use the above pattern to perform a series of data modification statements within the scope of a transaction.</span></span> <span data-ttu-id="8d5d3-159">在步骤 2 中，我们将了解如何使用分部类来添加这些方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-159">In Step 2 we'll see how to use partial classes to add these methods.</span></span>

## <a name="step-1-creating-the-working-with-batched-data-web-pages"></a><span data-ttu-id="8d5d3-160">步骤 1：使用批处理的数据 Web 页创建工作</span><span class="sxs-lookup"><span data-stu-id="8d5d3-160">Step 1: Creating the Working with Batched Data Web Pages</span></span>

<span data-ttu-id="8d5d3-161">我们开始探索如何扩展以支持数据库事务的 DAL 之前，让 s 先花点时间来创建我们将在本教程需要 ASP.NET web pages 和遵循的三个。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-161">Before we start exploring how to augment the DAL to support database transactions, let s first take a moment to create the ASP.NET web pages that we will need for this tutorial and the three that follow.</span></span> <span data-ttu-id="8d5d3-162">首先，通过添加一个名为的新文件夹`BatchData`，然后添加以下 ASP.NET 页面中，将使用每个页面相关联`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-162">Start by adding a new folder named `BatchData` and then add the following ASP.NET pages, associating each page with the `Site.master` master page.</span></span>

- `Default.aspx`
- `Transactions.aspx`
- `BatchUpdate.aspx`
- `BatchDelete.aspx`
- `BatchInsert.aspx`


![将 ASP.NET 页面添加与 SqlDataSource 相关的教程](wrapping-database-modifications-within-a-transaction-cs/_static/image1.gif)

<span data-ttu-id="8d5d3-164">**图 1**:将 ASP.NET 页面添加与 SqlDataSource 相关的教程</span><span class="sxs-lookup"><span data-stu-id="8d5d3-164">**Figure 1**: Add the ASP.NET Pages for the SqlDataSource-Related Tutorials</span></span>


<span data-ttu-id="8d5d3-165">与其他文件夹，一样`Default.aspx`将使用`SectionLevelTutorialListing.ascx`用户控件，若要列出其部分中的教程。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-165">As with the other folders, `Default.aspx` will use the `SectionLevelTutorialListing.ascx` User Control to list the tutorials within its section.</span></span> <span data-ttu-id="8d5d3-166">因此，此用户控件添加到`Default.aspx`通过从解决方案资源管理器中拖到页面上的设计视图中拖动。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-166">Therefore, add this User Control to `Default.aspx` by dragging it from the Solution Explorer onto the page s Design view.</span></span>


<span data-ttu-id="8d5d3-167">[![将 SectionLevelTutorialListing.ascx 用户控件添加到 Default.aspx](wrapping-database-modifications-within-a-transaction-cs/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-167">[![Add the SectionLevelTutorialListing.ascx User Control to Default.aspx](wrapping-database-modifications-within-a-transaction-cs/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image1.png)</span></span>

<span data-ttu-id="8d5d3-168">**图 2**:添加`SectionLevelTutorialListing.ascx`到用户控件`Default.aspx`([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-168">**Figure 2**: Add the `SectionLevelTutorialListing.ascx` User Control to `Default.aspx` ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image2.png))</span></span>


<span data-ttu-id="8d5d3-169">最后，将这四个页面添加到条目为`Web.sitemap`文件。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-169">Lastly, add these four pages as entries to the `Web.sitemap` file.</span></span> <span data-ttu-id="8d5d3-170">具体而言，自定义后添加以下标记站点图`<siteMapNode>`:</span><span class="sxs-lookup"><span data-stu-id="8d5d3-170">Specifically, add the following markup after the Customizing the Site Map `<siteMapNode>`:</span></span>


[!code-xml[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample2.xml)]

<span data-ttu-id="8d5d3-171">更新后`Web.sitemap`，花点时间查看通过浏览器网站的教程。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-171">After updating `Web.sitemap`, take a moment to view the tutorials website through a browser.</span></span> <span data-ttu-id="8d5d3-172">在左侧的菜单现在包含批处理的数据教程使用的项。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-172">The menu on the left now includes items for the working with batched data tutorials.</span></span>


![站点图现在包括批处理的数据教程使用的条目](wrapping-database-modifications-within-a-transaction-cs/_static/image3.gif)

<span data-ttu-id="8d5d3-174">**图 3**:站点图现在包括批处理的数据教程使用的条目</span><span class="sxs-lookup"><span data-stu-id="8d5d3-174">**Figure 3**: The Site Map Now Includes Entries for the Working with Batched Data Tutorials</span></span>


## <a name="step-2-updating-the-data-access-layer-to-support-database-transactions"></a><span data-ttu-id="8d5d3-175">步骤 2：更新数据访问层，以便支持数据库事务</span><span class="sxs-lookup"><span data-stu-id="8d5d3-175">Step 2: Updating the Data Access Layer to Support Database Transactions</span></span>

<span data-ttu-id="8d5d3-176">返回在第一个教程中，我们讨论[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)，DAL 中的类型化数据集组成 DataTables 和 Tableadapter。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-176">As we discussed back in the first tutorial, [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md), the Typed DataSet in our DAL is composed of DataTables and TableAdapters.</span></span> <span data-ttu-id="8d5d3-177">DataTables 保存数据时，Tableadapter 提供的功能，若要从数据库的数据读入数据表，若要使用到数据表和等所做的更改更新数据库。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-177">The DataTables hold data while the TableAdapters provide the functionality to read data from the database into the DataTables, to update the database with changes made to the DataTables, and so forth.</span></span> <span data-ttu-id="8d5d3-178">前面曾提到，Tableadapter 还提供用于更新数据，我为批量更新和 DB 直接引用了这两种模式。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-178">Recall that the TableAdapters provide two patterns for updating data, which I referred to as Batch Update and DB-Direct.</span></span> <span data-ttu-id="8d5d3-179">使用批更新模式时，数据集、 DataTable 或 Datarow 的集合传递 TableAdapter。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-179">With the Batch Update pattern, the TableAdapter is passed a DataSet, DataTable, or collection of DataRows.</span></span> <span data-ttu-id="8d5d3-180">此数据枚举和每个插入、 修改或已删除的行， `InsertCommand`， `UpdateCommand`，或`DeleteCommand`执行。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-180">This data is enumerated and for each inserted, modified, or deleted row, the `InsertCommand`, `UpdateCommand`, or `DeleteCommand` is executed.</span></span> <span data-ttu-id="8d5d3-181">使用 DB 直接模式时，TableAdapter 是改为传递列插入、 更新或删除一条记录所需的值。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-181">With the DB-Direct pattern, the TableAdapter is instead passed the values of the columns necessary for inserting, updating, or deleting a single record.</span></span> <span data-ttu-id="8d5d3-182">DB 直接模式方法然后使用这些传入的值以执行正确`InsertCommand`， `UpdateCommand`，或`DeleteCommand`语句。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-182">The DB Direct pattern method then uses those passed-in values to execute the appropriate `InsertCommand`, `UpdateCommand`, or `DeleteCommand` statement.</span></span>

<span data-ttu-id="8d5d3-183">无论使用的更新模式，自动生成的 Tableadapter 方法不使用事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-183">Regardless of the update pattern used, the TableAdapters auto-generated methods do not use transactions.</span></span> <span data-ttu-id="8d5d3-184">默认情况下每个 insert、 update 或 delete 执行 TableAdapter 的被视为单个离散操作。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-184">By default each insert, update, or delete performed by the TableAdapter is treated as a single discrete operation.</span></span> <span data-ttu-id="8d5d3-185">例如，假设由 BLL 中某些代码使用 DB 直接模式是将十个记录插入数据库。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-185">For instance, imagine that the DB-Direct pattern is used by some code in the BLL to insert ten records into the database.</span></span> <span data-ttu-id="8d5d3-186">此代码将调用 TableAdapter 的`Insert`方法十倍。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-186">This code would call the TableAdapter s `Insert` method ten times.</span></span> <span data-ttu-id="8d5d3-187">如果前五个插入成功，但第 6 项导致了异常前, 五个插入的记录将保持在数据库中。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-187">If the first five inserts succeed, but the sixth one resulted in an exception, the first five inserted records would remain in the database.</span></span> <span data-ttu-id="8d5d3-188">同样，如果批更新模式用于执行插入、 更新和删除到插入、 修改和删除数据表中的行，如果第一个的多个修改成功，但更高版本时遇到错误，这些早期的修改，已完成将保留在数据库中。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-188">Similarly, if the Batch Update pattern is used to perform inserts, updates, and deletes to the inserted, modified, and deleted rows in a DataTable, if the first several modifications succeeded but a later one encountered an error, those earlier modifications that completed would remain in the database.</span></span>

<span data-ttu-id="8d5d3-189">在某些情况下，我们想要确保在修改的一系列原子性。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-189">In certain scenarios we want to ensure atomicity across a series of modifications.</span></span> <span data-ttu-id="8d5d3-190">若要完成此我们必须通过添加新执行的方法来手动扩展 TableAdapter `InsertCommand`， `UpdateCommand`，和`DeleteCommand`s 之下的事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-190">To accomplish this we must manually extend the TableAdapter by adding new methods that execute the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s under the umbrella of a transaction.</span></span> <span data-ttu-id="8d5d3-191">在中[创建数据访问层](../introduction/creating-a-data-access-layer-cs.md)我们在使用[分部类](http://en.wikipedia.org/wiki/Partial_type)来扩展类型数据集内 DataTables 的功能。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-191">In [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-cs.md) we looked at using [partial classes](http://en.wikipedia.org/wiki/Partial_type) to extend the functionality of the DataTables within the Typed DataSet.</span></span> <span data-ttu-id="8d5d3-192">此方法还可以用于 Tableadapter。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-192">This technique can also be used with TableAdapters.</span></span>

<span data-ttu-id="8d5d3-193">类型化数据集`Northwind.xsd`位于`App_Code`文件夹的`DAL`子文件夹。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-193">The Typed DataSet `Northwind.xsd` is located in the `App_Code` folder s `DAL` subfolder.</span></span> <span data-ttu-id="8d5d3-194">创建子文件夹中的`DAL`名为的文件夹`TransactionSupport`并添加名为的新类文件`ProductsTableAdapter.TransactionSupport.cs`（请参阅图 4）。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-194">Create a subfolder in the `DAL` folder named `TransactionSupport` and add a new class file named `ProductsTableAdapter.TransactionSupport.cs` (see Figure 4).</span></span> <span data-ttu-id="8d5d3-195">此文件将保存的部分实现`ProductsTableAdapter`，包括用于执行数据修改使用事务的方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-195">This file will hold the partial implementation of the `ProductsTableAdapter` that includes methods for performing data modifications using a transaction.</span></span>


![添加一个名为 TransactionSupport 文件夹和名为 ProductsTableAdapter.TransactionSupport.cs 的类文件](wrapping-database-modifications-within-a-transaction-cs/_static/image4.gif)

<span data-ttu-id="8d5d3-197">**图 4**:添加名为的文件夹`TransactionSupport`和名为的类文件 `ProductsTableAdapter.TransactionSupport.cs`</span><span class="sxs-lookup"><span data-stu-id="8d5d3-197">**Figure 4**: Add a Folder Named `TransactionSupport` and a Class File Named `ProductsTableAdapter.TransactionSupport.cs`</span></span>


<span data-ttu-id="8d5d3-198">输入以下代码到`ProductsTableAdapter.TransactionSupport.cs`文件：</span><span class="sxs-lookup"><span data-stu-id="8d5d3-198">Enter the following code into the `ProductsTableAdapter.TransactionSupport.cs` file:</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample3.cs)]

<span data-ttu-id="8d5d3-199">`partial`关键字在类声明中此处指示中添加的成员为要添加到编译器`ProductsTableAdapter`类中`NorthwindTableAdapters`命名空间。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-199">The `partial` keyword in the class declaration here indicates to the compiler that the members added within are to be added to the `ProductsTableAdapter` class in the `NorthwindTableAdapters` namespace.</span></span> <span data-ttu-id="8d5d3-200">请注意`using System.Data.SqlClient`在文件顶部的语句。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-200">Note the `using System.Data.SqlClient` statement at the top of the file.</span></span> <span data-ttu-id="8d5d3-201">因为 TableAdapter 配置为使用 SqlClient 提供程序，在内部它使用[ `SqlDataAdapter` ](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx)要向数据库发出其命令对象。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-201">Since the TableAdapter was configured to use the SqlClient provider, internally it uses a [`SqlDataAdapter`](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx) object to issue its commands to the database.</span></span> <span data-ttu-id="8d5d3-202">因此，我们需要使用`SqlTransaction`类，以开始事务，然后将其提交或回滚它。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-202">Consequently, we need to use the `SqlTransaction` class to begin the transaction and then to commit it or roll it back.</span></span> <span data-ttu-id="8d5d3-203">如果使用 Microsoft SQL Server 之外的数据存储，你将需要使用相应的提供程序。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-203">If you are using a data store other than Microsoft SQL Server, you'll need to use the appropriate provider.</span></span>

<span data-ttu-id="8d5d3-204">这些方法提供了开始回滚所需的构造块，并提交事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-204">These methods provide the building blocks needed to start, rollback, and commit a transaction.</span></span> <span data-ttu-id="8d5d3-205">它们标记`public`，使他们能够在使用`ProductsTableAdapter`、 DAL 中的另一个类或从另一个层体系结构，如 BLL。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-205">They are marked `public`, enabling them to be used from within the `ProductsTableAdapter`, from another class in the DAL, or from another layer in the architecture, such as the BLL.</span></span> <span data-ttu-id="8d5d3-206">`BeginTransaction` 此时将打开 TableAdapter s 内部`SqlConnection`（如果需要），开始事务，并将它分配给`Transaction`属性，并将事务附加到内部`SqlDataAdapter`s`SqlCommand`对象。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-206">`BeginTransaction` opens the TableAdapter s internal `SqlConnection` (if needed), begins the transaction and assigns it to the `Transaction` property, and attaches the transaction to the internal `SqlDataAdapter` s `SqlCommand` objects.</span></span> <span data-ttu-id="8d5d3-207">`CommitTransaction` 并`RollbackTransaction`调用`Transaction`对象 s`Commit`并`Rollback`方法，分别，再关闭内部`Connection`对象。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-207">`CommitTransaction` and `RollbackTransaction` call the `Transaction` object s `Commit` and `Rollback` methods, respectively, before closing the internal `Connection` object.</span></span>

## <a name="step-3-adding-methods-to-update-and-delete-data-under-the-umbrella-of-a-transaction"></a><span data-ttu-id="8d5d3-208">步骤 3：添加方法以更新和删除数据之下的事务</span><span class="sxs-lookup"><span data-stu-id="8d5d3-208">Step 3: Adding Methods to Update and Delete Data Under the Umbrella of a Transaction</span></span>

<span data-ttu-id="8d5d3-209">完成这些方法中，我们重新准备好将方法添加到`ProductsDataTable`或执行一系列命令之下的事务的 BLL。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-209">With these methods complete, we re ready to add methods to `ProductsDataTable` or the BLL that perform a series of commands under the umbrella of a transaction.</span></span> <span data-ttu-id="8d5d3-210">以下方法使用批更新模式来更新`ProductsDataTable`实例使用的事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-210">The following method uses the Batch Update pattern to update a `ProductsDataTable` instance using a transaction.</span></span> <span data-ttu-id="8d5d3-211">它通过调用来启动一个事务`BeginTransaction`方法，然后使用`try...catch`块以发出数据修改语句。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-211">It starts a transaction by calling the `BeginTransaction` method and then uses a `try...catch` block to issue the data modification statements.</span></span> <span data-ttu-id="8d5d3-212">如果在调用`Adapter`对象 s`Update`方法会引发异常，则执行会传输到`catch`块，将回滚事务并重新引发的异常。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-212">If the call to the `Adapter` object s `Update` method results in an exception, execution will transfer to the `catch` block where the transaction will be rolled back and the exception re-thrown.</span></span> <span data-ttu-id="8d5d3-213">请记住，`Update`方法通过枚举所提供的行来实现批处理更新模式`ProductsDataTable`并执行必要`InsertCommand`， `UpdateCommand`，和`DeleteCommand`s。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-213">Recall that the `Update` method implements the Batch Update pattern by enumerating the rows of the supplied `ProductsDataTable` and performing the necessary `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s.</span></span> <span data-ttu-id="8d5d3-214">如果任何一个的这些命令将导致错误，事务已回滚，撤消上一事务 s 生命周期内进行的修改。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-214">If any one of these commands results in an error, the transaction is rolled back, undoing the previous modifications made during the transaction s lifetime.</span></span> <span data-ttu-id="8d5d3-215">应`Update`语句完成不会出错，整个提交事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-215">Should the `Update` statement complete without error, the transaction is committed in its entirety.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample4.cs)]

<span data-ttu-id="8d5d3-216">添加`UpdateWithTransaction`方法`ProductsTableAdapter`类中的分部类通过`ProductsTableAdapter.TransactionSupport.cs`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-216">Add the `UpdateWithTransaction` method to the `ProductsTableAdapter` class through the partial class in `ProductsTableAdapter.TransactionSupport.cs`.</span></span> <span data-ttu-id="8d5d3-217">或者，此方法无法添加到的业务逻辑层 s`ProductsBLL`类的一些小的语法更改。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-217">Alternatively, this method could be added to the Business Logic Layer s `ProductsBLL` class with a few minor syntactical changes.</span></span> <span data-ttu-id="8d5d3-218">即关键字考虑到这`this.BeginTransaction()`， `this.CommitTransaction()`，并`this.RollbackTransaction()`需要替换`Adapter`(回想一下，`Adapter`中的属性的名称`ProductsBLL`类型的`ProductsTableAdapter`)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-218">Namely, the keyword this in `this.BeginTransaction()`, `this.CommitTransaction()`, and `this.RollbackTransaction()` would need to be replaced with `Adapter` (recall that `Adapter` is the name of a property in `ProductsBLL` of type `ProductsTableAdapter`).</span></span>

<span data-ttu-id="8d5d3-219">`UpdateWithTransaction`方法使用批更新模式中，但也在事务中，如下所示的方法的范围内使用一系列数据库直接调用。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-219">The `UpdateWithTransaction` method uses the Batch Update pattern, but a series of DB-Direct calls can also be used within the scope of a transaction, as the following method shows.</span></span> <span data-ttu-id="8d5d3-220">`DeleteProductsWithTransaction`方法接受作为输入`List<T>`类型的`int`，这是`ProductID`s 可删除。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-220">The `DeleteProductsWithTransaction` method accepts as input a `List<T>` of type `int`, which are the `ProductID` s to delete.</span></span> <span data-ttu-id="8d5d3-221">方法启动的事务通过调用`BeginTransaction`，然后在`try`块中，循环访问提供列表调用 DB 直接模式`Delete`方法为每个`ProductID`值。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-221">The method initiates the transaction via a call to `BeginTransaction` and then, in the `try` block, iterates through the supplied list calling the DB-Direct pattern `Delete` method for each `ProductID` value.</span></span> <span data-ttu-id="8d5d3-222">如果对调用任一`Delete`失败，控制权转至`catch`块，则回滚事务并重新引发的异常。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-222">If any of the calls to `Delete` fails, control is transferred to the `catch` block where the transaction is rolled back and the exception re-thrown.</span></span> <span data-ttu-id="8d5d3-223">如果所有调用`Delete`成功，则将提交事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-223">If all calls to `Delete` succeed, then transaction is committed.</span></span> <span data-ttu-id="8d5d3-224">将以下方法添加到`ProductsBLL`类。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-224">Add this method to the `ProductsBLL` class.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample5.cs)]

## <a name="applying-transactions-across-multiple-tableadapters"></a><span data-ttu-id="8d5d3-225">应用事务跨多个 Tableadapter</span><span class="sxs-lookup"><span data-stu-id="8d5d3-225">Applying Transactions Across Multiple TableAdapters</span></span>

<span data-ttu-id="8d5d3-226">在本教程中检查与事务相关的代码允许使用针对多个语句`ProductsTableAdapter`被视为原子操作。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-226">The transaction-related code examined in this tutorial allows for multiple statements against the `ProductsTableAdapter` to be treated as an atomic operation.</span></span> <span data-ttu-id="8d5d3-227">但是，如果需要以原子方式执行多个不同的数据库表进行修改呢？</span><span class="sxs-lookup"><span data-stu-id="8d5d3-227">But what if multiple modifications to different database tables need to be performed atomically?</span></span> <span data-ttu-id="8d5d3-228">例如，在删除某个类别时，我们可能首先想要重新分配到某些其他类别及其当前产品。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-228">For instance, when deleting a category, we might first want to reassign its current products to some other category.</span></span> <span data-ttu-id="8d5d3-229">这两个步骤重新分配产品和删除该类别应作为一个原子操作执行。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-229">These two steps reassigning the products and deleting the category should be executed as an atomic operation.</span></span> <span data-ttu-id="8d5d3-230">但`ProductsTableAdapter`包括仅用于修改方法`Products`表和`CategoriesTableAdapter`包括仅用于修改方法`Categories`表。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-230">But the `ProductsTableAdapter` includes only methods for modifying the `Products` table and the `CategoriesTableAdapter` includes only methods for modifying the `Categories` table.</span></span> <span data-ttu-id="8d5d3-231">那么，如何事务可以涵盖这两个 Tableadapter</span><span class="sxs-lookup"><span data-stu-id="8d5d3-231">So how can a transaction encompass both TableAdapters?</span></span>

<span data-ttu-id="8d5d3-232">一种方法是将方法添加到`CategoriesTableAdapter`名为`DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)`然后使该方法调用的存储的过程，同时重新分配产品并删除存储过程中定义的事务范围内的类别。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-232">One option is to add a method to the `CategoriesTableAdapter` named `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` and have that method call a stored procedure that both reassigns the products and deletes the category within the scope of a transaction defined within the stored procedure.</span></span> <span data-ttu-id="8d5d3-233">我们将在以后的教程中介绍了如何开始、 提交、 以及在存储过程中的回滚事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-233">We'll look at how to begin, commit, and rollback transactions in stored procedures in a future tutorial.</span></span>

<span data-ttu-id="8d5d3-234">另一种方法是在包含 DAL 中创建一个帮助器类`DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)`方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-234">Another option is to create a helper class in the DAL that contains the `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` method.</span></span> <span data-ttu-id="8d5d3-235">此方法将创建的实例`CategoriesTableAdapter`并`ProductsTableAdapter`然后将这些设置两个 Tableadapter`Connection`属性设置为相同`SqlConnection`实例。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-235">This method would create an instance of the `CategoriesTableAdapter` and the `ProductsTableAdapter` and then set these two TableAdapters `Connection` properties to the same `SqlConnection` instance.</span></span> <span data-ttu-id="8d5d3-236">在该点的两个 Tableadapter 之一启动通过调用事务`BeginTransaction`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-236">At that point, either one of the two TableAdapters would initiate the transaction with a call to `BeginTransaction`.</span></span> <span data-ttu-id="8d5d3-237">用于重新分配产品和删除该类别的 Tableadapter 方法会调用在`try...catch`事务提交或回滚返回根据需要使用的块。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-237">The TableAdapters methods for reassigning the products and deleting the category would be invoked in a `try...catch` block with the transaction committed or rolled back as needed.</span></span>

## <a name="step-4-adding-theupdatewithtransactionmethod-to-the-business-logic-layer"></a><span data-ttu-id="8d5d3-238">步骤 4：添加`UpdateWithTransaction`业务逻辑层方法</span><span class="sxs-lookup"><span data-stu-id="8d5d3-238">Step 4: Adding the`UpdateWithTransaction`Method to the Business Logic Layer</span></span>

<span data-ttu-id="8d5d3-239">在步骤 3 中我们添加了`UpdateWithTransaction`方法`ProductsTableAdapter`DAL 中。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-239">In Step 3 we added an `UpdateWithTransaction` method to the `ProductsTableAdapter` in the DAL.</span></span> <span data-ttu-id="8d5d3-240">我们应将相应的方法添加到 BLL。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-240">We should add a corresponding method to the BLL.</span></span> <span data-ttu-id="8d5d3-241">表示层可以直接向 DAL 调用下调用时`UpdateWithTransaction`方法，这些教程有努力定义隔离从表示层 DAL 分层式体系结构。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-241">While the Presentation Layer could call directly down to the DAL to invoke the `UpdateWithTransaction` method, these tutorials have strived to define a layered architecture that insulates the DAL from the Presentation Layer.</span></span> <span data-ttu-id="8d5d3-242">因此，它理应我们继续这种方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-242">Therefore, it behooves us to continue this approach.</span></span>

<span data-ttu-id="8d5d3-243">打开`ProductsBLL`类文件，并添加一个名为`UpdateWithTransaction`到相应的 DAL 方法只需调用。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-243">Open the `ProductsBLL` class file and add a method named `UpdateWithTransaction` that simply calls down to the corresponding DAL method.</span></span> <span data-ttu-id="8d5d3-244">现在应在两个新方法`ProductsBLL`: `UpdateWithTransaction`，只需添加和`DeleteProductsWithTransaction`，它被添加在步骤 3 中。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-244">There should now be two new methods in `ProductsBLL`: `UpdateWithTransaction`, which you just added, and `DeleteProductsWithTransaction`, which was added in Step 3.</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample6.cs)]

> [!NOTE]
> <span data-ttu-id="8d5d3-245">这些方法不包括`DataObjectMethodAttribute`分配给中的大多数其他方法特性`ProductsBLL`类，因为我们将调用这些方法直接从 ASP.NET 页代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-245">These methods do not include the `DataObjectMethodAttribute` attribute assigned to most other methods in the `ProductsBLL` class because we'll be invoking these methods directly from the ASP.NET pages code-behind classes.</span></span> <span data-ttu-id="8d5d3-246">请记住，`DataObjectMethodAttribute`用于标记哪些方法应出现在 ObjectDataSource 的配置数据源向导和 （选择、 更新、 插入或删除） 哪些选项卡下。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-246">Recall that `DataObjectMethodAttribute` is used to flag what methods should appear in the ObjectDataSource s Configure Data Source wizard and under what tab (SELECT, UPDATE, INSERT, or DELETE).</span></span> <span data-ttu-id="8d5d3-247">因为 GridView 中没有任何对批处理编辑或删除的内置支持，我们需要以编程方式调用这些方法，而不是使用无代码的声明性方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-247">Since the GridView lacks any built-in support for batch editing or deleting, we'll have to invoke these methods programmatically rather than use the code-free declarative approach.</span></span>


## <a name="step-5-atomically-updating-database-data-from-the-presentation-layer"></a><span data-ttu-id="8d5d3-248">步骤 5：以原子方式更新数据库数据的表示层</span><span class="sxs-lookup"><span data-stu-id="8d5d3-248">Step 5: Atomically Updating Database Data from the Presentation Layer</span></span>

<span data-ttu-id="8d5d3-249">为了说明该事务已更新一批记录时的效果，让 s 创建一个用户界面，列出在 GridView 中的所有产品，并包含一个按钮 Web 控件，单击时，将重新分配产品`CategoryID`值。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-249">To illustrate the effect that the transaction has when updating a batch of records, let s create a user interface that lists all products in a GridView and includes a Button Web control that, when clicked, reassigns the products `CategoryID` values.</span></span> <span data-ttu-id="8d5d3-250">具体而言，将进度类别重新分配，以便分配一个有效的第一个的多个产品`CategoryID`分配的值而有些则是有意不存在`CategoryID`值。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-250">In particular, the category reassignment will progress so that the first several products are assigned a valid `CategoryID` value while others are purposefully assigned a non-existent `CategoryID` value.</span></span> <span data-ttu-id="8d5d3-251">如果我们尝试与产品更新数据库，其`CategoryID`不匹配现有类别的`CategoryID`、 外键约束冲突将会发生，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-251">If we attempt to update the database with a product whose `CategoryID` does not match an existing category s `CategoryID`, a foreign key constraint violation will occur and an exception will be raised.</span></span> <span data-ttu-id="8d5d3-252">我们将看到在此示例是，当使用事务从外键约束冲突所引发的异常将导致以前有效`CategoryID`要回滚的更改。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-252">What we'll see in this example is that when using a transaction the exception raised from the foreign key constraint violation will cause the previous valid `CategoryID` changes to be rolled back.</span></span> <span data-ttu-id="8d5d3-253">当未使用事务，但是，将保持对初始类别进行修改。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-253">When not using a transaction, however, the modifications to the initial categories will remain.</span></span>

<span data-ttu-id="8d5d3-254">首先打开`Transactions.aspx`页中`BatchData`文件夹，然后拖动 GridView 从工具箱拖到设计器。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-254">Start by opening the `Transactions.aspx` page in the `BatchData` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="8d5d3-255">设置其`ID`到`Products`并从其智能标记，请将其绑定到名为新 ObjectDataSource `ProductsDataSource`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-255">Set its `ID` to `Products` and, from its smart tag, bind it to a new ObjectDataSource named `ProductsDataSource`.</span></span> <span data-ttu-id="8d5d3-256">配置对象数据源以提取其数据从`ProductsBLL`类的`GetProducts`方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-256">Configure the ObjectDataSource to pull its data from the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="8d5d3-257">这将是只读的 GridView，因此设置下拉列表中插入、 更新和删除 （无） 选项卡并单击完成。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-257">This will be a read-only GridView, so set the drop-down lists in the UPDATE, INSERT, and DELETE tabs to (None) and click Finish.</span></span>


<span data-ttu-id="8d5d3-258">[![图 5:配置对象数据源使用 ProductsBLL 类的 GetProducts 方法](wrapping-database-modifications-within-a-transaction-cs/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-258">[![Figure 5: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProducts Method](wrapping-database-modifications-within-a-transaction-cs/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image3.png)</span></span>

<span data-ttu-id="8d5d3-259">**图 5**:图 5：配置为使用 ObjectDataSource`ProductsBLL`类 s`GetProducts`方法 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-259">**Figure 5**: Figure 5: Configure the ObjectDataSource to Use the `ProductsBLL` Class s `GetProducts` Method ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image4.png))</span></span>


<span data-ttu-id="8d5d3-260">[![设置下拉列表中插入、 更新和删除选项卡为 （无）](wrapping-database-modifications-within-a-transaction-cs/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-260">[![Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None)](wrapping-database-modifications-within-a-transaction-cs/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image5.png)</span></span>

<span data-ttu-id="8d5d3-261">**图 6**:设置下拉列表列出了在更新、 插入和删除选项卡中为 （无） ([单击此项可查看原尺寸图像](wrapping-database-modifications-within-a-transaction-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-261">**Figure 6**: Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None) ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image6.png))</span></span>


<span data-ttu-id="8d5d3-262">完成配置数据源向导后，Visual Studio 将创建 BoundFields 和产品数据字段 CheckBoxField。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-262">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and a CheckBoxField for the product data fields.</span></span> <span data-ttu-id="8d5d3-263">删除所有这些字段除外`ProductID`， `ProductName`， `CategoryID`，和`CategoryName`并重命名`ProductName`并`CategoryName`BoundFields`HeaderText`为产品和类别中，属性分别。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-263">Remove all of these fields except for `ProductID`, `ProductName`, `CategoryID`, and `CategoryName` and rename the `ProductName` and `CategoryName` BoundFields `HeaderText` properties to Product and Category, respectively.</span></span> <span data-ttu-id="8d5d3-264">从智能标记中，选中启用分页选项。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-264">From the smart tag, check the Enable Paging option.</span></span> <span data-ttu-id="8d5d3-265">以后进行这些修改，GridView 和 ObjectDataSource s 声明性标记看起来应如下所示：</span><span class="sxs-lookup"><span data-stu-id="8d5d3-265">After making these modifications, the GridView and ObjectDataSource s declarative markup should look like the following:</span></span>


[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample7.aspx)]

<span data-ttu-id="8d5d3-266">接下来，添加 GridView 上面的三个按钮 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-266">Next, add three Button Web controls above the GridView.</span></span> <span data-ttu-id="8d5d3-267">设置为刷新网格、 对修改类别 （与事务），第二个 s 和到修改类别 （而无需事务） 的第三个 s s 文本属性的第一个按钮。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-267">Set the first Button s Text property to Refresh Grid, the second s to Modify Categories (WITH TRANSACTION), and the third one s to Modify Categories (WITHOUT TRANSACTION) .</span></span>


[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample8.aspx)]

<span data-ttu-id="8d5d3-268">此时 Visual Studio 中的设计视图应类似于屏幕截图中图 7 所示。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-268">At this point the Design view in Visual Studio should look similar to the screen shot shown in Figure 7.</span></span>


<span data-ttu-id="8d5d3-269">[![页包含一个 GridView 和三个按钮 Web 控件](wrapping-database-modifications-within-a-transaction-cs/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-269">[![The Page Contains a GridView and Three Button Web Controls](wrapping-database-modifications-within-a-transaction-cs/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image7.png)</span></span>

<span data-ttu-id="8d5d3-270">**图 7**:页包含 GridView 和三个按钮 Web 控件 ([单击此项可查看原尺寸图像](wrapping-database-modifications-within-a-transaction-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-270">**Figure 7**: The Page Contains a GridView and Three Button Web Controls ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image8.png))</span></span>


<span data-ttu-id="8d5d3-271">创建事件处理程序为每个三个按钮的`Click`事件并使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="8d5d3-271">Create event handlers for each of the three Button s `Click` events and use the following code:</span></span>


[!code-csharp[Main](wrapping-database-modifications-within-a-transaction-cs/samples/sample9.cs)]

<span data-ttu-id="8d5d3-272">刷新按钮 s`Click`事件处理程序只需重新绑定到 GridView 数据，通过调用`Products`GridView 的`DataBind`方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-272">The refresh Button s `Click` event handler simply rebinds the data to the GridView by calling the `Products` GridView s `DataBind` method.</span></span>

<span data-ttu-id="8d5d3-273">第二个事件处理程序将重新分配产品`CategoryID`s，并使用来自 BLL 来执行数据库的新事务方法更新之下的事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-273">The second event handler reassigns the products `CategoryID` s and uses the new transaction method from the BLL to perform the database updates under the umbrella of a transaction.</span></span> <span data-ttu-id="8d5d3-274">请注意，每个产品 s`CategoryID`随意设为相同的值作为其`ProductID`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-274">Note that each product s `CategoryID` is arbitrarily set to the same value as its `ProductID`.</span></span> <span data-ttu-id="8d5d3-275">这将正常的前几种产品，由于这些产品具有`ProductID`发生这种情况将映射到有效的值`CategoryID`s。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-275">This will work fine for the first few products, since those products have `ProductID` values that happen to map to valid `CategoryID` s.</span></span> <span data-ttu-id="8d5d3-276">但出现一次`ProductID`s 开始变得过大，这种巧合的重叠`ProductID`s 和`CategoryID`s 不再适用。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-276">But once the `ProductID` s start getting too large, this coincidental overlap of `ProductID` s and `CategoryID` s no longer applies.</span></span>

<span data-ttu-id="8d5d3-277">第三个`Click`事件处理程序更新产品`CategoryID`中相同的方式，但将更新发送到数据库使用`ProductsTableAdapter`s 默认`Update`方法。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-277">The third `Click` event handler updates the products `CategoryID` s in the same manner, but sends the update to the database using the `ProductsTableAdapter` s default `Update` method.</span></span> <span data-ttu-id="8d5d3-278">这`Update`方法不会包装在一个事务内的命令系列中，以便在第一个遇到的外键约束冲突错误之前进行这些更改将保持不变。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-278">This `Update` method does not wrap the series of commands within a transaction, so those changes are made prior to the first encountered foreign key constraint violation error will persist.</span></span>

<span data-ttu-id="8d5d3-279">若要演示此行为，请访问此页上的通过浏览器。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-279">To demonstrate this behavior, visit this page through a browser.</span></span> <span data-ttu-id="8d5d3-280">最初应看到数据的第一页，如图 8 中所示。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-280">Initially you should see the first page of data as shown in Figure 8.</span></span> <span data-ttu-id="8d5d3-281">接下来，单击修改类别 （与事务） 按钮。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-281">Next, click the Modify Categories (WITH TRANSACTION) button.</span></span> <span data-ttu-id="8d5d3-282">这将导致回发并尝试更新的所有产品`CategoryID`值，但会导致违反外键约束 （请参阅图 9）。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-282">This will cause a postback and attempt to update all of the products `CategoryID` values, but will result in a foreign key constraint violation (see Figure 9).</span></span>


<span data-ttu-id="8d5d3-283">[![产品显示在可分页的 GridView](wrapping-database-modifications-within-a-transaction-cs/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-283">[![The Products are Displayed in a Pageable GridView](wrapping-database-modifications-within-a-transaction-cs/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image9.png)</span></span>

<span data-ttu-id="8d5d3-284">**图 8**:可分页的 GridView 中显示的产品 ([单击此项可查看原尺寸图像](wrapping-database-modifications-within-a-transaction-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-284">**Figure 8**: The Products are Displayed in a Pageable GridView ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image10.png))</span></span>


<span data-ttu-id="8d5d3-285">[![重新分配类别导致违反外键约束](wrapping-database-modifications-within-a-transaction-cs/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-285">[![Reassigning the Categories Results in a Foreign Key Constraint Violation](wrapping-database-modifications-within-a-transaction-cs/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image11.png)</span></span>

<span data-ttu-id="8d5d3-286">**图 9**:重新分配类别导致违反了外键约束 ([单击此项可查看原尺寸图像](wrapping-database-modifications-within-a-transaction-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-286">**Figure 9**: Reassigning the Categories Results in a Foreign Key Constraint Violation ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image12.png))</span></span>


<span data-ttu-id="8d5d3-287">现在，单击浏览器 s 后退按钮，然后单击刷新网格按钮。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-287">Now hit your browser s Back button and then click the Refresh Grid button.</span></span> <span data-ttu-id="8d5d3-288">刷新数据后你应看到完全相同的输出，如图 8 中所示。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-288">Upon refreshing the data you should see the exact same output as shown in Figure 8.</span></span> <span data-ttu-id="8d5d3-289">也就是说，甚至是虽然某些产品`CategoryID`s 的已更改为合法值和在数据库中更新，它们时回滚发生外键约束冲突。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-289">That is, even though some of the products `CategoryID` s were changed to legal values and updated in the database, they were rolled back when the foreign key constraint violation occurred.</span></span>

<span data-ttu-id="8d5d3-290">现在，尝试单击修改类别 （而无需事务） 按钮。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-290">Now try clicking the Modify Categories (WITHOUT TRANSACTION) button.</span></span> <span data-ttu-id="8d5d3-291">这会导致相同的外键约束冲突错误 （请参阅图 9），这一次的那些产品，但其`CategoryID`值已更改为合法值将不会回滚。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-291">This will result in the same foreign key constraint violation error (see Figure 9), but this time those products whose `CategoryID` values were changed to a legal value will not be rolled back.</span></span> <span data-ttu-id="8d5d3-292">按浏览器 s 后退按钮，然后刷新网格按钮。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-292">Hit your browser s Back button and then the Refresh Grid button.</span></span> <span data-ttu-id="8d5d3-293">如图 10 所示，`CategoryID`的前八个产品已被重新分配。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-293">As Figure 10 shows, the `CategoryID` s of the first eight products have been reassigned.</span></span> <span data-ttu-id="8d5d3-294">例如，在图 8 中，更改针对必须`CategoryID`为 1，但在图 10 it s 中被重新分配到 2。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-294">For example, in Figure 8, Chang had a `CategoryID` of 1, but in Figure 10 it s been reassigned to 2.</span></span>


<span data-ttu-id="8d5d3-295">[![某些产品类别 Id 值更新时其他人已不是](wrapping-database-modifications-within-a-transaction-cs/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-295">[![Some Products CategoryID Values were Updated While Others Were Not](wrapping-database-modifications-within-a-transaction-cs/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-cs/_static/image13.png)</span></span>

<span data-ttu-id="8d5d3-296">**图 10**:某些产品`CategoryID`值更新时其他人已不是 ([单击以查看实际尺寸的图像](wrapping-database-modifications-within-a-transaction-cs/_static/image14.png))</span><span class="sxs-lookup"><span data-stu-id="8d5d3-296">**Figure 10**: Some Products `CategoryID` Values were Updated While Others Were Not ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-cs/_static/image14.png))</span></span>


## <a name="summary"></a><span data-ttu-id="8d5d3-297">总结</span><span class="sxs-lookup"><span data-stu-id="8d5d3-297">Summary</span></span>

<span data-ttu-id="8d5d3-298">默认情况下，TableAdapter 的方法在事务的作用域内不包装执行的数据库语句，但我们可以轻而易举地添加方法将创建、 提交和回滚事务。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-298">By default, the TableAdapter s methods do not wrap the executed database statements within the scope of a transaction, but with a little work we can add methods that will create, commit, and rollback a transaction.</span></span> <span data-ttu-id="8d5d3-299">在本教程中，我们将创建三个此类方法中的`ProductsTableAdapter`类： `BeginTransaction`， `CommitTransaction`，和`RollbackTransaction`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-299">In this tutorial we created three such methods in the `ProductsTableAdapter` class: `BeginTransaction`, `CommitTransaction`, and `RollbackTransaction`.</span></span> <span data-ttu-id="8d5d3-300">我们已了解如何使用这些方法以及`try...catch`要进行数据修改语句的一系列原子块。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-300">We saw how to use these methods along with a `try...catch` block to make a series of data modification statements atomic.</span></span> <span data-ttu-id="8d5d3-301">具体而言，我们创建了`UpdateWithTransaction`中的方法`ProductsTableAdapter`，它使用批更新模式来执行必要的修改的行对所提供的`ProductsDataTable`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-301">In particular, we created the `UpdateWithTransaction` method in the `ProductsTableAdapter`, which uses the Batch Update pattern to perform the necessary modifications to the rows of a supplied `ProductsDataTable`.</span></span> <span data-ttu-id="8d5d3-302">我们还添加了`DeleteProductsWithTransaction`方法`ProductsBLL`类中的 BLL，接受`List`的`ProductID`作为其输入值，并调用 DB 直接模式方法`Delete`为每个`ProductID`。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-302">We also added the `DeleteProductsWithTransaction` method to the `ProductsBLL` class in the BLL, which accepts a `List` of `ProductID` values as its input and calls the DB-Direct pattern method `Delete` for each `ProductID`.</span></span> <span data-ttu-id="8d5d3-303">这两种方法首先创建一个事务，然后执行中的数据修改语句`try...catch`块。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-303">Both methods start by creating a transaction and then executing the data modification statements within a `try...catch` block.</span></span> <span data-ttu-id="8d5d3-304">如果发生异常，回滚事务，否则它是已提交。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-304">If an exception occurs, the transaction is rolled back, otherwise it is committed.</span></span>

<span data-ttu-id="8d5d3-305">步骤 5 所示事务性批处理更新与忘记了使用事务的批处理更新的效果。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-305">Step 5 illustrated the effect of transactional batch updates versus batch updates that neglected to use a transaction.</span></span> <span data-ttu-id="8d5d3-306">在接下来三个教程中我们将在本教程中的布局的基础之上生成，创建用于执行批量更新、 删除和插入的用户界面。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-306">In the next three tutorials we will build upon the foundation laid in this tutorial and create user interfaces for performing batch updates, deletes, and inserts.</span></span>

<span data-ttu-id="8d5d3-307">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="8d5d3-307">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="8d5d3-308">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="8d5d3-308">Further Reading</span></span>

<span data-ttu-id="8d5d3-309">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="8d5d3-309">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="8d5d3-310">维护与事务的数据库一致性</span><span class="sxs-lookup"><span data-stu-id="8d5d3-310">Maintaining Database Consistency with Transactions</span></span>](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)
- [<span data-ttu-id="8d5d3-311">管理 SQL Server 中的事务的存储过程</span><span class="sxs-lookup"><span data-stu-id="8d5d3-311">Managing Transactions in SQL Server Stored Procedures</span></span>](http://www.4guysfromrolla.com/webtech/080305-1.shtml)
- [<span data-ttu-id="8d5d3-312">事务变得更容易： `System.Transactions`</span><span class="sxs-lookup"><span data-stu-id="8d5d3-312">Transactions Made Easy: `System.Transactions`</span></span>](https://blogs.msdn.com/florinlazar/archive/2004/07/23/192239.aspx)
- [<span data-ttu-id="8d5d3-313">TransactionScope 和 DataAdapters</span><span class="sxs-lookup"><span data-stu-id="8d5d3-313">TransactionScope and DataAdapters</span></span>](http://andyclymer.blogspot.com/2007/01/transactionscope-and-dataadapters.html)
- [<span data-ttu-id="8d5d3-314">在.NET 中使用 Oracle 数据库事务</span><span class="sxs-lookup"><span data-stu-id="8d5d3-314">Using Oracle Database Transactions in .NET</span></span>](http://www.oracle.com/technology/pub/articles/price_dbtrans_dotnet.html)

## <a name="about-the-author"></a><span data-ttu-id="8d5d3-315">关于作者</span><span class="sxs-lookup"><span data-stu-id="8d5d3-315">About the Author</span></span>

<span data-ttu-id="8d5d3-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)的七个部 asp/ASP.NET 书籍并创办了作者[4GuysFromRolla.com](http://www.4guysfromrolla.com)，自 1998 年以来一直致力于 Microsoft Web 技术。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="8d5d3-317">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-317">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="8d5d3-318">他最新著作是[ *Sams Teach 自己 ASP.NET 2.0 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-318">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="8d5d3-319">他可以到达[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-319">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="8d5d3-320">或通过他的博客，其中，请参阅[ http://ScottOnWriting.NET ](http://ScottOnWriting.NET)。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-320">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="8d5d3-321">特别感谢</span><span class="sxs-lookup"><span data-stu-id="8d5d3-321">Special Thanks To</span></span>

<span data-ttu-id="8d5d3-322">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-322">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="8d5d3-323">本教程中的潜在顾客审阅者是 Dave Gardner、 Hilton Giesenow 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="8d5d3-323">Lead reviewers for this tutorial were Dave Gardner, Hilton Giesenow, and Teresa Murphy.</span></span> <span data-ttu-id="8d5d3-324">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="8d5d3-324">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="8d5d3-325">如果是这样，给我在行[ mitchell@4GuysFromRolla.com。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="8d5d3-325">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> [<span data-ttu-id="8d5d3-326">下一页</span><span class="sxs-lookup"><span data-stu-id="8d5d3-326">Next</span></span>](batch-updating-cs.md)

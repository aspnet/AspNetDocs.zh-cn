---
uid: web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-vb
title: 包装事务内的数据库修改（VB） |Microsoft Docs
author: rick-anderson
description: 本教程是第四个教程，其中介绍了如何更新、删除和插入批数据。 在本教程中，我们将了解数据库事务如何允许 。
ms.author: riande
ms.date: 06/26/2007
ms.assetid: 7d821db5-6cbb-4b38-af14-198f9155fc82
msc.legacyurl: /web-forms/overview/data-access/working-with-batched-data/wrapping-database-modifications-within-a-transaction-vb
msc.type: authoredcontent
ms.openlocfilehash: dee95ee2789a69aac5aa79b8358e58e3ee99e1b2
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74636572"
---
# <a name="wrapping-database-modifications-within-a-transaction-vb"></a><span data-ttu-id="06227-104">包装事务内的数据库修改 (VB)</span><span class="sxs-lookup"><span data-stu-id="06227-104">Wrapping Database Modifications within a Transaction (VB)</span></span>

<span data-ttu-id="06227-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="06227-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="06227-106">[下载代码](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_VB.zip)或[下载 PDF](wrapping-database-modifications-within-a-transaction-vb/_static/datatutorial63vb1.pdf)</span><span class="sxs-lookup"><span data-stu-id="06227-106">[Download Code](https://download.microsoft.com/download/3/9/f/39f92b37-e92e-4ab3-909e-b4ef23d01aa3/ASPNET_Data_Tutorial_63_VB.zip) or [Download PDF](wrapping-database-modifications-within-a-transaction-vb/_static/datatutorial63vb1.pdf)</span></span>

> <span data-ttu-id="06227-107">本教程是第四个教程，其中介绍了如何更新、删除和插入批数据。</span><span class="sxs-lookup"><span data-stu-id="06227-107">This tutorial is the first of four that looks at updating, deleting, and inserting batches of data.</span></span> <span data-ttu-id="06227-108">在本教程中，我们将了解数据库事务如何允许以原子操作的形式执行批处理修改，这可确保所有步骤均成功或所有步骤均失败。</span><span class="sxs-lookup"><span data-stu-id="06227-108">In this tutorial we learn how database transactions allow batch modifications to be carried out as an atomic operation, which ensures that either all steps succeed or all steps fail.</span></span>

## <a name="introduction"></a><span data-ttu-id="06227-109">简介</span><span class="sxs-lookup"><span data-stu-id="06227-109">Introduction</span></span>

<span data-ttu-id="06227-110">正如我们从有关[插入、更新和删除数据](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-vb.md)教程的概述开始，GridView 为行级编辑和删除提供内置支持。</span><span class="sxs-lookup"><span data-stu-id="06227-110">As we saw starting with the [An Overview of Inserting, Updating, and Deleting Data](../editing-inserting-and-deleting-data/an-overview-of-inserting-updating-and-deleting-data-vb.md) tutorial, the GridView provides built-in support for row-level editing and deleting.</span></span> <span data-ttu-id="06227-111">只需单击几下鼠标，就能创建一个丰富的数据修改接口，而无需编写代码行，只要您是每行都有编辑和删除的内容。</span><span class="sxs-lookup"><span data-stu-id="06227-111">With a few clicks of the mouse it is possible to create a rich data modification interface without writing a line of code, so long as you are content with editing and deleting on a per-row basis.</span></span> <span data-ttu-id="06227-112">但是，在某些情况下，这种情况并不充分，我们需要为用户提供编辑或删除一批记录的能力。</span><span class="sxs-lookup"><span data-stu-id="06227-112">However, in certain scenarios this is insufficient and we need to provide users with the ability to edit or delete a batch of records.</span></span>

<span data-ttu-id="06227-113">例如，大多数基于 web 的电子邮件客户端使用网格来列出每个消息，其中每行都包含一个复选框以及电子邮件信息（主题、发件人等）。</span><span class="sxs-lookup"><span data-stu-id="06227-113">For example, most web-based email clients use a grid to list each message where each row includes a checkbox along with the email s information (subject, sender, and so forth).</span></span> <span data-ttu-id="06227-114">此接口允许用户通过选中并单击 "删除选择的消息" 按钮来删除多个消息。</span><span class="sxs-lookup"><span data-stu-id="06227-114">This interface permits the user to delete multiple messages by checking them and then clicking a Delete Selected Messages button.</span></span> <span data-ttu-id="06227-115">批处理编辑接口非常适合于用户经常编辑多个不同记录的情况。</span><span class="sxs-lookup"><span data-stu-id="06227-115">A batch editing interface is ideal in situations where users commonly edit many different records.</span></span> <span data-ttu-id="06227-116">除了强制用户单击 "编辑"、进行更改，然后单击每个需要修改的记录的 "更新" 时，批处理编辑界面都会使用其编辑界面呈现每一行。</span><span class="sxs-lookup"><span data-stu-id="06227-116">Rather than forcing the user to click Edit, make their change, and then click Update for each record that needs to be modified, a batch editing interface renders each row with its editing interface.</span></span> <span data-ttu-id="06227-117">用户可以快速修改需要更改的行集，然后通过单击 "全部更新" 按钮保存这些更改。</span><span class="sxs-lookup"><span data-stu-id="06227-117">The user can quickly modify the set of rows that need to be changed and then save these changes by clicking an Update All button.</span></span> <span data-ttu-id="06227-118">本教程将介绍如何创建用于插入、编辑和删除批数据的接口。</span><span class="sxs-lookup"><span data-stu-id="06227-118">In this set of tutorials we'll examine how to create interfaces for inserting, editing, and deleting batches of data.</span></span>

<span data-ttu-id="06227-119">执行批处理操作时，很重要的一点是，确定批处理中的某些操作在其他操作失败时是否可以成功。</span><span class="sxs-lookup"><span data-stu-id="06227-119">When performing batch operations it s important to determine whether it should be possible for some of the operations in the batch to succeed while others fail.</span></span> <span data-ttu-id="06227-120">假设有一个批处理删除接口-如果成功删除第一个选定记录，则会发生什么情况，但第二个记录由于外键约束冲突而失败。</span><span class="sxs-lookup"><span data-stu-id="06227-120">Consider a batch deleting interface - what should happen if the first selected record is deleted successfully, but the second one fails, say, because of a foreign key constraint violation?</span></span> <span data-ttu-id="06227-121">第一条记录是否应该回滚，或者第一条记录是否可接受？</span><span class="sxs-lookup"><span data-stu-id="06227-121">Should the first record s delete be rolled back or is it acceptable for the first record to remain deleted?</span></span>

<span data-ttu-id="06227-122">如果希望批处理操作被视为[原子操作](http://en.wikipedia.org/wiki/Atomic_operation)，其中无论是成功完成的所有步骤还是所有步骤均失败，则需要对数据访问层进行扩充以支持[数据库事务](http://en.wikipedia.org/wiki/Database_transaction)。</span><span class="sxs-lookup"><span data-stu-id="06227-122">If you want the batch operation to be treated as an [atomic operation](http://en.wikipedia.org/wiki/Atomic_operation), one where either all of the steps succeed or all of the steps fail, then the Data Access Layer needs to be augmented to include support for [database transactions](http://en.wikipedia.org/wiki/Database_transaction).</span></span> <span data-ttu-id="06227-123">数据库事务可保证在事务的涵盖下执行的一组 `INSERT`、`UPDATE`和 `DELETE` 语句的原子性，这是大多数新式数据库系统都支持的一项功能。</span><span class="sxs-lookup"><span data-stu-id="06227-123">Database transactions guarantee atomicity for the set of `INSERT`, `UPDATE`, and `DELETE` statements executed under the umbrella of the transaction and are a feature supported by most all modern database systems.</span></span>

<span data-ttu-id="06227-124">在本教程中，我们将介绍如何扩展 DAL 以使用数据库事务。</span><span class="sxs-lookup"><span data-stu-id="06227-124">In this tutorial we'll look at how to extend the DAL to use database transactions.</span></span> <span data-ttu-id="06227-125">后续教程将检查如何实现用于批量插入、更新和删除接口的网页。</span><span class="sxs-lookup"><span data-stu-id="06227-125">Subsequent tutorials will examine implementing web pages for batch inserting, updating, and deleting interfaces.</span></span> <span data-ttu-id="06227-126">让我们开始吧！</span><span class="sxs-lookup"><span data-stu-id="06227-126">Let s get started!</span></span>

> [!NOTE]
> <span data-ttu-id="06227-127">在批处理事务中修改数据时，并不总是需要原子性。</span><span class="sxs-lookup"><span data-stu-id="06227-127">When modifying data in a batch transaction, atomicity is not always needed.</span></span> <span data-ttu-id="06227-128">在某些情况下，可能可以接受某些数据修改，但在同一批次中，其他人会失败，例如从基于 web 的电子邮件客户端中删除一组电子邮件。</span><span class="sxs-lookup"><span data-stu-id="06227-128">In some scenarios, it may be acceptable to have some data modifications succeed and others in the same batch fail, such as when deleting a set of emails from a web-based email client.</span></span> <span data-ttu-id="06227-129">如果在删除过程中出现数据库错误，则很可能会在不错误的情况下处理这些记录。</span><span class="sxs-lookup"><span data-stu-id="06227-129">If there s a database error midway through the deletion process, it s probably acceptable that those records processed without error remain deleted.</span></span> <span data-ttu-id="06227-130">在这种情况下，不需要修改 DAL 以支持数据库事务。</span><span class="sxs-lookup"><span data-stu-id="06227-130">In such cases, the DAL does not need to be modified to support database transactions.</span></span> <span data-ttu-id="06227-131">但还有其他批处理操作方案，其中的原子性至关重要。</span><span class="sxs-lookup"><span data-stu-id="06227-131">There are other batch operation scenarios, however, where atomicity is vital.</span></span> <span data-ttu-id="06227-132">当客户将其资金从一个银行帐户移到另一个银行帐户时，必须执行两项操作：必须从第一个帐户中扣除资金，然后再将其添加到第二个帐户。</span><span class="sxs-lookup"><span data-stu-id="06227-132">When a customer moves her funds from one bank account to another, two operations must be performed: the funds must be deducted from the first account and then added to the second.</span></span> <span data-ttu-id="06227-133">虽然银行可能不介意第一步成功完成，但第二步却失败，但其客户理解。</span><span class="sxs-lookup"><span data-stu-id="06227-133">While the bank may not mind having the first step succeed but the second step fail, its customers would understandably be upset.</span></span> <span data-ttu-id="06227-134">我建议您完成本教程并实现对 DAL 的增强，以支持数据库事务，即使您不打算在批处理中将它们用于插入、更新和删除接口，我们将在以下三个教程中构建。</span><span class="sxs-lookup"><span data-stu-id="06227-134">I encourage you to work through this tutorial and implement the enhancements to the DAL to support database transactions even if you do not plan on using them in the batch inserting, updating, and deleting interfaces we'll be building in the following three tutorials.</span></span>

## <a name="an-overview-of-transactions"></a><span data-ttu-id="06227-135">事务概述</span><span class="sxs-lookup"><span data-stu-id="06227-135">An Overview of Transactions</span></span>

<span data-ttu-id="06227-136">大多数数据库都支持*事务*，使多个数据库命令可以分组为一个逻辑工作单元。</span><span class="sxs-lookup"><span data-stu-id="06227-136">Most databases include support for *transactions*, which enable multiple database commands to be grouped into a single logical unit of work.</span></span> <span data-ttu-id="06227-137">构成事务的数据库命令保证是原子的，这意味着所有命令都将失败或全部成功。</span><span class="sxs-lookup"><span data-stu-id="06227-137">The database commands that comprise a transaction are guaranteed to be atomic, meaning that either all commands will fail or all will succeed.</span></span>

<span data-ttu-id="06227-138">通常，使用以下模式通过 SQL 语句实现事务：</span><span class="sxs-lookup"><span data-stu-id="06227-138">In general, transactions are implemented through SQL statements using the following pattern:</span></span>

1. <span data-ttu-id="06227-139">指示事务的开始。</span><span class="sxs-lookup"><span data-stu-id="06227-139">Indicate the start of a transaction.</span></span>
2. <span data-ttu-id="06227-140">执行构成事务的 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="06227-140">Execute the SQL statements that comprise the transaction.</span></span>
3. <span data-ttu-id="06227-141">如果步骤2中的某个语句出错，则回滚事务。</span><span class="sxs-lookup"><span data-stu-id="06227-141">If there is an error in one of the statements from Step 2, rollback the transaction.</span></span>
4. <span data-ttu-id="06227-142">如果步骤2中的所有语句都完成且没有错误，请提交该事务。</span><span class="sxs-lookup"><span data-stu-id="06227-142">If all of the statements from Step 2 complete without error, commit the transaction.</span></span>

<span data-ttu-id="06227-143">在编写 SQL 脚本或创建存储过程时，或者通过编程方式使用[`System.Transactions` 命名空间](https://msdn.microsoft.com/library/system.transactions.aspx)中的类时，可以手动输入用于创建、提交和回滚事务的 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="06227-143">The SQL statements used to create, commit, and roll back the transaction can be entered manually when writing SQL scripts or creating stored procedures, or through programmatic means using either ADO.NET or the classes in the [`System.Transactions` namespace](https://msdn.microsoft.com/library/system.transactions.aspx).</span></span> <span data-ttu-id="06227-144">在本教程中，我们将仅使用 ADO.NET 检查管理事务。</span><span class="sxs-lookup"><span data-stu-id="06227-144">In this tutorial we will only examine managing transactions using ADO.NET.</span></span> <span data-ttu-id="06227-145">在将来的教程中，我们将介绍如何在数据访问层中使用存储过程，此时我们将浏览用于创建、回滚和提交事务的 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="06227-145">In a future tutorial we will look at how to use stored procedures in the Data Access Layer, at which time we'll explore the SQL statements for creating, rolling back, and committing transactions.</span></span> <span data-ttu-id="06227-146">同时，有关详细信息，请参阅在[SQL Server 存储过程中管理事务](http://www.4guysfromrolla.com/webtech/080305-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="06227-146">In the meantime, consult [Managing Transactions in SQL Server Stored Procedures](http://www.4guysfromrolla.com/webtech/080305-1.shtml) for more information.</span></span>

> [!NOTE]
> <span data-ttu-id="06227-147">使用 `System.Transactions` 命名空间中的[`TransactionScope` 类](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx)，开发人员可以以编程方式包装事务范围内的一系列语句，并包括对涉及多个源的复杂事务的支持，例如两个不同的数据库，甚至异类类型的数据存储，如 Microsoft SQL Server 数据库、Oracle 数据库和 Web 服务。</span><span class="sxs-lookup"><span data-stu-id="06227-147">The [`TransactionScope` class](https://msdn.microsoft.com/library/system.transactions.transactionscope.aspx) in the `System.Transactions` namespace enables developers to programmatically wrap a series of statements within the scope of a transaction and includes support for complex transactions that involve multiple sources, such as two different databases or even heterogeneous types of data stores, such as a Microsoft SQL Server database, an Oracle database, and a Web service.</span></span> <span data-ttu-id="06227-148">我决定在此教程中使用 ADO.NET 事务，而不是 `TransactionScope` 类，因为 ADO.NET 更特定于数据库事务，在许多情况下，消耗的资源要少得多。</span><span class="sxs-lookup"><span data-stu-id="06227-148">I ve decided to use ADO.NET transactions for this tutorial instead of the `TransactionScope` class because ADO.NET is more specific for database transactions and, in many cases, is far less resource intensive.</span></span> <span data-ttu-id="06227-149">此外，在某些情况下，`TransactionScope` 类使用 Microsoft 分布式事务处理协调器（MSDTC）。</span><span class="sxs-lookup"><span data-stu-id="06227-149">In addition, under certain scenarios the `TransactionScope` class uses the Microsoft Distributed Transaction Coordinator (MSDTC).</span></span> <span data-ttu-id="06227-150">MSDTC 的配置、实现和性能问题使其成为一个专门的高级主题，并超出了这些教程的范围。</span><span class="sxs-lookup"><span data-stu-id="06227-150">The configuration, implementation, and performance issues surrounding MSDTC makes it a rather specialized and advanced topic and beyond the scope of these tutorials.</span></span>

<span data-ttu-id="06227-151">在 ADO.NET 中使用 SqlClient 提供程序时，将通过调用[`SqlConnection` 类](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx)s [`BeginTransaction` 方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx)来启动事务，该方法返回[`SqlTransaction` 对象](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx)。</span><span class="sxs-lookup"><span data-stu-id="06227-151">When working with the SqlClient provider in ADO.NET, transactions are initiated through a call to the [`SqlConnection` class](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.aspx) s [`BeginTransaction` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqlconnection.begintransaction.aspx), which returns a [`SqlTransaction` object](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.aspx).</span></span> <span data-ttu-id="06227-152">构成事务的数据修改语句置于 `try...catch` 块内。</span><span class="sxs-lookup"><span data-stu-id="06227-152">The data modification statements that makeup the transaction are placed within a `try...catch` block.</span></span> <span data-ttu-id="06227-153">如果 `try` 块中的语句发生错误，则执行会传输到 `catch` 块，在这种情况下，可通过 `SqlTransaction` 对象[`Rollback` 方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx)回滚事务。</span><span class="sxs-lookup"><span data-stu-id="06227-153">If an error occurs in a statement in the `try` block, execution transfers to the `catch` block where the transaction can be rolled back via the `SqlTransaction` object s [`Rollback` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.rollback.aspx).</span></span> <span data-ttu-id="06227-154">如果所有语句都成功完成，则在 `try` 块末尾调用 `SqlTransaction` 对象 s [`Commit` 方法](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx)将提交该事务。</span><span class="sxs-lookup"><span data-stu-id="06227-154">If all of the statements complete successfully, a call to the `SqlTransaction` object s [`Commit` method](https://msdn.microsoft.com/library/system.data.sqlclient.sqltransaction.commit.aspx) at the end of the `try` block commits the transaction.</span></span> <span data-ttu-id="06227-155">下面的代码段演示了此模式。</span><span class="sxs-lookup"><span data-stu-id="06227-155">The following code snippet illustrates this pattern.</span></span> <span data-ttu-id="06227-156">有关将事务与 ADO.NET 结合使用的其他语法和示例，请参阅使用[事务维护数据库一致性](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)。</span><span class="sxs-lookup"><span data-stu-id="06227-156">See [Maintaining Database Consistency with Transactions](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx) for additional syntax and examples of using transactions with ADO.NET.</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample1.vb)]

<span data-ttu-id="06227-157">默认情况下，类型化数据集中的 Tableadapter 不使用事务。</span><span class="sxs-lookup"><span data-stu-id="06227-157">By default, the TableAdapters in a Typed DataSet do not use transactions.</span></span> <span data-ttu-id="06227-158">若要为事务提供支持，我们需要增加 TableAdapter 类，使其包含使用以上模式在事务范围内执行一系列数据修改语句的其他方法。</span><span class="sxs-lookup"><span data-stu-id="06227-158">To provide support for transactions we need to augment the TableAdapter classes to include additional methods that use the above pattern to perform a series of data modification statements within the scope of a transaction.</span></span> <span data-ttu-id="06227-159">在步骤2中，我们将了解如何使用分部类添加这些方法。</span><span class="sxs-lookup"><span data-stu-id="06227-159">In Step 2 we'll see how to use partial classes to add these methods.</span></span>

## <a name="step-1-creating-the-working-with-batched-data-web-pages"></a><span data-ttu-id="06227-160">步骤1：创建使用批处理数据网页</span><span class="sxs-lookup"><span data-stu-id="06227-160">Step 1: Creating the Working with Batched Data Web Pages</span></span>

<span data-ttu-id="06227-161">在开始探索如何扩充 DAL 以支持数据库事务之前，首先请花一些时间来创建本教程所需的 ASP.NET 网页以及下面的三个网页。</span><span class="sxs-lookup"><span data-stu-id="06227-161">Before we start exploring how to augment the DAL to support database transactions, let s first take a moment to create the ASP.NET web pages that we will need for this tutorial and the three that follow.</span></span> <span data-ttu-id="06227-162">首先添加一个名为 `BatchData` 的新文件夹，然后添加以下 ASP.NET 页面，将每个页面与 `Site.master` 母版页相关联。</span><span class="sxs-lookup"><span data-stu-id="06227-162">Start by adding a new folder named `BatchData` and then add the following ASP.NET pages, associating each page with the `Site.master` master page.</span></span>

- `Default.aspx`
- `Transactions.aspx`
- `BatchUpdate.aspx`
- `BatchDelete.aspx`
- `BatchInsert.aspx`

![为 SqlDataSource 相关教程添加 ASP.NET 页](wrapping-database-modifications-within-a-transaction-vb/_static/image1.gif)

<span data-ttu-id="06227-164">**图 1**：添加 SqlDataSource 相关教程的 ASP.NET 页</span><span class="sxs-lookup"><span data-stu-id="06227-164">**Figure 1**: Add the ASP.NET Pages for the SqlDataSource-Related Tutorials</span></span>

<span data-ttu-id="06227-165">对于其他文件夹，`Default.aspx` 将使用 `SectionLevelTutorialListing.ascx` 用户控件列出其部分中的教程。</span><span class="sxs-lookup"><span data-stu-id="06227-165">As with the other folders, `Default.aspx` will use the `SectionLevelTutorialListing.ascx` User Control to list the tutorials within its section.</span></span> <span data-ttu-id="06227-166">因此，通过将此用户控件从解决方案资源管理器拖到页面 s 设计视图，将该用户控件添加到 `Default.aspx`。</span><span class="sxs-lookup"><span data-stu-id="06227-166">Therefore, add this User Control to `Default.aspx` by dragging it from the Solution Explorer onto the page s Design view.</span></span>

<span data-ttu-id="06227-167">[![将 SectionLevelTutorialListing 用户控件添加到 default.aspx](wrapping-database-modifications-within-a-transaction-vb/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="06227-167">[![Add the SectionLevelTutorialListing.ascx User Control to Default.aspx](wrapping-database-modifications-within-a-transaction-vb/_static/image2.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image1.png)</span></span>

<span data-ttu-id="06227-168">**图 2**：将 `SectionLevelTutorialListing.ascx` 用户控件添加到 `Default.aspx` （[单击以查看完全大小的图像](wrapping-database-modifications-within-a-transaction-vb/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-168">**Figure 2**: Add the `SectionLevelTutorialListing.ascx` User Control to `Default.aspx` ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image2.png))</span></span>

<span data-ttu-id="06227-169">最后，将这四个页面作为条目添加到 `Web.sitemap` 文件中。</span><span class="sxs-lookup"><span data-stu-id="06227-169">Lastly, add these four pages as entries to the `Web.sitemap` file.</span></span> <span data-ttu-id="06227-170">具体而言，请在自定义站点地图之后添加以下标记 `<siteMapNode>`：</span><span class="sxs-lookup"><span data-stu-id="06227-170">Specifically, add the following markup after the Customizing the Site Map `<siteMapNode>`:</span></span>

[!code-xml[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample2.xml)]

<span data-ttu-id="06227-171">更新 `Web.sitemap`后，请花点时间通过浏览器查看教程网站。</span><span class="sxs-lookup"><span data-stu-id="06227-171">After updating `Web.sitemap`, take a moment to view the tutorials website through a browser.</span></span> <span data-ttu-id="06227-172">左侧的菜单包含用于使用批量数据教程的项。</span><span class="sxs-lookup"><span data-stu-id="06227-172">The menu on the left now includes items for the working with batched data tutorials.</span></span>

![站点映射现在包含用于使用批量数据教程的条目](wrapping-database-modifications-within-a-transaction-vb/_static/image3.gif)

<span data-ttu-id="06227-174">**图 3**：站点地图现在包含用于使用批量数据教程的条目</span><span class="sxs-lookup"><span data-stu-id="06227-174">**Figure 3**: The Site Map Now Includes Entries for the Working with Batched Data Tutorials</span></span>

## <a name="step-2-updating-the-data-access-layer-to-support-database-transactions"></a><span data-ttu-id="06227-175">步骤2：更新数据访问层以支持数据库事务</span><span class="sxs-lookup"><span data-stu-id="06227-175">Step 2: Updating the Data Access Layer to Support Database Transactions</span></span>

<span data-ttu-id="06227-176">正如我们在第一个教程中所述，[创建数据访问层](../introduction/creating-a-data-access-layer-vb.md)，DAL 中的类型化数据集由数据表和 tableadapter 组成。</span><span class="sxs-lookup"><span data-stu-id="06227-176">As we discussed back in the first tutorial, [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-vb.md), the Typed DataSet in our DAL is composed of DataTables and TableAdapters.</span></span> <span data-ttu-id="06227-177">数据表保存数据时，Tableadapter 提供了将数据从数据库读入到数据表中的功能，用于通过对数据表的更改来更新数据库等。</span><span class="sxs-lookup"><span data-stu-id="06227-177">The DataTables hold data while the TableAdapters provide the functionality to read data from the database into the DataTables, to update the database with changes made to the DataTables, and so forth.</span></span> <span data-ttu-id="06227-178">回忆一下，Tableadapter 提供了两种用于更新数据的模式，我称之为批更新和数据库直通。</span><span class="sxs-lookup"><span data-stu-id="06227-178">Recall that the TableAdapters provide two patterns for updating data, which I referred to as Batch Update and DB-Direct.</span></span> <span data-ttu-id="06227-179">使用批处理更新模式时，TableAdapter 会传递到 Datarow 的数据集、DataTable 或集合。</span><span class="sxs-lookup"><span data-stu-id="06227-179">With the Batch Update pattern, the TableAdapter is passed a DataSet, DataTable, or collection of DataRows.</span></span> <span data-ttu-id="06227-180">枚举此数据，并对每个已插入、已修改或已删除的行执行 `InsertCommand`、`UpdateCommand`或 `DeleteCommand`。</span><span class="sxs-lookup"><span data-stu-id="06227-180">This data is enumerated and for each inserted, modified, or deleted row, the `InsertCommand`, `UpdateCommand`, or `DeleteCommand` is executed.</span></span> <span data-ttu-id="06227-181">使用 DB 直通模式时，TableAdapter 会传递插入、更新或删除单个记录所需的列值。</span><span class="sxs-lookup"><span data-stu-id="06227-181">With the DB-Direct pattern, the TableAdapter is instead passed the values of the columns necessary for inserting, updating, or deleting a single record.</span></span> <span data-ttu-id="06227-182">然后，DB 直接模式方法使用传入的值执行适当的 `InsertCommand`、`UpdateCommand`或 `DeleteCommand` 语句。</span><span class="sxs-lookup"><span data-stu-id="06227-182">The DB Direct pattern method then uses those passed-in values to execute the appropriate `InsertCommand`, `UpdateCommand`, or `DeleteCommand` statement.</span></span>

<span data-ttu-id="06227-183">无论使用何种更新模式，Tableadapter 自动生成的方法不使用事务。</span><span class="sxs-lookup"><span data-stu-id="06227-183">Regardless of the update pattern used, the TableAdapters auto-generated methods do not use transactions.</span></span> <span data-ttu-id="06227-184">默认情况下，由 TableAdapter 执行的每个插入、更新或删除操作都被视为一个单独的操作。</span><span class="sxs-lookup"><span data-stu-id="06227-184">By default each insert, update, or delete performed by the TableAdapter is treated as a single discrete operation.</span></span> <span data-ttu-id="06227-185">例如，假设 BLL 中的某些代码使用 DB 直通模式将十条记录插入到数据库中。</span><span class="sxs-lookup"><span data-stu-id="06227-185">For instance, imagine that the DB-Direct pattern is used by some code in the BLL to insert ten records into the database.</span></span> <span data-ttu-id="06227-186">此代码将调用 TableAdapter s `Insert` 方法十次。</span><span class="sxs-lookup"><span data-stu-id="06227-186">This code would call the TableAdapter s `Insert` method ten times.</span></span> <span data-ttu-id="06227-187">如果前5个插入成功，但第六个插入导致了异常，则前5个插入的记录将保留在数据库中。</span><span class="sxs-lookup"><span data-stu-id="06227-187">If the first five inserts succeed, but the sixth one resulted in an exception, the first five inserted records would remain in the database.</span></span> <span data-ttu-id="06227-188">同样，如果使用批处理更新模式来对 DataTable 中已插入的、已修改的和已删除的行执行插入、更新和删除操作，则如果前几个修改已成功，但出现错误，则这些之前的修改将"已完成" 将保留在数据库中。</span><span class="sxs-lookup"><span data-stu-id="06227-188">Similarly, if the Batch Update pattern is used to perform inserts, updates, and deletes to the inserted, modified, and deleted rows in a DataTable, if the first several modifications succeeded but a later one encountered an error, those earlier modifications that completed would remain in the database.</span></span>

<span data-ttu-id="06227-189">在某些情况下，我们希望确保一系列修改的原子性。</span><span class="sxs-lookup"><span data-stu-id="06227-189">In certain scenarios we want to ensure atomicity across a series of modifications.</span></span> <span data-ttu-id="06227-190">若要实现此目的，我们必须通过添加新方法来手动扩展 TableAdapter，该方法在事务的伞下执行 `InsertCommand`、`UpdateCommand`和 `DeleteCommand`。</span><span class="sxs-lookup"><span data-stu-id="06227-190">To accomplish this we must manually extend the TableAdapter by adding new methods that execute the `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s under the umbrella of a transaction.</span></span> <span data-ttu-id="06227-191">在[创建数据访问层](../introduction/creating-a-data-access-layer-vb.md)中，我们介绍了如何使用[分部类](http://en.wikipedia.org/wiki/Partial_type)来扩展类型化数据集中的数据表功能。</span><span class="sxs-lookup"><span data-stu-id="06227-191">In [Creating a Data Access Layer](../introduction/creating-a-data-access-layer-vb.md) we looked at using [partial classes](http://en.wikipedia.org/wiki/Partial_type) to extend the functionality of the DataTables within the Typed DataSet.</span></span> <span data-ttu-id="06227-192">此方法还可与 Tableadapter 一起使用。</span><span class="sxs-lookup"><span data-stu-id="06227-192">This technique can also be used with TableAdapters.</span></span>

<span data-ttu-id="06227-193">类型化数据集 `Northwind.xsd` 位于 `App_Code` 文件夹 s `DAL` 子文件夹中。</span><span class="sxs-lookup"><span data-stu-id="06227-193">The Typed DataSet `Northwind.xsd` is located in the `App_Code` folder s `DAL` subfolder.</span></span> <span data-ttu-id="06227-194">在名为 `TransactionSupport` `DAL` 文件夹中创建一个子文件夹，并添加一个名为 `ProductsTableAdapter.TransactionSupport.vb` 的新类文件（参见图4）。</span><span class="sxs-lookup"><span data-stu-id="06227-194">Create a subfolder in the `DAL` folder named `TransactionSupport` and add a new class file named `ProductsTableAdapter.TransactionSupport.vb` (see Figure 4).</span></span> <span data-ttu-id="06227-195">此文件将保存 `ProductsTableAdapter` 的部分实现，其中包括使用事务执行数据修改的方法。</span><span class="sxs-lookup"><span data-stu-id="06227-195">This file will hold the partial implementation of the `ProductsTableAdapter` that includes methods for performing data modifications using a transaction.</span></span>

![添加一个名为 TransactionSupport 的文件夹和一个名为 ProductsTableAdapter 的类文件。](wrapping-database-modifications-within-a-transaction-vb/_static/image4.gif)

<span data-ttu-id="06227-197">**图 4**：添加名为 `TransactionSupport` 的文件夹和名为 `ProductsTableAdapter.TransactionSupport.vb` 的类文件</span><span class="sxs-lookup"><span data-stu-id="06227-197">**Figure 4**: Add a Folder Named `TransactionSupport` and a Class File Named `ProductsTableAdapter.TransactionSupport.vb`</span></span>

<span data-ttu-id="06227-198">在 `ProductsTableAdapter.TransactionSupport.vb` 文件中输入以下代码：</span><span class="sxs-lookup"><span data-stu-id="06227-198">Enter the following code into the `ProductsTableAdapter.TransactionSupport.vb` file:</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample3.vb)]

<span data-ttu-id="06227-199">此处的类声明中的 `Partial` 关键字向编译器指示中添加的成员将添加到 `NorthwindTableAdapters` 命名空间中的 `ProductsTableAdapter` 类中。</span><span class="sxs-lookup"><span data-stu-id="06227-199">The `Partial` keyword in the class declaration here indicates to the compiler that the members added within are to be added to the `ProductsTableAdapter` class in the `NorthwindTableAdapters` namespace.</span></span> <span data-ttu-id="06227-200">请注意文件顶部的 `Imports System.Data.SqlClient` 语句。</span><span class="sxs-lookup"><span data-stu-id="06227-200">Note the `Imports System.Data.SqlClient` statement at the top of the file.</span></span> <span data-ttu-id="06227-201">由于 TableAdapter 配置为使用 SqlClient 提供程序，因此，在内部它使用[`SqlDataAdapter`](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx)对象向数据库发出其命令。</span><span class="sxs-lookup"><span data-stu-id="06227-201">Since the TableAdapter was configured to use the SqlClient provider, internally it uses a [`SqlDataAdapter`](https://msdn.microsoft.com/library/system.data.sqlclient.sqldataadapter.aspx) object to issue its commands to the database.</span></span> <span data-ttu-id="06227-202">因此，需要使用 `SqlTransaction` 类来启动事务，然后将其提交或回滚。</span><span class="sxs-lookup"><span data-stu-id="06227-202">Consequently, we need to use the `SqlTransaction` class to begin the transaction and then to commit it or roll it back.</span></span> <span data-ttu-id="06227-203">如果使用 Microsoft SQL Server 以外的数据存储，则需要使用相应的提供程序。</span><span class="sxs-lookup"><span data-stu-id="06227-203">If you are using a data store other than Microsoft SQL Server, you'll need to use the appropriate provider.</span></span>

<span data-ttu-id="06227-204">这些方法提供启动、回滚和提交事务所需的构建基块。</span><span class="sxs-lookup"><span data-stu-id="06227-204">These methods provide the building blocks needed to start, rollback, and commit a transaction.</span></span> <span data-ttu-id="06227-205">它们标记为 `Public`，使其可以从 `ProductsTableAdapter`中、从 DAL 中的另一个类或结构中的其他层（如 BLL）使用。</span><span class="sxs-lookup"><span data-stu-id="06227-205">They are marked `Public`, enabling them to be used from within the `ProductsTableAdapter`, from another class in the DAL, or from another layer in the architecture, such as the BLL.</span></span> <span data-ttu-id="06227-206">`BeginTransaction` 打开 TableAdapter 的内部 `SqlConnection` （如果需要），则启动该事务并将其分配给 `Transaction` 属性，并将该事务附加到 `SqlCommand` 对象的内部 `SqlDataAdapter`。</span><span class="sxs-lookup"><span data-stu-id="06227-206">`BeginTransaction` opens the TableAdapter s internal `SqlConnection` (if needed), begins the transaction and assigns it to the `Transaction` property, and attaches the transaction to the internal `SqlDataAdapter` s `SqlCommand` objects.</span></span> <span data-ttu-id="06227-207">`CommitTransaction` 和 `RollbackTransaction` 在关闭内部 `Rollback` 对象之前，分别调用 `Transaction` 对象 `Commit` 和 `Connection` 方法。</span><span class="sxs-lookup"><span data-stu-id="06227-207">`CommitTransaction` and `RollbackTransaction` call the `Transaction` object s `Commit` and `Rollback` methods, respectively, before closing the internal `Connection` object.</span></span>

## <a name="step-3-adding-methods-to-update-and-delete-data-under-the-umbrella-of-a-transaction"></a><span data-ttu-id="06227-208">步骤3：添加方法以更新和删除事务涵盖下的数据</span><span class="sxs-lookup"><span data-stu-id="06227-208">Step 3: Adding Methods to Update and Delete Data Under the Umbrella of a Transaction</span></span>

<span data-ttu-id="06227-209">完成这些方法后，我们就可以将方法添加到 `ProductsDataTable` 或 BLL，它们会在事务的一系列下执行一系列命令。</span><span class="sxs-lookup"><span data-stu-id="06227-209">With these methods complete, we re ready to add methods to `ProductsDataTable` or the BLL that perform a series of commands under the umbrella of a transaction.</span></span> <span data-ttu-id="06227-210">下面的方法使用批处理更新模式来更新使用事务的 `ProductsDataTable` 实例。</span><span class="sxs-lookup"><span data-stu-id="06227-210">The following method uses the Batch Update pattern to update a `ProductsDataTable` instance using a transaction.</span></span> <span data-ttu-id="06227-211">它通过调用 `BeginTransaction` 方法来启动事务，然后使用 `Try...Catch` 块发出数据修改语句。</span><span class="sxs-lookup"><span data-stu-id="06227-211">It starts a transaction by calling the `BeginTransaction` method and then uses a `Try...Catch` block to issue the data modification statements.</span></span> <span data-ttu-id="06227-212">如果对 `Adapter` 对象 s `Update` 方法的调用导致了异常，则执行将传输到将回滚事务并再次引发异常的 `catch` 块。</span><span class="sxs-lookup"><span data-stu-id="06227-212">If the call to the `Adapter` object s `Update` method results in an exception, execution will transfer to the `catch` block where the transaction will be rolled back and the exception re-thrown.</span></span> <span data-ttu-id="06227-213">请记住，`Update` 方法通过枚举提供的 `ProductsDataTable` 的行并执行必要的 `InsertCommand`、`UpdateCommand`和 `DeleteCommand` 来实现批处理更新模式。</span><span class="sxs-lookup"><span data-stu-id="06227-213">Recall that the `Update` method implements the Batch Update pattern by enumerating the rows of the supplied `ProductsDataTable` and performing the necessary `InsertCommand`, `UpdateCommand`, and `DeleteCommand` s.</span></span> <span data-ttu-id="06227-214">如果这些命令中的任何一个导致错误，则会回滚事务，并撤消事务生存期内先前所做的修改。</span><span class="sxs-lookup"><span data-stu-id="06227-214">If any one of these commands results in an error, the transaction is rolled back, undoing the previous modifications made during the transaction s lifetime.</span></span> <span data-ttu-id="06227-215">如果 `Update` 语句完全没有错误，则会完全提交事务。</span><span class="sxs-lookup"><span data-stu-id="06227-215">Should the `Update` statement complete without error, the transaction is committed in its entirety.</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample4.vb)]

<span data-ttu-id="06227-216">通过 `ProductsTableAdapter.TransactionSupport.vb`中的分部类将 `UpdateWithTransaction` 方法添加到 `ProductsTableAdapter` 类。</span><span class="sxs-lookup"><span data-stu-id="06227-216">Add the `UpdateWithTransaction` method to the `ProductsTableAdapter` class through the partial class in `ProductsTableAdapter.TransactionSupport.vb`.</span></span> <span data-ttu-id="06227-217">另外，还可以将此方法添加到业务逻辑层的 `ProductsBLL` 类中，并进行几次语法更改。</span><span class="sxs-lookup"><span data-stu-id="06227-217">Alternatively, this method could be added to the Business Logic Layer s `ProductsBLL` class with a few minor syntactical changes.</span></span> <span data-ttu-id="06227-218">也就是说，`Me.BeginTransaction()`、`Me.CommitTransaction()`和 `Me.RollbackTransaction()` 中的关键字 `Me` 需要替换为 `Adapter` （回想一下，`Adapter` 是 `ProductsBLL` 类型 `ProductsTableAdapter`的属性的名称。</span><span class="sxs-lookup"><span data-stu-id="06227-218">Namely, the keyword `Me` in `Me.BeginTransaction()`, `Me.CommitTransaction()`, and `Me.RollbackTransaction()` would need to be replaced with `Adapter` (recall that `Adapter` is the name of a property in `ProductsBLL` of type `ProductsTableAdapter`).</span></span>

<span data-ttu-id="06227-219">`UpdateWithTransaction` 方法使用批处理更新模式，但也可以在事务范围内使用一系列 DB 直通调用，如下面的方法所示。</span><span class="sxs-lookup"><span data-stu-id="06227-219">The `UpdateWithTransaction` method uses the Batch Update pattern, but a series of DB-Direct calls can also be used within the scope of a transaction, as the following method shows.</span></span> <span data-ttu-id="06227-220">`DeleteProductsWithTransaction` 方法接受作为输入 `Integer`类型的 `List(Of T)`，这是要删除的 `ProductID`。</span><span class="sxs-lookup"><span data-stu-id="06227-220">The `DeleteProductsWithTransaction` method accepts as input a `List(Of T)` of type `Integer`, which are the `ProductID` s to delete.</span></span> <span data-ttu-id="06227-221">方法通过调用 `BeginTransaction` 来启动事务，然后，在 `Try` 块中，会循环访问提供的列表，为每个 `ProductID` 值调用 DB 直通模式 `Delete` 方法。</span><span class="sxs-lookup"><span data-stu-id="06227-221">The method initiates the transaction via a call to `BeginTransaction` and then, in the `Try` block, iterates through the supplied list calling the DB-Direct pattern `Delete` method for each `ProductID` value.</span></span> <span data-ttu-id="06227-222">如果对 `Delete` 的任何调用失败，则会将控制转移到事务回滚的 `Catch` 块，并重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="06227-222">If any of the calls to `Delete` fails, control is transferred to the `Catch` block where the transaction is rolled back and the exception re-thrown.</span></span> <span data-ttu-id="06227-223">如果 `Delete` 对的所有调用都成功，则提交事务。</span><span class="sxs-lookup"><span data-stu-id="06227-223">If all calls to `Delete` succeed, then transaction is committed.</span></span> <span data-ttu-id="06227-224">将此方法添加到 `ProductsBLL` 类。</span><span class="sxs-lookup"><span data-stu-id="06227-224">Add this method to the `ProductsBLL` class.</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample5.vb)]

## <a name="applying-transactions-across-multiple-tableadapters"></a><span data-ttu-id="06227-225">跨多个 Tableadapter 应用事务</span><span class="sxs-lookup"><span data-stu-id="06227-225">Applying Transactions Across Multiple TableAdapters</span></span>

<span data-ttu-id="06227-226">本教程中所述的与事务相关的代码允许将 `ProductsTableAdapter` 的多个语句视为一个原子操作。</span><span class="sxs-lookup"><span data-stu-id="06227-226">The transaction-related code examined in this tutorial allows for multiple statements against the `ProductsTableAdapter` to be treated as an atomic operation.</span></span> <span data-ttu-id="06227-227">但如果需要以原子方式对不同数据库表进行多个修改，会怎样呢？</span><span class="sxs-lookup"><span data-stu-id="06227-227">But what if multiple modifications to different database tables need to be performed atomically?</span></span> <span data-ttu-id="06227-228">例如，在删除类别时，我们可能需要首先将其当前产品重新分配给其他类别。</span><span class="sxs-lookup"><span data-stu-id="06227-228">For instance, when deleting a category, we might first want to reassign its current products to some other category.</span></span> <span data-ttu-id="06227-229">这两个步骤重新分配产品并删除类别应作为原子操作执行。</span><span class="sxs-lookup"><span data-stu-id="06227-229">These two steps reassigning the products and deleting the category should be executed as an atomic operation.</span></span> <span data-ttu-id="06227-230">但 `ProductsTableAdapter` 仅包括用于修改 `Products` 表的方法，而 `CategoriesTableAdapter` 只包含修改 `Categories` 表的方法。</span><span class="sxs-lookup"><span data-stu-id="06227-230">But the `ProductsTableAdapter` includes only methods for modifying the `Products` table and the `CategoriesTableAdapter` includes only methods for modifying the `Categories` table.</span></span> <span data-ttu-id="06227-231">那么，事务如何能同时包含这两个 Tableadapter 呢？</span><span class="sxs-lookup"><span data-stu-id="06227-231">So how can a transaction encompass both TableAdapters?</span></span>

<span data-ttu-id="06227-232">一种选择是将方法添加到名为 `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` 的 `CategoriesTableAdapter`，并让该方法调用一个存储过程，该存储过程将重新分配产品并删除存储过程中定义的事务范围内的类别。</span><span class="sxs-lookup"><span data-stu-id="06227-232">One option is to add a method to the `CategoriesTableAdapter` named `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` and have that method call a stored procedure that both reassigns the products and deletes the category within the scope of a transaction defined within the stored procedure.</span></span> <span data-ttu-id="06227-233">在将来的教程中，我们将介绍如何在存储过程中开始、提交和回滚事务。</span><span class="sxs-lookup"><span data-stu-id="06227-233">We'll look at how to begin, commit, and rollback transactions in stored procedures in a future tutorial.</span></span>

<span data-ttu-id="06227-234">另一种方法是在包含 `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` 方法的 DAL 中创建帮助器类。</span><span class="sxs-lookup"><span data-stu-id="06227-234">Another option is to create a helper class in the DAL that contains the `DeleteCategoryAndReassignProducts(categoryIDtoDelete, reassignToCategoryID)` method.</span></span> <span data-ttu-id="06227-235">此方法将创建 `CategoriesTableAdapter` 和 `ProductsTableAdapter` 的实例，然后将这两个 Tableadapter `Connection` 属性设置为相同的 `SqlConnection` 实例。</span><span class="sxs-lookup"><span data-stu-id="06227-235">This method would create an instance of the `CategoriesTableAdapter` and the `ProductsTableAdapter` and then set these two TableAdapters `Connection` properties to the same `SqlConnection` instance.</span></span> <span data-ttu-id="06227-236">此时，两个 Tableadapter 中的一个将通过调用 `BeginTransaction`来启动该事务。</span><span class="sxs-lookup"><span data-stu-id="06227-236">At that point, either one of the two TableAdapters would initiate the transaction with a call to `BeginTransaction`.</span></span> <span data-ttu-id="06227-237">用于重新分配产品和删除类别的 Tableadapter 方法将在提交或回滚事务的 `Try...Catch` 块中调用。</span><span class="sxs-lookup"><span data-stu-id="06227-237">The TableAdapters methods for reassigning the products and deleting the category would be invoked in a `Try...Catch` block with the transaction committed or rolled back as needed.</span></span>

## <a name="step-4-adding-theupdatewithtransactionmethod-to-the-business-logic-layer"></a><span data-ttu-id="06227-238">步骤4：将`UpdateWithTransaction`方法添加到业务逻辑层</span><span class="sxs-lookup"><span data-stu-id="06227-238">Step 4: Adding the`UpdateWithTransaction`Method to the Business Logic Layer</span></span>

<span data-ttu-id="06227-239">在步骤3中，我们将 `UpdateWithTransaction` 方法添加到 DAL 中的 `ProductsTableAdapter`。</span><span class="sxs-lookup"><span data-stu-id="06227-239">In Step 3 we added an `UpdateWithTransaction` method to the `ProductsTableAdapter` in the DAL.</span></span> <span data-ttu-id="06227-240">应向 BLL 添加相应的方法。</span><span class="sxs-lookup"><span data-stu-id="06227-240">We should add a corresponding method to the BLL.</span></span> <span data-ttu-id="06227-241">尽管表示层可以直接调用 DAL 来调用 `UpdateWithTransaction` 方法，但这些教程 strived 定义了一个将 DAL 与表示层隔离的分层体系结构。</span><span class="sxs-lookup"><span data-stu-id="06227-241">While the Presentation Layer could call directly down to the DAL to invoke the `UpdateWithTransaction` method, these tutorials have strived to define a layered architecture that insulates the DAL from the Presentation Layer.</span></span> <span data-ttu-id="06227-242">因此，它 behooves 我们继续此方法。</span><span class="sxs-lookup"><span data-stu-id="06227-242">Therefore, it behooves us to continue this approach.</span></span>

<span data-ttu-id="06227-243">打开 `ProductsBLL` 类文件，并添加一个名为 `UpdateWithTransaction` 的方法，该方法只需向下调用相应的 DAL 方法。</span><span class="sxs-lookup"><span data-stu-id="06227-243">Open the `ProductsBLL` class file and add a method named `UpdateWithTransaction` that simply calls down to the corresponding DAL method.</span></span> <span data-ttu-id="06227-244">现在，`ProductsBLL`中应该有两个新方法： `UpdateWithTransaction`（刚刚添加的）和 `DeleteProductsWithTransaction`，这是在步骤3中添加的。</span><span class="sxs-lookup"><span data-stu-id="06227-244">There should now be two new methods in `ProductsBLL`: `UpdateWithTransaction`, which you just added, and `DeleteProductsWithTransaction`, which was added in Step 3.</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample6.vb)]

> [!NOTE]
> <span data-ttu-id="06227-245">这些方法不包括分配给 `ProductsBLL` 类中大多数其他方法的 `DataObjectMethodAttribute` 属性，因为我们将直接从 ASP.NET 页代码隐藏类调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="06227-245">These methods do not include the `DataObjectMethodAttribute` attribute assigned to most other methods in the `ProductsBLL` class because we'll be invoking these methods directly from the ASP.NET pages code-behind classes.</span></span> <span data-ttu-id="06227-246">请记住，`DataObjectMethodAttribute` 用于标记应在 ObjectDataSource 的 "配置数据源" 向导中以及哪些选项卡（SELECT、UPDATE、INSERT 或 DELETE）上出现哪些方法。</span><span class="sxs-lookup"><span data-stu-id="06227-246">Recall that `DataObjectMethodAttribute` is used to flag what methods should appear in the ObjectDataSource s Configure Data Source wizard and under what tab (SELECT, UPDATE, INSERT, or DELETE).</span></span> <span data-ttu-id="06227-247">由于 GridView 缺少对批处理编辑或删除的任何内置支持，因此必须以编程方式而不是使用无代码的声明性方法来调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="06227-247">Since the GridView lacks any built-in support for batch editing or deleting, we'll have to invoke these methods programmatically rather than use the code-free declarative approach.</span></span>

## <a name="step-5-atomically-updating-database-data-from-the-presentation-layer"></a><span data-ttu-id="06227-248">步骤5：以原子方式更新表示层中的数据库数据</span><span class="sxs-lookup"><span data-stu-id="06227-248">Step 5: Atomically Updating Database Data from the Presentation Layer</span></span>

<span data-ttu-id="06227-249">为了说明该事务在更新一批记录时所具有的影响，让我们创建一个用户界面，该界面列出了 GridView 中的所有产品并包含一个按钮 Web 控件，单击该控件时，将 `CategoryID` 值重新分配产品。</span><span class="sxs-lookup"><span data-stu-id="06227-249">To illustrate the effect that the transaction has when updating a batch of records, let s create a user interface that lists all products in a GridView and includes a Button Web control that, when clicked, reassigns the products `CategoryID` values.</span></span> <span data-ttu-id="06227-250">特别是，类别重新分配将进行，以便为前几个产品分配一个有效的 `CategoryID` 值，而另一些产品则有意分配了不存在的 `CategoryID` 值。</span><span class="sxs-lookup"><span data-stu-id="06227-250">In particular, the category reassignment will progress so that the first several products are assigned a valid `CategoryID` value while others are purposefully assigned a non-existent `CategoryID` value.</span></span> <span data-ttu-id="06227-251">如果我们尝试使用其 `CategoryID` 与现有类别 `CategoryID`不匹配的产品更新数据库，则会发生外键约束冲突，并将引发异常。</span><span class="sxs-lookup"><span data-stu-id="06227-251">If we attempt to update the database with a product whose `CategoryID` does not match an existing category s `CategoryID`, a foreign key constraint violation will occur and an exception will be raised.</span></span> <span data-ttu-id="06227-252">在此示例中，我们将看到，在使用事务时，外键约束冲突引发的异常将导致回滚之前的有效 `CategoryID` 更改。</span><span class="sxs-lookup"><span data-stu-id="06227-252">What we'll see in this example is that when using a transaction the exception raised from the foreign key constraint violation will cause the previous valid `CategoryID` changes to be rolled back.</span></span> <span data-ttu-id="06227-253">但是，如果不使用事务，将保留对初始类别所做的修改。</span><span class="sxs-lookup"><span data-stu-id="06227-253">When not using a transaction, however, the modifications to the initial categories will remain.</span></span>

<span data-ttu-id="06227-254">首先打开 `BatchData` 文件夹中的 "`Transactions.aspx`" 页，然后从 "工具箱" 拖动到设计器上。</span><span class="sxs-lookup"><span data-stu-id="06227-254">Start by opening the `Transactions.aspx` page in the `BatchData` folder and drag a GridView from the Toolbox onto the Designer.</span></span> <span data-ttu-id="06227-255">将其 `ID` 设置为 `Products`，并从其智能标记将其绑定到名为 `ProductsDataSource`的新 ObjectDataSource。</span><span class="sxs-lookup"><span data-stu-id="06227-255">Set its `ID` to `Products` and, from its smart tag, bind it to a new ObjectDataSource named `ProductsDataSource`.</span></span> <span data-ttu-id="06227-256">将 ObjectDataSource 配置为从 `ProductsBLL` 类 `GetProducts` 方法拉取其数据。</span><span class="sxs-lookup"><span data-stu-id="06227-256">Configure the ObjectDataSource to pull its data from the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="06227-257">这将是一个只读的 GridView，因此，将 "更新"、"插入" 和 "删除" 选项卡中的下拉列表设置为 "（无）"，然后单击 "完成"。</span><span class="sxs-lookup"><span data-stu-id="06227-257">This will be a read-only GridView, so set the drop-down lists in the UPDATE, INSERT, and DELETE tabs to (None) and click Finish.</span></span>

<span data-ttu-id="06227-258">[![将 ObjectDataSource 配置为使用 ProductsBLL Class s GetProducts 方法](wrapping-database-modifications-within-a-transaction-vb/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="06227-258">[![Configure the ObjectDataSource to Use the ProductsBLL Class s GetProducts Method](wrapping-database-modifications-within-a-transaction-vb/_static/image5.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image3.png)</span></span>

<span data-ttu-id="06227-259">**图 5**：将 ObjectDataSource 配置为使用 `ProductsBLL` 类 `GetProducts` 方法（[单击以查看完全大小的映像](wrapping-database-modifications-within-a-transaction-vb/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-259">**Figure 5**: Configure the ObjectDataSource to Use the `ProductsBLL` Class s `GetProducts` Method ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image4.png))</span></span>

<span data-ttu-id="06227-260">[![在 "更新"、"插入" 和 "删除" 选项卡中将下拉列表设置为 "（无）"](wrapping-database-modifications-within-a-transaction-vb/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="06227-260">[![Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None)](wrapping-database-modifications-within-a-transaction-vb/_static/image6.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image5.png)</span></span>

<span data-ttu-id="06227-261">**图 6**：将 "更新"、"插入" 和 "删除" 选项卡中的下拉列表设置为 "（无）" （[单击查看完全大小的映像](wrapping-database-modifications-within-a-transaction-vb/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-261">**Figure 6**: Set the Drop-Down Lists in the UPDATE, INSERT, and DELETE Tabs to (None) ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image6.png))</span></span>

<span data-ttu-id="06227-262">完成 "配置数据源" 向导后，Visual Studio 将为 "产品数据" 字段创建 BoundFields 和一个 CheckBoxField。</span><span class="sxs-lookup"><span data-stu-id="06227-262">After completing the Configure Data Source wizard, Visual Studio will create BoundFields and a CheckBoxField for the product data fields.</span></span> <span data-ttu-id="06227-263">删除除 `ProductID`、`ProductName`、`CategoryID`和 `CategoryName` 以外的所有字段，并将 `ProductName` `CategoryName` 属性分别重命名为 "产品" 和 "类别"。</span><span class="sxs-lookup"><span data-stu-id="06227-263">Remove all of these fields except for `ProductID`, `ProductName`, `CategoryID`, and `CategoryName` and rename the `ProductName` and `CategoryName` BoundFields `HeaderText` properties to Product and Category, respectively.</span></span> <span data-ttu-id="06227-264">从智能标记中，选中 "启用分页" 选项。</span><span class="sxs-lookup"><span data-stu-id="06227-264">From the smart tag, check the Enable Paging option.</span></span> <span data-ttu-id="06227-265">进行这些修改后，GridView 和 ObjectDataSource 的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="06227-265">After making these modifications, the GridView and ObjectDataSource s declarative markup should look like the following:</span></span>

[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample7.aspx)]

<span data-ttu-id="06227-266">接下来，在 GridView 上方添加三个按钮 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="06227-266">Next, add three Button Web controls above the GridView.</span></span> <span data-ttu-id="06227-267">将第一个按钮的 Text 属性设置为 "刷新网格"，将第二个按钮设置为 "修改类别（带有事务）"，然后将第三个按钮设置为 "修改类别（不包含事务）"。</span><span class="sxs-lookup"><span data-stu-id="06227-267">Set the first Button s Text property to Refresh Grid, the second s to Modify Categories (WITH TRANSACTION), and the third one s to Modify Categories (WITHOUT TRANSACTION) .</span></span>

[!code-aspx[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample8.aspx)]

<span data-ttu-id="06227-268">此时，Visual Studio 中的设计视图应类似于图7中所示的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="06227-268">At this point the Design view in Visual Studio should look similar to the screen shot shown in Figure 7.</span></span>

<span data-ttu-id="06227-269">[![页面包含一个 GridView 和三个按钮 Web 控件](wrapping-database-modifications-within-a-transaction-vb/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="06227-269">[![The Page Contains a GridView and Three Button Web Controls](wrapping-database-modifications-within-a-transaction-vb/_static/image7.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image7.png)</span></span>

<span data-ttu-id="06227-270">**图 7**：页面包含一个 GridView 和三个按钮 Web 控件（[单击以查看完全大小的图像](wrapping-database-modifications-within-a-transaction-vb/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-270">**Figure 7**: The Page Contains a GridView and Three Button Web Controls ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image8.png))</span></span>

<span data-ttu-id="06227-271">为三个按钮的每个 `Click` 事件创建事件处理程序，并使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="06227-271">Create event handlers for each of the three Button s `Click` events and use the following code:</span></span>

[!code-vb[Main](wrapping-database-modifications-within-a-transaction-vb/samples/sample9.vb)]

<span data-ttu-id="06227-272">`Click` 事件处理程序的 "刷新" 按钮，只需调用 `Products` GridView s `DataBind` 方法即可将数据重新绑定到 GridView。</span><span class="sxs-lookup"><span data-stu-id="06227-272">The refresh Button s `Click` event handler simply rebinds the data to the GridView by calling the `Products` GridView s `DataBind` method.</span></span>

<span data-ttu-id="06227-273">第二个事件处理程序将 `CategoryID` 中的产品进行重新分配，并使用 BLL 中的新事务方法，在事务的涵盖下执行数据库更新。</span><span class="sxs-lookup"><span data-stu-id="06227-273">The second event handler reassigns the products `CategoryID` s and uses the new transaction method from the BLL to perform the database updates under the umbrella of a transaction.</span></span> <span data-ttu-id="06227-274">请注意，每个产品 `CategoryID` 任意设置为与 `ProductID`相同的值。</span><span class="sxs-lookup"><span data-stu-id="06227-274">Note that each product s `CategoryID` is arbitrarily set to the same value as its `ProductID`.</span></span> <span data-ttu-id="06227-275">这将适用于前几个产品，因为这些产品的 `ProductID` 值会映射到有效 `CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="06227-275">This will work fine for the first few products, since those products have `ProductID` values that happen to map to valid `CategoryID` s.</span></span> <span data-ttu-id="06227-276">但一旦 `ProductID` 开始变得过大，这巧合将重叠 `ProductID` s，`CategoryID` 将不再适用。</span><span class="sxs-lookup"><span data-stu-id="06227-276">But once the `ProductID` s start getting too large, this coincidental overlap of `ProductID` s and `CategoryID` s no longer applies.</span></span>

<span data-ttu-id="06227-277">第三个 `Click` 事件处理程序以相同的方式更新产品 `CategoryID`，但使用 `ProductsTableAdapter` 默认 `Update` 方法将更新发送到数据库。</span><span class="sxs-lookup"><span data-stu-id="06227-277">The third `Click` event handler updates the products `CategoryID` s in the same manner, but sends the update to the database using the `ProductsTableAdapter` s default `Update` method.</span></span> <span data-ttu-id="06227-278">此 `Update` 方法不会包装事务内的一系列命令，因此，在遇到第一个遇到的外键约束冲突错误之前，这些更改将保持不变。</span><span class="sxs-lookup"><span data-stu-id="06227-278">This `Update` method does not wrap the series of commands within a transaction, so those changes are made prior to the first encountered foreign key constraint violation error will persist.</span></span>

<span data-ttu-id="06227-279">若要演示此行为，请通过浏览器访问此页。</span><span class="sxs-lookup"><span data-stu-id="06227-279">To demonstrate this behavior, visit this page through a browser.</span></span> <span data-ttu-id="06227-280">最初应会看到第一页数据，如图8所示。</span><span class="sxs-lookup"><span data-stu-id="06227-280">Initially you should see the first page of data as shown in Figure 8.</span></span> <span data-ttu-id="06227-281">接下来，单击 "修改类别（带有事务）" 按钮。</span><span class="sxs-lookup"><span data-stu-id="06227-281">Next, click the Modify Categories (WITH TRANSACTION) button.</span></span> <span data-ttu-id="06227-282">这将导致回发并尝试将所有产品 `CategoryID` 值更新，但会导致外键约束冲突（参见图9）。</span><span class="sxs-lookup"><span data-stu-id="06227-282">This will cause a postback and attempt to update all of the products `CategoryID` values, but will result in a foreign key constraint violation (see Figure 9).</span></span>

<span data-ttu-id="06227-283">[![产品显示在可分页 GridView 中](wrapping-database-modifications-within-a-transaction-vb/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="06227-283">[![The Products are Displayed in a Pageable GridView](wrapping-database-modifications-within-a-transaction-vb/_static/image8.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image9.png)</span></span>

<span data-ttu-id="06227-284">**图 8**：产品显示在一个可分页的 GridView 中（[单击以查看完全大小的图像](wrapping-database-modifications-within-a-transaction-vb/_static/image10.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-284">**Figure 8**: The Products are Displayed in a Pageable GridView ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image10.png))</span></span>

<span data-ttu-id="06227-285">[重新分配类别 ![导致违反外键约束](wrapping-database-modifications-within-a-transaction-vb/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="06227-285">[![Reassigning the Categories Results in a Foreign Key Constraint Violation](wrapping-database-modifications-within-a-transaction-vb/_static/image9.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image11.png)</span></span>

<span data-ttu-id="06227-286">**图 9**：重新分配类别导致外键约束冲突（[单击以查看完全大小的图像](wrapping-database-modifications-within-a-transaction-vb/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-286">**Figure 9**: Reassigning the Categories Results in a Foreign Key Constraint Violation ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image12.png))</span></span>

<span data-ttu-id="06227-287">现在，单击浏览器的 "后退" 按钮，然后单击 "刷新网格" 按钮。</span><span class="sxs-lookup"><span data-stu-id="06227-287">Now hit your browser s Back button and then click the Refresh Grid button.</span></span> <span data-ttu-id="06227-288">刷新数据时，应看到完全相同的输出，如图8所示。</span><span class="sxs-lookup"><span data-stu-id="06227-288">Upon refreshing the data you should see the exact same output as shown in Figure 8.</span></span> <span data-ttu-id="06227-289">也就是说，即使某些产品 `CategoryID` 更改为合法值并在数据库中更新，但在违反外键约束时，它们也会回滚。</span><span class="sxs-lookup"><span data-stu-id="06227-289">That is, even though some of the products `CategoryID` s were changed to legal values and updated in the database, they were rolled back when the foreign key constraint violation occurred.</span></span>

<span data-ttu-id="06227-290">现在，尝试单击 "修改类别（不包含事务）" 按钮。</span><span class="sxs-lookup"><span data-stu-id="06227-290">Now try clicking the Modify Categories (WITHOUT TRANSACTION) button.</span></span> <span data-ttu-id="06227-291">这会导致相同的外键约束冲突错误（参见图9），但这一次，那些 `CategoryID` 值更改为合法值的产品将不会回滚。</span><span class="sxs-lookup"><span data-stu-id="06227-291">This will result in the same foreign key constraint violation error (see Figure 9), but this time those products whose `CategoryID` values were changed to a legal value will not be rolled back.</span></span> <span data-ttu-id="06227-292">单击浏览器的 "后退" 按钮，然后单击 "刷新网格" 按钮。</span><span class="sxs-lookup"><span data-stu-id="06227-292">Hit your browser s Back button and then the Refresh Grid button.</span></span> <span data-ttu-id="06227-293">如图10所示，已重新分配前8种产品的 `CategoryID`。</span><span class="sxs-lookup"><span data-stu-id="06227-293">As Figure 10 shows, the `CategoryID` s of the first eight products have been reassigned.</span></span> <span data-ttu-id="06227-294">例如，在图8中，改动的 `CategoryID` 为1，但在图10中，它已重新分配给2。</span><span class="sxs-lookup"><span data-stu-id="06227-294">For example, in Figure 8, Chang had a `CategoryID` of 1, but in Figure 10 it s been reassigned to 2.</span></span>

<span data-ttu-id="06227-295">[![一些产品类别 Id 值已更新，但其他产品不存在](wrapping-database-modifications-within-a-transaction-vb/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="06227-295">[![Some Products CategoryID Values were Updated While Others Were Not](wrapping-database-modifications-within-a-transaction-vb/_static/image10.gif)](wrapping-database-modifications-within-a-transaction-vb/_static/image13.png)</span></span>

<span data-ttu-id="06227-296">**图 10**：某些产品 `CategoryID` 值已更新，但其他产品未更新（[单击查看全尺寸映像](wrapping-database-modifications-within-a-transaction-vb/_static/image14.png)）</span><span class="sxs-lookup"><span data-stu-id="06227-296">**Figure 10**: Some Products `CategoryID` Values were Updated While Others Were Not ([Click to view full-size image](wrapping-database-modifications-within-a-transaction-vb/_static/image14.png))</span></span>

## <a name="summary"></a><span data-ttu-id="06227-297">总结</span><span class="sxs-lookup"><span data-stu-id="06227-297">Summary</span></span>

<span data-ttu-id="06227-298">默认情况下，TableAdapter s 方法不会将已执行的数据库语句包装在事务范围内，但是，我们可以添加创建、提交和回滚事务的方法。</span><span class="sxs-lookup"><span data-stu-id="06227-298">By default, the TableAdapter s methods do not wrap the executed database statements within the scope of a transaction, but with a little work we can add methods that will create, commit, and rollback a transaction.</span></span> <span data-ttu-id="06227-299">在本教程中，我们在 `ProductsTableAdapter` 类中创建了三种方法： `BeginTransaction`、`CommitTransaction`和 `RollbackTransaction`。</span><span class="sxs-lookup"><span data-stu-id="06227-299">In this tutorial we created three such methods in the `ProductsTableAdapter` class: `BeginTransaction`, `CommitTransaction`, and `RollbackTransaction`.</span></span> <span data-ttu-id="06227-300">我们了解了如何将这些方法与 `Try...Catch` 块结合使用，使一系列数据修改语句成为原子的。</span><span class="sxs-lookup"><span data-stu-id="06227-300">We saw how to use these methods along with a `Try...Catch` block to make a series of data modification statements atomic.</span></span> <span data-ttu-id="06227-301">具体而言，我们在 `ProductsTableAdapter`中创建了 `UpdateWithTransaction` 方法，该方法使用批处理更新模式来对提供的 `ProductsDataTable`的行执行必要的修改。</span><span class="sxs-lookup"><span data-stu-id="06227-301">In particular, we created the `UpdateWithTransaction` method in the `ProductsTableAdapter`, which uses the Batch Update pattern to perform the necessary modifications to the rows of a supplied `ProductsDataTable`.</span></span> <span data-ttu-id="06227-302">我们还将 `DeleteProductsWithTransaction` 方法添加到 BLL 中的 `ProductsBLL` 类，该方法接受 `ProductID` 值的 `List` 作为其输入，并为每个 `Delete` 调用 DB 直通模式方法 `ProductID`。</span><span class="sxs-lookup"><span data-stu-id="06227-302">We also added the `DeleteProductsWithTransaction` method to the `ProductsBLL` class in the BLL, which accepts a `List` of `ProductID` values as its input and calls the DB-Direct pattern method `Delete` for each `ProductID`.</span></span> <span data-ttu-id="06227-303">这两种方法首先创建一个事务，然后在 `Try...Catch` 块内执行数据修改语句。</span><span class="sxs-lookup"><span data-stu-id="06227-303">Both methods start by creating a transaction and then executing the data modification statements within a `Try...Catch` block.</span></span> <span data-ttu-id="06227-304">如果发生异常，事务将回滚，否则将被提交。</span><span class="sxs-lookup"><span data-stu-id="06227-304">If an exception occurs, the transaction is rolled back, otherwise it is committed.</span></span>

<span data-ttu-id="06227-305">步骤5阐释了事务批更新与忽略使用事务的批处理更新的影响。</span><span class="sxs-lookup"><span data-stu-id="06227-305">Step 5 illustrated the effect of transactional batch updates versus batch updates that neglected to use a transaction.</span></span> <span data-ttu-id="06227-306">在接下来的三个教程中，我们将在本教程的基础上构建，并创建用于执行批量更新、删除和插入操作的用户界面。</span><span class="sxs-lookup"><span data-stu-id="06227-306">In the next three tutorials we will build upon the foundation laid in this tutorial and create user interfaces for performing batch updates, deletes, and inserts.</span></span>

<span data-ttu-id="06227-307">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="06227-307">Happy Programming!</span></span>

## <a name="further-reading"></a><span data-ttu-id="06227-308">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="06227-308">Further Reading</span></span>

<span data-ttu-id="06227-309">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="06227-309">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="06227-310">维护事务的数据库一致性</span><span class="sxs-lookup"><span data-stu-id="06227-310">Maintaining Database Consistency with Transactions</span></span>](http://aspnet.4guysfromrolla.com/articles/072705-1.aspx)
- [<span data-ttu-id="06227-311">在 SQL Server 存储过程中管理事务</span><span class="sxs-lookup"><span data-stu-id="06227-311">Managing Transactions in SQL Server Stored Procedures</span></span>](http://www.4guysfromrolla.com/webtech/080305-1.shtml)
- [<span data-ttu-id="06227-312">简化了事务： `System.Transactions`</span><span class="sxs-lookup"><span data-stu-id="06227-312">Transactions Made Easy: `System.Transactions`</span></span>](https://blogs.msdn.com/florinlazar/archive/2004/07/23/192239.aspx)
- [<span data-ttu-id="06227-313">TransactionScope 和 Dataadapter</span><span class="sxs-lookup"><span data-stu-id="06227-313">TransactionScope and DataAdapters</span></span>](http://andyclymer.blogspot.com/2007/01/transactionscope-and-dataadapters.html)
- [<span data-ttu-id="06227-314">在 .NET 中使用 Oracle Database 事务</span><span class="sxs-lookup"><span data-stu-id="06227-314">Using Oracle Database Transactions in .NET</span></span>](http://www.oracle.com/technology/pub/articles/price_dbtrans_dotnet.html)

## <a name="about-the-author"></a><span data-ttu-id="06227-315">关于作者</span><span class="sxs-lookup"><span data-stu-id="06227-315">About the Author</span></span>

<span data-ttu-id="06227-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="06227-316">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="06227-317">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="06227-317">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="06227-318">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="06227-318">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="06227-319">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="06227-319">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="06227-320">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="06227-320">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="06227-321">特别感谢</span><span class="sxs-lookup"><span data-stu-id="06227-321">Special Thanks To</span></span>

<span data-ttu-id="06227-322">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="06227-322">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="06227-323">本教程的主管评审者是 Dave Gardner、Hilton Giesenow 和 Teresa Murphy。</span><span class="sxs-lookup"><span data-stu-id="06227-323">Lead reviewers for this tutorial were Dave Gardner, Hilton Giesenow, and Teresa Murphy.</span></span> <span data-ttu-id="06227-324">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="06227-324">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="06227-325">如果是这样，请在mitchell@4GuysFromRolla.com放置一行[。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="06227-325">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="06227-326">[上一页](batch-inserting-cs.md)
> [下一页](batch-updating-vb.md)</span><span class="sxs-lookup"><span data-stu-id="06227-326">[Previous](batch-inserting-cs.md)
[Next](batch-updating-vb.md)</span></span>

---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: 通过大量数据有效分页（C#） |Microsoft Docs
author: rick-anderson
description: 在处理大量数据时，数据呈现控件的默认分页选项不合适，因为它的基础数据源控件 retriev 。
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: a3e9562035cb24987b01fcdff5fbfb5fa8a1f894
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74629747"
---
# <a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="8b3ed-103">通过大量数据有效分页 (C#)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>

<span data-ttu-id="8b3ed-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="8b3ed-105">[下载示例应用](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe)或[下载 PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="8b3ed-106">当处理大量数据时，数据呈现控件的默认分页选项不合适，因为即使只显示数据的子集，其基础数据源控件也会检索所有记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="8b3ed-107">在这种情况下，必须启用自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="8b3ed-108">简介</span><span class="sxs-lookup"><span data-stu-id="8b3ed-108">Introduction</span></span>

<span data-ttu-id="8b3ed-109">如前面的教程中所述，可以通过以下两种方式之一实现分页：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="8b3ed-110">只需在数据 Web 控件的智能标记中选中 "启用分页" 选项即可实现**默认分页**;但是，无论何时查看数据页，ObjectDataSource 都将检索*所有*记录，即使该页只显示其中的一个子集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="8b3ed-111">**自定义分页**通过只从数据库中检索那些需要为用户请求的特定数据页显示的记录，从而提高了默认分页的性能;但是，自定义分页的实现工作比默认分页要多得多，</span><span class="sxs-lookup"><span data-stu-id="8b3ed-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="8b3ed-112">由于实现的方便性，只需选中一个复选框即可完成！</span><span class="sxs-lookup"><span data-stu-id="8b3ed-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="8b3ed-113">默认分页是一个极具吸引力的选项。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-113">default paging is an attractive option.</span></span> <span data-ttu-id="8b3ed-114">不过，在检索所有记录时，它的 na 方法会使其成为可能的选择，当通过足够大的数据量或包含多个并发用户的站点进行分页时。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="8b3ed-115">在这种情况下，必须启用自定义分页，才能提供响应式系统。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="8b3ed-116">自定义分页的难题是，可以编写一个查询，该查询返回特定数据页所需的精确记录集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="8b3ed-117">幸运的是，Microsoft SQL Server 2005 为排名结果提供了一个新的关键字，这使我们可以编写一个查询，以便有效地检索正确的记录子集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="8b3ed-118">在本教程中，我们将了解如何使用此新的 SQL Server 2005 关键字在 GridView 控件中实现自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="8b3ed-119">尽管自定义分页的用户界面与默认分页的用户界面完全相同，但使用自定义分页从一个页面单步执行到下一个页面的速度要快于默认分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="8b3ed-120">自定义分页所表现出的确切性能提升取决于正在分页的记录总数以及要放置在数据库服务器上的负载。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="8b3ed-121">在本教程结束时，我们将介绍一些大致的指标，其中展示了通过自定义分页获得的性能优势。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="8b3ed-122">步骤1：了解自定义分页过程</span><span class="sxs-lookup"><span data-stu-id="8b3ed-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="8b3ed-123">在对数据进行分页时，页面中显示的准确记录取决于所请求的数据页和每页显示的记录数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="8b3ed-124">例如，假设我们想要翻阅81产品，每页显示10种产品。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="8b3ed-125">查看第一页时，d 需要产品1到 10;查看第二页时，我们对产品11至20感兴趣，依此类推。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="8b3ed-126">有三个变量用于决定需要检索的记录以及应如何呈现分页接口：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="8b3ed-127">**起始行索引**要显示的数据页中第一行的索引;可以通过将页索引与每页显示的记录相乘，然后再添加，来计算此索引。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="8b3ed-128">例如，在每次对记录10进行分页时，对于第一页（其页索引为0），起始行索引为 0 \* 10 + 1 或 1;对于第二页（其页索引为1），起始行索引为 1 \* 10 + 1 或11。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="8b3ed-129">**最大行**数每页显示的最大记录数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="8b3ed-130">在最后一页中，此变量称为最大行数，返回的记录可能少于页面大小。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="8b3ed-131">例如，在每页的 81 products 10 个记录分页时，第九页和最后一页将只有一条记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="8b3ed-132">不过，如果没有页面，将显示超出最大行值的记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="8b3ed-133">**总记录**数：要分页到的记录总数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="8b3ed-134">尽管此变量不需要确定要为给定页面检索的记录，但它确实规定了分页接口。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="8b3ed-135">例如，如果要将81的产品寻呼到其中，则分页接口知道在分页 UI 中显示九个页码。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="8b3ed-136">通过默认分页，开始行索引计算为页索引的积和页面大小加一，而最大行只是页面大小。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="8b3ed-137">由于在呈现任何数据页时，默认分页将从数据库中检索所有记录，因此，每行的索引都是已知的，从而使移动到起始行索引行成为一项重要任务。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="8b3ed-138">而且，总记录计数随时可用，因为它只是 DataTable 中的记录数（或用来保存数据库结果的任何对象）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="8b3ed-139">给定起始行索引和最大行变量，自定义分页实现只能返回从起始行索引开始到最大行数后的记录的精确子集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="8b3ed-140">自定义分页提供两个难题：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="8b3ed-141">我们必须能够有效地将行索引与要分页的整个数据中的每一行关联起来，以便我们可以开始在指定的起始行索引处返回记录</span><span class="sxs-lookup"><span data-stu-id="8b3ed-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="8b3ed-142">我们需要提供分页的记录总数</span><span class="sxs-lookup"><span data-stu-id="8b3ed-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="8b3ed-143">在接下来的两个步骤中，我们将检查需要对这两个挑战作出响应的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="8b3ed-144">除了 SQL 脚本之外，我们还需要在 DAL 和 BLL 中实现方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="8b3ed-145">步骤2：返回分页的记录总数</span><span class="sxs-lookup"><span data-stu-id="8b3ed-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="8b3ed-146">在我们检查如何检索所显示页面的准确记录子集之前，让我们先来看看如何返回分页的记录总数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="8b3ed-147">此信息是正确配置寻呼用户界面所必需的。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="8b3ed-148">可以使用[`COUNT` 聚合函数](https://msdn.microsoft.com/library/ms175997.aspx)获取特定 SQL 查询返回的记录总数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="8b3ed-149">例如，若要确定 `Products` 表中的记录总数，可以使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="8b3ed-150">让我们向 DAL 添加一个返回此信息的方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="8b3ed-151">具体而言，我们将创建一个名为 `TotalNumberOfProducts()` 的 DAL 方法，该方法执行上面所示的 `SELECT` 语句。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="8b3ed-152">首先打开 `App_Code/DAL` 文件夹中 `Northwind.xsd` 类型化的数据集文件。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="8b3ed-153">接下来，右键单击设计器中的 `ProductsTableAdapter`，然后选择 "添加查询"。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="8b3ed-154">如前面的教程中所示，这将使我们能够将新方法添加到 DAL，在调用该方法时，将执行特定的 SQL 语句或存储过程。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="8b3ed-155">与前面教程中的 TableAdapter 方法一样，对于这种方法，选择使用即席 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![使用即席 SQL 语句](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="8b3ed-157">**图 1**：使用即席 SQL 语句</span><span class="sxs-lookup"><span data-stu-id="8b3ed-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="8b3ed-158">在下一个屏幕上，可以指定要创建的查询类型。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="8b3ed-159">由于此查询将返回单个标量值 `Products` 表中的记录总数，请选择返回单个值选项的 `SELECT`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![将查询配置为使用返回单个值的 SELECT 语句](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="8b3ed-161">**图 2**：将查询配置为使用返回单个值的 SELECT 语句</span><span class="sxs-lookup"><span data-stu-id="8b3ed-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="8b3ed-162">在指示要使用的查询类型后，接下来必须指定查询。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-162">After indicating the type of query to use, we must next specify the query.</span></span>

![使用 SELECT COUNT （\*） FROM Products 查询](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="8b3ed-164">**图 3**：使用 PRODUCTS 查询中的 SELECT COUNT （\*）</span><span class="sxs-lookup"><span data-stu-id="8b3ed-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="8b3ed-165">最后，指定方法的名称。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="8b3ed-166">如前所述，让 `TotalNumberOfProducts`使用。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![将 DAL 方法命名为 TotalNumberOfProducts](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="8b3ed-168">**图 4**：命名 DAL 方法 TotalNumberOfProducts</span><span class="sxs-lookup"><span data-stu-id="8b3ed-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="8b3ed-169">单击 "完成" 后，向导会将 `TotalNumberOfProducts` 方法添加到 DAL。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="8b3ed-170">如果 SQL 查询的结果是 `NULL`的，则 DAL 中返回的标量返回可为 null 的类型。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="8b3ed-171">但 `COUNT` 查询将始终返回非`NULL` 值;不管，DAL 方法返回一个可以为 null 的整数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="8b3ed-172">除了 DAL 方法之外，我们还需要使用 BLL 中的方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="8b3ed-173">打开 `ProductsBLL` 类文件，并添加 `TotalNumberOfProducts` 方法，只需向下调用 DAL s `TotalNumberOfProducts` 方法：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="8b3ed-174">DAL s `TotalNumberOfProducts` 方法返回一个可以为 null 的整数;但是，我们已经创建了 `ProductsBLL` 类的 `TotalNumberOfProducts` 方法，使其返回标准整数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="8b3ed-175">因此，我们需要让 `ProductsBLL` 类 `TotalNumberOfProducts` 方法返回由 DAL s `TotalNumberOfProducts` 方法返回的可以为 null 的整数的值部分。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="8b3ed-176">对 `GetValueOrDefault()` 的调用将返回可为 null 的整数值（如果存在）; 否则为。如果 `null`可以为 null 的整数，则返回默认整数值0。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="8b3ed-177">步骤3：返回记录的精确子集</span><span class="sxs-lookup"><span data-stu-id="8b3ed-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="8b3ed-178">接下来的任务是在 DAL 和 BLL 中创建接受前面讨论的 "起始行索引" 和 "最大行数" 变量的方法，并返回相应的记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="8b3ed-179">在执行此操作之前，先查看所需的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="8b3ed-180">我们所面临的挑战是，我们必须能够有效地将索引分配给要分页到的整个结果中的每一行，以便我们可以只返回从起始行索引（和最大记录数到最大记录数）开始的这些记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="8b3ed-181">如果数据库表中已有作为行索引的列，这不是一项挑战。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="8b3ed-182">乍一看，我们可能认为 `Products` 表的 `ProductID` 字段足以满足要求，因为第一个产品的 `ProductID` 为1，第二个为2，依此类推。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="8b3ed-183">但是，删除产品会使序列中存在间隔，使以前此方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="8b3ed-184">有两种用于有效地将行索引与数据关联以便逐页处理的常规方法，从而允许检索准确的记录子集：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="8b3ed-185">**使用 SQL Server 2005 s `ROW_NUMBER()` 关键字**new SQL Server 2005，`ROW_NUMBER()` 关键字根据某些排序将排名与每个返回的记录相关联。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="8b3ed-186">此排名可用作每行的行索引。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="8b3ed-187">**使用表变量和 `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` 语句](https://msdn.microsoft.com/library/ms188774.aspx)可用于指定查询在终止之前应处理的总记录数;[表变量](http://www.sqlteam.com/item.asp?ItemID=9454)是可容纳表格数据的本地 t-sql 变量，类似于[临时表](http://www.sqlteam.com/item.asp?ItemID=2029)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="8b3ed-188">此方法同样适用于 Microsoft SQL Server 2005 和 SQL Server 2000 （而 `ROW_NUMBER()` 方法仅适用于 SQL Server 2005）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="8b3ed-189">这里的思路是创建一个表变量，其中包含一个 `IDENTITY` 列和一个列，其中包含要对其数据进行分页的表的主键。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="8b3ed-190">接下来，要将其数据分页到的表的内容转储到表变量中，从而为表中的每条记录关联顺序行索引（通过 `IDENTITY` 列）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="8b3ed-191">填充表变量后，可以执行表变量上与基础表联接的 `SELECT` 语句来提取特定记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="8b3ed-192">`SET ROWCOUNT` 语句用于智能地限制需要转储到表变量中的记录数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="8b3ed-193">此方法的效率取决于所请求的页码，因为 `SET ROWCOUNT` 的值被赋予 "起始行索引" 和 "最大行" 的值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="8b3ed-194">当通过低编号页面（如前几页的数据）进行分页时，此方法非常有效。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="8b3ed-195">但是，在检索到结尾附近的页时，它会表现出默认的分页性能。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="8b3ed-196">本教程使用 `ROW_NUMBER()` 关键字实现自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="8b3ed-197">有关使用表变量和 `SET ROWCOUNT` 方法的详细信息，请参阅[通过大型结果集进行分页的更高效方法](http://www.4guysfromrolla.com/webtech/042606-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="8b3ed-198">使用以下语法将 `ROW_NUMBER()` 关键字与按特定顺序返回的每条记录关联的排名：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="8b3ed-199">`ROW_NUMBER()` 返回一个数值，该数值指定与指定排序相关的每条记录的等级。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="8b3ed-200">例如，若要查看每种产品的排名，按从最昂贵到最高的顺序排序，可以使用以下查询：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="8b3ed-201">图5显示了通过 Visual Studio 中的查询窗口运行时的这一查询结果。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="8b3ed-202">请注意，产品按价格排序，并按每行的价格排名排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![为每个返回的记录包含价格排名](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="8b3ed-204">**图 5**：为每个返回的记录包含价格排名</span><span class="sxs-lookup"><span data-stu-id="8b3ed-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="8b3ed-205">`ROW_NUMBER()` 只是 SQL Server 2005 中提供的众多新排名函数之一。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="8b3ed-206">若要深入了解 `ROW_NUMBER()`以及其他排名函数，请参阅[使用 Microsoft SQL Server 2005 返回排名结果](http://www.4guysfromrolla.com/webtech/010406-1.shtml)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="8b3ed-207">在按 `OVER` 子句中指定 `ORDER BY` 列对结果进行排序（`UnitPrice`，在上面的示例中），SQL Server 必须对结果进行排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="8b3ed-208">如果对通过列对结果进行排序所依据的列存在聚集索引，则这是一个快速操作，如果有覆盖索引，则这是一个快速操作，否则可能更昂贵。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="8b3ed-209">若要帮助提高足够大的查询性能，请考虑为排序所依据的列添加非聚集索引。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="8b3ed-210">有关性能注意事项的详细信息，请参阅[SQL Server 2005 中的排名函数和性能](http://www.sql-server-performance.com/ak_ranking_functions.asp)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="8b3ed-211">`ROW_NUMBER()` 返回的排名信息不能直接在 `WHERE` 子句中使用。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="8b3ed-212">但是，可以使用派生表来返回 `ROW_NUMBER()` 结果，该结果随后可以出现在 `WHERE` 子句中。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="8b3ed-213">例如，下面的查询使用派生表返回 "产品名称" 和 "单价" 列，并使用 `ROW_NUMBER()` 结果，然后使用 `WHERE` 子句只返回价格级别介于11和20之间的产品：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="8b3ed-214">进一步扩展此概念，可以利用这种方法，根据所需的起始行索引和最大行值检索特定的数据页：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="8b3ed-215">稍后将在本教程中看到，ObjectDataSource 提供的 *`StartRowIndex`* 从零开始编制索引，而 SQL Server 2005 返回的 `ROW_NUMBER()` 值从1开始索引。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="8b3ed-216">因此，`WHERE` 子句返回的记录的 `PriceRank` 严格大于 *`StartRowIndex`* ，小于或等于 *`StartRowIndex`*  +  *`MaximumRows`* 。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="8b3ed-217">现在，我们已经讨论了如何使用 `ROW_NUMBER()` 来检索特定的数据页（给定起始行索引和最大行值），接下来我们需要将此逻辑作为 DAL 和 BLL 中的方法实现。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="8b3ed-218">创建此查询时，必须确定结果的排序依据：让我们按字母顺序对产品进行排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="8b3ed-219">这意味着，在本教程中，通过自定义分页实现，我们将无法创建自定义分页报表，也不能对其进行排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="8b3ed-220">但在下一教程中，我们将了解如何提供此类功能。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="8b3ed-221">在上一部分中，我们将 DAL 方法创建为即席 SQL 语句。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="8b3ed-222">遗憾的是，由 TableAdapter 向导使用的 Visual Studio 中的 T-sql 分析器不像 `ROW_NUMBER()` 函数使用的 `OVER` 语法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="8b3ed-223">因此，我们必须将此 DAL 方法创建为存储过程。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="8b3ed-224">从 "视图" 菜单中选择 "服务器资源管理器" （或按 Ctrl + Alt + S），然后展开 "`NORTHWND.MDF`" 节点。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="8b3ed-225">若要添加新的存储过程，请右键单击 "存储过程" 节点，然后选择 "添加新存储过程" （见图6）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![添加用于对产品进行分页的新存储过程](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="8b3ed-227">**图 6**：添加新的存储过程以通过产品进行分页</span><span class="sxs-lookup"><span data-stu-id="8b3ed-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="8b3ed-228">此存储过程应接受两个整数输入参数-`@startRowIndex` 和 `@maximumRows` 并使用 `ProductName` 字段排序的 `ROW_NUMBER()` 函数，仅返回大于指定 `@startRowIndex` 的行并小于或等于 `@startRowIndex` + `@maximumRow`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="8b3ed-229">将以下脚本输入新的存储过程，然后单击 "保存" 图标，将该存储过程添加到数据库中。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="8b3ed-230">创建存储过程后，请花点时间进行测试。右键单击服务器资源管理器中的 `GetProductsPaged` 存储过程名称，然后选择 "执行" 选项。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="8b3ed-231">然后，Visual Studio 会提示输入参数，`@startRowIndex` 和 `@maximumRow` （参见图7）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="8b3ed-232">尝试不同的值并检查结果。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-232">Try different values and examine the results.</span></span>

![输入 @startRowIndex 和 @maximumRows 参数的值](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="8b3ed-234"><strong>图 7</strong>：输入 @startRowIndex 和 @maximumRows 参数的值</span><span class="sxs-lookup"><span data-stu-id="8b3ed-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="8b3ed-235">选择这些输入参数值后，"输出" 窗口会显示结果。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="8b3ed-236">图8显示了为 `@startRowIndex` 和 `@maximumRows` 参数传递10时的结果。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="8b3ed-237">[![返回将在第二页数据中显示的记录](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="8b3ed-238">**图 8**：返回将在第二页数据中显示的记录（[单击以查看完全大小的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png)）</span><span class="sxs-lookup"><span data-stu-id="8b3ed-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>

<span data-ttu-id="8b3ed-239">创建此存储过程后，就可以创建 `ProductsTableAdapter` 方法了。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="8b3ed-240">打开 `Northwind.xsd` 类型化数据集，右键单击 `ProductsTableAdapter`，然后选择 "添加查询" 选项。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="8b3ed-241">不要使用即席 SQL 语句创建查询，而是使用现有的存储过程创建它。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![使用现有存储过程创建 DAL 方法](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="8b3ed-243">**图 9**：使用现有存储过程创建 DAL 方法</span><span class="sxs-lookup"><span data-stu-id="8b3ed-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="8b3ed-244">接下来，系统会提示选择要调用的存储过程。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="8b3ed-245">从下拉列表中选择 `GetProductsPaged` 存储过程。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![从下拉列表中选择 "GetProductsPaged" 存储过程](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="8b3ed-247">**图 10**：从下拉列表中选择 "GetProductsPaged" 存储过程</span><span class="sxs-lookup"><span data-stu-id="8b3ed-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="8b3ed-248">接下来的屏幕会询问存储过程返回的数据类型：表格数据、单个值或无值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="8b3ed-249">由于 `GetProductsPaged` 存储过程可以返回多个记录，因此表示返回表格数据。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![指示存储过程返回表格数据](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="8b3ed-251">**图 11**：指示存储过程返回表格数据</span><span class="sxs-lookup"><span data-stu-id="8b3ed-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="8b3ed-252">最后，指示要创建的方法的名称。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="8b3ed-253">与前面的教程一样，请继续使用 "填充 DataTable" 和 "返回 DataTable" 创建方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="8b3ed-254">将第一个方法命名 `FillPaged` 第二个 `GetProductsPaged`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![将方法命名为 FillPaged 和 GetProductsPaged](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="8b3ed-256">**图 12**：将方法命名为 FillPaged 和 GetProductsPaged</span><span class="sxs-lookup"><span data-stu-id="8b3ed-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="8b3ed-257">除了创建用于返回特定产品页的 DAL 方法之外，我们还需要在 BLL 中提供此类功能。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="8b3ed-258">与 DAL 方法一样，BLL s GetProductsPaged 方法必须接受两个整数输入来指定起始行索引和最大行数，并且必须只返回那些在指定范围内的记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="8b3ed-259">在 ProductsBLL 类中创建这样一种 BLL 方法，只需向下调用 DAL s GetProductsPaged 方法，如下所示：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="8b3ed-260">可以为 BLL 方法的输入参数使用任何名称，但正如我们稍后将看到的，在配置 ObjectDataSource 以使用此方法时，选择使用 `startRowIndex` 和 `maximumRows` 可节省额外的工作量。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="8b3ed-261">步骤4：将 ObjectDataSource 配置为使用自定义分页</span><span class="sxs-lookup"><span data-stu-id="8b3ed-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="8b3ed-262">使用 BLL 和 DAL 方法来访问特定记录子集完成后，我们便可以创建一个 GridView 控件，该控件使用自定义分页来浏览其基础记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="8b3ed-263">首先打开 `PagingAndSorting` 文件夹中的 "`EfficientPaging.aspx`" 页，向页面添加一个 GridView，然后将其配置为使用新的 ObjectDataSource 控件。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="8b3ed-264">在过去的教程中，我们通常将 ObjectDataSource 配置为使用 `ProductsBLL` 类 `GetProducts` 方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="8b3ed-265">但这一次，我们要改为使用 `GetProductsPaged` 方法，因为 `GetProducts` 方法返回数据库中的*所有*产品，而 `GetProductsPaged` 只返回特定的记录子集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![将 ObjectDataSource 配置为使用 ProductsBLL 类 s GetProductsPaged 方法](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="8b3ed-267">**图 13**：将 ObjectDataSource 配置为使用 ProductsBLL 类 s GetProductsPaged 方法</span><span class="sxs-lookup"><span data-stu-id="8b3ed-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="8b3ed-268">由于我们要创建只读 GridView，请花点时间将 "插入"、"更新" 和 "删除" 选项卡中的 "方法" 下拉列表设置为 "（无）"。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="8b3ed-269">接下来，ObjectDataSource 向导会提示我们输入 `GetProductsPaged` 方法的源 `startRowIndex` 和 `maximumRows` 输入参数值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="8b3ed-270">这些输入参数实际上由 GridView 自动设置，因此只需将源设置为 "无"，然后单击 "完成" 即可。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![将输入参数源保留为 "无"](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="8b3ed-272">**图 14**：将输入参数源保留为 "无"</span><span class="sxs-lookup"><span data-stu-id="8b3ed-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="8b3ed-273">完成 ObjectDataSource 向导后，GridView 将包含每个产品数据字段的 BoundField 或 CheckBoxField。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="8b3ed-274">您可以根据自己的情况自由地定制 GridView 的外观。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="8b3ed-275">我选择仅显示 `ProductName`、`CategoryName`、`SupplierName`、`QuantityPerUnit`和 `UnitPrice` BoundFields。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="8b3ed-276">此外，通过选中其智能标记中的 "启用分页" 复选框，将 GridView 配置为支持分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="8b3ed-277">进行这些更改后，GridView 和 ObjectDataSource 声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="8b3ed-278">但是，如果您通过浏览器访问该页面，则不会在此处找到 GridView。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![不显示 GridView](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="8b3ed-280">**图 15**：不显示 GridView</span><span class="sxs-lookup"><span data-stu-id="8b3ed-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="8b3ed-281">缺少 GridView，因为 ObjectDataSource 目前使用0作为 `GetProductsPaged` `startRowIndex` 和 `maximumRows` 输入参数的值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="8b3ed-282">因此，生成的 SQL 查询未返回任何记录，因此不会显示 GridView。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="8b3ed-283">若要解决此情况，需要将 ObjectDataSource 配置为使用自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="8b3ed-284">可以在以下步骤中完成此操作：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="8b3ed-285">**将 objectdatasource `EnablePaging` 属性设置为 `true`** 这向 ObjectDataSource 指示它必须传递到 `SelectMethod` 两个附加参数：一个用于指定起始行索引（[`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)），另一个用于指定最大行数（[`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="8b3ed-286">**设置 ObjectDataSource s `StartRowIndexParameterName` 并相应地 `MaximumRowsParameterName` 属性**，`StartRowIndexParameterName` 和 `MaximumRowsParameterName` 属性指示为自定义分页目的传入 `SelectMethod` 的输入参数的名称。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="8b3ed-287">默认情况下，这些参数名称是 `startIndexRow` 和 `maximumRows`，这就是为什么在 BLL 中创建 `GetProductsPaged` 方法时，我将这些值用于输入参数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="8b3ed-288">例如，如果选择使用不同的参数名称进行 `GetProductsPaged` 方法，例如 `startIndex` 和 `maxRows`，则需要相应地设置 ObjectDataSource 的 `StartRowIndexParameterName` 和 `MaximumRowsParameterName` 属性（例如，用于 `StartRowIndexParameterName` 的 startIndex 以及 `MaximumRowsParameterName`的 maxRows）。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="8b3ed-289">**将 ObjectDataSource s [`SelectCountMethod` 属性](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx)设置为方法的名称，该方法返回分页的记录总数（`TotalNumberOfProducts`）** ，这意味着 `ProductsBLL` 类的 `TotalNumberOfProducts` 方法返回使用执行 `SELECT COUNT(*) FROM Products` 查询的 DAL 方法进行分页的记录总数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="8b3ed-290">ObjectDataSource 需要此信息才能正确呈现分页接口。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="8b3ed-291">**从 objectdatasource 的声明性标记中删除 `startRowIndex` 和 `maximumRows` `<asp:Parameter>` 元素**，在通过该向导配置 objectdatasource 时，Visual Studio 会自动添加两个 `GetProductsPaged` 方法 s 输入参数的 `<asp:Parameter>` 元素。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="8b3ed-292">通过将 `EnablePaging` 设置为 `true`，将自动传递这些参数;如果它们也出现在声明性语法中，则 ObjectDataSource 会尝试将*四个*参数传递给 `GetProductsPaged` 方法，将两个参数传递给 `TotalNumberOfProducts` 方法。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="8b3ed-293">如果忘记删除这些 `<asp:Parameter>` 元素，则在通过浏览器访问页面时，你将收到类似于以下的错误消息： *ObjectDataSource "ObjectDataSource1" 找不到具有参数的非泛型方法 "TotalNumberOfProducts"： startRowIndex，maximumRows*。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="8b3ed-294">进行这些更改后，ObjectDataSource 的声明性语法应如下所示：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="8b3ed-295">请注意，已设置 "`EnablePaging`" 和 "`SelectCountMethod`" 属性，并且已删除 `<asp:Parameter>` 元素。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="8b3ed-296">图16显示了这些更改之后属性窗口的屏幕截图。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![若要使用自定义分页，请配置 ObjectDataSource 控件](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="8b3ed-298">**图 16**：若要使用自定义分页，请配置 ObjectDataSource 控件</span><span class="sxs-lookup"><span data-stu-id="8b3ed-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="8b3ed-299">进行这些更改后，请通过浏览器访问此页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="8b3ed-300">应会看到列出了10个产品，按字母顺序排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="8b3ed-301">请花点时间逐行查看数据。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="8b3ed-302">虽然在默认分页与自定义分页之间没有与最终用户之间的视觉差别，但自定义分页可通过大量数据更有效地分页，因为它只检索需要为给定页面显示的记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="8b3ed-303">[使用自定义分页 ![按产品名称排序的数据](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="8b3ed-304">**图 17**：按产品名称排序的数据已使用自定义分页进行分页（[单击以查看完全大小的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="8b3ed-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="8b3ed-305">使用自定义分页时，ObjectDataSource s `SelectCountMethod` 返回的页计数值存储在 GridView 的视图状态中。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="8b3ed-306">"`PageIndex`"、"`EditIndex`"、"`SelectedIndex`"、"`DataKeys` 集合" 等其他 GridView 变量存储在*控件状态*中，无论 GridView 的 "`EnableViewState`" 属性的值如何，都会保持该状态。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="8b3ed-307">由于使用视图状态将 `PageCount` 值保留在回发之间，因此当使用包含链接的分页界面将您转到最后一页时，必须启用 GridView 的视图状态。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="8b3ed-308">（如果分页接口不包含指向最后一页的直接链接，则可以禁用视图状态。）</span><span class="sxs-lookup"><span data-stu-id="8b3ed-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="8b3ed-309">单击 "最后一页" 链接将导致回发，并指示 GridView 更新其 `PageIndex` 属性。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="8b3ed-310">如果单击最后一个页面链接，则 GridView 会将其 `PageIndex` 属性分配给小于其 `PageCount` 属性的值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="8b3ed-311">禁用视图状态时，将会在回发之间丢失 `PageCount` 值，并改为向 `PageIndex` 分配最大整数值。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="8b3ed-312">接下来，GridView 尝试通过将 `PageSize` 和 `PageCount` 属性相乘来确定起始行索引。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="8b3ed-313">这会导致 `OverflowException`，因为产品超出了允许的最大整数大小。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="8b3ed-314">实现自定义分页和排序</span><span class="sxs-lookup"><span data-stu-id="8b3ed-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="8b3ed-315">当前的自定义分页实现要求在创建 `GetProductsPaged` 存储过程时，通过静态方式指定数据分页的顺序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="8b3ed-316">不过，您可能已注意到，除了启用分页选项外，GridView s 智能标记还包含 "启用排序" 复选框。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="8b3ed-317">遗憾的是，将排序支持添加到具有当前自定义分页实现的 GridView，只会对当前查看的数据页上的记录进行排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="8b3ed-318">例如，如果您将 GridView 配置为还支持分页，然后在查看数据的第一页时按产品名称降序排序，则它会反转第1页上产品的顺序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="8b3ed-319">如图18所示，如按反向字母顺序进行排序时，Carnarvon 稀有作为第一个产品，这会忽略 Carnarvon 稀有之后出现的71其他产品，按字母顺序排列;只有第一页上的记录才会被视为排序。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="8b3ed-320">[仅 ![当前页面上显示的数据进行排序](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="8b3ed-321">**图 18**：仅对当前页上显示的数据进行排序（[单击以查看完全大小的图像](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="8b3ed-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>

<span data-ttu-id="8b3ed-322">排序仅适用于当前数据页，因为在从 BLL s `GetProductsPaged` 方法检索到数据之后，此方法仅返回特定页的记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="8b3ed-323">若要正确实现排序，需要将排序表达式传递到 `GetProductsPaged` 方法，以便在返回数据的特定页面之前，对数据进行适当排名。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="8b3ed-324">我们将在下一教程中了解如何实现此目的。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="8b3ed-325">实现自定义分页和删除</span><span class="sxs-lookup"><span data-stu-id="8b3ed-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="8b3ed-326">如果你在使用自定义分页技术对其数据进行分页的 GridView 中启用删除功能，你会发现，在删除最后一页中的最后一条记录时，GridView 会消失，而不会正确地递减 GridView 的 `PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="8b3ed-327">若要重现此错误，请为刚创建的教程启用删除。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="8b3ed-328">请访问最后一页（第9页），其中你应该会看到单个产品，因为我们将在81产品和10个产品中一次分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="8b3ed-329">删除此产品。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-329">Delete this product.</span></span>

<span data-ttu-id="8b3ed-330">删除最后一种产品后 *，GridView 会*自动进入第8页，此类功能将表现为默认分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="8b3ed-331">但是，对于自定义分页，在删除最后一页上的最后一个产品后，GridView 完全从屏幕上消失。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="8b3ed-332">导致这种情况的*确切原因是*在本教程的范围之外，有关此问题的根源，请参阅[从具有自定义分页的 GridView 中删除最后一页上的最后一条记录](http://scottonwriting.net/sowblog/posts/7326.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="8b3ed-333">概括而言，由于在单击 "删除" 按钮时，GridView 执行的步骤顺序如下：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="8b3ed-334">删除记录</span><span class="sxs-lookup"><span data-stu-id="8b3ed-334">Delete the record</span></span>
2. <span data-ttu-id="8b3ed-335">获取要为指定的 `PageIndex` 和 `PageSize` 显示的相应记录</span><span class="sxs-lookup"><span data-stu-id="8b3ed-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="8b3ed-336">检查以确保 `PageIndex` 不超过数据源中的数据页数;如果是这样，将自动减小 GridView `PageIndex` 属性</span><span class="sxs-lookup"><span data-stu-id="8b3ed-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="8b3ed-337">使用在步骤2中获取的记录将适当的数据页绑定到 GridView</span><span class="sxs-lookup"><span data-stu-id="8b3ed-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="8b3ed-338">此问题源自于第2步：在提取要显示的记录时使用的 `PageIndex` 仍是刚删除其唯一记录的最后一页的 `PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="8b3ed-339">因此，在步骤2中，*不*会返回任何记录，因为该数据的最后一页不再包含任何记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="8b3ed-340">然后，在步骤3中，GridView 认识到其 `PageIndex` 属性大于数据源中的总页数（因为我们已删除最后一页中的最后一条记录），因此将其 `PageIndex` 属性减少。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="8b3ed-341">在步骤4中，GridView 尝试将自身绑定到步骤2中检索到的数据;但在步骤2中未返回任何记录，因此导致了一个空的 GridView。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="8b3ed-342">对于默认分页，此问题不会出现，因为在第2步中，将从数据源检索*所有*记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="8b3ed-343">若要解决此问题，我们有两个选择。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-343">To fix this we have two options.</span></span> <span data-ttu-id="8b3ed-344">第一种方法是创建 GridView `RowDeleted` 事件处理程序的事件处理程序，该事件处理程序确定刚刚删除的页面中显示的记录数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="8b3ed-345">如果只有一条记录，则刚删除的记录必须是最后一个记录，并且我们需要减小 GridView `PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="8b3ed-346">当然，如果删除操作确实成功，我们只想更新 `PageIndex`，这可以通过确保 `e.Exception` 属性 `null`来确定。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="8b3ed-347">此方法有效，因为它将更新步骤1之后但在步骤2之前的 `PageIndex`。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="8b3ed-348">因此，在步骤2中，返回相应的记录集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="8b3ed-349">若要实现此目的，请使用如下所示的代码：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-349">To accomplish this, use code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="8b3ed-350">另一种解决方法是为 ObjectDataSource `RowDeleted` 事件创建事件处理程序，并将 `AffectedRows` 属性设置为值1。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="8b3ed-351">删除步骤1中的记录后（但在步骤2中重新检索数据之前），如果一个或多个行受操作影响，则 GridView 将更新其 `PageIndex` 属性。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="8b3ed-352">但是，ObjectDataSource 并不设置 `AffectedRows` 属性，因此将省略此步骤。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="8b3ed-353">执行此步骤的一种方法是，如果删除操作成功完成，则手动设置 `AffectedRows` 属性。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="8b3ed-354">这可以通过使用如下代码来实现：</span><span class="sxs-lookup"><span data-stu-id="8b3ed-354">This can be accomplished using code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="8b3ed-355">这两个事件处理程序的代码都可在 `EfficientPaging.aspx` 示例的代码隐藏类中找到。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="8b3ed-356">比较默认和自定义分页的性能</span><span class="sxs-lookup"><span data-stu-id="8b3ed-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="8b3ed-357">自定义分页仅检索所需记录，而默认分页将返回所查看的每个页面的*所有*记录，因此，这显然，自定义分页比默认分页更有效。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="8b3ed-358">但自定义分页的效率要高得多？</span><span class="sxs-lookup"><span data-stu-id="8b3ed-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="8b3ed-359">通过从默认分页转为自定义分页，可以查看哪种性能提升？</span><span class="sxs-lookup"><span data-stu-id="8b3ed-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="8b3ed-360">遗憾的是，这里没有任何一个合适的答案。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="8b3ed-361">性能提升取决于许多因素，最重要的两个因素是要分页到的记录数，以及放置在数据库服务器和 web 服务器与数据库服务器之间的通信通道上的负载。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="8b3ed-362">对于只有少量记录的小型表，性能差异可能会忽略不计。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="8b3ed-363">对于包含数千到数百行的大型表，性能差异很大。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="8b3ed-364">使用[SQL Server 2005 的 ASP.NET 2.0 中](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)的 "地雷" 自定义分页一文包含一些运行的性能测试，这些测试在分页通过包含50000记录的数据库表时，会表现出这两种分页技术之间的性能差异。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="8b3ed-365">在这些测试中，我使用[ASP.NET 跟踪功能](https://msdn.microsoft.com/library/y13fw6we.aspx)在 SQL Server 级别（使用[SQL 事件探查器](https://msdn.microsoft.com/library/ms173757.aspx)）和 ASP.NET 页上都检查了执行查询的时间。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="8b3ed-366">请记住，这些测试是在具有单个活动用户的开发框上运行的，因此是 unscientific 的，不会模拟典型的网站负载模式。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="8b3ed-367">无论如何，结果都说明了在使用大量数据时，默认和自定义分页的执行时间的相对差异。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="8b3ed-368">**平均持续时间（秒）**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="8b3ed-369">**读取次数**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="8b3ed-370">**默认分页 SQL 事件探查器**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="8b3ed-371">1.411</span><span class="sxs-lookup"><span data-stu-id="8b3ed-371">1.411</span></span> | <span data-ttu-id="8b3ed-372">383</span><span class="sxs-lookup"><span data-stu-id="8b3ed-372">383</span></span> |
| <span data-ttu-id="8b3ed-373">**自定义分页 SQL 事件探查器**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="8b3ed-374">0.002</span><span class="sxs-lookup"><span data-stu-id="8b3ed-374">0.002</span></span> | <span data-ttu-id="8b3ed-375">29</span><span class="sxs-lookup"><span data-stu-id="8b3ed-375">29</span></span> |
| <span data-ttu-id="8b3ed-376">**默认分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="8b3ed-377">2.379</span><span class="sxs-lookup"><span data-stu-id="8b3ed-377">2.379</span></span> | <span data-ttu-id="8b3ed-378">*不适用*</span><span class="sxs-lookup"><span data-stu-id="8b3ed-378">*N/A*</span></span> |
| <span data-ttu-id="8b3ed-379">**自定义分页 ASP.NET 跟踪**</span><span class="sxs-lookup"><span data-stu-id="8b3ed-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="8b3ed-380">0.029</span><span class="sxs-lookup"><span data-stu-id="8b3ed-380">0.029</span></span> | <span data-ttu-id="8b3ed-381">*不适用*</span><span class="sxs-lookup"><span data-stu-id="8b3ed-381">*N/A*</span></span> |

<span data-ttu-id="8b3ed-382">正如您所看到的，检索特定的数据页需要354的平均读取量，而一小部分时间完成。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="8b3ed-383">在 ASP.NET 页上，自定义页面在使用默认分页时，可以在<sup>接近1/100 的</sup>时间进行呈现。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="8b3ed-384">请参阅[我的文章](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx)，以了解有关这些结果的详细信息以及代码和数据库，你可以下载这些内容以在你自己的环境中重现这些测试。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="8b3ed-385">总结</span><span class="sxs-lookup"><span data-stu-id="8b3ed-385">Summary</span></span>

<span data-ttu-id="8b3ed-386">默认分页是一个 cinch，只需检查数据 Web 控件的 "智能标记" 中的 "启用分页" 复选框，就会产生性能的代价。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="8b3ed-387">使用默认分页时，当用户请求任何数据页时，将返回*所有*记录，即使只显示一小部分记录。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="8b3ed-388">为了应对这种性能开销，ObjectDataSource 提供了一个可选的分页选项自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="8b3ed-389">尽管自定义分页通过仅检索那些需要显示的记录来改善默认分页性能问题，但它更多是实现自定义分页。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="8b3ed-390">首先，必须正确（并且有效地）写入查询所请求的特定记录子集。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="8b3ed-391">这可以通过多种方式完成：本教程中所述的是使用 SQL Server 2005 s new `ROW_NUMBER()` 函数对结果进行排序，然后只返回排名落在指定范围内的结果。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="8b3ed-392">此外，我们还需要添加一个方法来确定要分页到的记录总数。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="8b3ed-393">创建这些 DAL 和 BLL 方法后，我们还需要配置 ObjectDataSource，使其能够确定要分页到多少个记录，并可以将起始行索引和最大行值正确地传递给 BLL。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="8b3ed-394">虽然实现自定义分页需要执行一些步骤，但并不像默认分页那样简单，但在通过足够大量的数据进行分页时，自定义分页是必需的。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="8b3ed-395">如所述，自定义分页可能会在 ASP.NET 页面呈现时间之外舍弃秒，并可以通过一个或多个数量级使数据库服务器上的负载变亮。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="8b3ed-396">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="8b3ed-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="8b3ed-397">关于作者</span><span class="sxs-lookup"><span data-stu-id="8b3ed-397">About the Author</span></span>

<span data-ttu-id="8b3ed-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的[4GuysFromRolla.com](http://www.4guysfromrolla.com)，已在使用 Microsoft Web 技术，自1998开始。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="8b3ed-399">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="8b3ed-400">他的最新书籍是，[*在24小时内，sam ASP.NET 2.0*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="8b3ed-401">可以[mitchell@4GuysFromRolla.com访问。](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="8b3ed-402">或通过他的博客，可以在[http://ScottOnWriting.NET](http://ScottOnWriting.NET)找到。</span><span class="sxs-lookup"><span data-stu-id="8b3ed-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="8b3ed-403">[上一页](paging-and-sorting-report-data-cs.md)
> [下一页](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="8b3ed-403">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>

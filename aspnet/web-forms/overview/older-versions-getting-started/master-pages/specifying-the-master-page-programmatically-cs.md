---
uid: web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-cs
title: 以编程方式指定母版页（C#） |Microsoft Docs
author: rick-anderson
description: 查看如何通过 PreInit 事件处理程序以编程方式设置内容页的母版页。
ms.author: riande
ms.date: 07/28/2008
ms.assetid: 7c4a3445-2440-4aee-b9fd-779c05e6abb2
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/specifying-the-master-page-programmatically-cs
msc.type: authoredcontent
ms.openlocfilehash: 0db23ea05ba001c2bf9fc5330a60a767caa568a0
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74590350"
---
# <a name="specifying-the-master-page-programmatically-c"></a><span data-ttu-id="a9031-103">以编程方式指定母版页 (C#)</span><span class="sxs-lookup"><span data-stu-id="a9031-103">Specifying the Master Page Programmatically (C#)</span></span>

<span data-ttu-id="a9031-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="a9031-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="a9031-105">[下载代码](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.zip)或[下载 PDF](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="a9031-105">[Download Code](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.zip) or [Download PDF](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_09_CS.pdf)</span></span>

> <span data-ttu-id="a9031-106">查看如何通过 PreInit 事件处理程序以编程方式设置内容页的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-106">Looks at setting the content page's master page programmatically via the PreInit event handler.</span></span>

## <a name="introduction"></a><span data-ttu-id="a9031-107">简介</span><span class="sxs-lookup"><span data-stu-id="a9031-107">Introduction</span></span>

<span data-ttu-id="a9031-108">由于在[*使用母版页创建站点范围布局*](creating-a-site-wide-layout-using-master-pages-cs.md)的便捷性示例中，所有内容页都通过 `@Page` 指令中的 `MasterPageFile` 属性以声明方式引用了其母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-108">Since the inaugural example in [*Creating a Site-Wide Layout Using Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md), all content pages have referenced their master page declaratively via the `MasterPageFile` attribute in the `@Page` directive.</span></span> <span data-ttu-id="a9031-109">例如，以下 `@Page` 指令将内容页链接到母版页 `Site.master`：</span><span class="sxs-lookup"><span data-stu-id="a9031-109">For example, the following `@Page` directive links the content page to the master page `Site.master`:</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample1.aspx)]

<span data-ttu-id="a9031-110">`System.Web.UI` 命名空间中的[`Page` 类](https://msdn.microsoft.com/library/system.web.ui.page.aspx)包括一个[`MasterPageFile` 属性](https://msdn.microsoft.com/library/system.web.ui.page.masterpagefile.aspx)，该属性返回内容页的母版页的路径;此属性由 `@Page` 指令设置。</span><span class="sxs-lookup"><span data-stu-id="a9031-110">The [`Page` class](https://msdn.microsoft.com/library/system.web.ui.page.aspx) in the `System.Web.UI` namespace includes a [`MasterPageFile` property](https://msdn.microsoft.com/library/system.web.ui.page.masterpagefile.aspx) that returns the path to the content page's master page; it is this property that is set by the `@Page` directive.</span></span> <span data-ttu-id="a9031-111">此属性还可用于以编程方式指定内容页的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-111">This property can also be used to programmatically specify the content page's master page.</span></span> <span data-ttu-id="a9031-112">如果要根据外部因素（如访问页面的用户）动态分配母版页，此方法非常有用。</span><span class="sxs-lookup"><span data-stu-id="a9031-112">This approach is useful if you want to dynamically assign the master page based on external factors, such as the user visiting the page.</span></span>

<span data-ttu-id="a9031-113">在本教程中，我们将向网站添加另一个母版页，并动态确定要在运行时使用的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-113">In this tutorial we add a second master page to our website and dynamically decide which master page to use at runtime.</span></span>

## <a name="step-1-a-look-at-the-page-lifecycle"></a><span data-ttu-id="a9031-114">步骤1：查看页面生命周期</span><span class="sxs-lookup"><span data-stu-id="a9031-114">Step 1: A Look at the Page Lifecycle</span></span>

<span data-ttu-id="a9031-115">每当为内容页的 ASP.NET 页面的 web 服务器发出请求时，ASP.NET 引擎都必须将页面的内容控件保险丝到母版页的相应 ContentPlaceHolder 控件中。</span><span class="sxs-lookup"><span data-stu-id="a9031-115">Whenever a request arrives at the web server for an ASP.NET page that is a content page, the ASP.NET engine must fuse the page's Content controls into the master page's corresponding ContentPlaceHolder controls.</span></span> <span data-ttu-id="a9031-116">这种合成创建单个控件层次结构，然后可以通过典型的页面生命周期进行处理。</span><span class="sxs-lookup"><span data-stu-id="a9031-116">This fusion creates a single control hierarchy that can then proceed through the typical page lifecycle.</span></span>

<span data-ttu-id="a9031-117">图1演示了这种合成。</span><span class="sxs-lookup"><span data-stu-id="a9031-117">Figure 1 illustrates this fusion.</span></span> <span data-ttu-id="a9031-118">图1中的步骤1显示初始内容和母版页控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="a9031-118">Step 1 in Figure 1 shows the initial content and master page control hierarchies.</span></span> <span data-ttu-id="a9031-119">在 PreInit 阶段的结尾处，将页面中的内容控件添加到母版页中的相应 Contentplaceholder （步骤2）。</span><span class="sxs-lookup"><span data-stu-id="a9031-119">At the tail end of the PreInit stage the Content controls in the page are added to the corresponding ContentPlaceHolders in the master page (Step 2).</span></span> <span data-ttu-id="a9031-120">在这种合成后，母版页充当已保险丝控件层次结构的根。</span><span class="sxs-lookup"><span data-stu-id="a9031-120">After this fusion, the master page serves as the root of the fused control hierarchy.</span></span> <span data-ttu-id="a9031-121">然后，将此融合的控件层次结构添加到页面以生成最终控制层次结构（步骤3）。</span><span class="sxs-lookup"><span data-stu-id="a9031-121">This fused control hierarchy is then added to the page to produce the finalized control hierarchy (Step 3).</span></span> <span data-ttu-id="a9031-122">最终结果是页面的控件层次结构包括已保险丝的控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="a9031-122">The net result is that the page's control hierarchy includes the fused control hierarchy.</span></span>

<span data-ttu-id="a9031-123">[![母版页和内容页的控件层次结构在 PreInit 阶段一起融合在一起](specifying-the-master-page-programmatically-cs/_static/image2.png)](specifying-the-master-page-programmatically-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-123">[![The Master Page and Content Page's Control Hierarchies are Fused Together during the PreInit Stage](specifying-the-master-page-programmatically-cs/_static/image2.png)](specifying-the-master-page-programmatically-cs/_static/image1.png)</span></span>

<span data-ttu-id="a9031-124">**图 01**：母版页和内容页的控件层次结构在 PreInit 阶段一起融合在一起（[单击以查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-124">**Figure 01**: The Master Page and Content Page's Control Hierarchies are Fused Together during the PreInit Stage ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image3.png))</span></span>

## <a name="step-2-setting-themasterpagefileproperty-from-code"></a><span data-ttu-id="a9031-125">步骤2：从代码设置`MasterPageFile`属性</span><span class="sxs-lookup"><span data-stu-id="a9031-125">Step 2: Setting the`MasterPageFile`Property from Code</span></span>

<span data-ttu-id="a9031-126">此合成中 partakes 的内容取决于 `Page` 对象的 `MasterPageFile` 属性的值。</span><span class="sxs-lookup"><span data-stu-id="a9031-126">What master page partakes in this fusion depends on the value of the `Page` object's `MasterPageFile` property.</span></span> <span data-ttu-id="a9031-127">在 `@Page` 指令中设置 `MasterPageFile` 属性可以在初始化阶段（这是页面生命周期的第一阶段）中分配 `Page`的 `MasterPageFile` 属性的最终效果。</span><span class="sxs-lookup"><span data-stu-id="a9031-127">Setting the `MasterPageFile` attribute in the `@Page` directive has the net effect of assigning the `Page`'s `MasterPageFile` property during the Initialization stage, which is the very first stage of the page's lifecycle.</span></span> <span data-ttu-id="a9031-128">还可以通过编程方式设置此属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-128">We can alternatively set this property programmatically.</span></span> <span data-ttu-id="a9031-129">但是，在图1中的合成之前，必须设置此属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-129">However, it is imperative that this property be set before the fusion in Figure 1 takes place.</span></span>

<span data-ttu-id="a9031-130">在 PreInit 阶段开始时，`Page` 对象将引发其[`PreInit` 事件](https://msdn.microsoft.com/library/system.web.ui.page.preinit.aspx)并调用其[`OnPreInit` 方法](https://msdn.microsoft.com/library/system.web.ui.page.onpreinit.aspx)。</span><span class="sxs-lookup"><span data-stu-id="a9031-130">At the start of the PreInit stage the `Page` object raises its [`PreInit` event](https://msdn.microsoft.com/library/system.web.ui.page.preinit.aspx) and calls its [`OnPreInit` method](https://msdn.microsoft.com/library/system.web.ui.page.onpreinit.aspx).</span></span> <span data-ttu-id="a9031-131">若要以编程方式设置母版页，可以为 `PreInit` 事件创建事件处理程序，也可以重写 `OnPreInit` 方法。</span><span class="sxs-lookup"><span data-stu-id="a9031-131">To set the master page programmatically, then, we can either create an event handler for the `PreInit` event or override the `OnPreInit` method.</span></span> <span data-ttu-id="a9031-132">让我们看看这两种方法。</span><span class="sxs-lookup"><span data-stu-id="a9031-132">Let's look at both approaches.</span></span>

<span data-ttu-id="a9031-133">首先打开 `Default.aspx.cs`，它是站点主页的代码隐藏类文件。</span><span class="sxs-lookup"><span data-stu-id="a9031-133">Start by opening `Default.aspx.cs`, the code-behind class file for our site's homepage.</span></span> <span data-ttu-id="a9031-134">键入以下代码，为页面的 `PreInit` 事件添加事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="a9031-134">Add an event handler for the page's `PreInit` event by typing in the following code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample2.cs)]

<span data-ttu-id="a9031-135">可以从此处设置 "`MasterPageFile`" 属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-135">From here we can set the `MasterPageFile` property.</span></span> <span data-ttu-id="a9031-136">更新代码，以便它将 "~/Site.master" 值分配给 `MasterPageFile` 属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-136">Update the code so that it assigns the value "~/Site.master" to the `MasterPageFile` property.</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample3.cs)]

<span data-ttu-id="a9031-137">如果设置了断点并开始调试，你将看到，无论何时访问 `Default.aspx` 页面，或每当此页面回发时，都将执行 `Page_PreInit` 事件处理程序，并将 `MasterPageFile` 属性分配给 "~/Site.master"。</span><span class="sxs-lookup"><span data-stu-id="a9031-137">If you set a breakpoint and start with debugging you'll see that whenever the `Default.aspx` page is visited or whenever there's a postback to this page, the `Page_PreInit` event handler executes and the `MasterPageFile` property is assigned to "~/Site.master".</span></span>

<span data-ttu-id="a9031-138">或者，您可以重写 `Page` 类的 `OnPreInit` 方法，并在其中设置 `MasterPageFile` 属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-138">Alternatively, you can override the `Page` class's `OnPreInit` method and set the `MasterPageFile` property there.</span></span> <span data-ttu-id="a9031-139">在此示例中，我们不会在特定页面中设置母版页，而是从 `BasePage`。</span><span class="sxs-lookup"><span data-stu-id="a9031-139">For this example, let's not set the master page in a particular page, but rather from `BasePage`.</span></span> <span data-ttu-id="a9031-140">回忆一下，我们在[*母版页教程中指定标题、Meta 标记和其他 HTML 标头*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md)后，创建了一个自定义的基本页类（`BasePage`）。</span><span class="sxs-lookup"><span data-stu-id="a9031-140">Recall that we created a custom base page class (`BasePage`) back in the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial.</span></span> <span data-ttu-id="a9031-141">目前 `BasePage` 重写 `Page` 类的 `OnLoadComplete` 方法，在该方法中，它基于站点地图数据设置页面的 `Title` 属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-141">Currently `BasePage` overrides the `Page` class's `OnLoadComplete` method, where it sets the page's `Title` property based on the site map data.</span></span> <span data-ttu-id="a9031-142">让我们更新 `BasePage`，`OnPreInit` 以通过编程方式指定母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-142">Let's update `BasePage` to also override the `OnPreInit` method to programmatically specify the master page.</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample4.cs)]

<span data-ttu-id="a9031-143">由于所有内容页均派生自 `BasePage`，因此所有内容页现在都以编程方式分配了其母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-143">Because all our content pages derive from `BasePage`, all of them now have their master page programmatically assigned.</span></span> <span data-ttu-id="a9031-144">此时，`Default.aspx.cs` 中的 `PreInit` 事件处理程序是多余的;随意将其删除。</span><span class="sxs-lookup"><span data-stu-id="a9031-144">At this point the `PreInit` event handler in `Default.aspx.cs` is superfluous; feel free to remove it.</span></span>

### <a name="what-about-thepagedirective"></a><span data-ttu-id="a9031-145">`@Page`指令呢？</span><span class="sxs-lookup"><span data-stu-id="a9031-145">What About the`@Page`Directive?</span></span>

<span data-ttu-id="a9031-146">这可能有点令人困惑：内容页的 `MasterPageFile` 属性现在是在两个位置指定的：在 `BasePage` 类的 `OnPreInit` 方法中以编程方式，以及通过每个内容页的 `@Page` 指令中的 `MasterPageFile` 特性。</span><span class="sxs-lookup"><span data-stu-id="a9031-146">What may be a little confusing is that the content pages' `MasterPageFile` properties are now being specified in two places: programmatically in the `BasePage` class's `OnPreInit` method as well as through the `MasterPageFile` attribute in each content page's `@Page` directive.</span></span>

<span data-ttu-id="a9031-147">页面生命周期的第一阶段是初始化阶段。</span><span class="sxs-lookup"><span data-stu-id="a9031-147">The first stage in the page lifecycle is the Initialization stage.</span></span> <span data-ttu-id="a9031-148">在此阶段中，`Page` 对象的 `MasterPageFile` 属性分配给 `@Page` 指令中 `MasterPageFile` 属性的值（如果已提供）。</span><span class="sxs-lookup"><span data-stu-id="a9031-148">During this stage the `Page` object's `MasterPageFile` property is assigned the value of the `MasterPageFile` attribute in the `@Page` directive (if it is provided).</span></span> <span data-ttu-id="a9031-149">PreInit 阶段遵循初始化阶段，这里是以编程方式设置 `Page` 对象的 `MasterPageFile` 属性，从而覆盖从 `@Page` 指令分配的值。</span><span class="sxs-lookup"><span data-stu-id="a9031-149">The PreInit stage follows the Initialization stage, and it is here where we programmatically set the `Page` object's `MasterPageFile` property, thereby overwriting the value assigned from the `@Page` directive.</span></span> <span data-ttu-id="a9031-150">由于我们要以编程方式设置 `Page` 对象的 `MasterPageFile` 属性，因此可以从 `@Page` 指令中删除 `MasterPageFile` 属性，而不会影响最终用户的体验。</span><span class="sxs-lookup"><span data-stu-id="a9031-150">Because we are setting the `Page` object's `MasterPageFile` property programmatically, we could remove the `MasterPageFile` attribute from the `@Page` directive without affecting the end user's experience.</span></span> <span data-ttu-id="a9031-151">若要说服这一点，请继续从 `Default.aspx` 的 `@Page` 指令中删除 `MasterPageFile` 属性，然后通过浏览器访问该页面。</span><span class="sxs-lookup"><span data-stu-id="a9031-151">To convince yourself of this, go ahead and remove the `MasterPageFile` attribute from the `@Page` directive in `Default.aspx` and then visit the page through a browser.</span></span> <span data-ttu-id="a9031-152">正如您所期望的那样，输出与删除属性之前相同。</span><span class="sxs-lookup"><span data-stu-id="a9031-152">As you would expect, the output is the same as before the attribute was removed.</span></span>

<span data-ttu-id="a9031-153">是通过 `@Page` 指令还是以编程方式设置 `MasterPageFile` 属性无关紧要最终用户的体验。</span><span class="sxs-lookup"><span data-stu-id="a9031-153">Whether the `MasterPageFile` property is set via the `@Page` directive or programmatically is inconsequential to the end user's experience.</span></span> <span data-ttu-id="a9031-154">但是，Visual Studio 会在设计时使用 `@Page` 指令中的 `MasterPageFile` 属性，以在设计器中生成 WYSIWYG 视图。</span><span class="sxs-lookup"><span data-stu-id="a9031-154">However, the `MasterPageFile` attribute in the `@Page` directive is used by Visual Studio during design-time to produce the WYSIWYG view in the Designer.</span></span> <span data-ttu-id="a9031-155">如果你返回到 Visual Studio 中的 `Default.aspx`，并导航到该设计器，则会看到消息 "母版页错误：页面上有需要母版页引用的控件，但未指定任何内容" （参见图2）。</span><span class="sxs-lookup"><span data-stu-id="a9031-155">If you return to `Default.aspx` in Visual Studio and navigate to the Designer you'll see the message, "Master Page error: The page has controls that require a Master Page reference, but none is specified" (see Figure 2).</span></span>

<span data-ttu-id="a9031-156">简而言之，需要在 `@Page` 指令中保留 `MasterPageFile` 特性，以便在 Visual Studio 中使用丰富的设计时体验。</span><span class="sxs-lookup"><span data-stu-id="a9031-156">In short, you need to leave the `MasterPageFile` attribute in the `@Page` directive to enjoy a rich design-time experience in Visual Studio.</span></span>

<span data-ttu-id="a9031-157">[![Visual Studio 使用 @Page 指令的 MasterPageFile 特性来呈现设计视图](specifying-the-master-page-programmatically-cs/_static/image5.png)](specifying-the-master-page-programmatically-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-157">[![Visual Studio Uses the @Page Directive's MasterPageFile Attribute to Render the Design View](specifying-the-master-page-programmatically-cs/_static/image5.png)](specifying-the-master-page-programmatically-cs/_static/image4.png)</span></span>

<span data-ttu-id="a9031-158">**图 02**： Visual Studio 使用 `@Page` 指令的 `MasterPageFile` 属性呈现设计视图（[单击查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-158">**Figure 02**: Visual Studio Uses the `@Page` Directive's `MasterPageFile` Attribute to Render the Design View  ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image6.png))</span></span>

## <a name="step-3-creating-an-alternative-master-page"></a><span data-ttu-id="a9031-159">步骤3：创建备用母版页</span><span class="sxs-lookup"><span data-stu-id="a9031-159">Step 3: Creating an Alternative Master Page</span></span>

<span data-ttu-id="a9031-160">由于可以在运行时以编程方式设置内容页的母版页，因此可以根据某些外部条件动态加载特定的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-160">Because a content page's master page can be set programmatically at runtime it's possible to dynamically load a particular master page based on some external criteria.</span></span> <span data-ttu-id="a9031-161">此功能在站点布局需要根据用户的不同情况下非常有用。</span><span class="sxs-lookup"><span data-stu-id="a9031-161">This functionality can be useful in situations where the site's layout needs to vary based on the user.</span></span> <span data-ttu-id="a9031-162">例如，博客引擎 web 应用程序可能允许其用户为其博客选择布局，其中每个布局与不同的母版页关联。</span><span class="sxs-lookup"><span data-stu-id="a9031-162">For instance, a blog engine web application may allow its users to choose a layout for their blog, where each layout is associated with a different master page.</span></span> <span data-ttu-id="a9031-163">在运行时，当访问者查看用户的博客时，web 应用程序需要确定博客的布局并动态地将相应的母版页与内容页相关联。</span><span class="sxs-lookup"><span data-stu-id="a9031-163">At runtime, when a visitor is viewing a user's blog, the web application would need to determine the blog's layout and dynamically associate the corresponding master page with the content page.</span></span>

<span data-ttu-id="a9031-164">让我们看看如何根据某些外部条件在运行时动态加载母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-164">Let's examine how to dynamically load a master page at runtime based on some external criteria.</span></span> <span data-ttu-id="a9031-165">我们的网站当前只包含一个母版页（`Site.master`）。</span><span class="sxs-lookup"><span data-stu-id="a9031-165">Our website currently contains just one master page (`Site.master`).</span></span> <span data-ttu-id="a9031-166">我们需要另一个母版页来说明如何在运行时选择母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-166">We need another master page to illustrate choosing a master page at runtime.</span></span> <span data-ttu-id="a9031-167">此步骤重点介绍如何创建和配置新的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-167">This step focuses on creating and configuring the new master page.</span></span> <span data-ttu-id="a9031-168">步骤4介绍如何确定要在运行时使用的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-168">Step 4 looks at determining what master page to use at runtime.</span></span>

<span data-ttu-id="a9031-169">在名为 `Alternate.master`的根文件夹中创建新的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-169">Create a new master page in the root folder named `Alternate.master`.</span></span> <span data-ttu-id="a9031-170">同时向网站添加一个名为 `AlternateStyles.css`的新样式表。</span><span class="sxs-lookup"><span data-stu-id="a9031-170">Also add a new style sheet to the website named `AlternateStyles.css`.</span></span>

<span data-ttu-id="a9031-171">[![向网站添加另一个母版页和 CSS 文件](specifying-the-master-page-programmatically-cs/_static/image8.png)](specifying-the-master-page-programmatically-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-171">[![Add Another Master Page and CSS File to the Website](specifying-the-master-page-programmatically-cs/_static/image8.png)](specifying-the-master-page-programmatically-cs/_static/image7.png)</span></span>

<span data-ttu-id="a9031-172">**图 03**：向网站添加另一个母版页和 CSS 文件（[单击以查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-172">**Figure 03**: Add Another Master Page and CSS File to the Website ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image9.png))</span></span>

<span data-ttu-id="a9031-173">我已经设计了 `Alternate.master` 母版页，使标题显示在页面顶部、在深蓝色背景中居中显示。</span><span class="sxs-lookup"><span data-stu-id="a9031-173">I've designed the `Alternate.master` master page to have the title displayed at the top of the page, centered and on a navy background.</span></span> <span data-ttu-id="a9031-174">我已经分配了左栏并将该内容移到 `MainContent` ContentPlaceHolder 控件下，该控件现在跨越整个页面的宽度。</span><span class="sxs-lookup"><span data-stu-id="a9031-174">I've dispensed of the left column and moved that content beneath the `MainContent` ContentPlaceHolder control, which now spans the entire width of the page.</span></span> <span data-ttu-id="a9031-175">此外，我 nixed 未排序的课程列表，并将其替换为上面 `MainContent`的水平列表。</span><span class="sxs-lookup"><span data-stu-id="a9031-175">Furthermore, I nixed the unordered Lessons list and replaced it with a horizontal list above `MainContent`.</span></span> <span data-ttu-id="a9031-176">我还更新了母版页使用的字体和颜色（通过扩展、其内容页）。</span><span class="sxs-lookup"><span data-stu-id="a9031-176">I also updated the fonts and colors used by the master page (and, by extension, its content pages).</span></span> <span data-ttu-id="a9031-177">图4显示了使用 `Alternate.master` 母版页时的 `Default.aspx`。</span><span class="sxs-lookup"><span data-stu-id="a9031-177">Figure 4 shows `Default.aspx` when using the `Alternate.master` master page.</span></span>

> [!NOTE]
> <span data-ttu-id="a9031-178">ASP.NET 包括定义*主题*的功能。</span><span class="sxs-lookup"><span data-stu-id="a9031-178">ASP.NET includes the ability to define *Themes*.</span></span> <span data-ttu-id="a9031-179">主题是可在运行时应用于页面的图像、CSS 文件和样式相关的 Web 控件属性设置的集合。</span><span class="sxs-lookup"><span data-stu-id="a9031-179">A Theme is a collection of images, CSS files, and style-related Web control property settings that can be applied to a page at runtime.</span></span> <span data-ttu-id="a9031-180">如果你的网站布局不同于显示的图像及其 CSS 规则，则可以使用主题。</span><span class="sxs-lookup"><span data-stu-id="a9031-180">Themes are the way to go if your site's layouts differ only in the images displayed and by their CSS rules.</span></span> <span data-ttu-id="a9031-181">如果布局不同，如使用不同的 Web 控件或具有完全不同的布局，则需要使用单独的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-181">If the layouts differ more substantially, such as using different Web controls or having a radically different layout, then you will need to use separate master pages.</span></span> <span data-ttu-id="a9031-182">有关主题的详细信息，请参阅本教程末尾的其他阅读部分。</span><span class="sxs-lookup"><span data-stu-id="a9031-182">Consult the Further Reading section at the end of this tutorial for more information on Themes.</span></span>

<span data-ttu-id="a9031-183">[![我们的内容页现在可以使用全新的外观](specifying-the-master-page-programmatically-cs/_static/image11.png)](specifying-the-master-page-programmatically-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-183">[![Our Content Pages Can Now Use a New Look and Feel](specifying-the-master-page-programmatically-cs/_static/image11.png)](specifying-the-master-page-programmatically-cs/_static/image10.png)</span></span>

<span data-ttu-id="a9031-184">**图 04**：现在，我们的内容页可以使用全新的外观（[单击查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-184">**Figure 04**: Our Content Pages Can Now Use a New Look and Feel ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image12.png))</span></span>

<span data-ttu-id="a9031-185">当 "大纲" 和 "内容" 页的标记融合后，`MasterPage` 类将进行检查以确保内容页中的每个内容控件都引用母版页中的 ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="a9031-185">When the master and content pages' markup are fused, the `MasterPage` class checks to ensure that every Content control in the content page references a ContentPlaceHolder in the master page.</span></span> <span data-ttu-id="a9031-186">如果找到引用不存在的 ContentPlaceHolder 的内容控件，则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="a9031-186">An exception is thrown if a Content control that references a non-existent ContentPlaceHolder is found.</span></span> <span data-ttu-id="a9031-187">换句话说，分配到内容页的母版页对于内容页中的每个内容控件都有一个 ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="a9031-187">In other words, it is imperative that the master page being assigned to the content page have a ContentPlaceHolder for each Content control in the content page.</span></span>

<span data-ttu-id="a9031-188">`Site.master` 母版页包含四个 ContentPlaceHolder 控件：</span><span class="sxs-lookup"><span data-stu-id="a9031-188">The `Site.master` master page includes four ContentPlaceHolder controls:</span></span>

- `head`
- `MainContent`
- `QuickLoginUI`
- `LeftColumnContent`

<span data-ttu-id="a9031-189">网站中的某些内容页面只包含一个或两个内容控件;其他功能包括每个可用 Contentplaceholder 的内容控件。</span><span class="sxs-lookup"><span data-stu-id="a9031-189">Some of the content pages in our website include just one or two Content controls; others include a Content control for each of the available ContentPlaceHolders.</span></span> <span data-ttu-id="a9031-190">如果新的母版页（`Alternate.master`）可能被分配给那些内容页，这些内容页在 `Site.master` 中具有所有 Contentplaceholder 的内容控件，则 `Alternate.master` 还必须包含与 `Site.master`相同的 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="a9031-190">If our new master page (`Alternate.master`) may ever be assigned to those content pages that have Content controls for all of the ContentPlaceHolders in `Site.master` then it is essential that `Alternate.master` also include the same ContentPlaceHolder controls as `Site.master`.</span></span>

<span data-ttu-id="a9031-191">若要使 `Alternate.master` 母版页与地雷类似（参见图4），请首先在 `AlternateStyles.css` 样式表中定义母版页的样式。</span><span class="sxs-lookup"><span data-stu-id="a9031-191">To get your `Alternate.master` master page to look similar to mine (see Figure 4), start by defining the master page's styles in the `AlternateStyles.css` style sheet.</span></span> <span data-ttu-id="a9031-192">将以下规则添加到 `AlternateStyles.css`：</span><span class="sxs-lookup"><span data-stu-id="a9031-192">Add the following rules into `AlternateStyles.css`:</span></span>

[!code-css[Main](specifying-the-master-page-programmatically-cs/samples/sample5.css)]

<span data-ttu-id="a9031-193">接下来，将以下声明性标记添加到 `Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="a9031-193">Next, add the following declarative markup to `Alternate.master`.</span></span> <span data-ttu-id="a9031-194">如您所见，`Alternate.master` 包含四个具有与 `Site.master`中的 ContentPlaceHolder 控件相同的 `ID` 值的 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="a9031-194">As you can see, `Alternate.master` contains four ContentPlaceHolder controls with the same `ID` values as the ContentPlaceHolder controls in `Site.master`.</span></span> <span data-ttu-id="a9031-195">此外，它还包括一个 ScriptManager 控件，该控件对于使用 ASP.NET AJAX framework 的网站中的页面是必需的。</span><span class="sxs-lookup"><span data-stu-id="a9031-195">Moreover, it includes a ScriptManager control, which is necessary for those pages in our website that use the ASP.NET AJAX framework.</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample6.aspx)]

### <a name="testing-the-new-master-page"></a><span data-ttu-id="a9031-196">测试新的母版页</span><span class="sxs-lookup"><span data-stu-id="a9031-196">Testing the New Master Page</span></span>

<span data-ttu-id="a9031-197">若要测试此新母版页，请更新 `BasePage` 类的 `OnPreInit` 方法，以便将 "~/Alternate.master" 值分配给 `MasterPageFile` 属性，然后访问该网站。</span><span class="sxs-lookup"><span data-stu-id="a9031-197">To test this new master page update the `BasePage` class's `OnPreInit` method so that the `MasterPageFile` property is assigned the value "~/Alternate.master" and then visit the website.</span></span> <span data-ttu-id="a9031-198">每个页面都应正常运行，但不包括两个错误： `~/Admin/AddProduct.aspx` 和 `~/Admin/Products.aspx`。</span><span class="sxs-lookup"><span data-stu-id="a9031-198">Every page should function without error except for two: `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx`.</span></span> <span data-ttu-id="a9031-199">将产品添加到 `~/Admin/AddProduct.aspx` 中的 DetailsView 将导致尝试设置母版页的 `GridMessageText` 属性的代码行 `NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="a9031-199">Adding a product to the DetailsView in `~/Admin/AddProduct.aspx` results in a `NullReferenceException` from the line of code that attempts to set the master page's `GridMessageText` property.</span></span> <span data-ttu-id="a9031-200">当访问时 `~/Admin/Products.aspx` 在页面加载时引发 `InvalidCastException`，并出现以下消息： "无法将类型为" 的对象强制转换为类型 '\_.ASP\_master '。 "</span><span class="sxs-lookup"><span data-stu-id="a9031-200">When visiting `~/Admin/Products.aspx` an `InvalidCastException` is thrown on page load with the message: "Unable to cast object of type 'ASP.alternate\_master' to type 'ASP.site\_master'."</span></span>

<span data-ttu-id="a9031-201">之所以发生这些错误是因为 `Site.master` 代码隐藏类包括 `Alternate.master`中未定义的公共事件、属性和方法。</span><span class="sxs-lookup"><span data-stu-id="a9031-201">These errors occur because the `Site.master` code-behind class includes public events, properties, and methods that are not defined in `Alternate.master`.</span></span> <span data-ttu-id="a9031-202">这两个页面的标记部分具有一个引用 `Site.master` 母版页的 `@MasterType` 指令。</span><span class="sxs-lookup"><span data-stu-id="a9031-202">The markup portion of these two pages have a `@MasterType` directive that references the `Site.master` master page.</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample7.aspx)]

<span data-ttu-id="a9031-203">此外，中的 DetailsView `ItemInserted` 事件处理程序 `~/Admin/AddProduct.aspx` 包括将松散类型化的 `Page.Master` 属性强制转换为类型 `Site`的对象的代码。</span><span class="sxs-lookup"><span data-stu-id="a9031-203">Also, the DetailsView's `ItemInserted` event handler in `~/Admin/AddProduct.aspx` includes code that casts the loosely-typed `Page.Master` property to an object of type `Site`.</span></span> <span data-ttu-id="a9031-204">`@MasterType` 指令（以这种方式使用）和 `ItemInserted` 事件处理程序中的强制转换将 `~/Admin/AddProduct.aspx` 和 `~/Admin/Products.aspx` 页面紧密耦合到 `Site.master` 母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-204">The `@MasterType` directive (used this way) and the cast in the `ItemInserted` event handler tightly couples the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages to the `Site.master` master page.</span></span>

<span data-ttu-id="a9031-205">若要中断此紧密耦合，我们可以让 `Site.master` 和 `Alternate.master` 派生自包含公共成员定义的公共基类。</span><span class="sxs-lookup"><span data-stu-id="a9031-205">To break this tight coupling we can have `Site.master` and `Alternate.master` derive from a common base class that contains definitions for the public members.</span></span> <span data-ttu-id="a9031-206">接下来，我们可以更新 `@MasterType` 指令以引用此公共基类型。</span><span class="sxs-lookup"><span data-stu-id="a9031-206">Following that, we can update the `@MasterType` directive to reference this common base type.</span></span>

### <a name="creating-a-custom-base-master-page-class"></a><span data-ttu-id="a9031-207">创建自定义基母版页类</span><span class="sxs-lookup"><span data-stu-id="a9031-207">Creating a Custom Base Master Page Class</span></span>

<span data-ttu-id="a9031-208">将新的类文件添加到名为 `BaseMasterPage.cs` `App_Code` 文件夹中，并将其从 `System.Web.UI.MasterPage`派生。</span><span class="sxs-lookup"><span data-stu-id="a9031-208">Add a new class file to the `App_Code` folder named `BaseMasterPage.cs` and have it derive from `System.Web.UI.MasterPage`.</span></span> <span data-ttu-id="a9031-209">我们需要在 `BaseMasterPage`中定义 `RefreshRecentProductsGrid` 方法和 `GridMessageText` 属性，但我们不能只是将它们从 `Site.master` 中移出，因为这些成员使用的是特定于 `Site.master` 母版页的 Web 控件（`RecentProducts` GridView 和 `GridMessage` 标签）。</span><span class="sxs-lookup"><span data-stu-id="a9031-209">We need to define the `RefreshRecentProductsGrid` method and the `GridMessageText` property in `BaseMasterPage`, but we can't simply move them there from `Site.master` because these members work with Web controls that are specific to the `Site.master` master page (the `RecentProducts` GridView and `GridMessage` Label).</span></span>

<span data-ttu-id="a9031-210">我们需要做的就是将 `BaseMasterPage` 配置为在其中定义这些成员，但实际是通过 `BaseMasterPage`派生类（`Site.master` 和 `Alternate.master`）实现的。</span><span class="sxs-lookup"><span data-stu-id="a9031-210">What we need to do is configure `BaseMasterPage` in such a way that these members are defined there, but are actually implemented by `BaseMasterPage`'s derived classes (`Site.master` and `Alternate.master`).</span></span> <span data-ttu-id="a9031-211">这种类型的继承可以通过将类及其成员标记为 `abstract`来实现。</span><span class="sxs-lookup"><span data-stu-id="a9031-211">This type of inheritance is possible by marking the class and its members as `abstract`.</span></span> <span data-ttu-id="a9031-212">简而言之，将 `abstract` 关键字添加到这两个成员时，宣布 `BaseMasterPage` 未实现 `RefreshRecentProductsGrid` 和 `GridMessageText`，但其派生类将为。</span><span class="sxs-lookup"><span data-stu-id="a9031-212">In short, adding the `abstract` keyword to these two members announces that `BaseMasterPage` hasn't implemented `RefreshRecentProductsGrid` and `GridMessageText`, but that its derived classes will.</span></span>

<span data-ttu-id="a9031-213">还需要在 `BaseMasterPage` 中定义 `PricesDoubled` 事件，并为派生类提供一种引发事件的方法。</span><span class="sxs-lookup"><span data-stu-id="a9031-213">We also need to define the `PricesDoubled` event in `BaseMasterPage` and provide a means by the derived classes to raise the event.</span></span> <span data-ttu-id="a9031-214">.NET Framework 中使用的模式可帮助实现此行为，这是在基类中创建一个公共事件，并添加一个名为 `OnEventName`的受保护的 `virtual` 方法。</span><span class="sxs-lookup"><span data-stu-id="a9031-214">The pattern used in the .NET Framework to facilitate this behavior is to create a public event in the base class and add a protected, `virtual` method named `OnEventName`.</span></span> <span data-ttu-id="a9031-215">然后，派生类可以调用此方法来引发事件，或者可以重写它以在引发事件之前或之后立即执行代码。</span><span class="sxs-lookup"><span data-stu-id="a9031-215">Derived classes can then call this method to raise the event or can override it to execute code immediately before or after the event is raised.</span></span>

<span data-ttu-id="a9031-216">更新 `BaseMasterPage` 类，使其包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="a9031-216">Update your `BaseMasterPage` class so that it contains the following code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample8.cs)]

<span data-ttu-id="a9031-217">接下来，请跳到 `Site.master` 代码隐藏类，并使其从 `BaseMasterPage`派生。</span><span class="sxs-lookup"><span data-stu-id="a9031-217">Next, go to the `Site.master` code-behind class and have it derive from `BaseMasterPage`.</span></span> <span data-ttu-id="a9031-218">由于 `BaseMasterPage` 是 `abstract` 我们需要在 `Site.master`中覆盖这些 `abstract` 成员。</span><span class="sxs-lookup"><span data-stu-id="a9031-218">Because `BaseMasterPage` is `abstract` we need to override those `abstract` members here in `Site.master`.</span></span> <span data-ttu-id="a9031-219">将 `override` 关键字添加到方法和属性定义。</span><span class="sxs-lookup"><span data-stu-id="a9031-219">Add the `override` keyword to the method and property definitions.</span></span> <span data-ttu-id="a9031-220">此外，使用对基类的 `OnPricesDoubled` 方法的调用来更新在 `DoublePrice` 按钮的 `Click` 事件处理程序中引发 `PricesDoubled` 事件的代码。</span><span class="sxs-lookup"><span data-stu-id="a9031-220">Also update the code that raises the `PricesDoubled` event in the `DoublePrice` Button's `Click` event handler with a call to the base class's `OnPricesDoubled` method.</span></span>

<span data-ttu-id="a9031-221">修改后，`Site.master` 代码隐藏类应包含以下代码：</span><span class="sxs-lookup"><span data-stu-id="a9031-221">After these modifications the `Site.master` code-behind class should contain the following code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample9.cs)]

<span data-ttu-id="a9031-222">我们还需要更新 `Alternate.master`的代码隐藏类，使其从 `BaseMasterPage` 派生并重写两个 `abstract` 成员。</span><span class="sxs-lookup"><span data-stu-id="a9031-222">We also need to update `Alternate.master`'s code-behind class to derive from `BaseMasterPage` and override the two `abstract` members.</span></span> <span data-ttu-id="a9031-223">但是，因为 `Alternate.master` 不包含列出了在将新产品添加到数据库后显示消息的 GridView，也不包含显示消息的 GridView，所以这些方法不需要执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="a9031-223">But because `Alternate.master` does not contain a GridView that lists the most recent products nor a Label that displays a message after a new product is added to the database, these methods do not need to do anything.</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample10.cs)]

### <a name="referencing-the-base-master-page-class"></a><span data-ttu-id="a9031-224">引用基母版页类</span><span class="sxs-lookup"><span data-stu-id="a9031-224">Referencing the Base Master Page Class</span></span>

<span data-ttu-id="a9031-225">现在，我们已完成了 `BaseMasterPage` 类，并让我们的两个母版页对其进行扩展，最后一步是更新 `~/Admin/AddProduct.aspx` 并 `~/Admin/Products.aspx` 页来引用此通用类型。</span><span class="sxs-lookup"><span data-stu-id="a9031-225">Now that we have completed the `BaseMasterPage` class and have our two master pages extending it, our final step is to update the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages to refer to this common type.</span></span> <span data-ttu-id="a9031-226">首先在以下两个页面中更改 `@MasterType` 指令：</span><span class="sxs-lookup"><span data-stu-id="a9031-226">Start by changing the `@MasterType` directive in both pages from:</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample11.aspx)]

<span data-ttu-id="a9031-227">结束时间：</span><span class="sxs-lookup"><span data-stu-id="a9031-227">To:</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample12.aspx)]

<span data-ttu-id="a9031-228">`@MasterType` 属性现在引用基类型（`BaseMasterPage`），而不是引用文件路径。</span><span class="sxs-lookup"><span data-stu-id="a9031-228">Rather than referencing a file path, the `@MasterType` property now references the base type (`BaseMasterPage`).</span></span> <span data-ttu-id="a9031-229">因此，在这两个页面的代码隐藏类中使用的强类型 `Master` 属性现在为类型 `BaseMasterPage` （而不是类型 `Site`）。</span><span class="sxs-lookup"><span data-stu-id="a9031-229">Consequently, the strongly-typed `Master` property used in both pages' code-behind classes is now of type `BaseMasterPage` (instead of type `Site`).</span></span> <span data-ttu-id="a9031-230">利用此更改，`~/Admin/Products.aspx`。</span><span class="sxs-lookup"><span data-stu-id="a9031-230">With this change in place revisit `~/Admin/Products.aspx`.</span></span> <span data-ttu-id="a9031-231">以前，这会导致发生强制转换错误，因为该页配置为使用 `Alternate.master` 母版页，而 `@MasterType` 指令引用了 `Site.master` 文件。</span><span class="sxs-lookup"><span data-stu-id="a9031-231">Previously, this resulted in a casting error because the page is configured to use the `Alternate.master` master page, but the `@MasterType` directive referenced the `Site.master` file.</span></span> <span data-ttu-id="a9031-232">但现在页面呈现时没有错误。</span><span class="sxs-lookup"><span data-stu-id="a9031-232">But now the page renders without error.</span></span> <span data-ttu-id="a9031-233">这是因为 `Alternate.master` 的母版页可以转换为 `BaseMasterPage` 类型的对象（因为它扩展了它）。</span><span class="sxs-lookup"><span data-stu-id="a9031-233">This is because the `Alternate.master` master page can be cast to an object of type `BaseMasterPage` (since it extends it).</span></span>

<span data-ttu-id="a9031-234">`~/Admin/AddProduct.aspx`需要进行一小的更改。</span><span class="sxs-lookup"><span data-stu-id="a9031-234">There's one small change that needs to be made in `~/Admin/AddProduct.aspx`.</span></span> <span data-ttu-id="a9031-235">DetailsView 控件的 `ItemInserted` 事件处理程序同时使用强类型 `Master` 属性和松散类型化的 `Page.Master` 属性。</span><span class="sxs-lookup"><span data-stu-id="a9031-235">The DetailsView control's `ItemInserted` event handler uses both the strongly-typed `Master` property and the loosely-typed `Page.Master` property.</span></span> <span data-ttu-id="a9031-236">我们在更新 `@MasterType` 指令时修复了强类型引用，但我们仍需要更新松类型引用。</span><span class="sxs-lookup"><span data-stu-id="a9031-236">We fixed the strongly-typed reference when we updated the `@MasterType` directive, but we still need to update the loosely-typed reference.</span></span> <span data-ttu-id="a9031-237">替换以下代码行：</span><span class="sxs-lookup"><span data-stu-id="a9031-237">Replace the following line of code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample13.cs)]

<span data-ttu-id="a9031-238">通过以下方式，将 `Page.Master` 转换为基类型：</span><span class="sxs-lookup"><span data-stu-id="a9031-238">With the following, which casts `Page.Master` to the base type:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample14.cs)]

## <a name="step-4-determining-what-master-page-to-bind-to-the-content-pages"></a><span data-ttu-id="a9031-239">步骤4：确定要绑定到内容页的母版页</span><span class="sxs-lookup"><span data-stu-id="a9031-239">Step 4: Determining What Master Page to Bind to the Content Pages</span></span>

<span data-ttu-id="a9031-240">`BasePage` 类当前将所有内容页的 `MasterPageFile` 属性设置为页面生命周期的 PreInit 阶段中的硬编码值。</span><span class="sxs-lookup"><span data-stu-id="a9031-240">Our `BasePage` class currently sets all content pages' `MasterPageFile` properties to a hard-coded value in the PreInit stage of the page lifecycle.</span></span> <span data-ttu-id="a9031-241">我们可以更新此代码，使其基于某个外部因素的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-241">We can update this code to base the master page on some external factor.</span></span> <span data-ttu-id="a9031-242">可能要加载的母版页依赖于当前登录用户的首选项。</span><span class="sxs-lookup"><span data-stu-id="a9031-242">Perhaps the master page to load depends on the preferences of the currently logged on user.</span></span> <span data-ttu-id="a9031-243">在这种情况下，我们需要在 `BasePage` 查找当前正在访问的用户的母版页首选项的 `OnPreInit` 方法中编写代码。</span><span class="sxs-lookup"><span data-stu-id="a9031-243">In that case, we'd need to write code in the `OnPreInit` method in `BasePage` that looks up the currently visiting user's master page preferences.</span></span>

<span data-ttu-id="a9031-244">让我们创建一个网页，该网页允许用户选择要使用的母版页-`Site.master` 或 `Alternate.master` 并将此选项保存到 Session 变量中。</span><span class="sxs-lookup"><span data-stu-id="a9031-244">Let's create a web page that allows the user to choose which master page to use - `Site.master` or `Alternate.master` - and save this choice in a Session variable.</span></span> <span data-ttu-id="a9031-245">首先在名为 `ChooseMasterPage.aspx`的根目录中创建一个新网页。</span><span class="sxs-lookup"><span data-stu-id="a9031-245">Start by creating a new web page in the root directory named `ChooseMasterPage.aspx`.</span></span> <span data-ttu-id="a9031-246">创建此页面（或任何其他内容页面之后）时，无需将其绑定到母版页，因为母版页是以编程方式在 `BasePage`中设置的。</span><span class="sxs-lookup"><span data-stu-id="a9031-246">When creating this page (or any other content pages henceforth) you don't need to bind it to a master page because the master page is set programmatically in `BasePage`.</span></span> <span data-ttu-id="a9031-247">但是，如果不将新页绑定到母版页，则新页的默认声明性标记将包含由母版页提供的 Web 窗体和其他内容。</span><span class="sxs-lookup"><span data-stu-id="a9031-247">However, if you do not bind the new page to a master page then the new page's default declarative markup contains a Web Form and other content supplied by the master page.</span></span> <span data-ttu-id="a9031-248">需要手动将此标记替换为适当的内容控件。</span><span class="sxs-lookup"><span data-stu-id="a9031-248">You'll need to manually replace this markup with the appropriate Content controls.</span></span> <span data-ttu-id="a9031-249">出于此原因，我发现将新的 ASP.NET 页面绑定到母版页更容易。</span><span class="sxs-lookup"><span data-stu-id="a9031-249">For that reason, I find it easier to bind the new ASP.NET page to a master page.</span></span>

> [!NOTE]
> <span data-ttu-id="a9031-250">由于 `Site.master` 和 `Alternate.master` 具有相同的一组 ContentPlaceHolder 控件，因此在创建新的内容页时选择的母版页并不重要。</span><span class="sxs-lookup"><span data-stu-id="a9031-250">Because `Site.master` and `Alternate.master` have the same set of ContentPlaceHolder controls it doesn't matter what master page you choose when creating the new content page.</span></span> <span data-ttu-id="a9031-251">为保持一致性，我建议使用 `Site.master`。</span><span class="sxs-lookup"><span data-stu-id="a9031-251">For consistency, I'd suggest using `Site.master`.</span></span>

<span data-ttu-id="a9031-252">[![将新的内容页添加到网站](specifying-the-master-page-programmatically-cs/_static/image14.png)](specifying-the-master-page-programmatically-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-252">[![Add a New Content Page to the Website](specifying-the-master-page-programmatically-cs/_static/image14.png)](specifying-the-master-page-programmatically-cs/_static/image13.png)</span></span>

<span data-ttu-id="a9031-253">**图 05**：向网站添加新的内容页（[单击以查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-253">**Figure 05**: Add a New Content Page to the Website ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image15.png))</span></span>

<span data-ttu-id="a9031-254">更新 `Web.sitemap` 文件以包含本课中的条目。</span><span class="sxs-lookup"><span data-stu-id="a9031-254">Update the `Web.sitemap` file to include an entry for this lesson.</span></span> <span data-ttu-id="a9031-255">将以下标记添加到母版页的 `<siteMapNode>` 下，并 ASP.NET AJAX 课程：</span><span class="sxs-lookup"><span data-stu-id="a9031-255">Add the following markup beneath the `<siteMapNode>` for the Master Pages and ASP.NET AJAX lesson:</span></span>

[!code-xml[Main](specifying-the-master-page-programmatically-cs/samples/sample15.xml)]

<span data-ttu-id="a9031-256">在将任何内容添加到 `ChooseMasterPage.aspx` 页面之前，请花点时间更新页面的代码隐藏类，使其从 `BasePage` （而不是 `System.Web.UI.Page`）派生。</span><span class="sxs-lookup"><span data-stu-id="a9031-256">Before adding any content to the `ChooseMasterPage.aspx` page take a moment to update the page's code-behind class so that it derives from `BasePage` (rather than `System.Web.UI.Page`).</span></span> <span data-ttu-id="a9031-257">接下来，向页面添加一个 DropDownList 控件，将其 `ID` 属性设置为 `MasterPageChoice`，然后添加两个 `Text` 值为 "~/Site.master" 和 "~/Alternate.master" 的 ListItems。</span><span class="sxs-lookup"><span data-stu-id="a9031-257">Next, add a DropDownList control to the page, set its `ID` property to `MasterPageChoice`, and add two ListItems with the `Text` values of "~/Site.master" and "~/Alternate.master".</span></span>

<span data-ttu-id="a9031-258">将按钮 Web 控件添加到页面，并将其 `ID` 和 `Text` 属性分别设置为 `SaveLayout` 和 "保存布局选项"。</span><span class="sxs-lookup"><span data-stu-id="a9031-258">Add a Button Web control to the page and set its `ID` and `Text` properties to `SaveLayout` and "Save Layout Choice", respectively.</span></span> <span data-ttu-id="a9031-259">此时，页面的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="a9031-259">At this point your page's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](specifying-the-master-page-programmatically-cs/samples/sample16.aspx)]

<span data-ttu-id="a9031-260">首次访问页面时，需要显示用户当前选定的母版页选项。</span><span class="sxs-lookup"><span data-stu-id="a9031-260">When the page is first visited we need to display the user's currently selected master page choice.</span></span> <span data-ttu-id="a9031-261">创建 `Page_Load` 事件处理程序并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="a9031-261">Create a `Page_Load` event handler and add the following code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample17.cs)]

<span data-ttu-id="a9031-262">上述代码仅在第一页访问（而不是在后续回发上）执行。</span><span class="sxs-lookup"><span data-stu-id="a9031-262">The above code executes only on the first page visit (and not on subsequent postbacks).</span></span> <span data-ttu-id="a9031-263">它首先检查会话变量 `MyMasterPage` 是否存在。</span><span class="sxs-lookup"><span data-stu-id="a9031-263">It first checks to see if the Session variable `MyMasterPage` exists.</span></span> <span data-ttu-id="a9031-264">如果是，则它会尝试在 `MasterPageChoice` DropDownList 中查找匹配的匹配项。</span><span class="sxs-lookup"><span data-stu-id="a9031-264">If it does, it attempts to find the matching ListItem in the `MasterPageChoice` DropDownList.</span></span> <span data-ttu-id="a9031-265">如果找到匹配的匹配，则将其 `Selected` 属性设置为 `true`。</span><span class="sxs-lookup"><span data-stu-id="a9031-265">If a matching ListItem is found, its `Selected` property is set to `true`.</span></span>

<span data-ttu-id="a9031-266">我们还需要将用户的选择保存到 `MyMasterPage` Session 变量中的代码。</span><span class="sxs-lookup"><span data-stu-id="a9031-266">We also need code that saves the user's choice into the `MyMasterPage` Session variable.</span></span> <span data-ttu-id="a9031-267">为 "`SaveLayout`" 按钮的 `Click` 事件创建事件处理程序，并添加以下代码：</span><span class="sxs-lookup"><span data-stu-id="a9031-267">Create an event handler for the `SaveLayout` Button's `Click` event and add the following code:</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample18.cs)]

> [!NOTE]
> <span data-ttu-id="a9031-268">在回发时，`Click` 事件处理程序的执行时间已被选中。</span><span class="sxs-lookup"><span data-stu-id="a9031-268">By the time the `Click` event handler executes on postback, the master page has already been selected.</span></span> <span data-ttu-id="a9031-269">因此，在下一页访问之前，用户的下拉列表选择将不起作用。</span><span class="sxs-lookup"><span data-stu-id="a9031-269">Therefore, the user's drop-down list selection won't be in effect until the next page visit.</span></span> <span data-ttu-id="a9031-270">`Response.Redirect` 强制浏览器重新请求 `ChooseMasterPage.aspx`。</span><span class="sxs-lookup"><span data-stu-id="a9031-270">The `Response.Redirect` forces the browser to re-request `ChooseMasterPage.aspx`.</span></span>

<span data-ttu-id="a9031-271">`ChooseMasterPage.aspx` 页面完成后，最终任务就是 `BasePage` 分配 `MasterPageFile` 属性，具体取决于 `MyMasterPage` Session 变量的值。</span><span class="sxs-lookup"><span data-stu-id="a9031-271">With the `ChooseMasterPage.aspx` page complete, our final task is to have `BasePage` assign the `MasterPageFile` property based on the value of the `MyMasterPage` Session variable.</span></span> <span data-ttu-id="a9031-272">如果未设置会话变量，则 `BasePage` 默认为 `Site.master`。</span><span class="sxs-lookup"><span data-stu-id="a9031-272">If the Session variable is not set have `BasePage` default to `Site.master`.</span></span>

[!code-csharp[Main](specifying-the-master-page-programmatically-cs/samples/sample19.cs)]

> [!NOTE]
> <span data-ttu-id="a9031-273">我将指定 `Page` 对象的 `MasterPageFile` 属性的代码从 `OnPreInit` 事件处理程序移到了两个单独的方法中。</span><span class="sxs-lookup"><span data-stu-id="a9031-273">I moved the code that assigns the `Page` object's `MasterPageFile` property out of the `OnPreInit` event handler and into two separate methods.</span></span> <span data-ttu-id="a9031-274">第一种方法 `SetMasterPageFile`，将 `MasterPageFile` 属性分配给第二个方法（`GetMasterPageFileFromSession`）返回的值。</span><span class="sxs-lookup"><span data-stu-id="a9031-274">This first method, `SetMasterPageFile`, assigns the `MasterPageFile` property to the value returned by the second method, `GetMasterPageFileFromSession`.</span></span> <span data-ttu-id="a9031-275">我将 `SetMasterPageFile` 方法 `virtual` 这样，扩展 `BasePage` 的未来类可以根据需要重写该方法以实现自定义逻辑。</span><span class="sxs-lookup"><span data-stu-id="a9031-275">I made the `SetMasterPageFile` method `virtual` so that future classes that extend `BasePage` can optionally override it to implement custom logic, if needed.</span></span> <span data-ttu-id="a9031-276">在下一教程中，我们将介绍覆盖 `BasePage`的 `SetMasterPageFile` 属性的示例。</span><span class="sxs-lookup"><span data-stu-id="a9031-276">We'll see an example of overriding `BasePage`'s `SetMasterPageFile` property in the next tutorial.</span></span>

<span data-ttu-id="a9031-277">准备好此代码后，请访问 `ChooseMasterPage.aspx` 页面。</span><span class="sxs-lookup"><span data-stu-id="a9031-277">With this code in place, visit the `ChooseMasterPage.aspx` page.</span></span> <span data-ttu-id="a9031-278">最初，会选择 `Site.master` 母版页（参见图6），但用户可以从下拉列表中选择不同的母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-278">Initially, the `Site.master` master page is selected (see Figure 6), but the user can pick a different master page from the drop-down list.</span></span>

<span data-ttu-id="a9031-279">[使用 "站点" 母版页显示 ![内容页](specifying-the-master-page-programmatically-cs/_static/image17.png)](specifying-the-master-page-programmatically-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-279">[![Content Pages are Displayed Using the Site.master Master Page](specifying-the-master-page-programmatically-cs/_static/image17.png)](specifying-the-master-page-programmatically-cs/_static/image16.png)</span></span>

<span data-ttu-id="a9031-280">**图 06**：使用 `Site.master` 母版页显示内容页（[单击以查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-280">**Figure 06**: Content Pages are Displayed Using the `Site.master` Master Page ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image18.png))</span></span>

<span data-ttu-id="a9031-281">[现在使用备用母版页母版页显示 ![内容页](specifying-the-master-page-programmatically-cs/_static/image20.png)](specifying-the-master-page-programmatically-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="a9031-281">[![Content Pages are Now Displayed Using the Alternate.master Master Page](specifying-the-master-page-programmatically-cs/_static/image20.png)](specifying-the-master-page-programmatically-cs/_static/image19.png)</span></span>

<span data-ttu-id="a9031-282">**图 07**：现在使用 "`Alternate.master`" 母版页显示内容页面（[单击查看完全大小的图像](specifying-the-master-page-programmatically-cs/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="a9031-282">**Figure 07**: Content Pages are Now Displayed Using the `Alternate.master` Master Page ([Click to view full-size image](specifying-the-master-page-programmatically-cs/_static/image21.png))</span></span>

## <a name="summary"></a><span data-ttu-id="a9031-283">总结</span><span class="sxs-lookup"><span data-stu-id="a9031-283">Summary</span></span>

<span data-ttu-id="a9031-284">访问内容页时，其内容控件与母版页的 ContentPlaceHolder 控件一起融合。</span><span class="sxs-lookup"><span data-stu-id="a9031-284">When a content page is visited, its Content controls are fused with its master page's ContentPlaceHolder controls.</span></span> <span data-ttu-id="a9031-285">内容页的母版页由 `Page` 类的 `MasterPageFile` 属性表示，该属性在初始化阶段分配给 `@Page` 指令的 `MasterPageFile` 特性。</span><span class="sxs-lookup"><span data-stu-id="a9031-285">The content page's master page is denoted by the `Page` class's `MasterPageFile` property, which is assigned to the `@Page` directive's `MasterPageFile` attribute during the Initialization stage.</span></span> <span data-ttu-id="a9031-286">在本教程中，我们可以为 `MasterPageFile` 属性分配一个值，前提是在 PreInit 阶段结束之前执行此操作。</span><span class="sxs-lookup"><span data-stu-id="a9031-286">As this tutorial showed, we can assign a value to the `MasterPageFile` property as long as we do so before the end of the PreInit stage.</span></span> <span data-ttu-id="a9031-287">如果能够以编程方式指定母版页，则会为更高级的方案打开门，如根据外部因素动态地将内容页绑定到母版页。</span><span class="sxs-lookup"><span data-stu-id="a9031-287">Being able to programmatically specify the master page opens the door for more advanced scenarios, such as dynamically binding a content page to a master page based on external factors.</span></span>

<span data-ttu-id="a9031-288">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="a9031-288">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="a9031-289">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="a9031-289">Further Reading</span></span>

<span data-ttu-id="a9031-290">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="a9031-290">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="a9031-291">ASP.NET 页生命周期关系图</span><span class="sxs-lookup"><span data-stu-id="a9031-291">ASP.NET Page Lifecycle Diagram</span></span>](http://emanish.googlepages.com/Asp.Net2.0Lifecycle.PNG)
- [<span data-ttu-id="a9031-292">ASP.NET 页生命周期概述</span><span class="sxs-lookup"><span data-stu-id="a9031-292">ASP.NET Page Lifecycle Overview</span></span>](https://msdn.microsoft.com/library/ms178472.aspx)
- [<span data-ttu-id="a9031-293">ASP.NET 主题和外观概述</span><span class="sxs-lookup"><span data-stu-id="a9031-293">ASP.NET Themes and Skins Overview</span></span>](https://msdn.microsoft.com/library/ykzx33wh.aspx)
- [<span data-ttu-id="a9031-294">母版页：提示、技巧和陷阱</span><span class="sxs-lookup"><span data-stu-id="a9031-294">Master Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="a9031-295">ASP.NET 中的主题</span><span class="sxs-lookup"><span data-stu-id="a9031-295">Themes in ASP.NET</span></span>](http://www.odetocode.com/articles/423.aspx)

### <a name="about-the-author"></a><span data-ttu-id="a9031-296">关于作者</span><span class="sxs-lookup"><span data-stu-id="a9031-296">About the Author</span></span>

<span data-ttu-id="a9031-297">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的多个 ASP/asp 和4GuysFromRolla.com 的作者已使用 Microsoft Web 技术，1998。</span><span class="sxs-lookup"><span data-stu-id="a9031-297">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="a9031-298">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="a9031-298">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="a9031-299">他的最新书籍是，[*在24小时内，sam ASP.NET 3.5*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="a9031-299">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco).</span></span> <span data-ttu-id="a9031-300">可以通过[http://ScottOnWriting.NET](http://scottonwriting.net/) [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)或通过他的博客访问 Scott。</span><span class="sxs-lookup"><span data-stu-id="a9031-300">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="a9031-301">特别感谢</span><span class="sxs-lookup"><span data-stu-id="a9031-301">Special Thanks To</span></span>

<span data-ttu-id="a9031-302">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="a9031-302">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="a9031-303">本教程的主管审查人员是 Suchi Banerjee。</span><span class="sxs-lookup"><span data-stu-id="a9031-303">Lead reviewer for this tutorial was Suchi Banerjee.</span></span> <span data-ttu-id="a9031-304">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="a9031-304">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="a9031-305">如果是这样，请在[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="a9031-305">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="a9031-306">[上一页](master-pages-and-asp-net-ajax-cs.md)
> [下一页](nested-master-pages-cs.md)</span><span class="sxs-lookup"><span data-stu-id="a9031-306">[Previous](master-pages-and-asp-net-ajax-cs.md)
[Next](nested-master-pages-cs.md)</span></span>

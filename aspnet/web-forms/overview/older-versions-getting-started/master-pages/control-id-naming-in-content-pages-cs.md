---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
title: 内容页中的控件 ID 命名C#（） |Microsoft Docs
author: rick-anderson
description: 阐释 ContentPlaceHolder 控件如何充当命名容器，从而以编程方式处理控件（通过 FindControl） 。
ms.author: riande
ms.date: 06/10/2008
ms.assetid: 1c7d0916-0988-4b4f-9a03-935e4b5af6af
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-cs
msc.type: authoredcontent
ms.openlocfilehash: e849e5860dc988e112cc3a65d976c16ecdf77416
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74624368"
---
# <a name="control-id-naming-in-content-pages-c"></a><span data-ttu-id="d8116-103">内容页中的控件 ID 命名 (C#)</span><span class="sxs-lookup"><span data-stu-id="d8116-103">Control ID Naming in Content Pages (C#)</span></span>

<span data-ttu-id="d8116-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="d8116-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="d8116-105">[下载代码](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip)或[下载 PDF](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="d8116-105">[Download Code](https://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_CS.zip) or [Download PDF](https://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_CS.pdf)</span></span>

> <span data-ttu-id="d8116-106">阐释 ContentPlaceHolder 控件如何充当命名容器，从而以编程方式处理控件（通过 FindControl）。</span><span class="sxs-lookup"><span data-stu-id="d8116-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindControl).</span></span> <span data-ttu-id="d8116-107">查看此问题和解决方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="d8116-108">还介绍了如何以编程方式访问生成的 ClientID 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>

## <a name="introduction"></a><span data-ttu-id="d8116-109">简介</span><span class="sxs-lookup"><span data-stu-id="d8116-109">Introduction</span></span>

<span data-ttu-id="d8116-110">所有 ASP.NET 服务器控件都包含一个 `ID` 属性，该属性用于唯一标识控件，并且是在代码隐藏类中以编程方式访问控件的方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="d8116-111">同样，HTML 文档中的元素可能包含唯一标识该元素的 `id` 属性;这些 `id` 值通常在客户端脚本中使用，以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="d8116-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="d8116-112">为此，可以假设当 ASP.NET 服务器控件呈现为 HTML 时，其 `ID` 值将用作呈现的 HTML 元素的 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="d8116-113">这并不一定是因为在某些情况下，只有单个 `ID` 值的单个控件在呈现的标记中可能出现多次。</span><span class="sxs-lookup"><span data-stu-id="d8116-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="d8116-114">假设有一个 GridView 控件，该控件包含具有 `ID` 值为 ProductName 的标签 Web 控件的 TemplateField。</span><span class="sxs-lookup"><span data-stu-id="d8116-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of ProductName.</span></span> <span data-ttu-id="d8116-115">当 GridView 在运行时绑定到其数据源时，将为每个 GridView 行重复一次此标签。</span><span class="sxs-lookup"><span data-stu-id="d8116-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="d8116-116">每个呈现的标签都需要唯一的 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="d8116-117">为了应对这种情况，ASP.NET 允许将某些控件表示为命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="d8116-118">命名容器用作新的 `ID` 命名空间。</span><span class="sxs-lookup"><span data-stu-id="d8116-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="d8116-119">命名容器中显示的任何服务器控件都具有以命名容器控件 `ID` 为前缀 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="d8116-120">例如，`GridView` 和 `GridViewRow` 类都是命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="d8116-121">因此，在 GridView TemplateField 中定义的标签控件具有 `ID` ProductName，并为其提供 `GridViewID_GridViewRowID_ProductName`的呈现 `id` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-121">Consequently, a Label control defined in a GridView TemplateField with `ID` ProductName is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="d8116-122">因为*GridViewRowID*对于每个 GridView 行都是唯一的，所以生成的 `id` 值是唯一的。</span><span class="sxs-lookup"><span data-stu-id="d8116-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="d8116-123">[`INamingContainer` 接口](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx)用于指示特定的 ASP.NET 服务器控件应作为命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="d8116-124">`INamingContainer` 接口不会拼写服务器控件必须实现的任何方法;相反，它用作标记。</span><span class="sxs-lookup"><span data-stu-id="d8116-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="d8116-125">在生成呈现的标记时，如果控件实现了此接口，则 ASP.NET 引擎会自动为其 `ID` 值加上其后代 "呈现 `id` 属性值。</span><span class="sxs-lookup"><span data-stu-id="d8116-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="d8116-126">步骤2中更详细地讨论了此过程。</span><span class="sxs-lookup"><span data-stu-id="d8116-126">This process is discussed in more detail in Step 2.</span></span>

<span data-ttu-id="d8116-127">命名容器不仅会更改呈现的 `id` 属性值，还会影响从 ASP.NET 页的代码隐藏类以编程方式引用控件的方式。</span><span class="sxs-lookup"><span data-stu-id="d8116-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="d8116-128">`FindControl("controlID")` 方法通常用于以编程方式引用 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="d8116-129">但 `FindControl` 不会穿透命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="d8116-130">因此，不能直接使用 `Page.FindControl` 方法来引用 GridView 或其他命名容器中的控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="d8116-131">您可能有猜出，母版页和 Contentplaceholder 都是作为命名容器实现的。</span><span class="sxs-lookup"><span data-stu-id="d8116-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="d8116-132">在本教程中，我们将探讨母版页如何影响 HTML 元素 `id` 值和使用 `FindControl`以编程方式在内容页中引用 Web 控件的方式。</span><span class="sxs-lookup"><span data-stu-id="d8116-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="d8116-133">步骤1：添加新的 ASP.NET 页面</span><span class="sxs-lookup"><span data-stu-id="d8116-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="d8116-134">为了演示本教程中讨论的概念，我们将新的 ASP.NET 页面添加到我们的网站中。</span><span class="sxs-lookup"><span data-stu-id="d8116-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="d8116-135">在根文件夹中创建名为 `IDIssues.aspx` 的新内容页，将其绑定到 `Site.master` 的母版页。</span><span class="sxs-lookup"><span data-stu-id="d8116-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>

![将内容页 IDIssues 添加到根文件夹](control-id-naming-in-content-pages-cs/_static/image1.png)

<span data-ttu-id="d8116-137">**图 01**：将 "内容" 页 `IDIssues.aspx` 添加到根文件夹</span><span class="sxs-lookup"><span data-stu-id="d8116-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>

<span data-ttu-id="d8116-138">Visual Studio 会自动为母版页的四个 Contentplaceholder 创建一个内容控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="d8116-139">如[*多 contentplaceholder 和默认内容*](multiple-contentplaceholders-and-default-content-cs.md)教程中所述，如果内容控件不存在，则改为发出母版页的默认 ContentPlaceHolder 内容。</span><span class="sxs-lookup"><span data-stu-id="d8116-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-cs.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="d8116-140">由于 `QuickLoginUI` 和 `LeftColumnContent` Contentplaceholder 包含此页的适当默认标记，请继续从 `IDIssues.aspx`中删除其相应的内容控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="d8116-141">此时，内容页的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="d8116-141">At this point, the content page's declarative markup should look like the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample1.aspx)]

<span data-ttu-id="d8116-142">在母版页教程的 "[*指定标题、Meta 标记和其他 HTML 标头*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md)" 中，我们创建了一个自定义的基本页类（`BasePage`），如果未显式设置该页面的标题，则会自动对其进行配置。</span><span class="sxs-lookup"><span data-stu-id="d8116-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-cs.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="d8116-143">为了使 `IDIssues.aspx` 页使用此功能，页的代码隐藏类必须从 `BasePage` 类（而不是 `System.Web.UI.Page`）派生。</span><span class="sxs-lookup"><span data-stu-id="d8116-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="d8116-144">修改代码隐藏类的定义，使其类似于以下内容：</span><span class="sxs-lookup"><span data-stu-id="d8116-144">Modify the code-behind class's definition so that it looks like the following:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample2.cs)]

<span data-ttu-id="d8116-145">最后，更新 `Web.sitemap` 文件以包含此新课程的条目。</span><span class="sxs-lookup"><span data-stu-id="d8116-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="d8116-146">添加一个 `<siteMapNode>` 元素，并将其 `title` 和 `url` 属性分别设置为 "控制 ID 命名问题" 和 `~/IDIssues.aspx`。</span><span class="sxs-lookup"><span data-stu-id="d8116-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="d8116-147">完成此添加后，`Web.sitemap` 文件的标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="d8116-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>

[!code-xml[Main](control-id-naming-in-content-pages-cs/samples/sample3.xml)]

<span data-ttu-id="d8116-148">如图2所示，`Web.sitemap` 中的新网站地图条目会立即反映在左列的 "课程" 部分中。</span><span class="sxs-lookup"><span data-stu-id="d8116-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>

![课程部分现在包含指向 &quot;控件 ID 命名问题的链接&quot;](control-id-naming-in-content-pages-cs/_static/image2.png)

<span data-ttu-id="d8116-150">**图 02**：本课部分现在包含指向 "控件 ID 命名问题" 的链接</span><span class="sxs-lookup"><span data-stu-id="d8116-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>

## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="d8116-151">步骤2：检查呈现的`ID`更改</span><span class="sxs-lookup"><span data-stu-id="d8116-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="d8116-152">为了更好地了解 ASP.NET 引擎对呈现的 `id` 服务器控件的值所做的修改，请将一些 Web 控件添加到 `IDIssues.aspx` 页，然后查看发送到浏览器的呈现的标记。</span><span class="sxs-lookup"><span data-stu-id="d8116-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="d8116-153">具体而言，键入文本 "请输入年龄："，后跟 TextBox Web 控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="d8116-154">在页面上进一步向下添加按钮 Web 控件和标签 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="d8116-155">将文本框的 `ID` 和 `Columns` 属性分别设置为 `Age` 和3。</span><span class="sxs-lookup"><span data-stu-id="d8116-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="d8116-156">设置该按钮的 `Text`，并 `ID` 属性设置为 "Submit" 并 `SubmitButton`。</span><span class="sxs-lookup"><span data-stu-id="d8116-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="d8116-157">清除标签的 `Text` 属性，并将其 `ID` 设置为 "`Results`"。</span><span class="sxs-lookup"><span data-stu-id="d8116-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="d8116-158">此时，内容控件的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="d8116-158">At this point your Content control's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](control-id-naming-in-content-pages-cs/samples/sample4.aspx)]

<span data-ttu-id="d8116-159">图3显示了通过 Visual Studio 的设计器查看的页面。</span><span class="sxs-lookup"><span data-stu-id="d8116-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>

<span data-ttu-id="d8116-160">[![页面包含三个 Web 控件：文本框、按钮和标签](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="d8116-160">[![The Page Includes Three Web Controls: a TextBox, Button, and Label](control-id-naming-in-content-pages-cs/_static/image4.png)](control-id-naming-in-content-pages-cs/_static/image3.png)</span></span>

<span data-ttu-id="d8116-161">**图 03**：页面包含三个 Web 控件：文本框、按钮和标签（[单击以查看完全大小的图像](control-id-naming-in-content-pages-cs/_static/image5.png)）</span><span class="sxs-lookup"><span data-stu-id="d8116-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image5.png))</span></span>

<span data-ttu-id="d8116-162">通过浏览器访问页面，然后查看 HTML 源。</span><span class="sxs-lookup"><span data-stu-id="d8116-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="d8116-163">正如以下标记所示，文本框、按钮和标签 Web 控件的 HTML 元素 `id` 值是 Web 控件的 `ID` 值与页面中命名容器的 `ID` 值的组合。</span><span class="sxs-lookup"><span data-stu-id="d8116-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample5.html)]

<span data-ttu-id="d8116-164">如本教程前面所述，母版页及其 Contentplaceholder 作为命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="d8116-165">因此，这两个控件都提供其嵌套控件的呈现 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="d8116-166">采用 TextBox 的 `id` 属性，例如： `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="d8116-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="d8116-167">回忆一下 TextBox 控件的 `ID` 值是 `Age`的。</span><span class="sxs-lookup"><span data-stu-id="d8116-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="d8116-168">此值以其 ContentPlaceHolder 控件的 `ID` 值为前缀，`MainContent`。</span><span class="sxs-lookup"><span data-stu-id="d8116-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="d8116-169">此外，此值以母版页的 `ID` 值为前缀，`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="d8116-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="d8116-170">净效果是由母版页、ContentPlaceHolder 控件和文本框本身的 `ID` 值组成 `id` 属性值。</span><span class="sxs-lookup"><span data-stu-id="d8116-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="d8116-171">图4说明了此行为。</span><span class="sxs-lookup"><span data-stu-id="d8116-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="d8116-172">若要确定 `Age` 文本框的呈现的 `id`，请从 TextBox 控件的 `ID` 值开始，`Age`。</span><span class="sxs-lookup"><span data-stu-id="d8116-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="d8116-173">接下来，按照控件层次结构向上操作。</span><span class="sxs-lookup"><span data-stu-id="d8116-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="d8116-174">在每个命名容器（具有粉颜色的节点）上，使用命名容器的 `id`作为当前呈现的 `id` 的前缀。</span><span class="sxs-lookup"><span data-stu-id="d8116-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>

![呈现的 id 属性基于命名容器的 ID 值](control-id-naming-in-content-pages-cs/_static/image6.png)

<span data-ttu-id="d8116-176">**图 04**：呈现的 `id` 属性基于命名容器的 `ID` 值</span><span class="sxs-lookup"><span data-stu-id="d8116-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>

> [!NOTE]
> <span data-ttu-id="d8116-177">如前文所述，呈现 `id` 属性的 `ctl00` 部分构成了母版页的 `ID` 值，但你可能想知道此 `ID` 值是如何产生的。</span><span class="sxs-lookup"><span data-stu-id="d8116-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="d8116-178">我们未在主页面或内容页中的任何位置指定它。</span><span class="sxs-lookup"><span data-stu-id="d8116-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="d8116-179">在 ASP.NET 页中，大多数服务器控件都是通过页的声明性标记显式添加的。</span><span class="sxs-lookup"><span data-stu-id="d8116-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="d8116-180">已在 `Site.master`的标记中显式指定 `MainContent` ContentPlaceHolder 控件;`Age` TextBox `IDIssues.aspx`的标记定义。</span><span class="sxs-lookup"><span data-stu-id="d8116-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="d8116-181">可以通过属性窗口或声明性语法指定这些类型的控件的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="d8116-182">其他控件（如母版页本身）未在声明性标记中定义。</span><span class="sxs-lookup"><span data-stu-id="d8116-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="d8116-183">因此，必须为我们自动生成其 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="d8116-184">ASP.NET 引擎在运行时为尚未显式设置 Id 的控件设置 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="d8116-185">它使用命名模式 `ctlXX`，其中*XX*是按顺序递增的整数值。</span><span class="sxs-lookup"><span data-stu-id="d8116-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>

<span data-ttu-id="d8116-186">由于母版页本身用作命名容器，因此在母版页中定义的 Web 控件也会改变 `id` 属性值。</span><span class="sxs-lookup"><span data-stu-id="d8116-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="d8116-187">例如，在 "[*使用母版页创建站点范围布局*](creating-a-site-wide-layout-using-master-pages-cs.md)" 教程中添加到母版页的 `DisplayDate` 标签包含以下呈现的标记：</span><span class="sxs-lookup"><span data-stu-id="d8116-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-cs.md) tutorial has the following rendered markup:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample6.html)]

<span data-ttu-id="d8116-188">请注意，`id` 属性包括母版页的 `ID` 值（`ctl00`）和标签 Web 控件的 `ID` 值（`DateDisplay`）。</span><span class="sxs-lookup"><span data-stu-id="d8116-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="d8116-189">步骤3：通过`FindControl` 以编程方式引用 Web 控件</span><span class="sxs-lookup"><span data-stu-id="d8116-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="d8116-190">每个 ASP.NET 服务器控件都包含一个 `FindControl("controlID")` 方法，该方法在控件的后代中搜索名为*controlID*的控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="d8116-191">如果找到此类控件，则返回它;如果未找到匹配的控件，`FindControl` 将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="d8116-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `null`.</span></span>

<span data-ttu-id="d8116-192">`FindControl` 在需要访问控件但没有对其进行直接引用的情况下很有用。</span><span class="sxs-lookup"><span data-stu-id="d8116-192">`FindControl` is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="d8116-193">例如，在使用诸如 GridView 这样的数据 Web 控件时，GridView 字段内的控件在声明性语法中定义一次，但在运行时，将为每个 GridView 行创建一个控件的实例。</span><span class="sxs-lookup"><span data-stu-id="d8116-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="d8116-194">因此，在运行时生成的控件存在，但不能通过代码隐藏类提供直接引用。</span><span class="sxs-lookup"><span data-stu-id="d8116-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="d8116-195">因此，需要使用 `FindControl` 以编程方式处理 GridView 字段中的特定控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="d8116-196">（有关使用 `FindControl` 访问数据 Web 控件的模板中的控件的详细信息，请参阅[基于数据的自定义格式设置](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md)。）将 Web 控件动态添加到 Web 窗体时，会出现这种情况，这是在[创建动态数据条目用户界面](https://msdn.microsoft.com/library/aa479330.aspx)中讨论的主题。</span><span class="sxs-lookup"><span data-stu-id="d8116-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-cs.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="d8116-197">为了说明如何使用 `FindControl` 方法在内容页中搜索控件，请为 `SubmitButton`的 `Click` 事件创建事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="d8116-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="d8116-198">在事件处理程序中，添加以下代码，该代码以编程方式引用 `Age` TextBox 并使用 `FindControl` 方法 `Results` 标签，然后基于用户输入在 `Results` 中显示消息。</span><span class="sxs-lookup"><span data-stu-id="d8116-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="d8116-199">当然，在此示例中，我们不需要使用 `FindControl` 引用 "标签" 和 "TextBox" 控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="d8116-200">我们可以通过其 `ID` 属性值直接引用它们。</span><span class="sxs-lookup"><span data-stu-id="d8116-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="d8116-201">我使用这里 `FindControl` 来说明从内容页中 `FindControl` 时所发生的情况。</span><span class="sxs-lookup"><span data-stu-id="d8116-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample7.cs)]

<span data-ttu-id="d8116-202">尽管用于调用 `FindControl` 方法的语法在 `SubmitButton_Click`的前两行中略有不同，但它们在语义上是等效的。</span><span class="sxs-lookup"><span data-stu-id="d8116-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="d8116-203">回忆一下，所有 ASP.NET 服务器控件都包含一个 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="d8116-204">这包括 `Page` 类，所有 ASP.NET 代码隐藏类都必须从该类派生。</span><span class="sxs-lookup"><span data-stu-id="d8116-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="d8116-205">因此，调用 `FindControl("controlID")` 等效于调用 `Page.FindControl("controlID")`，假设你未在代码隐藏类或自定义基类中重写 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="d8116-206">输入此代码后，请通过浏览器访问 `IDIssues.aspx` 页面，输入你的年龄，并单击 "提交" 按钮。</span><span class="sxs-lookup"><span data-stu-id="d8116-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="d8116-207">单击 "提交" 按钮时，会引发 `NullReferenceException` （请参阅图5）。</span><span class="sxs-lookup"><span data-stu-id="d8116-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>

<span data-ttu-id="d8116-208">[![引发 NullReferenceException](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="d8116-208">[![A NullReferenceException is Raised](control-id-naming-in-content-pages-cs/_static/image8.png)](control-id-naming-in-content-pages-cs/_static/image7.png)</span></span>

<span data-ttu-id="d8116-209">**图 05**：引发 `NullReferenceException` （[单击查看完全大小的图像](control-id-naming-in-content-pages-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="d8116-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image9.png))</span></span>

<span data-ttu-id="d8116-210">如果在 `SubmitButton_Click` 事件处理程序中设置断点，则会看到对 `FindControl` 的两次调用返回 `null` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return a `null` value.</span></span> <span data-ttu-id="d8116-211">尝试访问 `Age` 文本框的 `Text` 属性时，将引发 `NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="d8116-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="d8116-212">问题在于 `Control.FindControl` 仅搜索*控件* *在相同命名容器中*的后代。</span><span class="sxs-lookup"><span data-stu-id="d8116-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are *in the same naming container*.</span></span> <span data-ttu-id="d8116-213">由于母版页构成新的命名容器，因此对 `Page.FindControl("controlID")` 的调用永远不会将母版页对象 `ctl00`permeates。</span><span class="sxs-lookup"><span data-stu-id="d8116-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="d8116-214">（请返回到图4以查看控件层次结构，该层次结构显示 `Page` 对象作为母版页对象的父级 `ctl00`。）因此，找不到 "`Results` 标签" 和 "`Age`" 文本框，`ResultsLabel` 和 `AgeTextBox` 分配的值为 `null`。</span><span class="sxs-lookup"><span data-stu-id="d8116-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `null`.</span></span>

<span data-ttu-id="d8116-215">此挑战有两种解决方法：我们可以向下钻取一个命名容器，一次向适当的控制;也可以创建 permeates 命名容器的自己的 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="d8116-216">我们来看一下其中的每个选项。</span><span class="sxs-lookup"><span data-stu-id="d8116-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="d8116-217">深入了解适当的命名容器</span><span class="sxs-lookup"><span data-stu-id="d8116-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="d8116-218">若要使用 `FindControl` 引用 "`Results` 标签" 或 "`Age`" 文本框，需要从同一命名容器中的祖先控件调用 `FindControl`。</span><span class="sxs-lookup"><span data-stu-id="d8116-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="d8116-219">如图4所示，`MainContent` ContentPlaceHolder 控件是同一命名容器中 `Results` 或 `Age` 的唯一上级。</span><span class="sxs-lookup"><span data-stu-id="d8116-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="d8116-220">换言之，从 `MainContent` 控件调用 `FindControl` 方法（如下面的代码段所示）正确返回对 `Results` 或 `Age` 控件的引用。</span><span class="sxs-lookup"><span data-stu-id="d8116-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample8.cs)]

<span data-ttu-id="d8116-221">但是，我们无法使用上述语法通过内容页的代码隐藏类处理 `MainContent` ContentPlaceHolder，因为 ContentPlaceHolder 是在母版页中定义的。</span><span class="sxs-lookup"><span data-stu-id="d8116-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="d8116-222">相反，我们必须使用 `FindControl` 获取对 `MainContent`的引用。</span><span class="sxs-lookup"><span data-stu-id="d8116-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="d8116-223">将 `SubmitButton_Click` 事件处理程序中的代码替换为以下修改：</span><span class="sxs-lookup"><span data-stu-id="d8116-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample9.cs)]

<span data-ttu-id="d8116-224">如果通过浏览器访问此页，请输入你的年龄，然后单击 "提交" 按钮，将会引发 `NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="d8116-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="d8116-225">如果在 `SubmitButton_Click` 事件处理程序中设置了断点，则在尝试调用 `MainContent` 对象的 `FindControl` 方法时，会出现此异常。</span><span class="sxs-lookup"><span data-stu-id="d8116-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="d8116-226">`MainContent` 对象 `null`，因为 `FindControl` 方法无法找到名为 "MainContent" 的对象。</span><span class="sxs-lookup"><span data-stu-id="d8116-226">The `MainContent` object is `null` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="d8116-227">基本原因与 "`Results` 标签" 和 "`Age`" 文本框控件相同： `FindControl` 从控件层次结构的顶部开始搜索，但不渗透命名容器，但 `MainContent` ContentPlaceHolder 在母版页中，这是一个命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="d8116-228">在可以使用 `FindControl` 获取对 `MainContent`的引用之前，首先需要引用母版页控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="d8116-229">引用母版页后，我们可以通过 `FindControl` 并从那里获取对该 `MainContent` ContentPlaceHolder 的引用，`Results` 标签和 `Age` 文本框的引用（同样，通过使用 `FindControl`）。</span><span class="sxs-lookup"><span data-stu-id="d8116-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="d8116-230">但如何获取对母版页的引用？</span><span class="sxs-lookup"><span data-stu-id="d8116-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="d8116-231">通过检查呈现的标记中的 `id` 属性，可明显地 `ctl00`母版页的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="d8116-232">因此，我们可以使用 `Page.FindControl("ctl00")` 获取对母版页的引用，然后使用该对象获取对 `MainContent`等的引用。</span><span class="sxs-lookup"><span data-stu-id="d8116-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="d8116-233">以下代码片段演示了此逻辑：</span><span class="sxs-lookup"><span data-stu-id="d8116-233">The following snippet illustrates this logic:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample10.cs)]

<span data-ttu-id="d8116-234">尽管此代码当然会起作用，但它假定母版页的自动生成 `ID` 将始终 `ctl00`。</span><span class="sxs-lookup"><span data-stu-id="d8116-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="d8116-235">最好是对自动生成的值作出假设。</span><span class="sxs-lookup"><span data-stu-id="d8116-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="d8116-236">幸运的是，可以通过 `Page` 类的 `Master` 属性访问母版页的引用。</span><span class="sxs-lookup"><span data-stu-id="d8116-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="d8116-237">因此，可以改为使用 `Page.Master.FindControl("MainContent")`，而不必使用 `FindControl("ctl00")` 获取母版页的引用以访问 `MainContent` ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="d8116-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="d8116-238">用以下代码更新 `SubmitButton_Click` 事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="d8116-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample11.cs)]

<span data-ttu-id="d8116-239">这次，通过浏览器访问页面，输入年龄，然后单击 "提交" 按钮时，会按预期方式在 `Results` 标签中显示邮件。</span><span class="sxs-lookup"><span data-stu-id="d8116-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>

<span data-ttu-id="d8116-240">[在标签中显示用户的年龄 ![](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="d8116-240">[![The User's Age is Displayed in the Label](control-id-naming-in-content-pages-cs/_static/image11.png)](control-id-naming-in-content-pages-cs/_static/image10.png)</span></span>

<span data-ttu-id="d8116-241">**图 06**：用户的年龄显示在标签中（[单击查看完全大小的图像](control-id-naming-in-content-pages-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="d8116-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image12.png))</span></span>

### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="d8116-242">通过命名容器递归搜索</span><span class="sxs-lookup"><span data-stu-id="d8116-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="d8116-243">前面的代码示例从母版页引用 `MainContent` ContentPlaceHolder 控件，然后从 `MainContent`中 `Results` 标签和 `Age` TextBox 控件，这是因为 `Control.FindControl` 方法只搜索*控件*的命名容器中的控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="d8116-244">在大多数情况下，使 `FindControl` 停留在命名容器内非常有用，因为两个不同命名容器中的两个控件可能具有相同的 `ID` 值。</span><span class="sxs-lookup"><span data-stu-id="d8116-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="d8116-245">请考虑在其一个 Templatefield 中定义名为 `ProductName` 的标签 Web 控件的 GridView 的情况。</span><span class="sxs-lookup"><span data-stu-id="d8116-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="d8116-246">当数据在运行时绑定到 GridView 时，将为每个 GridView 行创建一个 `ProductName` 标签。</span><span class="sxs-lookup"><span data-stu-id="d8116-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="d8116-247">如果 `FindControl` 搜索所有命名容器，并且我们调用了 `Page.FindControl("ProductName")`，则 `FindControl` 会返回哪些标签实例？</span><span class="sxs-lookup"><span data-stu-id="d8116-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="d8116-248">第一个 GridView 行中的 `ProductName` 标签？</span><span class="sxs-lookup"><span data-stu-id="d8116-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="d8116-249">最后一行中的值是多少？</span><span class="sxs-lookup"><span data-stu-id="d8116-249">The one in the last row?</span></span>

<span data-ttu-id="d8116-250">因此，在大多数情况下，只需 `Control.FindControl` 搜索*控件*的命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="d8116-251">但还有其他一些案例，例如一个面向我们的情况，在这种情况下，我们在所有命名容器中都有唯一的 `ID`，并希望避免精心引用控件层次结构中的每个命名容器以访问控件。</span><span class="sxs-lookup"><span data-stu-id="d8116-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="d8116-252">具有递归搜索所有命名容器的 `FindControl` 变体也是有意义的。</span><span class="sxs-lookup"><span data-stu-id="d8116-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="d8116-253">遗憾的是，.NET Framework 不包含这种方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="d8116-254">好消息是，我们可以创建自己的 `FindControl` 方法，以递归方式搜索所有命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="d8116-255">事实上，使用*扩展方法*时，我们可以将 `FindControlRecursive` 方法追加到 `Control` 类，以伴随其现有 `FindControl` 方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="d8116-256">扩展方法是C# 3.0 和 Visual Basic 9 的新增功能，这是 .NET Framework 版本3.5 和 Visual Studio 2008 附带的语言。</span><span class="sxs-lookup"><span data-stu-id="d8116-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="d8116-257">简而言之，扩展方法允许开发人员通过特殊语法为现有类类型创建新方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="d8116-258">有关这项有用功能的详细信息，请参阅我[的文章通过扩展方法扩展基类型功能](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)。</span><span class="sxs-lookup"><span data-stu-id="d8116-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>

<span data-ttu-id="d8116-259">若要创建扩展方法，请将新文件添加到名为 `PageExtensionMethods.cs`的 `App_Code` 文件夹。</span><span class="sxs-lookup"><span data-stu-id="d8116-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.cs`.</span></span> <span data-ttu-id="d8116-260">添加一个名为 `FindControlRecursive` 的扩展方法，该方法采用名为 `controlID`的 `string` 参数作为输入。</span><span class="sxs-lookup"><span data-stu-id="d8116-260">Add an extension method named `FindControlRecursive` that takes as an input a `string` parameter named `controlID`.</span></span> <span data-ttu-id="d8116-261">要使扩展方法正常工作，必须将类本身及其扩展方法标记 `static`。</span><span class="sxs-lookup"><span data-stu-id="d8116-261">For extension methods to work properly, it is vital that the class itself and its extension methods be marked `static`.</span></span> <span data-ttu-id="d8116-262">此外，所有扩展方法都必须接受扩展方法应用于的类型的对象作为其第一个参数，且此输入参数前面必须带有关键字 `this`。</span><span class="sxs-lookup"><span data-stu-id="d8116-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies, and this input parameter must be preceded with the keyword `this`.</span></span>

<span data-ttu-id="d8116-263">将以下代码添加到 `PageExtensionMethods.cs` 类文件中，以定义此类和 `FindControlRecursive` 扩展方法：</span><span class="sxs-lookup"><span data-stu-id="d8116-263">Add the following code to the `PageExtensionMethods.cs` class file to define this class and the `FindControlRecursive` extension method:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample12.cs)]

<span data-ttu-id="d8116-264">将此代码放置后，返回到 `IDIssues.aspx` 页的代码隐藏类，并注释掉当前的 `FindControl` 方法调用。</span><span class="sxs-lookup"><span data-stu-id="d8116-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="d8116-265">将它们替换为对 `Page.FindControlRecursive("controlID")`的调用。</span><span class="sxs-lookup"><span data-stu-id="d8116-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="d8116-266">扩展方法的含义是直接显示在 IntelliSense 下拉列表中。</span><span class="sxs-lookup"><span data-stu-id="d8116-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="d8116-267">如图7所示，在键入 Page，然后点击 period 时，`FindControlRecursive` 方法与其他 `Control` 类方法一起包含在 IntelliSense 下拉下。</span><span class="sxs-lookup"><span data-stu-id="d8116-267">As Figure 7 shows, when you type Page and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>

<span data-ttu-id="d8116-268">[IntelliSense 下拉方式包含 ![扩展方法](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="d8116-268">[![Extension Methods are Included in the IntelliSense Drop-Downs](control-id-naming-in-content-pages-cs/_static/image14.png)](control-id-naming-in-content-pages-cs/_static/image13.png)</span></span>

<span data-ttu-id="d8116-269">**图 07**：扩展方法包含在 IntelliSense 下拉项中（[单击以查看完全大小的图像](control-id-naming-in-content-pages-cs/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="d8116-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-cs/_static/image15.png))</span></span>

<span data-ttu-id="d8116-270">在 `SubmitButton_Click` 事件处理程序中输入以下代码，然后通过访问该页面，输入你的年龄，并单击 "提交" 按钮来对其进行测试。</span><span class="sxs-lookup"><span data-stu-id="d8116-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="d8116-271">如图6所示，生成的输出将为消息 "您的年龄段已过时！"</span><span class="sxs-lookup"><span data-stu-id="d8116-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample13.cs)]

> [!NOTE]
> <span data-ttu-id="d8116-272">因为扩展方法是C# 3.0 和 Visual Basic 9 的新手，所以如果使用的是 Visual Studio 2005，则不能使用扩展方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="d8116-273">相反，您需要在 helper 类中实现 `FindControlRecursive` 方法。</span><span class="sxs-lookup"><span data-stu-id="d8116-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="d8116-274">在他的博客文章中， [Rick Strahl](http://www.west-wind.com/WebLog/default.aspx)有此类示例， [ASP.NET 微波激射页和 `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)。</span><span class="sxs-lookup"><span data-stu-id="d8116-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>

## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="d8116-275">步骤4：在客户端脚本中使用正确的`id`属性值</span><span class="sxs-lookup"><span data-stu-id="d8116-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="d8116-276">如本教程中所述，通常在客户端脚本中使用 Web 控件的呈现 `id` 属性以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="d8116-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="d8116-277">例如，以下 JavaScript 通过其 `id` 引用 HTML 元素，然后在模式消息框中显示其值：</span><span class="sxs-lookup"><span data-stu-id="d8116-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>

[!code-csharp[Main](control-id-naming-in-content-pages-cs/samples/sample14.cs)]

<span data-ttu-id="d8116-278">请记住，在不包含命名容器的 ASP.NET 页面中，呈现的 HTML 元素的 `id` 属性与 Web 控件的 `ID` 属性值相同。</span><span class="sxs-lookup"><span data-stu-id="d8116-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="d8116-279">因此，很容易将属性值中的硬编码 `id` 为 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="d8116-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="d8116-280">也就是说，如果知道要通过客户端脚本访问 `Age` TextBox Web 控件，请通过调用 `document.getElementById("Age")`来执行此操作。</span><span class="sxs-lookup"><span data-stu-id="d8116-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="d8116-281">此方法的问题是，在使用母版页（或其他命名容器控件）时，呈现的 HTML `id` 与 Web 控件的 `ID` 属性不是同义词。</span><span class="sxs-lookup"><span data-stu-id="d8116-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="d8116-282">您的第一步可能是通过浏览器访问该页，并查看源以确定实际的 `id` 属性。</span><span class="sxs-lookup"><span data-stu-id="d8116-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="d8116-283">知道呈现的 `id` 值后，可以将其粘贴到对 `getElementById` 的调用中，以便访问通过客户端脚本所需的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="d8116-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="d8116-284">此方法小于理想方法，因为对页的控件层次结构的某些更改或对命名控件的 `ID` 属性的更改将更改生成的 `id` 属性，从而破坏 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="d8116-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="d8116-285">好消息是，呈现的 `id` 属性值可通过 Web 控件的[`ClientID` 属性](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx)在服务器端代码中访问。</span><span class="sxs-lookup"><span data-stu-id="d8116-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="d8116-286">应使用此属性来确定客户端脚本中使用的 `id` 属性值。</span><span class="sxs-lookup"><span data-stu-id="d8116-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="d8116-287">例如，若要向页面添加 JavaScript 函数（在调用时），则会在模式消息框中显示 "`Age`" 文本框的值，并将以下代码添加到 `Page_Load` 事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="d8116-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>

[!code-javascript[Main](control-id-naming-in-content-pages-cs/samples/sample15.js)]

<span data-ttu-id="d8116-288">上面的代码将 `Age` TextBox 的 ClientID 属性的值注入到 JavaScript 调用以 `getElementById`。</span><span class="sxs-lookup"><span data-stu-id="d8116-288">The above code injects the value of the `Age` TextBox's ClientID property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="d8116-289">如果通过浏览器访问此页并查看 HTML 源，会看到以下 JavaScript 代码：</span><span class="sxs-lookup"><span data-stu-id="d8116-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>

[!code-html[Main](control-id-naming-in-content-pages-cs/samples/sample16.html)]

<span data-ttu-id="d8116-290">请注意，正确的 `id` 属性值 `ctl00_MainContent_Age`会出现在对 `getElementById`的调用内。</span><span class="sxs-lookup"><span data-stu-id="d8116-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="d8116-291">由于此值是在运行时计算的，因此它的工作方式与对页面控件层次结构的后续更改无关。</span><span class="sxs-lookup"><span data-stu-id="d8116-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="d8116-292">此 JavaScript 示例只介绍如何添加正确引用服务器控件呈现的 HTML 元素的 JavaScript 函数。</span><span class="sxs-lookup"><span data-stu-id="d8116-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="d8116-293">若要使用此函数，需要创作额外的 JavaScript，以便在加载文档时或在特定的用户操作发生时调用该函数。</span><span class="sxs-lookup"><span data-stu-id="d8116-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="d8116-294">有关这些主题和相关主题的详细信息，请阅读使用[客户端脚本](https://msdn.microsoft.com/library/aa479302.aspx)。</span><span class="sxs-lookup"><span data-stu-id="d8116-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="d8116-295">总结</span><span class="sxs-lookup"><span data-stu-id="d8116-295">Summary</span></span>

<span data-ttu-id="d8116-296">某些 ASP.NET 服务器控件充当命名容器，它们会影响其子代控件的呈现 `id` 属性值，以及 `FindControl` 方法 canvassed 的控件的作用域。</span><span class="sxs-lookup"><span data-stu-id="d8116-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="d8116-297">对于母版页，母版页本身及其 ContentPlaceHolder 控件都是命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="d8116-298">因此，在使用 `FindControl`以编程方式引用内容页中的控件时，我们需要更多的工作。</span><span class="sxs-lookup"><span data-stu-id="d8116-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="d8116-299">在本教程中，我们介绍了两种方法：钻取到 ContentPlaceHolder 控件并调用其 `FindControl` 方法;并滚动我们自己的 `FindControl` 实现以递归方式搜索所有命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="d8116-300">除了引用 Web 控件的服务器端问题之外，还存在一些客户端问题。</span><span class="sxs-lookup"><span data-stu-id="d8116-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="d8116-301">在缺少命名容器的情况下，Web 控件的 `ID` 属性值和呈现 `id` 属性值都是相同的。</span><span class="sxs-lookup"><span data-stu-id="d8116-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="d8116-302">但在添加命名容器的情况下，呈现的 `id` 属性包括 Web 控件的 `ID` 值和控件层次结构的体系中的命名容器。</span><span class="sxs-lookup"><span data-stu-id="d8116-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="d8116-303">如果你使用 Web 控件的 `ClientID` 属性来确定客户端脚本中呈现的 `id` 属性值，则这些命名问题都是一个非问题。</span><span class="sxs-lookup"><span data-stu-id="d8116-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="d8116-304">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="d8116-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="d8116-305">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="d8116-305">Further Reading</span></span>

<span data-ttu-id="d8116-306">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="d8116-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="d8116-307">ASP.NET 母版页和 `FindControl`</span><span class="sxs-lookup"><span data-stu-id="d8116-307">ASP.NET Master Pages and `FindControl`</span></span>](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="d8116-308">创建动态数据条目用户界面</span><span class="sxs-lookup"><span data-stu-id="d8116-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="d8116-309">用扩展方法扩展基类型功能</span><span class="sxs-lookup"><span data-stu-id="d8116-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="d8116-310">如何：引用 ASP.NET 母版页内容</span><span class="sxs-lookup"><span data-stu-id="d8116-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="d8116-311">地主页面：提示、技巧和陷阱</span><span class="sxs-lookup"><span data-stu-id="d8116-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="d8116-312">使用客户端脚本</span><span class="sxs-lookup"><span data-stu-id="d8116-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="d8116-313">关于作者</span><span class="sxs-lookup"><span data-stu-id="d8116-313">About the Author</span></span>

<span data-ttu-id="d8116-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的多个 ASP/asp 和4GuysFromRolla.com 的作者已使用 Microsoft Web 技术，1998。</span><span class="sxs-lookup"><span data-stu-id="d8116-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="d8116-315">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="d8116-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="d8116-316">他的最新书籍是，[*在24小时内，sam ASP.NET 3.5*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="d8116-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="d8116-317">可以通过[http://ScottOnWriting.NET](http://scottonwriting.net/) [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)或通过他的博客访问 Scott。</span><span class="sxs-lookup"><span data-stu-id="d8116-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="d8116-318">特别感谢</span><span class="sxs-lookup"><span data-stu-id="d8116-318">Special Thanks To</span></span>

<span data-ttu-id="d8116-319">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="d8116-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="d8116-320">本教程的领导评审者是 Zack 的 Suchi Barnerjee。</span><span class="sxs-lookup"><span data-stu-id="d8116-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="d8116-321">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="d8116-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="d8116-322">如果是这样，请在[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)放置一行。</span><span class="sxs-lookup"><span data-stu-id="d8116-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="d8116-323">[上一页](urls-in-master-pages-cs.md)
> [下一页](interacting-with-the-master-page-from-the-content-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="d8116-323">[Previous](urls-in-master-pages-cs.md)
[Next](interacting-with-the-master-page-from-the-content-page-cs.md)</span></span>

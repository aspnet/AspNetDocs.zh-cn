---
uid: web-forms/overview/older-versions-getting-started/master-pages/nested-master-pages-cs
title: 嵌套的母版页（C#） |Microsoft Docs
author: rick-anderson
description: 演示如何将一个母版页嵌套在另一个母版页内。
ms.author: riande
ms.date: 07/28/2008
ms.assetid: 32b7fb6e-d74b-4048-91f8-70631b2523ee
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/nested-master-pages-cs
msc.type: authoredcontent
ms.openlocfilehash: 67093266567a97cd22b353115616484fd9ef155e
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74596475"
---
# <a name="nested-master-pages-c"></a><span data-ttu-id="1bea6-103">嵌套的母版页 (C#)</span><span class="sxs-lookup"><span data-stu-id="1bea6-103">Nested Master Pages (C#)</span></span>

<span data-ttu-id="1bea6-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="1bea6-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="1bea6-105">[下载代码](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_10_CS.zip)或[下载 PDF](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_10_CS.pdf)</span><span class="sxs-lookup"><span data-stu-id="1bea6-105">[Download Code](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_10_CS.zip) or [Download PDF](https://download.microsoft.com/download/d/6/6/d66ad554-afdd-409e-a5c3-201b774fbb31/ASPNET_MasterPages_Tutorial_10_CS.pdf)</span></span>

> <span data-ttu-id="1bea6-106">演示如何将一个母版页嵌套在另一个母版页内。</span><span class="sxs-lookup"><span data-stu-id="1bea6-106">Shows how to nest one master page within another.</span></span>

## <a name="introduction"></a><span data-ttu-id="1bea6-107">简介</span><span class="sxs-lookup"><span data-stu-id="1bea6-107">Introduction</span></span>

<span data-ttu-id="1bea6-108">在过去的九个教程中，我们了解了如何在母版页中实现站点范围的布局。</span><span class="sxs-lookup"><span data-stu-id="1bea6-108">Over the course of the past nine tutorials we have seen how to implement a site-wide layout with master pages.</span></span> <span data-ttu-id="1bea6-109">简而言之，母版页允许我们（页面开发人员）在母版页中定义常见标记，以及可以按内容页自定义的特定区域。</span><span class="sxs-lookup"><span data-stu-id="1bea6-109">In a nutshell, master pages allow us, the page developer, to define common markup in the master page along with specific regions that can be customized on a content page-by-content page basis.</span></span> <span data-ttu-id="1bea6-110">母版页中的 ContentPlaceHolder 控件表示可自定义的区域;ContentPlaceHolder 控件的自定义标记是通过内容控件在 "内容" 页中定义的。</span><span class="sxs-lookup"><span data-stu-id="1bea6-110">The ContentPlaceHolder controls in a master page indicate the customizable regions; the customized markup for the ContentPlaceHolder controls are defined in the content page via Content controls.</span></span>

<span data-ttu-id="1bea6-111">如果你在整个站点上使用单个布局，我们目前探索到的母版页技术非常好。</span><span class="sxs-lookup"><span data-stu-id="1bea6-111">The master page techniques we've explored thus far are great if you have a single layout used across the entire site.</span></span> <span data-ttu-id="1bea6-112">但是，许多大型网站都具有跨各个部分自定义的网站布局。</span><span class="sxs-lookup"><span data-stu-id="1bea6-112">However, many large websites have a site layout that is customized across various sections.</span></span> <span data-ttu-id="1bea6-113">例如，请考虑医院工作人员用来管理患者信息、活动和计费的卫生保健应用程序。</span><span class="sxs-lookup"><span data-stu-id="1bea6-113">For example, consider a health care application used by hospital staff to manage patient information, activities, and billing.</span></span> <span data-ttu-id="1bea6-114">在此应用程序中，可能有三种类型的网页：</span><span class="sxs-lookup"><span data-stu-id="1bea6-114">There may be three types of web pages in this application:</span></span>

- <span data-ttu-id="1bea6-115">员工特定的页面，其中教职员工成员可以更新可用性、查看计划或请求休假时间。</span><span class="sxs-lookup"><span data-stu-id="1bea6-115">Staff member-specific pages where staff members can update availability, view schedules, or request vacation time.</span></span>
- <span data-ttu-id="1bea6-116">患者特定的页面，其中的教职员工成员查看或编辑特定患者的信息。</span><span class="sxs-lookup"><span data-stu-id="1bea6-116">Patient-specific pages where staff members view or edit information for a specific patient.</span></span>
- <span data-ttu-id="1bea6-117">会计查看当前声明状态和财务报告的计费特定页面。</span><span class="sxs-lookup"><span data-stu-id="1bea6-117">Billing-specific pages where accountants review current claim statuses and financial reports.</span></span>

<span data-ttu-id="1bea6-118">每个页面都可能共用一个通用布局，例如，在顶部有一个菜单，一系列频繁使用的链接。</span><span class="sxs-lookup"><span data-stu-id="1bea6-118">Every page might share a common layout, such as a menu across the top and a series of frequently used links along the bottom.</span></span> <span data-ttu-id="1bea6-119">但工作人员、患者和计费特定页面可能需要自定义此通用布局。</span><span class="sxs-lookup"><span data-stu-id="1bea6-119">But the staff-, patient-, and billing-specific pages may need to customize this generic layout.</span></span> <span data-ttu-id="1bea6-120">例如，可能是所有员工特定的页面都应包括显示当前登录用户的可用性和每日计划的日历和任务列表。</span><span class="sxs-lookup"><span data-stu-id="1bea6-120">For example, perhaps all staff-specific pages should include a calendar and task list showing the currently logged on user's availability and daily schedule.</span></span> <span data-ttu-id="1bea6-121">可能所有特定于患者的页面都需要显示其信息正在编辑的患者的名称、地址和保险信息。</span><span class="sxs-lookup"><span data-stu-id="1bea6-121">Perhaps all patient-specific pages need to show the name, address, and insurance information for the patient whose information is being edited.</span></span>

<span data-ttu-id="1bea6-122">使用*嵌套的母版页*可以创建此类自定义的布局。</span><span class="sxs-lookup"><span data-stu-id="1bea6-122">It's possible to create such customized layouts by using *nested master pages*.</span></span> <span data-ttu-id="1bea6-123">为实现上述方案，我们首先创建一个母版页，其中定义了站点范围的布局、菜单和页脚内容，并使用 Contentplaceholder 定义了可自定义的区域。</span><span class="sxs-lookup"><span data-stu-id="1bea6-123">To implement the above scenario, we would start by creating a master page that defined the site-wide layout, the menu and footer content, with ContentPlaceHolders defining the customizable regions.</span></span> <span data-ttu-id="1bea6-124">接下来，我们将创建三个嵌套的母版页，每个页面都有一个。</span><span class="sxs-lookup"><span data-stu-id="1bea6-124">We would then create three nested master pages, one for each type of web page.</span></span> <span data-ttu-id="1bea6-125">每个嵌套母版页都将定义使用母版页的内容页类型中的内容。</span><span class="sxs-lookup"><span data-stu-id="1bea6-125">Each nested master page would define the content among the type of content pages that use the master page.</span></span> <span data-ttu-id="1bea6-126">换句话说，特定于患者的内容页的嵌套母版页包含标记和编程逻辑，以便显示有关要编辑的患者的信息。</span><span class="sxs-lookup"><span data-stu-id="1bea6-126">In other words, the nested master page for patient-specific content pages would include markup and programmatic logic for displaying information about the patient being edited.</span></span> <span data-ttu-id="1bea6-127">创建新的患者特定页面时，会将其绑定到此嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-127">When creating a new patient-specific page we would bind it to this nested master page.</span></span>

<span data-ttu-id="1bea6-128">本教程首先突出显示嵌套母版页的优点。</span><span class="sxs-lookup"><span data-stu-id="1bea6-128">This tutorial starts by highlighting the benefits of nested master pages.</span></span> <span data-ttu-id="1bea6-129">然后演示如何创建和使用嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-129">It then shows how to create and use nested master pages.</span></span>

> [!NOTE]
> <span data-ttu-id="1bea6-130">由于版本2.0 的 .NET Framework，因此可能会嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-130">Nested master pages have been possible since version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="1bea6-131">但是，Visual Studio 2005 未包括对嵌套母版页的设计时支持。</span><span class="sxs-lookup"><span data-stu-id="1bea6-131">However, Visual Studio 2005 did not include design-time support for nested master pages.</span></span> <span data-ttu-id="1bea6-132">好消息是，Visual Studio 2008 为嵌套母版页提供丰富的设计时体验。</span><span class="sxs-lookup"><span data-stu-id="1bea6-132">The good news is that Visual Studio 2008 offers a rich design-time experience for nested master pages.</span></span> <span data-ttu-id="1bea6-133">如果你有兴趣使用嵌套母版页，但仍在使用 Visual Studio 2005，请查看[Scott Guthrie](https://weblogs.asp.net/scottgu/)的博客文章，以及[在 VS 2005 设计时嵌套母版页的提示](https://weblogs.asp.net/scottgu/archive/2005/11/11/430382.aspx)。</span><span class="sxs-lookup"><span data-stu-id="1bea6-133">If you are interested in using nested master pages but are still using Visual Studio 2005, check out [Scott Guthrie](https://weblogs.asp.net/scottgu/)'s blog entry, [Tips for Nested Master Pages in VS 2005 Design-Time](https://weblogs.asp.net/scottgu/archive/2005/11/11/430382.aspx).</span></span>

## <a name="the-benefits-of-nested-master-pages"></a><span data-ttu-id="1bea6-134">嵌套母版页的优点</span><span class="sxs-lookup"><span data-stu-id="1bea6-134">The Benefits of Nested Master Pages</span></span>

<span data-ttu-id="1bea6-135">许多网站的网站设计和特定于某些类型的页面都有更多的自定义设计。</span><span class="sxs-lookup"><span data-stu-id="1bea6-135">Many websites have an overarching site design as well as more customized designs specific to certain types of pages.</span></span> <span data-ttu-id="1bea6-136">例如，在我们的演示 web 应用程序中，我们创建了一个基本的管理部分（`~/Admin` 文件夹中的页）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-136">For instance, in our demo web application we have created a rudimentary Administration section (the pages in the `~/Admin` folder).</span></span> <span data-ttu-id="1bea6-137">目前，`~/Admin` 文件夹中的网页使用的母版页与 "管理" 部分中的页面不相同（即 `Site.master` 或 `Alternate.master`，具体取决于用户的选择）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-137">Currently the web pages in the `~/Admin` folder use the same master page as those pages not in the administration section (namely, `Site.master` or `Alternate.master`, depending on the user's selection).</span></span>

> [!NOTE]
> <span data-ttu-id="1bea6-138">现在，假设我们的站点只包含一个母版页，`Site.master`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-138">For now, pretend that our site has just one master page, `Site.master`.</span></span> <span data-ttu-id="1bea6-139">我们将使用嵌套母版页，其中包含了在本教程后面的两个（或多个）母版页，以 "使用嵌套母版页作为管理部分"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-139">We'll address using nested master pages with two (or more) master pages starting with "Using a Nested Master Page for the Administration Section" later in this tutorial.</span></span>

<span data-ttu-id="1bea6-140">假设我们要求你自定义管理页面的布局，以包含其他信息或站点中其他页面不会出现的链接。</span><span class="sxs-lookup"><span data-stu-id="1bea6-140">Imagine that we were asked to customize the layout of the Administration pages to include additional information or links that would not otherwise be present in other pages in the site.</span></span> <span data-ttu-id="1bea6-141">实现此要求有四种方法：</span><span class="sxs-lookup"><span data-stu-id="1bea6-141">There are four techniques to implement this requirement:</span></span>

1. <span data-ttu-id="1bea6-142">手动添加特定于管理的信息并链接到 `~/Admin` 文件夹中的每个内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-142">Manually add the Administration-specific information and links to every content page in the `~/Admin` folder.</span></span>
2. <span data-ttu-id="1bea6-143">更新 `Site.master` 母版页，使其包含特定于管理部分的信息和链接，然后将代码添加到母版页，以根据是否访问某个管理页面来显示或隐藏这些部分。</span><span class="sxs-lookup"><span data-stu-id="1bea6-143">Update the `Site.master` master page to include the Administration section-specific information and links, and then add code to the master page to show or hide these sections based on whether one of the Administration pages is being visited.</span></span>
3. <span data-ttu-id="1bea6-144">为 "管理" 部分专门创建一个母版页，从 `Site.master`复制标记，添加特定于管理部分的信息和链接，然后更新 `~/Admin` 文件夹中的内容页以使用此新的母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-144">Create a new master page specifically for the Administration section, copy over the markup from `Site.master`, add the Administration section-specific information and links, and then update the content pages in the `~/Admin` folder to use this new master page.</span></span>
4. <span data-ttu-id="1bea6-145">创建一个绑定到 `Site.master` 的嵌套母版页，并使 `~/Admin` 文件夹中的内容页使用这一新的嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-145">Create a nested master page that binds to `Site.master` and have the content pages in the `~/Admin` folder use this new nested master page.</span></span> <span data-ttu-id="1bea6-146">此嵌套母版页只包含特定于 "管理" 页的附加信息和链接，并且不需要重复 `Site.master`中定义的标记。</span><span class="sxs-lookup"><span data-stu-id="1bea6-146">This nested master page would include just the additional information and links specific to the Administration pages and would not need to repeat the markup already defined in `Site.master`.</span></span>

<span data-ttu-id="1bea6-147">第一个选项是最小愉快。</span><span class="sxs-lookup"><span data-stu-id="1bea6-147">The first option is the least palatable.</span></span> <span data-ttu-id="1bea6-148">使用母版页的要点就是不需要将常见标记手动复制并粘贴到新的 ASP.NET 页面。</span><span class="sxs-lookup"><span data-stu-id="1bea6-148">The whole point of using master pages is to move away from having to manually copy and paste common markup to new ASP.NET pages.</span></span> <span data-ttu-id="1bea6-149">第二个选项是可接受的，但使应用程序的可维护性更低，因为它 bulks 仅偶尔显示的包含标记的母版页，并要求开发人员编辑母版页来处理此标记，并记住何时确切地说，特定标记是在隐藏时显示的。</span><span class="sxs-lookup"><span data-stu-id="1bea6-149">The second option is acceptable, but makes the application less maintainable as it bulks up the master pages with markup that is only occasionally displayed and requires developers editing the master page to work around this markup and to have to remember when, exactly, certain markup is displayed versus when it is hidden.</span></span> <span data-ttu-id="1bea6-150">这种方法不太 tenable，因为此母版页需要满足更多类型的网页的自定义。</span><span class="sxs-lookup"><span data-stu-id="1bea6-150">This approach would be less tenable as customizations from more and more types of web pages needed to be accommodated by this single master page.</span></span>

<span data-ttu-id="1bea6-151">第三个选项通过第二个选项删除出现的混乱和复杂性问题。</span><span class="sxs-lookup"><span data-stu-id="1bea6-151">The third option removes the clutter and complexity issues the surfaced with the second option.</span></span> <span data-ttu-id="1bea6-152">不过，第三种方法的主要缺点是，需要我们将通用布局从 `Site.master` 复制并粘贴到新的管理特定于区域的母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-152">However, option three's main drawback is that it requires us to copy and paste the common layout from `Site.master` to the new Administration section-specific master page.</span></span> <span data-ttu-id="1bea6-153">如果以后决定更改站点范围的布局，则必须记得在两个位置进行更改。</span><span class="sxs-lookup"><span data-stu-id="1bea6-153">If we later decide to change the site-wide layout we have to remember to change it in two places.</span></span>

<span data-ttu-id="1bea6-154">第四个选项（即嵌套母版页）为我们最大的第二个和第三个选项。</span><span class="sxs-lookup"><span data-stu-id="1bea6-154">The fourth option, nested master pages, give us the best of the second and third options.</span></span> <span data-ttu-id="1bea6-155">站点范围内的布局信息保留在一个文件中-顶级母版页，而特定区域特定区域的内容将被分为不同的文件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-155">The site-wide layout information is maintained in one file - the top-level master page - while the content specific to particular regions is separated out into different files.</span></span>

<span data-ttu-id="1bea6-156">本教程首先介绍如何创建和使用简单的嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-156">This tutorial starts with a look at creating and using a simple nested master page.</span></span> <span data-ttu-id="1bea6-157">我们创建了新的顶级母版页、两个嵌套母版页和两个内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-157">We create a brand new top-level master page, two nested master pages, and two content pages.</span></span> <span data-ttu-id="1bea6-158">从 "使用用于管理的嵌套母版页" 部分开始，我们将介绍如何更新现有的母版页体系结构以包括嵌套母版页的使用。</span><span class="sxs-lookup"><span data-stu-id="1bea6-158">Starting with "Using a Nested Master Page for the Administration Section," we look at updating our existing master page architecture to include the use of nested master pages.</span></span> <span data-ttu-id="1bea6-159">具体而言，我们将创建一个嵌套的母版页，并使用它为 `~/Admin` 文件夹中的内容页包含其他自定义内容。</span><span class="sxs-lookup"><span data-stu-id="1bea6-159">Specifically, we create a nested master page and use it to include additional custom content for the content pages in the `~/Admin` folder.</span></span>

## <a name="step-1-creating-a-simple-top-level-master-page"></a><span data-ttu-id="1bea6-160">步骤1：创建简单的顶层母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-160">Step 1: Creating a Simple Top-Level Master Page</span></span>

<span data-ttu-id="1bea6-161">基于某个现有的母版页创建嵌套的主控形状，然后更新现有内容页以使用此新的嵌套母版页，而不是顶层母版页，因为现有的内容页已经需要某些内容页顶层母版页中定义的 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-161">Creating a nested master based on one of the existing master pages and then updating an existing content page to use this new nested master page instead of the top-level master page entails some complexity because the existing content pages already expect certain ContentPlaceHolder controls defined in the top-level master page.</span></span> <span data-ttu-id="1bea6-162">因此，嵌套母版页还必须包含具有相同名称的相同 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-162">Therefore, the nested master page must also include the same ContentPlaceHolder controls with the same names.</span></span> <span data-ttu-id="1bea6-163">而且，我们的特定演示应用程序有两个母版页（`Site.master` 和 `Alternate.master`），它们基于用户的首选项动态分配到内容页，这会进一步增加复杂性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-163">Furthermore, our particular demo application has two master pages (`Site.master` and `Alternate.master`) that are dynamically assigned to a content page based on a user's preferences, which further adds to this complexity.</span></span> <span data-ttu-id="1bea6-164">我们将在本教程的后面部分介绍如何更新现有应用程序以使用嵌套母版页，但我们首先要重点介绍简单的嵌套母版页示例。</span><span class="sxs-lookup"><span data-stu-id="1bea6-164">We will look at updating the existing application to use nested master pages later in this tutorial, but let's first focus on a simple nested master pages example.</span></span>

<span data-ttu-id="1bea6-165">创建名为 `NestedMasterPages` 的新文件夹，然后将新的母版页文件添加到名为 `Simple.master`的文件夹中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-165">Create a new folder named `NestedMasterPages` and then add a new master page file to that folder named `Simple.master`.</span></span> <span data-ttu-id="1bea6-166">（请参阅图1，了解在添加此文件夹和文件后解决方案资源管理器的屏幕截图。）将 `AlternateStyles.css` 样式表文件从解决方案资源管理器拖到设计器上。</span><span class="sxs-lookup"><span data-stu-id="1bea6-166">(See Figure 1 for a screen shot of the Solution Explorer after this folder and file have been added.) Drag the `AlternateStyles.css` style sheet file from the Solution Explorer onto the Designer.</span></span> <span data-ttu-id="1bea6-167">这会将 `<link>` 元素添加到 `<head>` 元素中的样式表文件中，之后母版页的 `<head>` 元素的标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-167">This adds a `<link>` element to the style sheet file in the `<head>` element, after which the master page's `<head>` element's markup should look like:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample1.aspx)]

<span data-ttu-id="1bea6-168">接下来，在 `Simple.master`的 Web 窗体中添加以下标记：</span><span class="sxs-lookup"><span data-stu-id="1bea6-168">Next, add the following markup within the Web Form of `Simple.master`:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample2.aspx)]

<span data-ttu-id="1bea6-169">此标记在页面顶部显示一个标题为 "嵌套母版页（Simple）" 的链接，在深蓝色背景上以大白色字体显示。</span><span class="sxs-lookup"><span data-stu-id="1bea6-169">This markup displays a link titled "Nested Master Pages (Simple)" at the top of the page in a large white font on a navy background.</span></span> <span data-ttu-id="1bea6-170">下面是 `MainContent` ContentPlaceHolder 的。</span><span class="sxs-lookup"><span data-stu-id="1bea6-170">Beneath that is the `MainContent` ContentPlaceHolder.</span></span> <span data-ttu-id="1bea6-171">图1显示了在 Visual Studio 设计器中加载时的 `Simple.master` 母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-171">Figure 1 shows the `Simple.master` master page when loaded in the Visual Studio Designer.</span></span>

<span data-ttu-id="1bea6-172">[![嵌套母版页会定义特定于 "管理" 部分页面的内容](nested-master-pages-cs/_static/image2.png)](nested-master-pages-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-172">[![The Nested Master Page Defines Content Specific to the Pages in the Administration Section](nested-master-pages-cs/_static/image2.png)](nested-master-pages-cs/_static/image1.png)</span></span>

<span data-ttu-id="1bea6-173">**图 01**：嵌套母版页定义特定于 "管理" 部分中的页面的内容（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-173">**Figure 01**: The Nested Master Page Defines Content Specific to the Pages in the Administration Section ([Click to view full-size image](nested-master-pages-cs/_static/image3.png))</span></span>

## <a name="step-2-creating-a-simple-nested-master-page"></a><span data-ttu-id="1bea6-174">步骤2：创建简单的嵌套母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-174">Step 2: Creating a Simple Nested Master Page</span></span>

<span data-ttu-id="1bea6-175">`Simple.master` 包含两个 ContentPlaceHolder 控件：在 Web 窗体中添加的 `MainContent` ContentPlaceHolder 和 `<head>` 元素中的 `head` ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="1bea6-175">`Simple.master` contains two ContentPlaceHolder controls: the `MainContent` ContentPlaceHolder we added within the Web Form along with the `head` ContentPlaceHolder in the `<head>` element.</span></span> <span data-ttu-id="1bea6-176">如果我们要创建内容页并将其绑定到 `Simple.master` 内容页将具有两个引用两个 Contentplaceholder 的内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-176">If we were to create a content page and bind it to `Simple.master` the content page would have two Content controls referencing the two ContentPlaceHolders.</span></span> <span data-ttu-id="1bea6-177">同样，如果创建嵌套母版页并将其绑定到 `Simple.master`，则嵌套的母版页将具有两个内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-177">Similarly, if we create a nested master page and bind it to `Simple.master` then the nested master page will have two Content controls.</span></span>

<span data-ttu-id="1bea6-178">让我们将新的嵌套母版页添加到名为 `SimpleNested.master`的 `NestedMasterPages` 文件夹。</span><span class="sxs-lookup"><span data-stu-id="1bea6-178">Let's add a new nested master page to the `NestedMasterPages` folder named `SimpleNested.master`.</span></span> <span data-ttu-id="1bea6-179">右键单击 "`NestedMasterPages`" 文件夹，然后选择 "添加新项"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-179">Right-click on the `NestedMasterPages` folder and choose Add New Item.</span></span> <span data-ttu-id="1bea6-180">此时将打开图2所示的 "添加新项" 对话框。</span><span class="sxs-lookup"><span data-stu-id="1bea6-180">This brings up the Add New Item dialog box shown in Figure 2.</span></span> <span data-ttu-id="1bea6-181">选择 "母版页" 模板类型，然后键入新的母版页的名称。</span><span class="sxs-lookup"><span data-stu-id="1bea6-181">Select the Master Page template type and type in the name of the new master page.</span></span> <span data-ttu-id="1bea6-182">若要指示新的母版页应为嵌套母版页，请选中 "选择母版页" 复选框。</span><span class="sxs-lookup"><span data-stu-id="1bea6-182">To indicate that the new master page should be a nested master page, check the "Select master page" checkbox.</span></span>

<span data-ttu-id="1bea6-183">接下来，单击 "添加" 按钮。</span><span class="sxs-lookup"><span data-stu-id="1bea6-183">Next, click the Add button.</span></span> <span data-ttu-id="1bea6-184">这会显示将内容页绑定到母版页时看到的相同的 "选择母版页" 对话框（请参阅图3）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-184">This will display the same Select a Master Page dialog box you see when binding a content page to a master page (see Figure 3).</span></span> <span data-ttu-id="1bea6-185">选择 `NestedMasterPages` 文件夹中的 `Simple.master` 母版页，然后单击 "确定"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-185">Choose the `Simple.master` master page in the `NestedMasterPages` folder and click OK.</span></span>

> [!NOTE]
> <span data-ttu-id="1bea6-186">如果你使用 Web 应用程序项目模型而不是网站项目模型创建了你的 ASP.NET 网站，则在图2所示的 "添加新项" 对话框中将看不到 "选择母版页" 复选框。</span><span class="sxs-lookup"><span data-stu-id="1bea6-186">If you created your ASP.NET website using the Web Application Project model instead of the Web Site Project model you will not see the "Select master page" checkbox in the Add New Item dialog box shown in Figure 2.</span></span> <span data-ttu-id="1bea6-187">若要在使用 Web 应用程序项目模型时创建嵌套母版页，必须选择嵌套母版页模板（而不是母版页模板）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-187">To create a nested master page when using the Web Application Project model you must choose the Nested Master Page template (instead of the Master Page template).</span></span> <span data-ttu-id="1bea6-188">选择嵌套的母版页模板并单击 "添加" 后，将显示图3中所示的 "选择母版页" 对话框。</span><span class="sxs-lookup"><span data-stu-id="1bea6-188">After selecting the Nested Master Page template and clicking Add, the same Select a Master Page dialog box shown in Figure 3 will appear.</span></span>

<span data-ttu-id="1bea6-189">[![选中 "&quot;选择母版页&quot;" 复选框添加嵌套母版页](nested-master-pages-cs/_static/image5.png)](nested-master-pages-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-189">[![Check the &quot;Select master page&quot; Checkbox to Add a Nested Master Page](nested-master-pages-cs/_static/image5.png)](nested-master-pages-cs/_static/image4.png)</span></span>

<span data-ttu-id="1bea6-190">**图 02**：选中 "选择母版页" 复选框以添加嵌套母版页（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-190">**Figure 02**: Check the "Select master page" Checkbox to Add a Nested Master Page ([Click to view full-size image](nested-master-pages-cs/_static/image6.png))</span></span>

<span data-ttu-id="1bea6-191">[![将嵌套母版页绑定到简单的母版页母版页](nested-master-pages-cs/_static/image8.png)](nested-master-pages-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-191">[![Bind the Nested Master Page to the Simple.master Master Page](nested-master-pages-cs/_static/image8.png)](nested-master-pages-cs/_static/image7.png)</span></span>

<span data-ttu-id="1bea6-192">**图 03**：将嵌套母版页绑定到 `Simple.master` 母版页（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-192">**Figure 03**: Bind the Nested Master Page to the `Simple.master` Master Page ([Click to view full-size image](nested-master-pages-cs/_static/image9.png))</span></span>

<span data-ttu-id="1bea6-193">嵌套母版页的声明性标记（如下所示）包含两个内容控件，它们引用顶层母版页的两个 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-193">The nested master page's declarative markup, shown below, contains two Content controls referencing the top-level master page's two ContentPlaceHolder controls.</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample3.aspx)]

<span data-ttu-id="1bea6-194">除 `<%@ Master %>` 指令外，嵌套母版页的初始声明性标记与将内容页绑定到相同顶级母版页时最初生成的标记相同。</span><span class="sxs-lookup"><span data-stu-id="1bea6-194">Except for the `<%@ Master %>` directive, the nested master page's initial declarative markup is identical to the markup that is initially generated when binding a content page to the same top-level master page.</span></span> <span data-ttu-id="1bea6-195">与内容页的 `<%@ Page %>` 指令一样，此处的 `<%@ Master %>` 指令包含一个指定嵌套母版页的父母版页的 `MasterPageFile` 特性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-195">Like a content page's `<%@ Page %>` directive, the `<%@ Master %>` directive here includes a `MasterPageFile` attribute that specifies the nested master page's parent master page.</span></span> <span data-ttu-id="1bea6-196">嵌套母版页和绑定到相同顶级母版页的内容页之间的主要区别在于，嵌套母版页可以包含 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-196">The main difference between the nested master page and a content page bound to the same top-level master page is that the nested master page can include ContentPlaceHolder controls.</span></span> <span data-ttu-id="1bea6-197">嵌套母版页的 ContentPlaceHolder 控件定义内容页可自定义标记的区域。</span><span class="sxs-lookup"><span data-stu-id="1bea6-197">The nested master page's ContentPlaceHolder controls define the regions where the content pages can customize the markup.</span></span>

<span data-ttu-id="1bea6-198">更新此嵌套母版页，使其显示文本 "Hello，from SimpleNested！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-198">Update this nested master page so that it displays the text "Hello, from SimpleNested!"</span></span> <span data-ttu-id="1bea6-199">在与 `MainContent` ContentPlaceHolder 控件相对应的内容控件中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-199">in the Content control that corresponds to the `MainContent` ContentPlaceHolder control.</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample4.aspx)]

<span data-ttu-id="1bea6-200">完成此添加后，保存嵌套的母版页，然后将新的内容页添加到名为 `Default.aspx``NestedMasterPages` 文件夹中，并将其绑定到 `SimpleNested.master` 母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-200">After making this addition, save the nested master page and then add a new content page to the `NestedMasterPages` folder named `Default.aspx`, and bind it to the `SimpleNested.master` master page.</span></span> <span data-ttu-id="1bea6-201">添加此页后，你可能会感到惊讶，因为它不包含任何内容控件（见图4）！</span><span class="sxs-lookup"><span data-stu-id="1bea6-201">Upon adding this page you may be surprised to see that it contains no Content controls (see Figure 4)!</span></span> <span data-ttu-id="1bea6-202">内容页只能访问其*父*母版页的 contentplaceholder。</span><span class="sxs-lookup"><span data-stu-id="1bea6-202">A content page can only access its *parent* master page's ContentPlaceHolders.</span></span> <span data-ttu-id="1bea6-203">`SimpleNested.master` 不包含任何 ContentPlaceHolder 控件;因此，绑定到此母版页的任何内容页都不能包含任何内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-203">`SimpleNested.master` does not contain any ContentPlaceHolder controls; therefore, any content page bound to this master page cannot contain any Content controls.</span></span>

<span data-ttu-id="1bea6-204">[![新的内容页不包含任何内容控件](nested-master-pages-cs/_static/image11.png)](nested-master-pages-cs/_static/image10.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-204">[![The New Content Page Contains No Content Controls](nested-master-pages-cs/_static/image11.png)](nested-master-pages-cs/_static/image10.png)</span></span>

<span data-ttu-id="1bea6-205">**图 04**：新的内容页不包含任何内容控件（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-205">**Figure 04**: The New Content Page Contains No Content Controls ([Click to view full-size image](nested-master-pages-cs/_static/image12.png))</span></span>

<span data-ttu-id="1bea6-206">我们需要做的就是将嵌套的母版页（`SimpleNested.master`）更新为包含 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-206">What we need to do is update the nested master page (`SimpleNested.master`) to include ContentPlaceHolder controls.</span></span> <span data-ttu-id="1bea6-207">通常，您将希望嵌套母版页包含其父母版页所定义的每个 ContentPlaceHolder 的 ContentPlaceHolder，从而允许其子母版页或内容页使用顶层母版页的任何 ContentPlaceHolder控件.</span><span class="sxs-lookup"><span data-stu-id="1bea6-207">Typically you'll want your nested master pages to include a ContentPlaceHolder for each ContentPlaceHolder defined by its parent master page, thereby allowing its child master page or content page to work with any of the top-level master page's ContentPlaceHolder controls.</span></span>

<span data-ttu-id="1bea6-208">更新 `SimpleNested.master` 母版页，使其在其两个内容控件中包含 ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="1bea6-208">Update the `SimpleNested.master` master page to include a ContentPlaceHolder in its two Content controls.</span></span> <span data-ttu-id="1bea6-209">为 ContentPlaceHolder 控件指定与其内容控件引用的 ContentPlaceHolder 控件相同的名称。</span><span class="sxs-lookup"><span data-stu-id="1bea6-209">Give the ContentPlaceHolder controls the same name as the ContentPlaceHolder control their Content control refers to.</span></span> <span data-ttu-id="1bea6-210">也就是说，将名为 `MainContent` 的 ContentPlaceHolder 控件添加到 `SimpleNested.master` 中的内容控件，该控件引用 `Simple.master`中的 `MainContent` ContentPlaceHolder。</span><span class="sxs-lookup"><span data-stu-id="1bea6-210">That is, add a ContentPlaceHolder control named `MainContent` to the Content control in `SimpleNested.master` that references the `MainContent` ContentPlaceHolder in `Simple.master`.</span></span> <span data-ttu-id="1bea6-211">在引用 `head` ContentPlaceHolder 的内容控件中执行相同的操作。</span><span class="sxs-lookup"><span data-stu-id="1bea6-211">Do the same thing in the Content control that references the `head` ContentPlaceHolder.</span></span>

> [!NOTE]
> <span data-ttu-id="1bea6-212">尽管建议在嵌套母版页中命名 ContentPlaceHolder 控件的方式与顶层母版页中的 Contentplaceholder 相同，但不需要此命名对称。</span><span class="sxs-lookup"><span data-stu-id="1bea6-212">While I recommend naming the ContentPlaceHolder controls in the nested master page the same as the ContentPlaceHolders in the top-level master page, this naming symmetry is not required.</span></span> <span data-ttu-id="1bea6-213">可以在嵌套母版页中为 ContentPlaceHolder 控件指定任意名称。</span><span class="sxs-lookup"><span data-stu-id="1bea6-213">You can give the ContentPlaceHolder controls in your nested master page any name you like.</span></span> <span data-ttu-id="1bea6-214">但是，我发现，如果顶层母版页和嵌套母版页使用相同的名称，则可以更方便地记住哪些 Contentplaceholder 与页面区域相对应。</span><span class="sxs-lookup"><span data-stu-id="1bea6-214">However, I find it easier to remember what ContentPlaceHolders correspond with what regions of the page if my top-level master page and nested master pages use the same names.</span></span>

<span data-ttu-id="1bea6-215">进行这些添加后，`SimpleNested.master` 母版页的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-215">After making these additions your `SimpleNested.master` master page's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample5.aspx)]

<span data-ttu-id="1bea6-216">删除刚刚创建的 `Default.aspx` 内容页，然后重新添加该页面，并将其绑定到 `SimpleNested.master` 的母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-216">Delete the `Default.aspx` content page we just created and then re-add it, binding it to the `SimpleNested.master` master page.</span></span> <span data-ttu-id="1bea6-217">此时，Visual Studio 会将两个内容控件添加到 `Default.aspx`，同时引用 `SimpleNested.master` 中定义的 Contentplaceholder （参见图6）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-217">This time Visual Studio adds two Content controls to the `Default.aspx`, referencing the ContentPlaceHolders now defined in `SimpleNested.master` (see Figure 6).</span></span> <span data-ttu-id="1bea6-218">添加文本 "Hello，from default.aspx！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-218">Add the text, "Hello, from Default.aspx!"</span></span> <span data-ttu-id="1bea6-219">在引用 `MainContent`的内容控件中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-219">in the Content control that referenced `MainContent`.</span></span>

<span data-ttu-id="1bea6-220">图5显示了此处涉及的三个实体-`Simple.master`、`SimpleNested.master`和 `Default.aspx`，以及它们彼此之间的关系。</span><span class="sxs-lookup"><span data-stu-id="1bea6-220">Figure 5 shows the three entities involved here - `Simple.master`, `SimpleNested.master`, and `Default.aspx` - and how they relate to one another.</span></span> <span data-ttu-id="1bea6-221">如图所示，嵌套母版页实现其父对象的 ContentPlaceHolder 的内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-221">As the diagram shows, the nested master page implements Content controls for its parent's ContentPlaceHolder.</span></span> <span data-ttu-id="1bea6-222">如果需要对内容页访问这些区域，则嵌套母版页必须将其自己的 Contentplaceholder 添加到内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-222">If these regions need to be accessible to the content page, the nested master page must add its own ContentPlaceHolders to the Content controls.</span></span>

<span data-ttu-id="1bea6-223">[![顶级和嵌套母版页决定内容页的布局](nested-master-pages-cs/_static/image14.png)](nested-master-pages-cs/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-223">[![The Top-Level and Nested Master Pages Dictate the Content Page's Layout](nested-master-pages-cs/_static/image14.png)](nested-master-pages-cs/_static/image13.png)</span></span>

<span data-ttu-id="1bea6-224">**图 05**：顶级和嵌套母版页决定内容页的布局（[单击查看完全大小的图像](nested-master-pages-cs/_static/image15.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-224">**Figure 05**: The Top-Level and Nested Master Pages Dictate the Content Page's Layout ([Click to view full-size image](nested-master-pages-cs/_static/image15.png))</span></span>

<span data-ttu-id="1bea6-225">此行为说明内容页或母版页如何只 cognizant 其父母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-225">This behavior illustrates how a content page or master page is only cognizant of its parent master page.</span></span> <span data-ttu-id="1bea6-226">Visual Studio 设计器也指出了此行为。</span><span class="sxs-lookup"><span data-stu-id="1bea6-226">This behavior is also indicated by the Visual Studio Designer.</span></span> <span data-ttu-id="1bea6-227">图6显示了 `Default.aspx`的设计器。</span><span class="sxs-lookup"><span data-stu-id="1bea6-227">Figure 6 shows the Designer for `Default.aspx`.</span></span> <span data-ttu-id="1bea6-228">虽然设计器清楚地显示了哪些区域可从 "内容" 页进行编辑以及哪些部分不能，但它并不区分嵌套母版页中的哪些不可编辑区域以及顶层母版页中的区域。</span><span class="sxs-lookup"><span data-stu-id="1bea6-228">While the Designer clearly shows what regions are editable from the content page and what portions aren't, it doesn't disambiguate what non-editable regions are from the nested master page and what regions are from the top-level master page.</span></span>

<span data-ttu-id="1bea6-229">[![内容页现在包含嵌套母版页的 Contentplaceholder 的内容控件。](nested-master-pages-cs/_static/image17.png)](nested-master-pages-cs/_static/image16.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-229">[![The Content Page Now Includes Content Controls for the Nested Master Page's ContentPlaceHolders](nested-master-pages-cs/_static/image17.png)](nested-master-pages-cs/_static/image16.png)</span></span>

<span data-ttu-id="1bea6-230">**图 06**： "内容" 页现在包含用于嵌套母版页 Contentplaceholder 的内容控件（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image18.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-230">**Figure 06**: The Content Page Now Includes Content Controls for the Nested Master Page's ContentPlaceHolders ([Click to view full-size image](nested-master-pages-cs/_static/image18.png))</span></span>

## <a name="step-3-adding-a-second-simple-nested-master-page"></a><span data-ttu-id="1bea6-231">步骤3：添加第二个简单嵌套母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-231">Step 3: Adding a Second Simple Nested Master Page</span></span>

<span data-ttu-id="1bea6-232">如果有多个嵌套母版页，则嵌套母版页的优点更明显。</span><span class="sxs-lookup"><span data-stu-id="1bea6-232">The benefit of nested master pages is more evident when there are multiple nested master pages.</span></span> <span data-ttu-id="1bea6-233">为了说明此权益，请在 `NestedMasterPages` 文件夹中创建另一个嵌套的母版页;将这一新的嵌套母版页命名 `SimpleNestedAlternate.master`，并将其绑定到 `Simple.master` 母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-233">To illustrate this benefit, create another nested master page in the `NestedMasterPages` folder; name this new nested master page `SimpleNestedAlternate.master` and bind it to the `Simple.master` master page.</span></span> <span data-ttu-id="1bea6-234">将 ContentPlaceHolder 控件添加到嵌套母版页的两个内容控件中，就像我们在步骤2中所做的一样。</span><span class="sxs-lookup"><span data-stu-id="1bea6-234">Add ContentPlaceHolder controls in the nested master page's two Content controls like we did in Step 2.</span></span> <span data-ttu-id="1bea6-235">同时添加文本 "Hello，from SimpleNestedAlternate！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-235">Also add the text, "Hello, from SimpleNestedAlternate!"</span></span> <span data-ttu-id="1bea6-236">在与顶层母版页的 `MainContent` ContentPlaceHolder 的内容控件中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-236">in the Content control that corresponds to the top-level master page's `MainContent` ContentPlaceHolder.</span></span> <span data-ttu-id="1bea6-237">进行这些更改后，新的嵌套母版页的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-237">After making these changes your new nested master page's declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample6.aspx)]

<span data-ttu-id="1bea6-238">在 `NestedMasterPages` 文件夹中创建名为 `Alternate.aspx` 的内容页，并将其绑定到 `SimpleNestedAlternate.master` 嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-238">Create a content page named `Alternate.aspx` in the `NestedMasterPages` folder and bind it to the `SimpleNestedAlternate.master` nested master page.</span></span> <span data-ttu-id="1bea6-239">添加文本 "Hello，from 替补！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-239">Add the text, "Hello, from Alternate!"</span></span> <span data-ttu-id="1bea6-240">在与 `MainContent`相对应的内容控件中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-240">in the Content control that corresponds to `MainContent`.</span></span> <span data-ttu-id="1bea6-241">图7显示了通过 Visual Studio 设计器查看 `Alternate.aspx`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-241">Figure 7 shows `Alternate.aspx` when viewed through the Visual Studio Designer.</span></span>

<span data-ttu-id="1bea6-242">[![备用 .aspx 绑定到 SimpleNestedAlternate 母版页](nested-master-pages-cs/_static/image20.png)](nested-master-pages-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-242">[![Alternate.aspx is Bound to the SimpleNestedAlternate.master Master Page](nested-master-pages-cs/_static/image20.png)](nested-master-pages-cs/_static/image19.png)</span></span>

<span data-ttu-id="1bea6-243">**图 07**： `Alternate.aspx` 绑定到 `SimpleNestedAlternate.master` 母版页（[单击查看完全大小的图像](nested-master-pages-cs/_static/image21.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-243">**Figure 07**: `Alternate.aspx` is Bound to the `SimpleNestedAlternate.master` Master Page ([Click to view full-size image](nested-master-pages-cs/_static/image21.png))</span></span>

<span data-ttu-id="1bea6-244">将图7中的设计器与图6中的设计器进行比较。</span><span class="sxs-lookup"><span data-stu-id="1bea6-244">Compare the Designer in Figure 7 to the Designer in Figure 6.</span></span> <span data-ttu-id="1bea6-245">这两个内容页共享在顶层母版页（`Simple.master`）中定义的同一布局，即 "嵌套母版页教程（简单）" 标题。</span><span class="sxs-lookup"><span data-stu-id="1bea6-245">Both content pages share the same layout defined in the top-level master page (`Simple.master`), namely the "Nested Master Pages Tutorial (Simple)" title.</span></span> <span data-ttu-id="1bea6-246">但它们的父母版页中都定义了不同的内容-文本 "Hello，from SimpleNested！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-246">Yet both have distinct content defined in their parent master pages - the text "Hello, from SimpleNested!"</span></span> <span data-ttu-id="1bea6-247">图6和 "Hello，from SimpleNestedAlternate！"</span><span class="sxs-lookup"><span data-stu-id="1bea6-247">in Figure 6 and "Hello, from SimpleNestedAlternate!"</span></span> <span data-ttu-id="1bea6-248">图7所示。</span><span class="sxs-lookup"><span data-stu-id="1bea6-248">in Figure 7.</span></span> <span data-ttu-id="1bea6-249">当然，这种差异很简单，但你可以扩展此示例，使其包含更有意义的差异。</span><span class="sxs-lookup"><span data-stu-id="1bea6-249">Granted, these differences here are trivial, but you could extend this example to include more meaningful differences.</span></span> <span data-ttu-id="1bea6-250">例如，"`SimpleNested.master`" 页可能包含一个菜单，其中包含特定于其内容页的选项，而 `SimpleNestedAlternate.master` 可能包含与绑定到它的内容页相关的信息。</span><span class="sxs-lookup"><span data-stu-id="1bea6-250">For instance, the `SimpleNested.master` page might include a menu with options specific to its content pages, whereas `SimpleNestedAlternate.master` might have information pertinent to the content pages that bind to it.</span></span>

<span data-ttu-id="1bea6-251">现在，假设我们需要对 "网站布局" 进行更改。</span><span class="sxs-lookup"><span data-stu-id="1bea6-251">Now, imagine that we needed to make a change to the overarching site layout.</span></span> <span data-ttu-id="1bea6-252">例如，假设我们想要将常用链接列表添加到所有内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-252">For example, imagine that we wanted to add a list of common links to all content pages.</span></span> <span data-ttu-id="1bea6-253">为实现此目的，我们更新了顶层母版页，`Simple.master`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-253">To accomplish this we update the top-level master page, `Simple.master`.</span></span> <span data-ttu-id="1bea6-254">任何更改都会立即反映在其嵌套的母版页中，并通过扩展的内容页进行。</span><span class="sxs-lookup"><span data-stu-id="1bea6-254">Any changes there are immediately reflected in its nested master pages and, by extension, their content pages.</span></span>

<span data-ttu-id="1bea6-255">若要演示如何轻松地更改 "网站布局"，请打开 `Simple.master` 母版页，并在 `topContent` 和 `mainContent` `<div>` 元素之间添加以下标记：</span><span class="sxs-lookup"><span data-stu-id="1bea6-255">To demonstrate the ease with which we can change the overarching site layout, open the `Simple.master` master page and add the following markup between the `topContent` and `mainContent` `<div>` elements:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample7.aspx)]

<span data-ttu-id="1bea6-256">这会将两个链接添加到绑定到 `Simple.master`、`SimpleNested.master`或 `SimpleNestedAlternate.master`的每个页面的顶部;这些更改将立即应用于所有嵌套母版页及其内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-256">This adds two links to the top of every page that binds to `Simple.master`, `SimpleNested.master`, or `SimpleNestedAlternate.master`; these changes apply to all nested master pages and their content pages immediately.</span></span> <span data-ttu-id="1bea6-257">图8显示了通过浏览器查看 `Alternate.aspx`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-257">Figure 8 shows `Alternate.aspx` when viewed through a browser.</span></span> <span data-ttu-id="1bea6-258">请注意页面顶部的链接添加（与图7相比）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-258">Note the addition of the links at the top of the page (compared to Figure 7).</span></span>

<span data-ttu-id="1bea6-259">[![更改为顶层母版页会立即反映在其嵌套母版页及其内容页中。](nested-master-pages-cs/_static/image23.png)](nested-master-pages-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-259">[![Changed to the Top-Level Master Page are Immediately Reflected in its Nested Master Pages and Their Content Pages](nested-master-pages-cs/_static/image23.png)](nested-master-pages-cs/_static/image22.png)</span></span>

<span data-ttu-id="1bea6-260">**图 08**：更改为顶层母版页会立即反映在其嵌套母版页及其内容页面中（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image24.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-260">**Figure 08**: Changed to the Top-Level Master Page are Immediately Reflected in its Nested Master Pages and Their Content Pages ([Click to view full-size image](nested-master-pages-cs/_static/image24.png))</span></span>

## <a name="using-a-nested-master-page-for-the-administration-section"></a><span data-ttu-id="1bea6-261">使用 "管理" 部分的嵌套母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-261">Using a Nested Master Page for the Administration Section</span></span>

<span data-ttu-id="1bea6-262">此时，我们已经了解了嵌套母版页的优点，并了解了如何在 ASP.NET 应用程序中创建和使用它们。</span><span class="sxs-lookup"><span data-stu-id="1bea6-262">At this point we have looked at the advantages of nested master pages and have seen how to create and use them in an ASP.NET application.</span></span> <span data-ttu-id="1bea6-263">不过，步骤1、2和3中的示例涉及到创建新的顶级母版页、新建嵌套母版页和新内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-263">The examples in Steps 1, 2, and 3, however, involved creating a new top-level master page, new nested master pages, and new content pages.</span></span> <span data-ttu-id="1bea6-264">如何使用现有顶级母版页和内容页向网站添加新的嵌套母版页呢？</span><span class="sxs-lookup"><span data-stu-id="1bea6-264">What about adding a new nested master page to a website with an existing top-level master page and content pages?</span></span>

<span data-ttu-id="1bea6-265">将嵌套母版页集成到现有网站，并将其与现有内容页相关联需要比从头开始更多的工作。</span><span class="sxs-lookup"><span data-stu-id="1bea6-265">Integrating a nested master page into an existing website and associating it with existing content pages requires a bit more effort than starting from scratch.</span></span> <span data-ttu-id="1bea6-266">步骤4、5、6和7介绍了这些难题，因为我们增加了演示应用程序以包括一个名为 `AdminNested.master` 的新嵌套母版页，其中包含管理员的说明，由 `~/Admin` 文件夹中的 ASP.NET 页使用。</span><span class="sxs-lookup"><span data-stu-id="1bea6-266">Steps 4, 5, 6, and 7 explore these challenges as we augment our demo application to include a new nested master page named `AdminNested.master` that contains instructions for the administrator and is used by the ASP.NET pages in the `~/Admin` folder.</span></span>

<span data-ttu-id="1bea6-267">将嵌套母版页集成到演示应用程序中带来了以下障碍：</span><span class="sxs-lookup"><span data-stu-id="1bea6-267">Integrating a nested master page into our demo application introduces the following hurdles:</span></span>

- <span data-ttu-id="1bea6-268">`~/Admin` 文件夹中的现有内容页具有其母版页的特定期望。</span><span class="sxs-lookup"><span data-stu-id="1bea6-268">The existing content pages in the `~/Admin` folder have certain expectations from their master page.</span></span> <span data-ttu-id="1bea6-269">对于初学者，它们期望存在某些 ContentPlaceHolder 控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-269">For starters, they expect certain ContentPlaceHolder controls to be present.</span></span> <span data-ttu-id="1bea6-270">此外，`~/Admin/AddProduct.aspx` 和 `~/Admin/Products.aspx` 页将调用母版页的公共 `RefreshRecentProductsGrid` 方法，设置其 `GridMessageText` 属性，或具有其 `PricesDoubled` 事件的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="1bea6-270">Furthermore, the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages call the master page's public `RefreshRecentProductsGrid` method, set its `GridMessageText` property, or have an event handler for its `PricesDoubled` event.</span></span> <span data-ttu-id="1bea6-271">因此，嵌套母版页必须提供相同的 Contentplaceholder 和公共成员。</span><span class="sxs-lookup"><span data-stu-id="1bea6-271">Consequently, our nested master page must provide the same ContentPlaceHolders and public members.</span></span>
- <span data-ttu-id="1bea6-272">在前面的教程中，我们增强了 `BasePage` 类，以便基于会话变量动态设置 `Page` 对象的 `MasterPageFile` 属性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-272">In the preceding tutorial we enhanced the `BasePage` class to dynamically set the `Page` object's `MasterPageFile` property based on a Session variable.</span></span> <span data-ttu-id="1bea6-273">使用嵌套母版页时，如何支持动态母版页？</span><span class="sxs-lookup"><span data-stu-id="1bea6-273">How to we support dynamic master pages when using nested master pages?</span></span>

<span data-ttu-id="1bea6-274">当我们构建嵌套母版页，并从现有内容页中使用它时，这两个挑战将会出现。</span><span class="sxs-lookup"><span data-stu-id="1bea6-274">These two challenges will surface as we build the nested master page and use it from our existing content pages.</span></span> <span data-ttu-id="1bea6-275">我们会在出现这些问题时进行调查和克服。</span><span class="sxs-lookup"><span data-stu-id="1bea6-275">We'll investigate and surmount these issues as they arise.</span></span>

## <a name="step-4-creating-the-nested-master-page"></a><span data-ttu-id="1bea6-276">步骤4：创建嵌套母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-276">Step 4: Creating the Nested Master Page</span></span>

<span data-ttu-id="1bea6-277">第一项任务是创建要由 "管理" 部分中的页面使用的嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-277">Our first task is to create the nested master page to be used by the pages in the Administration section.</span></span> <span data-ttu-id="1bea6-278">正如我们在步骤2中看到的，添加新的嵌套母版页时，需要指定嵌套母版页的父母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-278">As we saw in Step 2, when adding a new nested master page we need to specify the nested master page's parent master page.</span></span> <span data-ttu-id="1bea6-279">但有两个顶级母版页： `Site.master` 和 `Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-279">But we have two top-level master pages: `Site.master` and `Alternate.master`.</span></span> <span data-ttu-id="1bea6-280">回忆一下，我们在前面的教程中创建了 `Alternate.master`，并在 `BasePage` 类中编写了代码，该代码在运行时将页面对象的 `MasterPageFile` 属性设置为 `Site.master` 或 `Alternate.master`，具体取决于 `MyMasterPage` 会话变量的值。</span><span class="sxs-lookup"><span data-stu-id="1bea6-280">Recall that we created `Alternate.master` in the preceding tutorial and wrote code in the `BasePage` class that set the Page object's `MasterPageFile` property at runtime to either `Site.master` or `Alternate.master` depending on the value of the `MyMasterPage` Session variable.</span></span>

<span data-ttu-id="1bea6-281">如何配置嵌套母版页，使其使用适当的顶层母版页？</span><span class="sxs-lookup"><span data-stu-id="1bea6-281">How do we configure our nested master page so that it uses the appropriate top-level master page?</span></span> <span data-ttu-id="1bea6-282">我们有两个选项：</span><span class="sxs-lookup"><span data-stu-id="1bea6-282">We have two options:</span></span>

- <span data-ttu-id="1bea6-283">创建两个嵌套母版页，`AdminNestedSite.master` 和 `AdminNestedAlternate.master`，并分别将它们绑定到顶层母版页 `Site.master` 和 `Alternate.master`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-283">Create two nested master pages, `AdminNestedSite.master` and `AdminNestedAlternate.master`, and bind them to the top-level master pages `Site.master` and `Alternate.master`, respectively.</span></span> <span data-ttu-id="1bea6-284">在 `BasePage`中，我们将 `Page` 对象的 `MasterPageFile` 设置为相应的嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-284">In `BasePage`, then, we'd set the `Page` object's `MasterPageFile` to the appropriate nested master page.</span></span>
- <span data-ttu-id="1bea6-285">创建单个嵌套母版页，并使内容页使用该特定母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-285">Create a single nested master page and have the content pages use this particular master page.</span></span> <span data-ttu-id="1bea6-286">然后，在运行时，需要在运行时将嵌套母版页的 `MasterPageFile` 属性设置为适当的顶级母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-286">Then, at runtime, we'd need to set the nested master page's `MasterPageFile` property to the appropriate top-level master page at runtime.</span></span> <span data-ttu-id="1bea6-287">（正如你现在可能已发现，母版页也有一个 `MasterPageFile` 属性。）</span><span class="sxs-lookup"><span data-stu-id="1bea6-287">(As you might have figured out by now, master pages also have a `MasterPageFile` property.)</span></span>

<span data-ttu-id="1bea6-288">我们将使用第二个选项。</span><span class="sxs-lookup"><span data-stu-id="1bea6-288">Let's use the second option.</span></span> <span data-ttu-id="1bea6-289">在名为 `AdminNested.master``~/Admin` 文件夹中创建单个嵌套母版页文件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-289">Create a single nested master page file in the `~/Admin` folder named `AdminNested.master`.</span></span> <span data-ttu-id="1bea6-290">由于 `Site.master` 和 `Alternate.master` 都具有相同的一组 ContentPlaceHolder 控件，因此，尽管我建议您将其绑定到 `Site.master` 以实现一致性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-290">Because both `Site.master` and `Alternate.master` have the same set of ContentPlaceHolder controls, it doesn't matter what master page you bind it to, although I encourage you to bind it to `Site.master` for consistency's sake.</span></span>

<span data-ttu-id="1bea6-291">[![将嵌套的母版页添加到 ~/Admin 文件夹中。](nested-master-pages-cs/_static/image26.png)](nested-master-pages-cs/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-291">[![Add a Nested Master Page to the ~/Admin Folder.](nested-master-pages-cs/_static/image26.png)](nested-master-pages-cs/_static/image25.png)</span></span>

<span data-ttu-id="1bea6-292">**图 09**：将嵌套母版页添加到 `~/Admin` 文件夹。</span><span class="sxs-lookup"><span data-stu-id="1bea6-292">**Figure 09**: Add a Nested Master Page to the `~/Admin` Folder.</span></span> <span data-ttu-id="1bea6-293">（[单击以查看完全大小的映像](nested-master-pages-cs/_static/image27.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-293">([Click to view full-size image](nested-master-pages-cs/_static/image27.png))</span></span>

<span data-ttu-id="1bea6-294">由于嵌套母版页绑定到具有四个 ContentPlaceHolder 控件的母版页，因此 Visual Studio 会将四个内容控件添加到新的嵌套母版页文件的初始标记中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-294">Because the nested master page is bound to a master page with four ContentPlaceHolder controls, Visual Studio adds four Content controls to the new nested master page file's initial markup.</span></span> <span data-ttu-id="1bea6-295">与第2步和第3步一样，在每个内容控件中添加 ContentPlaceHolder 控件，使其与顶层母版页的 ContentPlaceHolder 控件的名称相同。</span><span class="sxs-lookup"><span data-stu-id="1bea6-295">Like we did in Steps 2 and 3, add a ContentPlaceHolder control in each Content control, giving it the same name as the top-level master page's ContentPlaceHolder control.</span></span> <span data-ttu-id="1bea6-296">还将以下标记添加到与 `MainContent` ContentPlaceHolder 相对应的内容控件：</span><span class="sxs-lookup"><span data-stu-id="1bea6-296">Also add the following markup to the Content control that corresponds to the `MainContent` ContentPlaceHolder:</span></span>

[!code-html[Main](nested-master-pages-cs/samples/sample8.html)]

<span data-ttu-id="1bea6-297">接下来，在 `Styles.css` 和 `AlternateStyles.css` CSS 文件中定义 `instructions` CSS 类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-297">Next, define the `instructions` CSS class in the `Styles.css` and `AlternateStyles.css` CSS files.</span></span> <span data-ttu-id="1bea6-298">以下 CSS 规则会导致使用带有浅黄色背景色和黑色实线边框的 `instructions` 类样式的 HTML 元素显示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-298">The following CSS rules cause HTML elements styled with the `instructions` class to be displayed with a light yellow background color and a black, solid border:</span></span>

[!code-css[Main](nested-master-pages-cs/samples/sample9.css)]

<span data-ttu-id="1bea6-299">由于已将此标记添加到嵌套母版页，因此它将仅显示在使用此嵌套母版页的页面中（即，"管理" 部分中的页面）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-299">Because this markup has been added to the nested master page, it will only appear in those pages that use this nested master page (namely, the pages in the Administration section).</span></span>

<span data-ttu-id="1bea6-300">将这些添加到嵌套母版页后，其声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-300">After making these additions to your nested master page, its declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample10.aspx)]

<span data-ttu-id="1bea6-301">请注意，每个内容控件都有一个 ContentPlaceHolder 控件，并且为 ContentPlaceHolder 控件的 `ID` 属性分配与顶层母版页中对应 ContentPlaceHolder 控件相同的值。</span><span class="sxs-lookup"><span data-stu-id="1bea6-301">Note that each Content control has a ContentPlaceHolder control and that the ContentPlaceHolder controls' `ID` properties are assigned the same values as the corresponding ContentPlaceHolder controls in the top-level master page.</span></span> <span data-ttu-id="1bea6-302">此外，"管理" 部分特定的标记将显示在 `MainContent` ContentPlaceHolder 中。</span><span class="sxs-lookup"><span data-stu-id="1bea6-302">Moreover, the Administration section-specific markup appears in the `MainContent` ContentPlaceHolder.</span></span>

<span data-ttu-id="1bea6-303">图10显示了通过 Visual Studio 的设计器查看 `AdminNested.master` 嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-303">Figure 10 shows the `AdminNested.master` nested master page when viewed through Visual Studio's Designer.</span></span> <span data-ttu-id="1bea6-304">可以在 `MainContent` 内容控件顶部的黄色框中查看说明。</span><span class="sxs-lookup"><span data-stu-id="1bea6-304">You can see the instructions in the yellow box at the top of the `MainContent` Content control.</span></span>

<span data-ttu-id="1bea6-305">[![嵌套的母版页扩展了顶层母版页，以包含管理员的说明。](nested-master-pages-cs/_static/image29.png)](nested-master-pages-cs/_static/image28.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-305">[![The Nested Master Page Extends the Top-Level Master Page to Include Instructions for the Administrator.](nested-master-pages-cs/_static/image29.png)](nested-master-pages-cs/_static/image28.png)</span></span>

<span data-ttu-id="1bea6-306">**图 10**：嵌套的母版页扩展了顶层母版页，以包含管理员的说明。</span><span class="sxs-lookup"><span data-stu-id="1bea6-306">**Figure 10**: The Nested Master Page Extends the Top-Level Master Page to Include Instructions for the Administrator.</span></span> <span data-ttu-id="1bea6-307">（[单击以查看完全大小的映像](nested-master-pages-cs/_static/image30.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-307">([Click to view full-size image](nested-master-pages-cs/_static/image30.png))</span></span>

## <a name="step-5-updating-the-existing-content-pages-to-use-the-new-nested-master-page"></a><span data-ttu-id="1bea6-308">步骤5：更新现有内容页以使用新的嵌套母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-308">Step 5: Updating the Existing Content Pages to Use the New Nested Master Page</span></span>

<span data-ttu-id="1bea6-309">每次将新的内容页添加到 "管理" 部分时，需要将其绑定到刚刚创建的 `AdminNested.master` 母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-309">Anytime we add a new content page to the Administration section we need to bind it to the `AdminNested.master` master page we just created.</span></span> <span data-ttu-id="1bea6-310">但现有内容页呢？</span><span class="sxs-lookup"><span data-stu-id="1bea6-310">But what about the existing content pages?</span></span> <span data-ttu-id="1bea6-311">当前，站点中的所有内容页派生自 `BasePage` 类，该类在运行时以编程方式设置内容页的母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-311">Currently, all content pages in the site derive from the `BasePage` class, which programmatically sets the content page's master page at runtime.</span></span> <span data-ttu-id="1bea6-312">这不是我们想要用于 "管理" 部分中的内容页的行为。</span><span class="sxs-lookup"><span data-stu-id="1bea6-312">This is not the behavior we want for the content pages in the Administration section.</span></span> <span data-ttu-id="1bea6-313">相反，我们希望这些内容页始终使用 `AdminNested.master` 页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-313">Instead, we want these content pages to always use the `AdminNested.master` page.</span></span> <span data-ttu-id="1bea6-314">嵌套母版页负责在运行时选择正确的顶级内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-314">It will be the responsibility of the nested master page to choose the right top-level content page at runtime.</span></span>

<span data-ttu-id="1bea6-315">若要实现此所需行为，最佳方法是创建一个新的名为 `AdminBasePage` 的自定义基类类，以扩展 `BasePage` 类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-315">To best way to achieve this desired behavior is to create a new custom base page class named `AdminBasePage` that extends the `BasePage` class.</span></span> <span data-ttu-id="1bea6-316">然后 `AdminBasePage` 可以重写 `SetMasterPageFile` 并将 `Page` 对象的 `MasterPageFile` 设置为硬编码值 "~/Admin/AdminNested.master"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-316">`AdminBasePage` can then override the `SetMasterPageFile` and set the `Page` object's `MasterPageFile` to the hard-coded value "~/Admin/AdminNested.master".</span></span> <span data-ttu-id="1bea6-317">通过这种方式，派生自 `AdminBasePage` 的任何页面都将使用 `AdminNested.master`，而从 `BasePage` 派生的任何页面都将基于 `MyMasterPage` 会话变量的值将其 `MasterPageFile` 属性动态设置为 "~/Site.master" 或 "~/Alternate.master"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-317">In this way, any page that derives from `AdminBasePage` will use `AdminNested.master`, whereas any page that derives from `BasePage` will have its `MasterPageFile` property set dynamically to either "~/Site.master" or "~/Alternate.master" based on the value of the `MyMasterPage` Session variable.</span></span>

<span data-ttu-id="1bea6-318">首先将新的类文件添加到名为 `AdminBasePage.cs``App_Code` 文件夹。</span><span class="sxs-lookup"><span data-stu-id="1bea6-318">Start by adding a new class file to the `App_Code` folder named `AdminBasePage.cs`.</span></span> <span data-ttu-id="1bea6-319">让 `AdminBasePage` 扩展 `BasePage`，然后重写 `SetMasterPageFile` 方法。</span><span class="sxs-lookup"><span data-stu-id="1bea6-319">Have `AdminBasePage` extend `BasePage` and then override the `SetMasterPageFile` method.</span></span> <span data-ttu-id="1bea6-320">在该方法中，将 `MasterPageFile` 值 "~/Admin/AdminNested.master"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-320">In that method assign the `MasterPageFile` the value "~/Admin/AdminNested.master".</span></span> <span data-ttu-id="1bea6-321">进行这些更改后，类文件应如下所示：</span><span class="sxs-lookup"><span data-stu-id="1bea6-321">After making these changes your class file should look similar to the following:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample11.cs)]

<span data-ttu-id="1bea6-322">现在，我们需要在 "管理" 部分中的现有内容页派生自 `AdminBasePage` 而不是 `BasePage`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-322">We now need to have the existing content pages in the Administration section derive from `AdminBasePage` instead of `BasePage`.</span></span> <span data-ttu-id="1bea6-323">转到 `~/Admin` 文件夹中每个内容页面的代码隐藏类文件，然后进行此更改。</span><span class="sxs-lookup"><span data-stu-id="1bea6-323">Go to the code-behind class file for each content page in the `~/Admin` folder and make this change.</span></span> <span data-ttu-id="1bea6-324">例如，在 `~/Admin/Default.aspx` 你需要更改的代码隐藏类声明：</span><span class="sxs-lookup"><span data-stu-id="1bea6-324">For example, in `~/Admin/Default.aspx` you'd change the code-behind class declaration from:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample12.cs)]

<span data-ttu-id="1bea6-325">结束时间：</span><span class="sxs-lookup"><span data-stu-id="1bea6-325">To:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample13.cs)]

<span data-ttu-id="1bea6-326">图11描绘了顶层母版页（`Site.master` 或 `Alternate.master`）、嵌套母版页（`AdminNested.master`）和管理部分内容页之间的关系。</span><span class="sxs-lookup"><span data-stu-id="1bea6-326">Figure 11 depicts how the top-level master page (`Site.master` or `Alternate.master`), the nested master page (`AdminNested.master`), and the Administration section content pages relate to one another.</span></span>

<span data-ttu-id="1bea6-327">[![嵌套母版页会定义特定于 "管理" 部分页面的内容](nested-master-pages-cs/_static/image32.png)](nested-master-pages-cs/_static/image31.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-327">[![The Nested Master Page Defines Content Specific to the Pages in the Administration Section](nested-master-pages-cs/_static/image32.png)](nested-master-pages-cs/_static/image31.png)</span></span>

<span data-ttu-id="1bea6-328">**图 11**：嵌套母版页定义特定于 "管理" 部分中的页面的内容（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image33.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-328">**Figure 11**: The Nested Master Page Defines Content Specific to the Pages in the Administration Section ([Click to view full-size image](nested-master-pages-cs/_static/image33.png))</span></span>

## <a name="step-6-mirroring-the-master-pages-public-methods-and-properties"></a><span data-ttu-id="1bea6-329">步骤6：镜像母版页的公共方法和属性</span><span class="sxs-lookup"><span data-stu-id="1bea6-329">Step 6: Mirroring the Master Page's Public Methods and Properties</span></span>

<span data-ttu-id="1bea6-330">回忆一下，`~/Admin/AddProduct.aspx` 和 `~/Admin/Products.aspx` 页面以编程方式与母版页交互： `~/Admin/AddProduct.aspx` 调用母版页的公共 `RefreshRecentProductsGrid` 方法并设置其 `GridMessageText` 属性;`~/Admin/Products.aspx` 具有 `PricesDoubled` 事件的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="1bea6-330">Recall that the `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages interact programmatically with the master page: `~/Admin/AddProduct.aspx` calls the master page's public `RefreshRecentProductsGrid` method and sets its `GridMessageText` property; `~/Admin/Products.aspx` has an event handler for the `PricesDoubled` event.</span></span> <span data-ttu-id="1bea6-331">在前面的教程中，我们创建了一个定义这些公共成员的抽象 `BaseMasterPage` 类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-331">In the preceding tutorial we created an abstract `BaseMasterPage` class that defined these public members.</span></span>

<span data-ttu-id="1bea6-332">"`~/Admin/AddProduct.aspx`" 和 "`~/Admin/Products.aspx`" 页假定其母版页派生自 `BaseMasterPage` 类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-332">The `~/Admin/AddProduct.aspx` and `~/Admin/Products.aspx` pages assume that their master page derives from the `BaseMasterPage` class.</span></span> <span data-ttu-id="1bea6-333">但 `AdminNested.master` 页当前扩展了 `System.Web.UI.MasterPage` 类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-333">The `AdminNested.master` page, however, currently extends the `System.Web.UI.MasterPage` class.</span></span> <span data-ttu-id="1bea6-334">因此，当访问 `~/Admin/Products.aspx` 引发 `InvalidCastException` 时，消息： "无法将类型为\_" adminnested\_master "的对象强制转换为类型" BaseMasterPage "。</span><span class="sxs-lookup"><span data-stu-id="1bea6-334">As a result, when visiting `~/Admin/Products.aspx` an `InvalidCastException` is thrown with the message: "Unable to cast object of type 'ASP.admin\_adminnested\_master' to type 'BaseMasterPage'."</span></span>

<span data-ttu-id="1bea6-335">若要解决此问题，我们需要让 `AdminNested.master` 代码隐藏类 `BaseMasterPage`扩展。</span><span class="sxs-lookup"><span data-stu-id="1bea6-335">To fix this we need to have the `AdminNested.master` code-behind class extend `BaseMasterPage`.</span></span> <span data-ttu-id="1bea6-336">从以下项更新嵌套母版页的代码隐藏类声明：</span><span class="sxs-lookup"><span data-stu-id="1bea6-336">Update the nested master page's code-behind class declaration from:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample14.cs)]

<span data-ttu-id="1bea6-337">结束时间：</span><span class="sxs-lookup"><span data-stu-id="1bea6-337">To:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample15.cs)]

<span data-ttu-id="1bea6-338">尚未完成。</span><span class="sxs-lookup"><span data-stu-id="1bea6-338">We're not done yet.</span></span> <span data-ttu-id="1bea6-339">由于 `BaseMasterPage` 类是抽象类，因此需要重写 `abstract` 成员，`RefreshRecentProductsGrid` 和 `GridMessageText`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-339">Because the `BaseMasterPage` class is abstract, we need to override the `abstract` members, `RefreshRecentProductsGrid` and `GridMessageText`.</span></span> <span data-ttu-id="1bea6-340">顶级母版页使用这些成员更新其用户界面。</span><span class="sxs-lookup"><span data-stu-id="1bea6-340">These members are used by the top-level master pages to update their user interfaces.</span></span> <span data-ttu-id="1bea6-341">（实际上，只有 `Site.master` 的母版页使用这些方法，尽管这两个顶级母版页都实现了这些方法，因为这两种方法都扩展 `BaseMasterPage`。）</span><span class="sxs-lookup"><span data-stu-id="1bea6-341">(Actually, only the `Site.master` master page uses these methods, although both top-level master pages implement these methods, since both extend `BaseMasterPage`.)</span></span>

<span data-ttu-id="1bea6-342">尽管我们需要在 `AdminNested.master`中实现这些成员，但所有这些实现都只需调用嵌套母版页所使用的顶级母版页中的同一成员。</span><span class="sxs-lookup"><span data-stu-id="1bea6-342">While we need to implement these members in `AdminNested.master`, all these implementations need to do is simply call the same member in the top-level master page used by the nested master page.</span></span> <span data-ttu-id="1bea6-343">例如，在 "管理" 部分中的 "内容" 页调用嵌套母版页的 `RefreshRecentProductsGrid` 方法时，所有嵌套母版页都需要做的就是调用 `Site.master` 或 `Alternate.master`的 `RefreshRecentProductsGrid` 方法。</span><span class="sxs-lookup"><span data-stu-id="1bea6-343">For instance, when a content page in the Administration section calls the nested master page's `RefreshRecentProductsGrid` method, all the nested master page needs to do is, in turn, call `Site.master` or `Alternate.master`'s `RefreshRecentProductsGrid` method.</span></span>

<span data-ttu-id="1bea6-344">若要实现此目的，请首先将以下 `@MasterType` 指令添加到 `AdminNested.master`顶部：</span><span class="sxs-lookup"><span data-stu-id="1bea6-344">To achieve this, start by adding the following `@MasterType` directive to the top of `AdminNested.master`:</span></span>

[!code-aspx[Main](nested-master-pages-cs/samples/sample16.aspx)]

<span data-ttu-id="1bea6-345">请记住，`@MasterType` 指令将强类型属性添加到名为 `Master`的代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="1bea6-345">Recall that the `@MasterType` directive adds a strongly-typed property to the code-behind class named `Master`.</span></span> <span data-ttu-id="1bea6-346">然后，重写 `RefreshRecentProductsGrid` 和 `GridMessageText` 成员，只需将调用委托给 `Master`的相应方法即可：</span><span class="sxs-lookup"><span data-stu-id="1bea6-346">Then override the `RefreshRecentProductsGrid` and `GridMessageText` members and simply delegate the call to the `Master`'s corresponding method:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample17.cs)]

<span data-ttu-id="1bea6-347">使用此代码后，应能够访问并使用 "管理" 部分中的内容页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-347">With this code in place, you should be able to visit and use the content pages in the Administration section.</span></span> <span data-ttu-id="1bea6-348">图12显示了通过浏览器查看 `~/Admin/Products.aspx` 页面。</span><span class="sxs-lookup"><span data-stu-id="1bea6-348">Figure 12 shows the `~/Admin/Products.aspx` page when viewed through a browser.</span></span> <span data-ttu-id="1bea6-349">如您所见，页面包含在嵌套母版页中定义的 "管理说明" 框。</span><span class="sxs-lookup"><span data-stu-id="1bea6-349">As you can see, the page includes the Administration Instructions box, which is defined in the nested master page.</span></span>

<span data-ttu-id="1bea6-350">[!["管理" 部分中的内容页面包括每个页面顶部的说明](nested-master-pages-cs/_static/image35.png)](nested-master-pages-cs/_static/image34.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-350">[![The Content Pages in the Administration Section Include Instructions at the Top of Each Page](nested-master-pages-cs/_static/image35.png)](nested-master-pages-cs/_static/image34.png)</span></span>

<span data-ttu-id="1bea6-351">**图 12**： "管理" 部分中的内容页包含每个页面顶部的说明（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image36.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-351">**Figure 12**: The Content Pages in the Administration Section Include Instructions at the Top of Each Page ([Click to view full-size image](nested-master-pages-cs/_static/image36.png))</span></span>

## <a name="step-7-using-the-appropriate-top-level-master-page-at-runtime"></a><span data-ttu-id="1bea6-352">步骤7：在运行时使用合适的顶级母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-352">Step 7: Using the Appropriate Top-Level Master Page at Runtime</span></span>

<span data-ttu-id="1bea6-353">尽管 "管理" 部分中的所有内容页都可以完全正常运行，但它们都使用相同的顶层母版页，并忽略用户在 `ChooseMasterPage.aspx`选择的母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-353">While all the content pages in the Administration section are fully functional, they all use the same top-level master page and ignore the master page selected by the user at `ChooseMasterPage.aspx`.</span></span> <span data-ttu-id="1bea6-354">此行为的原因是嵌套母版页的 `MasterPageFile` 属性静态设置为在其 `<%@ Master %>` 指令中 `Site.master`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-354">This behavior is due to the fact that the nested master page has its `MasterPageFile` property statically set to `Site.master` in its `<%@ Master %>` directive.</span></span>

<span data-ttu-id="1bea6-355">若要使用由最终用户选择的顶层母版页，需要将 `AdminNested.master`的 `MasterPageFile` 属性设置为 `MyMasterPage` Session 变量中的值。</span><span class="sxs-lookup"><span data-stu-id="1bea6-355">To use the top-level master page selected by the end user we need to set the `AdminNested.master`'s `MasterPageFile` property to the value in the `MyMasterPage` Session variable.</span></span> <span data-ttu-id="1bea6-356">由于我们在 `BasePage`中设置内容页的 `MasterPageFile` 属性，因此，你可能会认为在 `BaseMasterPage` 或 `AdminNested.master`的代码隐藏类中设置嵌套母版页的 `MasterPageFile` 属性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-356">Because we set the content pages' `MasterPageFile` properties in `BasePage`, you may think that we would set the nested master page's `MasterPageFile` property in `BaseMasterPage` or in the `AdminNested.master`'s code-behind class.</span></span> <span data-ttu-id="1bea6-357">但这不起作用，因为我们需要在 PreInit 阶段结束时设置 "`MasterPageFile`" 属性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-357">This won't work, however, because we need to have set the `MasterPageFile` property by the end of the PreInit stage.</span></span> <span data-ttu-id="1bea6-358">可以通过编程方式从母版页进入页面生命周期的最早时间是 Init 阶段（在 PreInit 阶段后发生）。</span><span class="sxs-lookup"><span data-stu-id="1bea6-358">The earliest time that we can programmatically tap into the page lifecycle from a master page is the Init stage (which occurs after the PreInit stage).</span></span>

<span data-ttu-id="1bea6-359">因此，需要从内容页设置嵌套母版页的 `MasterPageFile` 属性。</span><span class="sxs-lookup"><span data-stu-id="1bea6-359">Therefore, we need to set the nested master page's `MasterPageFile` property from the content pages.</span></span> <span data-ttu-id="1bea6-360">使用 `AdminNested.master` 母版页的唯一内容页派生自 `AdminBasePage`。</span><span class="sxs-lookup"><span data-stu-id="1bea6-360">The only content pages that use the `AdminNested.master` master page derive from `AdminBasePage`.</span></span> <span data-ttu-id="1bea6-361">因此，可以将此逻辑放在此处。</span><span class="sxs-lookup"><span data-stu-id="1bea6-361">Therefore, we can put this logic there.</span></span> <span data-ttu-id="1bea6-362">在步骤5中，我们 u.i 了 `SetMasterPageFile` 方法，将 `Page` 对象的 `MasterPageFile` 属性设置为 "~/Admin/AdminNested.master"。</span><span class="sxs-lookup"><span data-stu-id="1bea6-362">In Step 5 we overrode the `SetMasterPageFile` method, setting the `Page` object's `MasterPageFile` property to "~/Admin/AdminNested.master".</span></span> <span data-ttu-id="1bea6-363">更新 `SetMasterPageFile`，同时将母版页的 `MasterPageFile` 属性设置为会话中存储的结果：</span><span class="sxs-lookup"><span data-stu-id="1bea6-363">Update `SetMasterPageFile` to also set the master page's `MasterPageFile` property to the result stored in Session:</span></span>

[!code-csharp[Main](nested-master-pages-cs/samples/sample18.cs)]

<span data-ttu-id="1bea6-364">在前面的教程中，我们添加到 `BasePage` 类的 `GetMasterPageFileFromSession` 方法将根据会话变量值返回相应的母版页文件路径。</span><span class="sxs-lookup"><span data-stu-id="1bea6-364">The `GetMasterPageFileFromSession` method, which we added to the `BasePage` class in the preceding tutorial, returns the appropriate master page file path based on the Session variable value.</span></span>

<span data-ttu-id="1bea6-365">进行此更改后，用户的母版页选择会转到 "管理" 部分。</span><span class="sxs-lookup"><span data-stu-id="1bea6-365">With this change in place, the user's master page selection carries over to the Administration section.</span></span> <span data-ttu-id="1bea6-366">图13显示了与图12相同的页，但在用户将其母版页选择更改为 `Alternate.master`后。</span><span class="sxs-lookup"><span data-stu-id="1bea6-366">Figure 13 shows the same page as Figure 12, but after the user has changed their master page selection to `Alternate.master`.</span></span>

<span data-ttu-id="1bea6-367">[!["嵌套的管理" 页使用用户选择的顶层母版页](nested-master-pages-cs/_static/image38.png)](nested-master-pages-cs/_static/image37.png)</span><span class="sxs-lookup"><span data-stu-id="1bea6-367">[![The Nested Administration Page Uses the Top-Level Master Page Selected by the User](nested-master-pages-cs/_static/image38.png)](nested-master-pages-cs/_static/image37.png)</span></span>

<span data-ttu-id="1bea6-368">**图 13**：嵌套管理页使用用户选择的顶层母版页（[单击以查看完全大小的图像](nested-master-pages-cs/_static/image39.png)）</span><span class="sxs-lookup"><span data-stu-id="1bea6-368">**Figure 13**: The Nested Administration Page Uses the Top-Level Master Page Selected by the User ([Click to view full-size image](nested-master-pages-cs/_static/image39.png))</span></span>

## <a name="summary"></a><span data-ttu-id="1bea6-369">总结</span><span class="sxs-lookup"><span data-stu-id="1bea6-369">Summary</span></span>

<span data-ttu-id="1bea6-370">与内容页绑定到母版页的方式非常类似，可以通过将子母版页绑定到父母版页来创建嵌套母版页。</span><span class="sxs-lookup"><span data-stu-id="1bea6-370">Much like how content pages can bind to a master page, it is possible to create nested master pages by having a child master page bind to a parent master page.</span></span> <span data-ttu-id="1bea6-371">子母版页可以为其每个父级的 Contentplaceholder 定义内容控件;然后，它可以将其自己的 ContentPlaceHolder 控件（以及其他标记）添加到这些内容控件。</span><span class="sxs-lookup"><span data-stu-id="1bea6-371">The child master page may define Content controls for each of its parent's ContentPlaceHolders; it can then add its own ContentPlaceHolder controls (as well as other markup) to these Content controls.</span></span> <span data-ttu-id="1bea6-372">嵌套的母版页在大 web 应用程序中非常有用，在这种情况下，所有页面都具有大致的外观，但站点的某些部分需要独有的自定义。</span><span class="sxs-lookup"><span data-stu-id="1bea6-372">Nested master pages are quite useful in large web applications where all pages share an overarching look and feel, yet certain sections of the site require unique customizations.</span></span>

<span data-ttu-id="1bea6-373">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="1bea6-373">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="1bea6-374">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="1bea6-374">Further Reading</span></span>

<span data-ttu-id="1bea6-375">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="1bea6-375">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="1bea6-376">嵌套 ASP.NET 母版页</span><span class="sxs-lookup"><span data-stu-id="1bea6-376">Nested ASP.NET Master Pages</span></span>](https://msdn.microsoft.com/library/x2b3ktt7.aspx)
- [<span data-ttu-id="1bea6-377">嵌套母版页和 VS 2005 设计时的提示</span><span class="sxs-lookup"><span data-stu-id="1bea6-377">Tips for Nested Master Pages and VS 2005 Design-Time</span></span>](https://weblogs.asp.net/scottgu/archive/2005/11/11/430382.aspx)
- [<span data-ttu-id="1bea6-378">VS 2008 嵌套母版页支持</span><span class="sxs-lookup"><span data-stu-id="1bea6-378">VS 2008 Nested Master Page Support</span></span>](https://weblogs.asp.net/scottgu/archive/2007/07/09/vs-2008-nested-master-page-support.aspx)

### <a name="about-the-author"></a><span data-ttu-id="1bea6-379">关于作者</span><span class="sxs-lookup"><span data-stu-id="1bea6-379">About the Author</span></span>

<span data-ttu-id="1bea6-380">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，创始人的多个 ASP/asp 和4GuysFromRolla.com 的作者已使用 Microsoft Web 技术，1998。</span><span class="sxs-lookup"><span data-stu-id="1bea6-380">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="1bea6-381">Scott 的工作方式是独立的顾问、培训师和撰稿人。</span><span class="sxs-lookup"><span data-stu-id="1bea6-381">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="1bea6-382">他的最新书籍是，[*在24小时内，sam ASP.NET 3.5*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="1bea6-382">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672329972/4guysfromrollaco).</span></span> <span data-ttu-id="1bea6-383">可以通过[http://ScottOnWriting.NET](http://scottonwriting.net/) [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)或通过他的博客访问 Scott。</span><span class="sxs-lookup"><span data-stu-id="1bea6-383">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="1bea6-384">特别感谢</span><span class="sxs-lookup"><span data-stu-id="1bea6-384">Special Thanks To</span></span>

<span data-ttu-id="1bea6-385">此教程系列由许多有用的审阅者查看。</span><span class="sxs-lookup"><span data-stu-id="1bea6-385">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="1bea6-386">想要查看我即将发布的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="1bea6-386">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="1bea6-387">如果是这样，请在[mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="1bea6-387">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="1bea6-388">[上一页](specifying-the-master-page-programmatically-cs.md)
> [下一页](creating-a-site-wide-layout-using-master-pages-vb.md)</span><span class="sxs-lookup"><span data-stu-id="1bea6-388">[Previous](specifying-the-master-page-programmatically-cs.md)
[Next](creating-a-site-wide-layout-using-master-pages-vb.md)</span></span>

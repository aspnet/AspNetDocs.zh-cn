---
uid: web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
title: 控件 ID 命名 (VB) 的内容页面中 |Microsoft Docs
author: rick-anderson
description: 说明了如何 ContentPlaceHolder 控件作为命名容器的因此可以以编程方式使用困难 （通过 FindControl) 控件...
ms.author: riande
ms.date: 06/10/2008
ms.assetid: dbb024a6-f043-4fc5-ad66-56556711875b
msc.legacyurl: /web-forms/overview/older-versions-getting-started/master-pages/control-id-naming-in-content-pages-vb
msc.type: authoredcontent
ms.openlocfilehash: dd60d02c2c3840edd4c0e1244623fcea0cb2db0b
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2019
ms.locfileid: "59386315"
---
# <a name="control-id-naming-in-content-pages-vb"></a><span data-ttu-id="41e93-103">内容页中的控件 ID 命名 (VB)</span><span class="sxs-lookup"><span data-stu-id="41e93-103">Control ID Naming in Content Pages (VB)</span></span>

<span data-ttu-id="41e93-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="41e93-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="41e93-105">[下载代码](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip)或[下载 PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)</span><span class="sxs-lookup"><span data-stu-id="41e93-105">[Download Code](http://download.microsoft.com/download/e/e/f/eef369f5-743a-4a52-908f-b6532c4ce0a4/ASPNET_MasterPages_Tutorial_05_VB.zip) or [Download PDF](http://download.microsoft.com/download/8/f/6/8f6349e4-6554-405a-bcd7-9b094ba5089a/ASPNET_MasterPages_Tutorial_05_VB.pdf)</span></span>

> <span data-ttu-id="41e93-106">说明了如何 ContentPlaceHolder 控件作为命名容器的因此可以以编程方式使用困难 （通过 FindControl) 控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-106">Illustrates how ContentPlaceHolder controls serve as a naming container and therefore make programmatically working with a control difficult (via FindControl).</span></span> <span data-ttu-id="41e93-107">探讨此问题和解决方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-107">Looks at this issue and workarounds.</span></span> <span data-ttu-id="41e93-108">此外介绍了如何以编程方式访问生成的 ClientID 值。</span><span class="sxs-lookup"><span data-stu-id="41e93-108">Also discusses how to programmatically access the resulting ClientID value.</span></span>


## <a name="introduction"></a><span data-ttu-id="41e93-109">介绍</span><span class="sxs-lookup"><span data-stu-id="41e93-109">Introduction</span></span>

<span data-ttu-id="41e93-110">所有 ASP.NET 服务器控件都包括`ID`属性，用于唯一标识该控件并是依据此控件以编程方式访问中的代码隐藏类的方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-110">All ASP.NET server controls include an `ID` property that uniquely identifies the control and is the means by which the control is programmatically accessed in the code-behind class.</span></span> <span data-ttu-id="41e93-111">同样，在 HTML 文档中的元素可能包括`id`唯一标识此元素的属性; 这些`id`值通常用于在客户端脚本中以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="41e93-111">Similarly, the elements in an HTML document may include an `id` attribute that uniquely identifies the element; these `id` values are often used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="41e93-112">鉴于此，你可能假设的 ASP.NET 服务器控件呈现为 HTML，其`ID`值将用作`id`呈现的 HTML 元素的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-112">Given this, you may assume that when an ASP.NET server control is rendered into HTML, its `ID` value is used as the `id` value of the rendered HTML element.</span></span> <span data-ttu-id="41e93-113">这不一定是这种情况因为在某些情况下一个控制与单个`ID`值可能会多次出现在呈现的标记。</span><span class="sxs-lookup"><span data-stu-id="41e93-113">This is not necessarily the case because in certain circumstances a single control with a single `ID` value may appear multiple times in the rendered markup.</span></span> <span data-ttu-id="41e93-114">请考虑 GridView 控件包含与标签 Web 控件使用 TemplateField`ID`的值`ProductName`。</span><span class="sxs-lookup"><span data-stu-id="41e93-114">Consider a GridView control that includes a TemplateField with a Label Web control with an `ID` value of `ProductName`.</span></span> <span data-ttu-id="41e93-115">在 GridView 绑定到其数据源在运行时，此标签将对每个 GridView 行一次重复。</span><span class="sxs-lookup"><span data-stu-id="41e93-115">When the GridView is bound to its data source at runtime, this Label is repeated once for every GridView row.</span></span> <span data-ttu-id="41e93-116">每个呈现标签需求的唯一`id`值。</span><span class="sxs-lookup"><span data-stu-id="41e93-116">Each rendered Label needs a unique `id` value.</span></span>

<span data-ttu-id="41e93-117">若要处理这种情况下，ASP.NET 允许某些控件表示为命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-117">To handle such scenarios, ASP.NET allows certain controls to be denoted as naming containers.</span></span> <span data-ttu-id="41e93-118">命名容器将用作新`ID`命名空间。</span><span class="sxs-lookup"><span data-stu-id="41e93-118">A naming container serves as a new `ID` namespace.</span></span> <span data-ttu-id="41e93-119">所有服务器控件的命名容器内显示都具有其呈现`id`值带有前缀`ID`命名的容器控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-119">Any server controls that appear within the naming container have their rendered `id` value prefixed with the `ID` of the naming container control.</span></span> <span data-ttu-id="41e93-120">例如，`GridView`和`GridViewRow`类都是命名的容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-120">For example, the `GridView` and `GridViewRow` classes are both naming containers.</span></span> <span data-ttu-id="41e93-121">因此，在使用 GridView TemplateField 中定义的标签控件`ID``ProductName`给定呈现`id`的值`GridViewID_GridViewRowID_ProductName`。</span><span class="sxs-lookup"><span data-stu-id="41e93-121">Consequently, a Label control defined in a GridView TemplateField with `ID` `ProductName` is given a rendered `id` value of `GridViewID_GridViewRowID_ProductName`.</span></span> <span data-ttu-id="41e93-122">因为*GridViewRowID*是唯一的每个 GridView 行，生成`id`值是唯一的。</span><span class="sxs-lookup"><span data-stu-id="41e93-122">Because *GridViewRowID* is unique for each GridView row, the resulting `id` values are unique.</span></span>

> [!NOTE]
> <span data-ttu-id="41e93-123">[ `INamingContainer`接口](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx)用于指示特定的 ASP.NET 服务器控件应充当命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-123">The [`INamingContainer` interface](https://msdn.microsoft.com/library/system.web.ui.inamingcontainer.aspx) is used to indicate that a particular ASP.NET server control should function as a naming container.</span></span> <span data-ttu-id="41e93-124">`INamingContainer`接口不会不拼写出任何服务器控件必须实现的方法; 而是使用作为的标记。</span><span class="sxs-lookup"><span data-stu-id="41e93-124">The `INamingContainer` interface does not spell out any methods that the server control must implement; rather, it's used as a marker.</span></span> <span data-ttu-id="41e93-125">在生成呈现的标记，如果某个控件实现此接口然后 ASP.NET 引擎自动添加前缀及其`ID`其子的值呈现`id`属性值。</span><span class="sxs-lookup"><span data-stu-id="41e93-125">In generating the rendered markup, if a control implements this interface then the ASP.NET engine automatically prefixes its `ID` value to its descendents' rendered `id` attribute values.</span></span> <span data-ttu-id="41e93-126">在步骤 2 中的更详细地介绍此过程。</span><span class="sxs-lookup"><span data-stu-id="41e93-126">This process is discussed in more detail in Step 2.</span></span>


<span data-ttu-id="41e93-127">命名容器不只更改呈现`id`属性值，但也会影响如何控件可能以编程方式从引用 ASP.NET 页面的代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="41e93-127">Naming containers not only change the rendered `id` attribute value, but also affect how the control may be programmatically referenced from the ASP.NET page's code-behind class.</span></span> <span data-ttu-id="41e93-128">`FindControl("controlID")`方法通常用于以编程方式引用的 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-128">The `FindControl("controlID")` method is commonly used to programmatically reference a Web control.</span></span> <span data-ttu-id="41e93-129">但是，`FindControl`不入侵通过命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-129">However, `FindControl` does not penetrate through naming containers.</span></span> <span data-ttu-id="41e93-130">因此，不能直接使用`Page.FindControl`方法来引用 GridView 或其他命名容器中的控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-130">Consequently, you cannot directly use the `Page.FindControl` method to reference controls within a GridView or other naming container.</span></span>

<span data-ttu-id="41e93-131">你可能已猜测到的如母版页和 Contentplaceholder 同时实现为容器命名。</span><span class="sxs-lookup"><span data-stu-id="41e93-131">As you may have surmised, master pages and ContentPlaceHolders are both implemented as naming containers.</span></span> <span data-ttu-id="41e93-132">在本教程中我们介绍如何 master pages 影响 HTML 元素`id`值和方法来以编程方式引用 Web 控件中内容页使用`FindControl`。</span><span class="sxs-lookup"><span data-stu-id="41e93-132">In this tutorial we examine how master pages affect HTML element `id` values and ways to programmatically reference Web controls within a content page using `FindControl`.</span></span>

## <a name="step-1-adding-a-new-aspnet-page"></a><span data-ttu-id="41e93-133">步骤 1：添加一个新的 ASP.NET 页</span><span class="sxs-lookup"><span data-stu-id="41e93-133">Step 1: Adding a New ASP.NET Page</span></span>

<span data-ttu-id="41e93-134">为了演示在本教程中讨论的概念，让我们将一个新的 ASP.NET 页面添加到我们的网站。</span><span class="sxs-lookup"><span data-stu-id="41e93-134">To demonstrate the concepts discussed in this tutorial, let's add a new ASP.NET page to our website.</span></span> <span data-ttu-id="41e93-135">创建一个名为的新内容页`IDIssues.aspx`在根文件夹中，将其绑定到`Site.master`母版页。</span><span class="sxs-lookup"><span data-stu-id="41e93-135">Create a new content page named `IDIssues.aspx` in the root folder, binding it to the `Site.master` master page.</span></span>


![将内容页 IDIssues.aspx 添加到根文件夹](control-id-naming-in-content-pages-vb/_static/image1.png)

<span data-ttu-id="41e93-137">**图 01**:添加内容页`IDIssues.aspx`的根文件夹</span><span class="sxs-lookup"><span data-stu-id="41e93-137">**Figure 01**: Add the Content Page `IDIssues.aspx` to the Root Folder</span></span>


<span data-ttu-id="41e93-138">Visual Studio 自动为每个母版页的四个 Contentplaceholder 创建内容控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-138">Visual Studio automatically creates a Content control for each of the master page's four ContentPlaceHolders.</span></span> <span data-ttu-id="41e93-139">如中所述[*多个 Contentplaceholder 和默认内容*](multiple-contentplaceholders-and-default-content-vb.md)教程中，如果内容控件不存在主页面的默认 ContentPlaceHolder 内容，将改为发出。</span><span class="sxs-lookup"><span data-stu-id="41e93-139">As noted in the [*Multiple ContentPlaceHolders and Default Content*](multiple-contentplaceholders-and-default-content-vb.md) tutorial, if a Content control is not present the master page's default ContentPlaceHolder content is emitted instead.</span></span> <span data-ttu-id="41e93-140">因为`QuickLoginUI`并`LeftColumnContent`Contentplaceholder 包含此页的合适的默认标记、 继续和删除其相应的内容控件从`IDIssues.aspx`。</span><span class="sxs-lookup"><span data-stu-id="41e93-140">Because the `QuickLoginUI` and `LeftColumnContent` ContentPlaceHolders contain suitable default markup for this page, go ahead and remove their corresponding Content controls from `IDIssues.aspx`.</span></span> <span data-ttu-id="41e93-141">此时，内容页的声明性标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="41e93-141">At this point, the content page's declarative markup should look like the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample1.aspx)]

<span data-ttu-id="41e93-142">在中[*母版页中指定的标题、 元标记和其他 HTML 标头*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md)教程中，我们创建一个自定义基本页类 (`BasePage`)，它是否会自动配置页面的标题未显式设置。</span><span class="sxs-lookup"><span data-stu-id="41e93-142">In the [*Specifying the Title, Meta Tags, and Other HTML Headers in the Master Page*](specifying-the-title-meta-tags-and-other-html-headers-in-the-master-page-vb.md) tutorial we created a custom base page class (`BasePage`) that automatically configures the page's title if it is not explicitly set.</span></span> <span data-ttu-id="41e93-143">有关`IDIssues.aspx`页上使用此功能，该页面的代码隐藏类必须派生自`BasePage`类 (而不是`System.Web.UI.Page`)。</span><span class="sxs-lookup"><span data-stu-id="41e93-143">For the `IDIssues.aspx` page to employ this functionality, the page's code-behind class must derive from the `BasePage` class (instead of `System.Web.UI.Page`).</span></span> <span data-ttu-id="41e93-144">修改代码隐藏类的定义，使它看起来如下所示：</span><span class="sxs-lookup"><span data-stu-id="41e93-144">Modify the code-behind class's definition so that it looks like the following:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample2.vb)]

<span data-ttu-id="41e93-145">最后，更新`Web.sitemap`文件以便包括本课程中新建一个条目。</span><span class="sxs-lookup"><span data-stu-id="41e93-145">Finally, update the `Web.sitemap` file to include an entry for this new lesson.</span></span> <span data-ttu-id="41e93-146">添加`<siteMapNode>`元素，并设置其`title`并`url`属性为"控件 ID 命名问题"和`~/IDIssues.aspx`分别。</span><span class="sxs-lookup"><span data-stu-id="41e93-146">Add a `<siteMapNode>` element and set its `title` and `url` attributes to "Control ID Naming Issues" and `~/IDIssues.aspx`, respectively.</span></span> <span data-ttu-id="41e93-147">进行此添加后你`Web.sitemap`文件的标记应如下所示：</span><span class="sxs-lookup"><span data-stu-id="41e93-147">After making this addition your `Web.sitemap` file's markup should look similar to the following:</span></span>


[!code-xml[Main](control-id-naming-in-content-pages-vb/samples/sample3.xml)]

<span data-ttu-id="41e93-148">如图 2 所示，在新的站点映射条目`Web.sitemap`立即反映在左侧列中的课程部分。</span><span class="sxs-lookup"><span data-stu-id="41e93-148">As Figure 2 illustrates, the new site map entry in `Web.sitemap` is immediately reflected in the Lessons section in the left column.</span></span>


![课程部分现在包括一个指向&quot;控件 ID 命名问题&quot;](control-id-naming-in-content-pages-vb/_static/image2.png)

<span data-ttu-id="41e93-150">**图 02**:课程部分现在包含"控件 ID 命名问题"的链接</span><span class="sxs-lookup"><span data-stu-id="41e93-150">**Figure 02**: The Lessons Section Now Includes a Link to "Control ID Naming Issues"</span></span>


## <a name="step-2-examining-the-renderedidchanges"></a><span data-ttu-id="41e93-151">步骤 2：检查呈现`ID`更改</span><span class="sxs-lookup"><span data-stu-id="41e93-151">Step 2: Examining the Rendered`ID`Changes</span></span>

<span data-ttu-id="41e93-152">若要更好地了解所做的修改 ASP.NET 向呈现引擎发出`id`server 的值控制，让我们添加到的几个 Web 控件`IDIssues.aspx`页上，然后查看呈现的标记发送到浏览器。</span><span class="sxs-lookup"><span data-stu-id="41e93-152">To better understand the modifications the ASP.NET engine makes to the rendered `id` values of server controls, let's add a few Web controls to the `IDIssues.aspx` page and then view the rendered markup sent to the browser.</span></span> <span data-ttu-id="41e93-153">具体而言，在文本中的类型"请输入你的年龄:"跟 TextBox Web 控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-153">Specifically, type in the text "Please enter your age:" followed by a TextBox Web control.</span></span> <span data-ttu-id="41e93-154">进一步向下的页上添加一个按钮 Web 控件和标签 Web 控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-154">Further down on the page add a Button Web control and a Label Web control.</span></span> <span data-ttu-id="41e93-155">设置文本框的`ID`并`Columns`属性设置为`Age`和 3，分别。</span><span class="sxs-lookup"><span data-stu-id="41e93-155">Set the TextBox's `ID` and `Columns` properties to `Age` and 3, respectively.</span></span> <span data-ttu-id="41e93-156">设置按钮的`Text`并`ID`属性设置为"提交"和`SubmitButton`。</span><span class="sxs-lookup"><span data-stu-id="41e93-156">Set the Button's `Text` and `ID` properties to "Submit" and `SubmitButton`.</span></span> <span data-ttu-id="41e93-157">清除的标签`Text`属性并设置其`ID`到`Results`。</span><span class="sxs-lookup"><span data-stu-id="41e93-157">Clear out the Label's `Text` property and set its `ID` to `Results`.</span></span>

<span data-ttu-id="41e93-158">此时内容控件的声明性标记应类似于下面：</span><span class="sxs-lookup"><span data-stu-id="41e93-158">At this point your Content control's declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](control-id-naming-in-content-pages-vb/samples/sample4.aspx)]

<span data-ttu-id="41e93-159">图 3 显示了通过 Visual Studio 设计器进行查看时页。</span><span class="sxs-lookup"><span data-stu-id="41e93-159">Figure 3 shows the page when viewed through Visual Studio's designer.</span></span>


[![T<span data-ttu-id="41e93-160">他页包含三个 Web 控件： 文本框、 按钮和标签]</span><span class="sxs-lookup"><span data-stu-id="41e93-160">he Page Includes Three Web Controls: a TextBox, Button, and Label]</span></span>(control-id-naming-in-content-pages-vb/_static/image4.png)](control-id-naming-in-content-pages-vb/_static/image3.png)

<span data-ttu-id="41e93-161">**图 03**:页包含三个 Web 控件： 文本框、 按钮和标签 ([单击此项可查看原尺寸图像](control-id-naming-in-content-pages-vb/_static/image5.png))</span><span class="sxs-lookup"><span data-stu-id="41e93-161">**Figure 03**: The Page Includes Three Web Controls: a TextBox, Button, and Label  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image5.png))</span></span>


<span data-ttu-id="41e93-162">访问通过浏览器页面，然后查看 HTML 源。</span><span class="sxs-lookup"><span data-stu-id="41e93-162">Visit the page through a browser and then view the HTML source.</span></span> <span data-ttu-id="41e93-163">以下标记显示，作为`id`文本框、 按钮和标签 Web 控件的 HTML 元素的值的多种`ID`Web 控件的值和`ID`页中的命名容器的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-163">As the markup below shows, the `id` values of the HTML elements for the TextBox, Button, and Label Web controls are a combination of the `ID` values of the Web controls and the `ID` values of the naming containers in the page.</span></span>


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample5.html)]

<span data-ttu-id="41e93-164">正如本教程前面部分所述，母版页和其 Contentplaceholder 作为命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-164">As noted earlier in this tutorial, both the master page and its ContentPlaceHolders serve as naming containers.</span></span> <span data-ttu-id="41e93-165">因此，同时参与呈现`ID`其嵌套的控件的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-165">Consequently, both contribute the rendered `ID` values of their nested controls.</span></span> <span data-ttu-id="41e93-166">采用文本框的`id`属性，例如： `ctl00_MainContent_Age`。</span><span class="sxs-lookup"><span data-stu-id="41e93-166">Take the TextBox's `id` attribute, for instance: `ctl00_MainContent_Age`.</span></span> <span data-ttu-id="41e93-167">请记住，TextBox 控件`ID`的值为`Age`。</span><span class="sxs-lookup"><span data-stu-id="41e93-167">Recall that the TextBox control's `ID` value was `Age`.</span></span> <span data-ttu-id="41e93-168">这其 ContentPlaceHolder 控件的带有前缀`ID`值， `MainContent`。</span><span class="sxs-lookup"><span data-stu-id="41e93-168">This is prefixed with its ContentPlaceHolder control's `ID` value, `MainContent`.</span></span> <span data-ttu-id="41e93-169">此外，此值以前缀与母版页`ID`值， `ctl00`。</span><span class="sxs-lookup"><span data-stu-id="41e93-169">Furthermore, this value is prefixed with the master page's `ID` value, `ctl00`.</span></span> <span data-ttu-id="41e93-170">实际效果是`id`属性值，其中包括`ID`母版页、 ContentPlaceHolder 控件和文本框本身的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-170">The net effect is an `id` attribute value consisting of the `ID` values of the master page, the ContentPlaceHolder control, and the TextBox itself.</span></span>

<span data-ttu-id="41e93-171">图 4 说明了此行为。</span><span class="sxs-lookup"><span data-stu-id="41e93-171">Figure 4 illustrates this behavior.</span></span> <span data-ttu-id="41e93-172">若要确定呈现`id`的`Age`文本框中，使用启动`ID`值的文本框控件， `Age`。</span><span class="sxs-lookup"><span data-stu-id="41e93-172">To determine the rendered `id` of the `Age` TextBox, start with the `ID` value of the TextBox control, `Age`.</span></span> <span data-ttu-id="41e93-173">接下来，努力完善控件层次结构。</span><span class="sxs-lookup"><span data-stu-id="41e93-173">Next, work your way up the control hierarchy.</span></span> <span data-ttu-id="41e93-174">在每个命名容器 （桃色颜色与这些节点），前缀呈现当前`id`使用的命名容器`id`。</span><span class="sxs-lookup"><span data-stu-id="41e93-174">At each naming container (those nodes with a peach color), prefix the current rendered `id` with the naming container's `id`.</span></span>


![Rendered id 属性是基于上 ID 值的命名容器](control-id-naming-in-content-pages-vb/_static/image6.png)

<span data-ttu-id="41e93-176">**图 04**:Rendered`id`属性是基于上`ID`命名容器的值</span><span class="sxs-lookup"><span data-stu-id="41e93-176">**Figure 04**: The Rendered `id` Attributes are Based On the `ID` Values of the Naming Containers</span></span>


> [!NOTE]
> <span data-ttu-id="41e93-177">如我们所述，`ctl00`部分呈现`id`属性构成`ID`值的主页上，但你可能想知道如何将此`ID`值的灵感。</span><span class="sxs-lookup"><span data-stu-id="41e93-177">As we discussed, the `ctl00` portion of the rendered `id` attribute constitutes the `ID` value of the master page, but you may be wondering how this `ID` value came about.</span></span> <span data-ttu-id="41e93-178">我们未指定其任意位置在我们的主数据库或内容页面中。</span><span class="sxs-lookup"><span data-stu-id="41e93-178">We did not specify it anywhere in our master or content page.</span></span> <span data-ttu-id="41e93-179">ASP.NET 页面中的大多数服务器控件通过页面的声明性标记显式添加。</span><span class="sxs-lookup"><span data-stu-id="41e93-179">Most server controls in an ASP.NET page are added explicitly through the page's declarative markup.</span></span> <span data-ttu-id="41e93-180">`MainContent`的标记中显式指定 ContentPlaceHolder 控件`Site.master`;`Age`文本框中已定义`IDIssues.aspx`的标记。</span><span class="sxs-lookup"><span data-stu-id="41e93-180">The `MainContent` ContentPlaceHolder control was explicitly specified in the markup of `Site.master`; the `Age` TextBox was defined `IDIssues.aspx`'s markup.</span></span> <span data-ttu-id="41e93-181">我们可以指定`ID`这些控件通过属性窗口或从声明性语法类型的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-181">We can specify the `ID` values for these types of controls through the Properties window or from the declarative syntax.</span></span> <span data-ttu-id="41e93-182">声明性标记中未定义其他控件，主页面本身，所示。</span><span class="sxs-lookup"><span data-stu-id="41e93-182">Other controls, like the master page itself, are not defined in the declarative markup.</span></span> <span data-ttu-id="41e93-183">因此，其`ID`值必须为我们自动生成。</span><span class="sxs-lookup"><span data-stu-id="41e93-183">Consequently, their `ID` values must be automatically generated for us.</span></span> <span data-ttu-id="41e93-184">ASP.NET 引擎集`ID`在运行时对其 Id 未显式设置这些控件的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-184">The ASP.NET engine sets the `ID` values at runtime for those controls whose IDs have not been explicitly set.</span></span> <span data-ttu-id="41e93-185">它使用的命名模式`ctlXX`，其中*XX*是按顺序递增的整数值。</span><span class="sxs-lookup"><span data-stu-id="41e93-185">It uses the naming pattern `ctlXX`, where *XX* is a sequentially increasing integer value.</span></span>


<span data-ttu-id="41e93-186">主页面本身中提供的命名容器，因为在母版页中定义的 Web 控件也已更改呈现`id`属性值。</span><span class="sxs-lookup"><span data-stu-id="41e93-186">Because the master page itself serves as a naming container, the Web controls defined in the master page also have altered rendered `id` attribute values.</span></span> <span data-ttu-id="41e93-187">例如，`DisplayDate`标签，我们添加到中的母版页[*使用母版页创建站点范围内布局*](creating-a-site-wide-layout-using-master-pages-vb.md)教程具有以下呈现标记：</span><span class="sxs-lookup"><span data-stu-id="41e93-187">For example, the `DisplayDate` Label we added to the master page in the [*Creating a Site-Wide Layout with Master Pages*](creating-a-site-wide-layout-using-master-pages-vb.md) tutorial has the following rendered markup:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample6.html)]

<span data-ttu-id="41e93-188">请注意，`id`属性包含这两个主页面的`ID`值 (`ctl00`) 和`ID`标签 Web 控件的值 (`DateDisplay`)。</span><span class="sxs-lookup"><span data-stu-id="41e93-188">Note that the `id` attribute includes both the master page's `ID` value (`ctl00`) and the `ID` value of the Label Web control (`DateDisplay`).</span></span>

## <a name="step-3-programmatically-referencing-web-controls-viafindcontrol"></a><span data-ttu-id="41e93-189">步骤 3：以编程方式引用通过 Web 控件`FindControl`</span><span class="sxs-lookup"><span data-stu-id="41e93-189">Step 3: Programmatically Referencing Web Controls via`FindControl`</span></span>

<span data-ttu-id="41e93-190">每个 ASP.NET 服务器控件包含`FindControl("controlID")`方法搜索名为的控件的控件的后代*controlID*。</span><span class="sxs-lookup"><span data-stu-id="41e93-190">Every ASP.NET server control includes a `FindControl("controlID")` method that searches the control's descendents for a control named *controlID*.</span></span> <span data-ttu-id="41e93-191">如果找到这样的控件，则返回;如果不找到任何匹配控件，则`FindControl`返回`Nothing`。</span><span class="sxs-lookup"><span data-stu-id="41e93-191">If such a control is found, it is returned; if no matching control is found, `FindControl` returns `Nothing`.</span></span>

`FindControl` <span data-ttu-id="41e93-192">在所需的访问控制，但没有对它的直接引用方案中非常有用。</span><span class="sxs-lookup"><span data-stu-id="41e93-192">is useful in scenarios where you need to access a control but you don't have a direct reference to it.</span></span> <span data-ttu-id="41e93-193">在 GridView 的字段中的控件时使用的数据 Web 控件，如 GridView，例如，在声明性语法中，一次定义但在运行时控件的实例创建的每个 GridView 行。</span><span class="sxs-lookup"><span data-stu-id="41e93-193">When working with data Web controls like the GridView, for example, the controls within the GridView's fields are defined once in the declarative syntax, but at runtime an instance of the control is created for each GridView row.</span></span> <span data-ttu-id="41e93-194">因此，在运行时生成的控件存在，但我们不提供可从代码隐藏类的直接引用。</span><span class="sxs-lookup"><span data-stu-id="41e93-194">Consequently, the controls generated at runtime exist, but we do not have a direct reference available from the code-behind class.</span></span> <span data-ttu-id="41e93-195">因此我们需要使用`FindControl`以编程方式使用 GridView 的字段内的特定控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-195">As a result we need to use `FindControl` to programmatically work with a specific control within the GridView's fields.</span></span> <span data-ttu-id="41e93-196">(有关使用的详细信息`FindControl`若要访问的数据 Web 控件模板中的控件，请参阅[自定义格式设置基于数据的](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md)。)动态地将 Web 控件添加到 Web 窗体时发生这同一情况下，本主题中所述[创建动态数据输入用户界面](https://msdn.microsoft.com/library/aa479330.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41e93-196">(For more information on using `FindControl` to access the controls within a data Web control's templates, see [Custom Formatting Based Upon Data](../../data-access/custom-formatting/custom-formatting-based-upon-data-vb.md).) This same scenario occurs when dynamically adding Web controls to a Web Form, a topic discussed in [Creating Dynamic Data Entry User Interfaces](https://msdn.microsoft.com/library/aa479330.aspx).</span></span>

<span data-ttu-id="41e93-197">若要演示如何使用`FindControl`方法搜索内容页中的控件创建的事件处理程序`SubmitButton`的`Click`事件。</span><span class="sxs-lookup"><span data-stu-id="41e93-197">To illustrate using the `FindControl` method to search for controls within a content page, create an event handler for the `SubmitButton`'s `Click` event.</span></span> <span data-ttu-id="41e93-198">事件处理程序中，添加以下代码，以编程方式引用`Age`文本框中并`Results`标签使用`FindControl`方法，然后显示一条消息中的`Results`基于用户的输入。</span><span class="sxs-lookup"><span data-stu-id="41e93-198">In the event handler, add the following code, which programmatically references the `Age` TextBox and `Results` Label using the `FindControl` method and then displays a message in `Results` based on the user's input.</span></span>

> [!NOTE]
> <span data-ttu-id="41e93-199">当然，我们无需使用`FindControl`以引用此示例中的标签和文本框控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-199">Of course, we don't need to use `FindControl` to reference the Label and TextBox controls for this example.</span></span> <span data-ttu-id="41e93-200">我们可以引用它们直接通过其`ID`属性值。</span><span class="sxs-lookup"><span data-stu-id="41e93-200">We could reference them directly via their `ID` property values.</span></span> <span data-ttu-id="41e93-201">我使用`FindControl`这里要说明使用时，会发生什么情况`FindControl`从内容页。</span><span class="sxs-lookup"><span data-stu-id="41e93-201">I use `FindControl` here to illustrate what happens when using `FindControl` from a content page.</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample7.vb)]

<span data-ttu-id="41e93-202">尽管用来调用的语法`FindControl`方法会稍有不同的前两行`SubmitButton_Click`，它们在语义上等效。</span><span class="sxs-lookup"><span data-stu-id="41e93-202">While the syntax used to call the `FindControl` method differs slightly in the first two lines of `SubmitButton_Click`, they are semantically equivalent.</span></span> <span data-ttu-id="41e93-203">回想一下，所有 ASP.NET 服务器控件都包括`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-203">Recall that all ASP.NET server controls include a `FindControl` method.</span></span> <span data-ttu-id="41e93-204">这包括`Page`从所有 ASP.NET 代码隐藏类必须派生自的类。</span><span class="sxs-lookup"><span data-stu-id="41e93-204">This includes the `Page` class, from which all ASP.NET code-behind classes must derive from.</span></span> <span data-ttu-id="41e93-205">因此，调用`FindControl("controlID")`等效于调用`Page.FindControl("controlID")`，假定尚未重写`FindControl`方法中代码隐藏类或自定义基类中。</span><span class="sxs-lookup"><span data-stu-id="41e93-205">Therefore, calling `FindControl("controlID")` is equivalent to calling `Page.FindControl("controlID")`, assuming you haven't overridden the `FindControl` method in your code-behind class or in a custom base class.</span></span>

<span data-ttu-id="41e93-206">后输入此代码，请访问`IDIssues.aspx`通过浏览器页上，输入你的年龄，然后单击"提交"按钮。</span><span class="sxs-lookup"><span data-stu-id="41e93-206">After entering this code, visit the `IDIssues.aspx` page through a browser, enter your age, and click the "Submit" button.</span></span> <span data-ttu-id="41e93-207">单击"提交"按钮时`NullReferenceException`引发 （请参见图 5）。</span><span class="sxs-lookup"><span data-stu-id="41e93-207">Upon clicking the "Submit" button a `NullReferenceException` is raised (see Figure 5).</span></span>


[![A <span data-ttu-id="41e93-208">引发 NullReferenceException]</span><span class="sxs-lookup"><span data-stu-id="41e93-208">NullReferenceException is Raised]</span></span>(control-id-naming-in-content-pages-vb/_static/image8.png)](control-id-naming-in-content-pages-vb/_static/image7.png)

<span data-ttu-id="41e93-209">**图 05**:一个`NullReferenceException`引发 ([单击以查看实际尺寸的图像](control-id-naming-in-content-pages-vb/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="41e93-209">**Figure 05**: A `NullReferenceException` is Raised  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image9.png))</span></span>


<span data-ttu-id="41e93-210">如果在中设置断点`SubmitButton_Click`事件处理程序会同时调用`FindControl`返回`Nothing`。</span><span class="sxs-lookup"><span data-stu-id="41e93-210">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that both calls to `FindControl` return `Nothing`.</span></span> <span data-ttu-id="41e93-211">`NullReferenceException`我们尝试访问时，将引发`Age`文本框的`Text`属性。</span><span class="sxs-lookup"><span data-stu-id="41e93-211">The `NullReferenceException` is raised when we attempt to access the `Age` TextBox's `Text` property.</span></span>

<span data-ttu-id="41e93-212">问题在于`Control.FindControl`仅搜索*控制*的相同的命名容器中的后代。</span><span class="sxs-lookup"><span data-stu-id="41e93-212">The problem is that `Control.FindControl` only searches *Control*'s descendents that are in the same naming container.</span></span> <span data-ttu-id="41e93-213">因为主页面构成新的命名容器，调用`Page.FindControl("controlID")`永远不会 permeates 母版页对象`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="41e93-213">Because the master page constitutes a new naming container, a call to `Page.FindControl("controlID")` never permeates the master page object `ctl00`.</span></span> <span data-ttu-id="41e93-214">(图 4，若要查看的控件层次结构，其中显示了将回指`Page`对象作为主页面对象的父对象`ctl00`。)因此，`Results`标签并`Age`找不到文本框中并`ResultsLabel`并`AgeTextBox`分配的值`Nothing`。</span><span class="sxs-lookup"><span data-stu-id="41e93-214">(Refer back to Figure 4 to view the control hierarchy, which shows the `Page` object as the parent of the master page object `ctl00`.) Therefore, the `Results` Label and `Age` TextBox are not found and `ResultsLabel` and `AgeTextBox` are assigned values of `Nothing`.</span></span>

<span data-ttu-id="41e93-215">有两个到这一难题的解决方法： 我们可以向下钻取，一个命名的容器一次，于相应的控件;或者，我们可以创建我们自己`FindControl`permeates 命名容器的方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-215">There are two workarounds to this challenge: we can drill down, one naming container at a time, to the appropriate control; or we can create our own `FindControl` method that permeates naming containers.</span></span> <span data-ttu-id="41e93-216">让我们检查每个选项。</span><span class="sxs-lookup"><span data-stu-id="41e93-216">Let's examine each of these options.</span></span>

### <a name="drilling-into-the-appropriate-naming-container"></a><span data-ttu-id="41e93-217">钻取到相应的命名容器</span><span class="sxs-lookup"><span data-stu-id="41e93-217">Drilling Into the Appropriate Naming Container</span></span>

<span data-ttu-id="41e93-218">若要使用`FindControl`引用`Results`标签或`Age`文本框中，我们需要调用`FindControl`从相同的命名容器中的一个祖先控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-218">To use `FindControl` to reference the `Results` Label or `Age` TextBox, we need to call `FindControl` from an ancestor control in the same naming container.</span></span> <span data-ttu-id="41e93-219">图 4 显示了，如`MainContent`ContentPlaceHolder 控件是唯一的祖先`Results`或`Age`的是同一个命名容器中。</span><span class="sxs-lookup"><span data-stu-id="41e93-219">As Figure 4 showed, the `MainContent` ContentPlaceHolder control is the only ancestor of `Results` or `Age` that is within the same naming container.</span></span> <span data-ttu-id="41e93-220">换而言之，调用`FindControl`方法从`MainContent`控件，如下面的代码段中所示将正确返回对引用`Results`或`Age`控件。</span><span class="sxs-lookup"><span data-stu-id="41e93-220">In other words, calling the `FindControl` method from the `MainContent` control, as shown in the code snippet below, correctly returns a reference to the `Results` or `Age` controls.</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample8.vb)]

<span data-ttu-id="41e93-221">但是，我们不能使用`MainContent`ContentPlaceHolder 从使用上面的语法，因为在母版页中定义 ContentPlaceHolder 我们内容页面的代码隐藏类。</span><span class="sxs-lookup"><span data-stu-id="41e93-221">However, we cannot work with the `MainContent` ContentPlaceHolder from our content page's code-behind class using the above syntax because the ContentPlaceHolder is defined in the master page.</span></span> <span data-ttu-id="41e93-222">相反，我们必须使用`FindControl`来获取对引用`MainContent`。</span><span class="sxs-lookup"><span data-stu-id="41e93-222">Instead, we have to use `FindControl` to get a reference to `MainContent`.</span></span> <span data-ttu-id="41e93-223">中的代码替换为`SubmitButton_Click`事件处理程序并进行以下修改：</span><span class="sxs-lookup"><span data-stu-id="41e93-223">Replace the code in the `SubmitButton_Click` event handler with the following modifications:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample9.vb)]

<span data-ttu-id="41e93-224">如果在访问通过浏览器页面，输入您的年龄，然后单击"提交"按钮，`NullReferenceException`引发。</span><span class="sxs-lookup"><span data-stu-id="41e93-224">If you visit the page through a browser, enter your age, and click the "Submit" button, a `NullReferenceException` is raised.</span></span> <span data-ttu-id="41e93-225">如果在中设置断点`SubmitButton_Click`事件处理程序会尝试进行调用时，会发生此异常`MainContent`对象的`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-225">If you set a breakpoint in the `SubmitButton_Click` event handler you will see that this exception occurs when attempting to call the `MainContent` object's `FindControl` method.</span></span> <span data-ttu-id="41e93-226">`MainContent`对象是否等于`Nothing`因为`FindControl`方法找不到名为"主要内容"的对象。</span><span class="sxs-lookup"><span data-stu-id="41e93-226">The `MainContent` object is equal to `Nothing` because the `FindControl` method cannot locate an object named "MainContent".</span></span> <span data-ttu-id="41e93-227">根本原因是与相同`Results`标签并`Age`TextBox 控件：`FindControl`从控件层次结构的顶部开始其搜索，并不入侵命名容器，但`MainContent`ContentPlaceHolder 是在主页上，这是命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-227">The underlying reason is the same as with the `Results` Label and `Age` TextBox controls: `FindControl` starts its search from the top of the control hierarchy and does not penetrate naming containers, but the `MainContent` ContentPlaceHolder is within the master page, which is a naming container.</span></span>

<span data-ttu-id="41e93-228">我们可以使用之前`FindControl`来获取对引用`MainContent`，我们首先需要对主页面控件的引用。</span><span class="sxs-lookup"><span data-stu-id="41e93-228">Before we can use `FindControl` to get a reference to `MainContent`, we first need a reference to the master page control.</span></span> <span data-ttu-id="41e93-229">母版页引用后我们可以获取对的引用`MainContent`通过 ContentPlaceHolder`FindControl`并从那里，引用`Results`标签和`Age`文本框中 (同样，通过使用`FindControl`)。</span><span class="sxs-lookup"><span data-stu-id="41e93-229">Once we have a reference to the master page we can get a reference to the `MainContent` ContentPlaceHolder via `FindControl` and, from there, references to the `Results` Label and `Age` TextBox (again, through using `FindControl`).</span></span> <span data-ttu-id="41e93-230">但是，我们如何获取对母版页的引用？</span><span class="sxs-lookup"><span data-stu-id="41e93-230">But how do we get a reference to the master page?</span></span> <span data-ttu-id="41e93-231">通过检查`id`呈现的标记中的属性是显而易见的主页面`ID`值是`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="41e93-231">By inspecting the `id` attributes in the rendered markup it's evident that the master page's `ID` value is `ctl00`.</span></span> <span data-ttu-id="41e93-232">因此，我们可以使用`Page.FindControl("ctl00")`若要获取对母版页的引用，然后使用该对象获取对引用`MainContent`，依次类推。</span><span class="sxs-lookup"><span data-stu-id="41e93-232">Therefore, we could use `Page.FindControl("ctl00")` to get a reference to the master page, then use that object to get a reference to `MainContent`, and so on.</span></span> <span data-ttu-id="41e93-233">以下代码片段说明了此逻辑：</span><span class="sxs-lookup"><span data-stu-id="41e93-233">The following snippet illustrates this logic:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample10.vb)]

<span data-ttu-id="41e93-234">尽管此代码也肯定可以生效，它假定主页面的自动生成`ID`始终为`ctl00`。</span><span class="sxs-lookup"><span data-stu-id="41e93-234">While this code will certainly work, it assumes that the master page's autogenerated `ID` will always be `ctl00`.</span></span> <span data-ttu-id="41e93-235">它永远不会是一个好办法使有关自动生成值的假设。</span><span class="sxs-lookup"><span data-stu-id="41e93-235">It's never a good idea to make assumptions about autogenerated values.</span></span>

<span data-ttu-id="41e93-236">幸运的是，对母版页的引用是可通过访问`Page`类的`Master`属性。</span><span class="sxs-lookup"><span data-stu-id="41e93-236">Fortunately, a reference to the master page is accessible through the `Page` class's `Master` property.</span></span> <span data-ttu-id="41e93-237">因此，而无需使用`FindControl("ctl00")`若要获取母版页的引用，以便访问`MainContent`ContentPlaceHolder，我们可以改为使用`Page.Master.FindControl("MainContent")`。</span><span class="sxs-lookup"><span data-stu-id="41e93-237">Therefore, instead of having to use `FindControl("ctl00")` to get a reference of the master page in order to access the `MainContent` ContentPlaceHolder, we can instead use `Page.Master.FindControl("MainContent")`.</span></span> <span data-ttu-id="41e93-238">更新`SubmitButton_Click`事件处理程序使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="41e93-238">Update the `SubmitButton_Click` event handler with the following code:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample11.vb)]

<span data-ttu-id="41e93-239">这一次，访问该网页通过浏览器中，输入你的年龄，然后单击"提交"按钮显示在消息`Results`标签、 按预期方式。</span><span class="sxs-lookup"><span data-stu-id="41e93-239">This time, visiting the page through a browser, entering your age, and clicking the "Submit" button displays the message in the `Results` Label, as expected.</span></span>


[![T<span data-ttu-id="41e93-240">他用户年龄是标签中显示的]</span><span class="sxs-lookup"><span data-stu-id="41e93-240">he User's Age is Displayed in the Label]</span></span>(control-id-naming-in-content-pages-vb/_static/image11.png)](control-id-naming-in-content-pages-vb/_static/image10.png)

<span data-ttu-id="41e93-241">**图 06**:标签中显示用户的年龄 ([单击此项可查看原尺寸图像](control-id-naming-in-content-pages-vb/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="41e93-241">**Figure 06**: The User's Age is Displayed in the Label  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image12.png))</span></span>


### <a name="recursively-searching-through-naming-containers"></a><span data-ttu-id="41e93-242">以递归方式搜索容器命名</span><span class="sxs-lookup"><span data-stu-id="41e93-242">Recursively Searching Through Naming Containers</span></span>

<span data-ttu-id="41e93-243">引用前面的代码示例的原因`MainContent`ContentPlaceHolder 控件从主页，然后`Results`标签和`Age`TextBox 控件从`MainContent`，是因为`Control.FindControl`方法只搜索内*控制*的命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-243">The reason the previous code example referenced the `MainContent` ContentPlaceHolder control from the master page, and then the `Results` Label and `Age` TextBox controls from `MainContent`, is because the `Control.FindControl` method only searches within *Control*'s naming container.</span></span> <span data-ttu-id="41e93-244">无`FindControl`命名容器中的保持在大多数情况下使意义上，因为在两个不同的命名容器中的两个控件可能具有相同`ID`值。</span><span class="sxs-lookup"><span data-stu-id="41e93-244">Having `FindControl` stay within the naming container makes sense in most scenarios because two controls in two different naming containers may have the same `ID` values.</span></span> <span data-ttu-id="41e93-245">请考虑一个 GridView，定义一个名为标签 Web 控件的大小写`ProductName`在其 Templatefield 之一中。</span><span class="sxs-lookup"><span data-stu-id="41e93-245">Consider the case of a GridView that defines a Label Web control named `ProductName` within one of its TemplateFields.</span></span> <span data-ttu-id="41e93-246">在数据绑定到在运行时，GridView`ProductName`会为每个 GridView 行创建标签。</span><span class="sxs-lookup"><span data-stu-id="41e93-246">When the data is bound to the GridView at runtime, a `ProductName` Label is created for each GridView row.</span></span> <span data-ttu-id="41e93-247">如果`FindControl`搜索通过所有命名容器，我们调用`Page.FindControl("ProductName")`，哪些标签实例应`FindControl`返回？</span><span class="sxs-lookup"><span data-stu-id="41e93-247">If `FindControl` searched through all naming containers and we called `Page.FindControl("ProductName")`, what Label instance should the `FindControl` return?</span></span> <span data-ttu-id="41e93-248">`ProductName`中第一个 GridView 行标签？</span><span class="sxs-lookup"><span data-stu-id="41e93-248">The `ProductName` Label in the first GridView row?</span></span> <span data-ttu-id="41e93-249">最后一行中的一个？</span><span class="sxs-lookup"><span data-stu-id="41e93-249">The one in the last row?</span></span>

<span data-ttu-id="41e93-250">因此`Control.FindControl`只需搜索*控制*的命名容器的意义在大多数情况下。</span><span class="sxs-lookup"><span data-stu-id="41e93-250">So having `Control.FindControl` search just *Control*'s naming container makes sense in most cases.</span></span> <span data-ttu-id="41e93-251">但其他情况下，如面向我们，我们具有一个唯一的一个`ID`跨所有容器都命名，并且想要避免这种引用来访问控件的控件层次结构中每个都命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-251">But there are other cases, such as the one facing us, where we have a unique `ID` across all naming containers and want to avoid having to meticulously reference each naming container in the control hierarchy to access a control.</span></span> <span data-ttu-id="41e93-252">具有`FindControl`太以递归方式搜索所有命名容器使感应的变体。</span><span class="sxs-lookup"><span data-stu-id="41e93-252">Having a `FindControl` variant that recursively searches all naming containers makes sense, too.</span></span> <span data-ttu-id="41e93-253">遗憾的是，.NET Framework 不包括此类方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-253">Unfortunately, the .NET Framework does not include such a method.</span></span>

<span data-ttu-id="41e93-254">值得高兴的是，我们可以创建我们自己`FindControl`方法，以递归方式搜索所有命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-254">The good news is that we can create our own `FindControl` method that recursively searches all naming containers.</span></span> <span data-ttu-id="41e93-255">事实上，使用*扩展方法*我们可以添加`FindControlRecursive`方法`Control`类来搭配其现有的`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-255">In fact, using *extension methods* we can tack on a `FindControlRecursive` method to the `Control` class to accompany its existing `FindControl` method.</span></span>

> [!NOTE]
> <span data-ttu-id="41e93-256">扩展方法是 C# 3.0 和 Visual Basic 9 随附的.NET Framework 版本 3.5 和 Visual Studio 2008 的语言的新功能。</span><span class="sxs-lookup"><span data-stu-id="41e93-256">Extension methods are a feature new to C# 3.0 and Visual Basic 9, which are the languages that ship with the .NET Framework version 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="41e93-257">简单地说，扩展方法允许开发人员创建特殊的语法通过现有的类类型的新方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-257">In short, extension methods allow for a developer to create a new method for an existing class type through a special syntax.</span></span> <span data-ttu-id="41e93-258">有关此有用的功能的详细信息，请参阅我的文章[使用扩展方法扩展基类型的功能](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41e93-258">For more information on this helpful feature, refer to my article, [Extending Base Type Functionality with Extension Methods](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx).</span></span>


<span data-ttu-id="41e93-259">若要创建扩展方法，将添加到新的文件`App_Code`文件夹名为`PageExtensionMethods.vb`。</span><span class="sxs-lookup"><span data-stu-id="41e93-259">To create the extension method, add a new file to the `App_Code` folder named `PageExtensionMethods.vb`.</span></span> <span data-ttu-id="41e93-260">添加名为的扩展方法`FindControlRecursive`作为输入，采用`String`参数名为`controlID`。</span><span class="sxs-lookup"><span data-stu-id="41e93-260">Add an extension method named `FindControlRecursive` that takes as an input a `String` parameter named `controlID`.</span></span> <span data-ttu-id="41e93-261">扩展方法才能正常工作，非常重要的类标记为`Module`且带有前缀的扩展方法`<Extension()>`属性。</span><span class="sxs-lookup"><span data-stu-id="41e93-261">For extension methods to work properly, it is vital that the class be marked as a `Module` and that the extension methods be prefixed with the `<Extension()>` attribute.</span></span> <span data-ttu-id="41e93-262">此外，所有扩展方法必须都接受作为其第一个参数对象，该类型对其应用的扩展方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-262">Moreover, all extension methods must accept as their first parameter an object of the type to which the extension method applies.</span></span>

<span data-ttu-id="41e93-263">将以下代码添加到`PageExtensionMethods.vb`文件来定义此`Module`和`FindControlRecursive`扩展方法：</span><span class="sxs-lookup"><span data-stu-id="41e93-263">Add the following code to the `PageExtensionMethods.vb` file to define this `Module` and the `FindControlRecursive` extension method:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample12.vb)]

<span data-ttu-id="41e93-264">利用此代码，返回到`IDIssues.aspx`页面的代码隐藏类并注释掉当前`FindControl`方法调用。</span><span class="sxs-lookup"><span data-stu-id="41e93-264">With this code in place, return to the `IDIssues.aspx` page's code-behind class and comment out the current `FindControl` method calls.</span></span> <span data-ttu-id="41e93-265">将它们替换为对调用`Page.FindControlRecursive("controlID")`。</span><span class="sxs-lookup"><span data-stu-id="41e93-265">Replace them with calls to `Page.FindControlRecursive("controlID")`.</span></span> <span data-ttu-id="41e93-266">什么是关于扩展方法是，它们显示直接在 IntelliSense 下拉列表中。</span><span class="sxs-lookup"><span data-stu-id="41e93-266">What's neat about extension methods is that they appear directly within the IntelliSense drop-down lists.</span></span> <span data-ttu-id="41e93-267">如图 7 所示，当您键入`Page`，然后点击句点`FindControlRecursive`IntelliSense 以及其他下拉列表中包含方法`Control`类方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-267">As Figure 7 shows, when you type `Page` and then hit period, the `FindControlRecursive` method is included in the IntelliSense drop-down along with the other `Control` class methods.</span></span>


[![E<span data-ttu-id="41e93-268">扩展名方法均包含在 IntelliSense 下拉列表]</span><span class="sxs-lookup"><span data-stu-id="41e93-268">xtension Methods are Included in the IntelliSense Drop-Downs]</span></span>(control-id-naming-in-content-pages-vb/_static/image14.png)](control-id-naming-in-content-pages-vb/_static/image13.png)

<span data-ttu-id="41e93-269">**图 07**:扩展方法均包含在 IntelliSense 下拉列表 ([单击此项可查看原尺寸图像](control-id-naming-in-content-pages-vb/_static/image15.png))</span><span class="sxs-lookup"><span data-stu-id="41e93-269">**Figure 07**: Extension Methods are Included in the IntelliSense Drop-Downs  ([Click to view full-size image](control-id-naming-in-content-pages-vb/_static/image15.png))</span></span>


<span data-ttu-id="41e93-270">输入以下代码到`SubmitButton_Click`事件处理程序，然后对其进行测试方法访问的页面，输入你的年龄，然后单击"提交"按钮。</span><span class="sxs-lookup"><span data-stu-id="41e93-270">Enter the following code into the `SubmitButton_Click` event handler and then test it by visiting the page, entering your age, and clicking the "Submit" button.</span></span> <span data-ttu-id="41e93-271">返回中图 6 所示，生成的输出将为消息，"您是年龄岁 ！"</span><span class="sxs-lookup"><span data-stu-id="41e93-271">As shown back in Figure 6, the resulting output will be the message, "You are age years old!"</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample13.vb)]

> [!NOTE]
> <span data-ttu-id="41e93-272">因为扩展方法不熟悉 C# 3.0 和 Visual Basic 9 中，如果您使用的 Visual Studio 2005 不能使用扩展方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-272">Because extension methods are new to C# 3.0 and Visual Basic 9, if you are using Visual Studio 2005 you cannot use extension methods.</span></span> <span data-ttu-id="41e93-273">相反，您需要实现`FindControlRecursive`中的帮助器类的方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-273">Instead, you'll need to implement the `FindControlRecursive` method in a helper class.</span></span> <span data-ttu-id="41e93-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx)在他的博客文章中具有此类示例[微波激射器的 ASP.NET 网页和`FindControl` ](http://www.west-wind.com/WebLog/posts/5127.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41e93-274">[Rick Strahl](http://www.west-wind.com/WebLog/default.aspx) has such an example in his blog post, [ASP.NET Maser Pages and `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx).</span></span>


## <a name="step-4-using-the-correctidattribute-value-in-client-side-script"></a><span data-ttu-id="41e93-275">步骤 4：使用正确`id`属性在客户端脚本中的值</span><span class="sxs-lookup"><span data-stu-id="41e93-275">Step 4: Using the Correct`id`Attribute Value in Client-Side Script</span></span>

<span data-ttu-id="41e93-276">在本教程中的简介中所述，Web 控件的呈现`id`属性通常用于在客户端脚本中以编程方式引用特定的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="41e93-276">As noted in this tutorial's introduction, a Web control's rendered `id` attribute is oftentimes used in client-side script to programmatically reference a particular HTML element.</span></span> <span data-ttu-id="41e93-277">例如，以下 JavaScript 引用 HTML 元素由其`id`然后在一个模式消息框中显示其值：</span><span class="sxs-lookup"><span data-stu-id="41e93-277">For example, the following JavaScript references an HTML element by its `id` and then displays its value in a modal message box:</span></span>


[!code-csharp[Main](control-id-naming-in-content-pages-vb/samples/sample14.cs)]

<span data-ttu-id="41e93-278">回想一下，在 ASP.NET 页，不包括命名容器，呈现的 HTML 元素的`id`属性等同于 Web 控件的`ID`属性值。</span><span class="sxs-lookup"><span data-stu-id="41e93-278">Recall that in ASP.NET pages that do not include a naming container, the rendered HTML element's `id` attribute is identical to the Web control's `ID` property value.</span></span> <span data-ttu-id="41e93-279">因此，很容易中进行硬编码`id`属性值为 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="41e93-279">Because of this, it is tempting to hard code in `id` attribute values into JavaScript code.</span></span> <span data-ttu-id="41e93-280">也就是说，如果您知道您想要访问`Age`TextBox Web 控件通过客户端脚本，这样通过调用`document.getElementById("Age")`。</span><span class="sxs-lookup"><span data-stu-id="41e93-280">That is, if you know you want to access the `Age` TextBox Web control through client-side script, do so via a call to `document.getElementById("Age")`.</span></span>

<span data-ttu-id="41e93-281">此方法的问题是，当使用主页面 （或其他命名容器控件中），呈现的 HTML`id`不是 Web 控件的同义词，`ID`属性。</span><span class="sxs-lookup"><span data-stu-id="41e93-281">The problem with this approach is that when using master pages (or other naming container controls), the rendered HTML `id` is not synonymous with the Web control's `ID` property.</span></span> <span data-ttu-id="41e93-282">您首先会想到可能访问通过浏览器页并查看源以确定实际`id`属性。</span><span class="sxs-lookup"><span data-stu-id="41e93-282">Your first inclination may be to visit the page through a browser and view the source to determine the actual `id` attribute.</span></span> <span data-ttu-id="41e93-283">一旦您知道呈现`id`值，您可以将其粘贴到对调用`getElementById`访问需要通过客户端侧脚本使用的 HTML 元素。</span><span class="sxs-lookup"><span data-stu-id="41e93-283">Once you know the rendered `id` value, you can paste it into the call to `getElementById` to access the HTML element you need to work with through client-side script.</span></span> <span data-ttu-id="41e93-284">这种方法是不太理想，因为某些更改页面的控件层次结构或将更改为`ID`命名控件的属性会更改生成`id`属性，从而破坏您的 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="41e93-284">This approach is less than ideal because certain changes to the page's control hierarchy or changes to the `ID` properties of the naming controls will alter the resulting `id` attribute, thereby breaking your JavaScript code.</span></span>

<span data-ttu-id="41e93-285">值得高兴的是`id`呈现的属性值是在服务器端代码中通过 Web 控件的可访问[`ClientID`属性](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41e93-285">The good news is that the `id` attribute value that is rendered is accessible in server-side code through the Web control's [`ClientID` property](https://msdn.microsoft.com/library/system.web.ui.control.clientid.aspx).</span></span> <span data-ttu-id="41e93-286">应使用此属性来确定`id`属性在客户端脚本中使用的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-286">You should use this property to determine the `id` attribute value used in client-side script.</span></span> <span data-ttu-id="41e93-287">例如，若要向页面添加 JavaScript 函数，调用时，显示的值`Age`文本框中模式消息框中，将以下代码添加到`Page_Load`事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="41e93-287">For example, to add a JavaScript function to the page that, when called, displays the value of the `Age` TextBox in a modal message box, add the following code to the `Page_Load` event handler:</span></span>


[!code-vb[Main](control-id-naming-in-content-pages-vb/samples/sample15.vb)]

<span data-ttu-id="41e93-288">上面的代码中插入的值`Age`文本框中的`ClientID`属性转换成 JavaScript 调用`getElementById`。</span><span class="sxs-lookup"><span data-stu-id="41e93-288">The above code injects the value of the `Age` TextBox's `ClientID` property into the JavaScript call to `getElementById`.</span></span> <span data-ttu-id="41e93-289">如果您访问此页上的通过浏览器并查看 HTML 源，您会发现以下 JavaScript 代码：</span><span class="sxs-lookup"><span data-stu-id="41e93-289">If you visit this page through a browser and view the HTML source, you'll find the following JavaScript code:</span></span>


[!code-html[Main](control-id-naming-in-content-pages-vb/samples/sample16.html)]

<span data-ttu-id="41e93-290">请注意如何正确`id`属性值， `ctl00_MainContent_Age`，将显示在调用`getElementById`。</span><span class="sxs-lookup"><span data-stu-id="41e93-290">Notice how the correct `id` attribute value, `ctl00_MainContent_Age`, appears within the call to `getElementById`.</span></span> <span data-ttu-id="41e93-291">在运行时计算此值，因为它的工作而不考虑对页面控件层次结构的更高版本更改。</span><span class="sxs-lookup"><span data-stu-id="41e93-291">Because this value is calculated at runtime, it works regardless of later changes to the page control hierarchy.</span></span>

> [!NOTE]
> <span data-ttu-id="41e93-292">此 JavaScript 示例只是演示如何将添加正确引用由服务器控件呈现的 HTML 元素的 JavaScript 函数。</span><span class="sxs-lookup"><span data-stu-id="41e93-292">This JavaScript example merely shows how to add a JavaScript function that correctly references the HTML element rendered by a server control.</span></span> <span data-ttu-id="41e93-293">若要使用此函数将需要编写额外的 JavaScript 调用该函数，或当文档加载时某些特定的用户操作怎样。</span><span class="sxs-lookup"><span data-stu-id="41e93-293">To use this function you would need to author additional JavaScript to call the function when the document loads or when some specific user action transpires.</span></span> <span data-ttu-id="41e93-294">有关这些详细信息和相关的主题，阅读[使用客户端侧脚本](https://msdn.microsoft.com/library/aa479302.aspx)。</span><span class="sxs-lookup"><span data-stu-id="41e93-294">For more information on these and related topics, read [Working with Client-Side Script](https://msdn.microsoft.com/library/aa479302.aspx).</span></span>


## <a name="summary"></a><span data-ttu-id="41e93-295">总结</span><span class="sxs-lookup"><span data-stu-id="41e93-295">Summary</span></span>

<span data-ttu-id="41e93-296">某些 ASP.NET 服务器控件用作命名的容器，这会影响呈现`id`属性值及其后代控件以及通过 canvassed 的控件的作用域`FindControl`方法。</span><span class="sxs-lookup"><span data-stu-id="41e93-296">Certain ASP.NET server controls act as naming containers, which affects the rendered `id` attribute values of their descendent controls as well as the scope of controls canvassed by the `FindControl` method.</span></span> <span data-ttu-id="41e93-297">有关主页面，主页面本身和其 ContentPlaceHolder 控件命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-297">With regards to master pages, both the master page itself and its ContentPlaceHolder controls are naming containers.</span></span> <span data-ttu-id="41e93-298">因此，我们需要将提出更多工作要以编程方式引用中内容页中使用的控件`FindControl`。</span><span class="sxs-lookup"><span data-stu-id="41e93-298">Consequently, we need to put forth a bit more work to programmatically reference controls within the content page using `FindControl`.</span></span> <span data-ttu-id="41e93-299">在本教程中，我们将探讨两种方法： 钻入 ContentPlaceHolder 控件并调用其`FindControl`方法; 和实施我们自己`FindControl`实现它以递归方式搜索所有命名容器。</span><span class="sxs-lookup"><span data-stu-id="41e93-299">In this tutorial we examined two techniques: drilling into the ContentPlaceHolder control and calling its `FindControl` method; and rolling our own `FindControl` implementation that recursively searches through all naming containers.</span></span>

<span data-ttu-id="41e93-300">除了与引用 Web 控件引入命名容器的服务器端的问题，还有一些客户端的问题。</span><span class="sxs-lookup"><span data-stu-id="41e93-300">In addition to the server-side issues naming containers introduce with regards to referencing Web controls, there are also client-side issues.</span></span> <span data-ttu-id="41e93-301">如果没有命名容器，Web 控件`ID`属性值并在其中呈现`id`属性值都是相同。</span><span class="sxs-lookup"><span data-stu-id="41e93-301">In the absence of naming containers, the Web control's `ID` property value and rendered `id` attribute value are one in the same.</span></span> <span data-ttu-id="41e93-302">但添加了命名容器，呈现`id`属性包括这两个`ID`Web 控件和在其控件层次结构体系中命名的容器的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-302">But with the addition of naming container, the rendered `id` attribute includes both the `ID` values of the Web control and the naming container(s) in its control hierarchy's ancestry.</span></span> <span data-ttu-id="41e93-303">这些命名问题是不产生问题，只要您使用 Web 控件`ClientID`属性来确定呈现`id`属性在客户端脚本中的值。</span><span class="sxs-lookup"><span data-stu-id="41e93-303">These naming concerns are a non-issue as long as you use the Web control's `ClientID` property to determine the rendered `id` attribute value in your client-side script.</span></span>

<span data-ttu-id="41e93-304">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="41e93-304">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="41e93-305">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="41e93-305">Further Reading</span></span>

<span data-ttu-id="41e93-306">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="41e93-306">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="41e93-307">ASP.NET 母版页和</span><span class="sxs-lookup"><span data-stu-id="41e93-307">ASP.NET Master Pages and</span></span> `FindControl`](http://www.west-wind.com/WebLog/posts/5127.aspx)
- [<span data-ttu-id="41e93-308">创建动态数据输入用户界面</span><span class="sxs-lookup"><span data-stu-id="41e93-308">Creating Dynamic Data Entry User Interfaces</span></span>](https://msdn.microsoft.com/library/aa479330.aspx)
- [<span data-ttu-id="41e93-309">将使用扩展方法的基类型功能扩展</span><span class="sxs-lookup"><span data-stu-id="41e93-309">Extending Base Type Functionality with Extension Methods</span></span>](http://aspnet.4guysfromrolla.com/articles/120507-1.aspx)
- [<span data-ttu-id="41e93-310">如何：引用 ASP.NET 主机页面内容</span><span class="sxs-lookup"><span data-stu-id="41e93-310">How To: Reference ASP.NET Master Page Content</span></span>](https://msdn.microsoft.com/library/xxwa0ff0.aspx)
- [<span data-ttu-id="41e93-311">本地主页：提示、 技巧和陷阱</span><span class="sxs-lookup"><span data-stu-id="41e93-311">Mater Pages: Tips, Tricks, and Traps</span></span>](http://www.odetocode.com/articles/450.aspx)
- [<span data-ttu-id="41e93-312">使用客户端脚本</span><span class="sxs-lookup"><span data-stu-id="41e93-312">Working with Client-Side Script</span></span>](https://msdn.microsoft.com/library/aa479302.aspx)

### <a name="about-the-author"></a><span data-ttu-id="41e93-313">关于作者</span><span class="sxs-lookup"><span data-stu-id="41e93-313">About the Author</span></span>

<span data-ttu-id="41e93-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml)，作者的多个部 asp/ASP.NET 书籍并创办了 4GuysFromRolla.com，一直从事 Microsoft Web 技术自 1998 年起。</span><span class="sxs-lookup"><span data-stu-id="41e93-314">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of multiple ASP/ASP.NET books and founder of 4GuysFromRolla.com, has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="41e93-315">Scott 是独立的顾问、 培训师和编写器。</span><span class="sxs-lookup"><span data-stu-id="41e93-315">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="41e93-316">他最新著作是[ *Sams Teach 自己 ASP.NET 3.5 24 小时内*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)。</span><span class="sxs-lookup"><span data-stu-id="41e93-316">His latest book is [*Sams Teach Yourself ASP.NET 3.5 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="41e93-317">可以在达到 Scott [ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)或通过他的博客[ http://ScottOnWriting.NET ](http://scottonwriting.net/)。</span><span class="sxs-lookup"><span data-stu-id="41e93-317">Scott can be reached at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com) or via his blog at [http://ScottOnWriting.NET](http://scottonwriting.net/).</span></span>

### <a name="special-thanks-to"></a><span data-ttu-id="41e93-318">特别感谢</span><span class="sxs-lookup"><span data-stu-id="41e93-318">Special Thanks To</span></span>

<span data-ttu-id="41e93-319">很多有用的审阅者已评审本系列教程。</span><span class="sxs-lookup"><span data-stu-id="41e93-319">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="41e93-320">本教程中的潜在顾客审阅者已 Zack Jones 和 Suchi Barnerjee。</span><span class="sxs-lookup"><span data-stu-id="41e93-320">Lead reviewers for this tutorial were Zack Jones and Suchi Barnerjee.</span></span> <span data-ttu-id="41e93-321">是否有兴趣查看我即将推出的 MSDN 文章？</span><span class="sxs-lookup"><span data-stu-id="41e93-321">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="41e93-322">如果是这样，给我在行[ mitchell@4GuysFromRolla.com ](mailto:mitchell@4GuysFromRolla.com)。</span><span class="sxs-lookup"><span data-stu-id="41e93-322">If so, drop me a line at [mitchell@4GuysFromRolla.com](mailto:mitchell@4GuysFromRolla.com).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="41e93-323">[上一页](urls-in-master-pages-vb.md)
> [下一页](interacting-with-the-master-page-from-the-content-page-vb.md)</span><span class="sxs-lookup"><span data-stu-id="41e93-323">[Previous](urls-in-master-pages-vb.md)
[Next](interacting-with-the-master-page-from-the-content-page-vb.md)</span></span>

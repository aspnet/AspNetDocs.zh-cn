---
uid: web-forms/overview/older-versions-getting-started/aspnet-ajax/understanding-asp-net-ajax-updatepanel-triggers
title: 了解 ASP.NET AJAX UpdatePanel 触发器 |Microsoft Docs
author: scottcate
description: 在 Visual Studio 中的标记编辑器中工作时，你可能会注意到（从 IntelliSense）有一个 UpdatePanel 控件的子元素。 符合之一 。
ms.author: riande
ms.date: 03/12/2008
ms.assetid: faab8503-2984-48a9-8a40-7728461abc50
msc.legacyurl: /web-forms/overview/older-versions-getting-started/aspnet-ajax/understanding-asp-net-ajax-updatepanel-triggers
msc.type: authoredcontent
ms.openlocfilehash: b1cc869f373d4f8283b4d92af74707c3f11fef61
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74588850"
---
# <a name="understanding-aspnet-ajax-updatepanel-triggers"></a><span data-ttu-id="e9a50-104">了解 ASP.NET AJAX UpdatePanel 触发器</span><span class="sxs-lookup"><span data-stu-id="e9a50-104">Understanding ASP.NET AJAX UpdatePanel Triggers</span></span>

<span data-ttu-id="e9a50-105">作者： [Scott Cate](https://github.com/scottcate)</span><span class="sxs-lookup"><span data-stu-id="e9a50-105">by [Scott Cate](https://github.com/scottcate)</span></span>

[<span data-ttu-id="e9a50-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="e9a50-106">Download PDF</span></span>](https://download.microsoft.com/download/C/1/9/C19A3451-1D14-477C-B703-54EF22E197EE/AJAX_tutorial02_Triggers_cs.pdf)

> <span data-ttu-id="e9a50-107">在 Visual Studio 中的标记编辑器中工作时，你可能会注意到（从 IntelliSense）有一个 UpdatePanel 控件的子元素。</span><span class="sxs-lookup"><span data-stu-id="e9a50-107">When working in the markup editor in Visual Studio, you may notice (from IntelliSense) that there are two child elements of an UpdatePanel control.</span></span> <span data-ttu-id="e9a50-108">其中一个是触发器元素，它指定页面上的控件（如果使用的是用户控件，则为用户控件），该元素将触发元素所在的 UpdatePanel 控件的部分呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-108">One of which is the Triggers element, which specifies the controls on the page (or the user control, if you are using one) that will trigger a partial render of the UpdatePanel control in which the element resides.</span></span>

## <a name="introduction"></a><span data-ttu-id="e9a50-109">简介</span><span class="sxs-lookup"><span data-stu-id="e9a50-109">Introduction</span></span>

<span data-ttu-id="e9a50-110">Microsoft 的 ASP.NET 技术引入了面向对象的和事件驱动的编程模型，并将其与编译的代码的优势结合起来。</span><span class="sxs-lookup"><span data-stu-id="e9a50-110">Microsoft's ASP.NET technology brings an object-oriented and event-driven programming model and unites it with the benefits of compiled code.</span></span> <span data-ttu-id="e9a50-111">但是，它的服务器端处理模型在技术中有一些固有的缺点，其中许多功能都可以通过 Microsoft ASP.NET 3.5 AJAX 扩展中包含的新功能来解决。</span><span class="sxs-lookup"><span data-stu-id="e9a50-111">However, its server-side processing model has several drawbacks inherent in the technology, many of which can be addressed by the new features included in the Microsoft ASP.NET 3.5 AJAX Extensions.</span></span> <span data-ttu-id="e9a50-112">这些扩展可实现许多新的丰富客户端功能，包括页面的部分呈现，无需整页刷新、通过客户端脚本访问 Web 服务的能力（包括 ASP.NET 分析 API）和广泛的客户端 API用于镜像在 ASP.NET 服务器端控制集内发现的许多控制方案。</span><span class="sxs-lookup"><span data-stu-id="e9a50-112">These extensions enable many new rich client features, including partial rendering of pages without requiring a full page refresh, the ability to access Web Services via client script (including the ASP.NET profiling API), and an extensive client-side API designed to mirror many of the control schemes seen in the ASP.NET server-side control set.</span></span>

<span data-ttu-id="e9a50-113">本白皮书检查 ASP.NET AJAX `UpdatePanel` 组件的 XML 触发器功能。</span><span class="sxs-lookup"><span data-stu-id="e9a50-113">This whitepaper examines the XML Triggers functionality of the ASP.NET AJAX `UpdatePanel` component.</span></span> <span data-ttu-id="e9a50-114">XML 触发器可以对组件进行精细的控制，这些组件可能会导致特定 UpdatePanel 控件的部分呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-114">XML Triggers give granular control over the components that can cause partial rendering for specific UpdatePanel controls.</span></span>

<span data-ttu-id="e9a50-115">本白皮书基于 .NET Framework 3.5 和 Visual Studio 2008 的 Beta 2 版本。</span><span class="sxs-lookup"><span data-stu-id="e9a50-115">This whitepaper is based on the Beta 2 release of the .NET Framework 3.5 and Visual Studio 2008.</span></span> <span data-ttu-id="e9a50-116">ASP.NET AJAX 扩展（以前面向 ASP.NET 2.0 的附加程序集）现在已集成到 .NET Framework 基类库中。</span><span class="sxs-lookup"><span data-stu-id="e9a50-116">The ASP.NET AJAX Extensions, previously an add-on assembly targeted at ASP.NET 2.0, are now integrated into the .NET Framework Base Class Library.</span></span> <span data-ttu-id="e9a50-117">本白皮书还假设你将使用 Visual Studio 2008，而不是 Visual Web Developer Express，并将根据 Visual Studio 的用户界面提供演练（尽管代码列表将完全兼容，而不考虑开发环境）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-117">This whitepaper also assumes that you will be working with Visual Studio 2008, not Visual Web Developer Express, and will provide walkthroughs according to the user interface of Visual Studio (although code listings will be entirely compatible regardless of development environment).</span></span>

## <a name="triggers"></a><span data-ttu-id="e9a50-118">*触发器*</span><span class="sxs-lookup"><span data-stu-id="e9a50-118">*Triggers*</span></span>

<span data-ttu-id="e9a50-119">给定 UpdatePanel 的触发器默认情况下，会自动包含任何调用回发的子控件，包括将其 `AutoPostBack` 属性设置为**true**的 TextBox 控件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-119">Triggers for a given UpdatePanel, by default, automatically include any child controls that invoke a postback, including (for example) TextBox controls that have their `AutoPostBack` property set to **true**.</span></span> <span data-ttu-id="e9a50-120">但是，也可以使用标记以声明方式包含触发器;这是在 UpdatePanel 控件声明的 `<triggers>` 部分中完成的。</span><span class="sxs-lookup"><span data-stu-id="e9a50-120">However, triggers can also be included declaratively using markup; this is done within the `<triggers>` section of the UpdatePanel control declaration.</span></span> <span data-ttu-id="e9a50-121">尽管可以通过 `Triggers` 集合属性访问触发器，但建议你在运行时（例如，如果控件在设计时不可用）通过使用页面的 ScriptManager 对象的 `RegisterAsyncPostBackControl(Control)` 方法在 `Page_Load` 事件内注册任何分部呈现触发器。</span><span class="sxs-lookup"><span data-stu-id="e9a50-121">Although triggers can be accessed via the `Triggers` collection property, it is recommended that you register any partial render triggers at run-time (for instance, if a control is not available at design time) by using the `RegisterAsyncPostBackControl(Control)` method of the ScriptManager object for your page, within the `Page_Load` event.</span></span> <span data-ttu-id="e9a50-122">请记住，页面是无状态的，因此你应在每次创建这些控件时重新注册这些控件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-122">Remember that Pages are stateless, and so you should re-register these controls every time they are created.</span></span>

<span data-ttu-id="e9a50-123">还可以禁用自动子触发器包含（因此，通过将 `ChildrenAsTriggers` 属性设置为**false**，创建回发的子控件不会自动触发部分呈现）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-123">Automatic child trigger inclusion can also be disabled (so that child controls that create postbacks do not automatically trigger partial renders) by setting the `ChildrenAsTriggers` property to **false**.</span></span> <span data-ttu-id="e9a50-124">这使您可以最大限度地分配哪些特定控件可以调用页面呈现，并建议您这样做，以便开发人员选择对事件做出响应，而不是处理可能出现的任何事件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-124">This allows you the greatest flexibility in assigning which specific controls may invoke a page render, and is recommended, so that a developer will opt-in to respond to an event, rather than handling any events that may arise.</span></span>

<span data-ttu-id="e9a50-125">请注意，当 "UpdateMode" 设置为 "**条件**" 时，如果触发了子 updatepanel 但父对象不是，则只有子 updatepanel 会刷新。</span><span class="sxs-lookup"><span data-stu-id="e9a50-125">Note that when UpdatePanel controls are nested, when the UpdateMode is set to **Conditional**, if the child UpdatePanel is triggered, but the parent is not, then only the child UpdatePanel will refresh.</span></span> <span data-ttu-id="e9a50-126">但是，如果刷新了父 UpdatePanel，则还会刷新子 UpdatePanel。</span><span class="sxs-lookup"><span data-stu-id="e9a50-126">However, if the parent UpdatePanel is refreshed, then the child UpdatePanel will also be refreshed.</span></span>

## <a name="the-lttriggersgt-element"></a><span data-ttu-id="e9a50-127">*&lt;触发&gt; 元素*</span><span class="sxs-lookup"><span data-stu-id="e9a50-127">*The &lt;Triggers&gt; Element*</span></span>

<span data-ttu-id="e9a50-128">在 Visual Studio 中的标记编辑器中工作时，你可能会注意到（从 IntelliSense）存在 `UpdatePanel` 控件的两个子元素。</span><span class="sxs-lookup"><span data-stu-id="e9a50-128">When working in the markup editor in Visual Studio, you may notice (from IntelliSense) that there are two child elements of an `UpdatePanel` control.</span></span> <span data-ttu-id="e9a50-129">最常见到的元素是 `<ContentTemplate>` 元素，该元素实质上封装了将由更新面板（我们正在启用部分呈现的内容）保存的内容。</span><span class="sxs-lookup"><span data-stu-id="e9a50-129">The most-frequently seen element is the `<ContentTemplate>` element, which essentially encapsulates the content that will be held by the update panel (the content for which we are enabling partial rendering).</span></span> <span data-ttu-id="e9a50-130">另一个元素是 `<Triggers>` 元素，该元素指定页面上的控件（如果使用的是用户控件），该元素将触发&gt; 元素的 &lt;触发器的 UpdatePanel 控件的部分呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-130">The other element is the `<Triggers>` element, which specifies the controls on the page (or the user control, if you are using one) that will trigger a partial render of the UpdatePanel control in which the &lt;Triggers&gt; element resides.</span></span>

<span data-ttu-id="e9a50-131">`<Triggers>` 元素可以包含两个子节点中的任意数量： `<asp:AsyncPostBackTrigger>` 和 `<asp:PostBackTrigger>`。</span><span class="sxs-lookup"><span data-stu-id="e9a50-131">The `<Triggers>` element can contain any number each of two child nodes: `<asp:AsyncPostBackTrigger>` and `<asp:PostBackTrigger>`.</span></span> <span data-ttu-id="e9a50-132">它们都接受两个属性，`ControlID` 和 `EventName`，并且可以在当前封装单元中指定任何控件（例如，如果您的 UpdatePanel 控件位于 Web 用户控件内，则不应尝试引用用户控件将驻留的页上的控件）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-132">They both accept two attributes, `ControlID` and `EventName`, and can specify any Control within the current unit of encapsulation (for instance, if your UpdatePanel control resides within a Web User Control, you should not attempt to reference a Control on the Page on which the User Control will reside).</span></span>

<span data-ttu-id="e9a50-133">`<asp:AsyncPostBackTrigger>` 元素特别有用，因为它可以从作为封装的单元中的*任何*updatepanel 控件的子控件（而不仅仅是此触发器所用的 updatepanel）作为子控件的任何事件定向。</span><span class="sxs-lookup"><span data-stu-id="e9a50-133">The `<asp:AsyncPostBackTrigger>` element is particularly useful in that it can target any event from a Control that exists as a child of *any* UpdatePanel control in the unit of encapsulation, not just the UpdatePanel under which this trigger is a child.</span></span> <span data-ttu-id="e9a50-134">因此，可以通过任何控件来触发部分页面更新。</span><span class="sxs-lookup"><span data-stu-id="e9a50-134">Thus, any control can be made to trigger a partial page update.</span></span>

<span data-ttu-id="e9a50-135">同样，`<asp:PostBackTrigger>` 元素可用于触发部分页面呈现，但需要完全往返服务器的情况。</span><span class="sxs-lookup"><span data-stu-id="e9a50-135">Similarly, the `<asp:PostBackTrigger>` element can be used to trigger a partial page render, but one that requires a full round-trip to the server.</span></span> <span data-ttu-id="e9a50-136">当控件通常会触发部分页面呈现时（例如，在 UpdatePanel 控件的 `<ContentTemplate>` 元素中存在 `Button` 控件）时，也可以使用此触发器元素强制执行完整页面呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-136">This trigger element can also be used to force a full page render when a control would otherwise normally trigger a partial page render (for instance, when a `Button` control exists in the `<ContentTemplate>` element of an UpdatePanel control).</span></span> <span data-ttu-id="e9a50-137">同样，PostBackTrigger 元素可以指定任何控件，该控件是当前封装单元中任何 UpdatePanel 控件的子控件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-137">Again, the PostBackTrigger element can specify any control that is a child of any UpdatePanel control in the current unit of encapsulation.</span></span>

## <a name="lttriggersgt-element-reference"></a><span data-ttu-id="e9a50-138">*&lt;触发器&gt; 元素引用*</span><span class="sxs-lookup"><span data-stu-id="e9a50-138">*&lt;Triggers&gt; Element Reference*</span></span>

<span data-ttu-id="e9a50-139">*标记后代：*</span><span class="sxs-lookup"><span data-stu-id="e9a50-139">*Markup Descendants:*</span></span>

| <span data-ttu-id="e9a50-140">**符**</span><span class="sxs-lookup"><span data-stu-id="e9a50-140">**Tag**</span></span> | <span data-ttu-id="e9a50-141">**描述**</span><span class="sxs-lookup"><span data-stu-id="e9a50-141">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="e9a50-142">&lt;asp： AsyncPostBackTrigger&gt;</span><span class="sxs-lookup"><span data-stu-id="e9a50-142">&lt;asp:AsyncPostBackTrigger&gt;</span></span> | <span data-ttu-id="e9a50-143">指定一个控件和事件，该控件和事件将导致包含此触发器引用的 UpdatePanel 的部分页面更新。</span><span class="sxs-lookup"><span data-stu-id="e9a50-143">Specifies a control and event that will cause a partial page update for the UpdatePanel that contains this trigger reference.</span></span> |
| <span data-ttu-id="e9a50-144">&lt;asp： PostBackTrigger&gt;</span><span class="sxs-lookup"><span data-stu-id="e9a50-144">&lt;asp:PostBackTrigger&gt;</span></span> | <span data-ttu-id="e9a50-145">指定将导致完整页面更新的控件和事件（完整页面刷新）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-145">Specifies a control and event that will cause a full page update (a full page refresh).</span></span> <span data-ttu-id="e9a50-146">此标记可用于在控件将以其他方式触发部分呈现时强制执行完全刷新。</span><span class="sxs-lookup"><span data-stu-id="e9a50-146">This tag can be used to force a full refresh when a control would otherwise trigger partial rendering.</span></span> |

## <a name="walkthrough-cross-updatepanel-triggers"></a><span data-ttu-id="e9a50-147">*演练：跨 UpdatePanel 触发器*</span><span class="sxs-lookup"><span data-stu-id="e9a50-147">*Walkthrough: Cross-UpdatePanel Triggers*</span></span>

1. <span data-ttu-id="e9a50-148">创建一个新的 ASP.NET 页面，其中包含 ScriptManager 对象集，用于启用部分呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-148">Create a new ASP.NET page with a ScriptManager object set to enable partial rendering.</span></span> <span data-ttu-id="e9a50-149">将两个 UpdatePanels 添加到此页-在第一页中，包括标签控件（Label1）和两个按钮控件（Button1 和 Button2）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-149">Add two UpdatePanels to this page - in the first, include a Label control ( Label1 ) and two Button controls ( Button1 and Button2 ).</span></span> <span data-ttu-id="e9a50-150">Button1 应显示 "单击以更新" 和 "Button2" 应显示 "单击以更新此项" 或沿这些行。</span><span class="sxs-lookup"><span data-stu-id="e9a50-150">Button1 should say Click to Update Both and Button2 should say Click to Update This, or something along those lines.</span></span> <span data-ttu-id="e9a50-151">在第二个 UpdatePanel 中，只包括 "标签" 控件（Label2），但将其 "前景色" 属性设置为默认值以外的其他值。</span><span class="sxs-lookup"><span data-stu-id="e9a50-151">In the second UpdatePanel, include only a Label control ( Label2 ), but set its ForeColor property to something other than the default to differentiate it.</span></span>
2. <span data-ttu-id="e9a50-152">将两个 UpdatePanel 标记的 UpdateMode 属性设置为 "**条件**"。</span><span class="sxs-lookup"><span data-stu-id="e9a50-152">Set the UpdateMode property of both UpdatePanel tags to **Conditional**.</span></span>

<span data-ttu-id="e9a50-153">**列表1： default.aspx 的标记：**</span><span class="sxs-lookup"><span data-stu-id="e9a50-153">**Listing 1: Markup for default.aspx:**</span></span> 

[!code-aspx[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample1.aspx)]

1. <span data-ttu-id="e9a50-154">在 "Button1" 的 Click 事件处理程序中，将 "Label1" 和 "Label2" 设置为依赖于时间的内容（如 "ToLongTimeString （）"）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-154">In the Click event handler for Button1, set Label1.Text and Label2.Text to something time-dependent (such as DateTime.Now.ToLongTimeString()).</span></span> <span data-ttu-id="e9a50-155">对于 Button2 的 Click 事件处理程序，只将 Label1 设置为与时间相关的值。</span><span class="sxs-lookup"><span data-stu-id="e9a50-155">For the Click event handler for Button2, set only Label1.Text to the time-dependent value.</span></span>

<span data-ttu-id="e9a50-156">**列表2： default.aspx.cs 中的代码隐藏（已剪裁）：**</span><span class="sxs-lookup"><span data-stu-id="e9a50-156">**Listing 2: Codebehind (trimmed) in default.aspx.cs:**</span></span> 

[!code-csharp[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample2.cs)]

1. <span data-ttu-id="e9a50-157">按 F5 生成并运行项目。</span><span class="sxs-lookup"><span data-stu-id="e9a50-157">Press F5 to build and run the project.</span></span> <span data-ttu-id="e9a50-158">请注意，单击 "更新两个面板" 时，两个标签都将更改文本;但是，当你单击 "更新此面板" 时，仅 Label1 更新。</span><span class="sxs-lookup"><span data-stu-id="e9a50-158">Note that, when you click Update Both Panels, both labels change text; however, when you click Update This Panel, only Label1 updates.</span></span>

[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image2.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image1.png)

<span data-ttu-id="e9a50-159">（[单击以查看完全大小的映像](understanding-asp-net-ajax-updatepanel-triggers/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="e9a50-159">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image3.png))</span></span>

## <a name="under-the-hood"></a><span data-ttu-id="e9a50-160">*揭秘*</span><span class="sxs-lookup"><span data-stu-id="e9a50-160">*Under the Hood*</span></span>

<span data-ttu-id="e9a50-161">利用我们刚刚构造的示例，我们可以看看 ASP.NET AJAX 正在做什么，以及如何使用我们的 UpdatePanel 跨面板触发器。</span><span class="sxs-lookup"><span data-stu-id="e9a50-161">Utilizing the example we just constructed, we can take a look at what ASP.NET AJAX is doing and how our UpdatePanel cross-panel triggers work.</span></span> <span data-ttu-id="e9a50-162">为此，我们将使用生成的页面源 HTML 以及名为 FireBug 的 Mozilla Firefox 扩展，我们可以轻松地检查 AJAX 回发。</span><span class="sxs-lookup"><span data-stu-id="e9a50-162">To do so, we will work with the generated page source HTML, as well as the Mozilla Firefox extension called FireBug - with it, we can easily examine the AJAX postbacks.</span></span> <span data-ttu-id="e9a50-163">我们还将使用 .NET 反射器工具 Lutz Roeder。</span><span class="sxs-lookup"><span data-stu-id="e9a50-163">We will also use the .NET Reflector tool by Lutz Roeder.</span></span> <span data-ttu-id="e9a50-164">这两种工具都可以免费使用，并且可以通过 internet 搜索来找到。</span><span class="sxs-lookup"><span data-stu-id="e9a50-164">Both of these tools are freely available online, and can be found with an internet search.</span></span>

<span data-ttu-id="e9a50-165">对页面源代码的检查几乎几乎不会显示任何内容;UpdatePanel 控件呈现为 `<div>` 容器，我们可以看到脚本资源包含由 `<asp:ScriptManager>`提供。</span><span class="sxs-lookup"><span data-stu-id="e9a50-165">An examination of the page source code shows almost nothing out of the ordinary; the UpdatePanel controls are rendered as `<div>` containers, and we can see the script resource includes provided by the `<asp:ScriptManager>`.</span></span> <span data-ttu-id="e9a50-166">此外，还有一些针对 AJAX 客户端脚本库内部的 PageRequestManager 的特定于 AJAX 的特定调用。</span><span class="sxs-lookup"><span data-stu-id="e9a50-166">There are also some new AJAX-specific calls to the PageRequestManager that are internal to the AJAX client script library.</span></span> <span data-ttu-id="e9a50-167">最后，我们会看到两个 UpdatePanel 容器，其中一容器 `<input>` 带有呈现为 `<span>` 容器的两个 `<asp:Label>` 控件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-167">Finally, we see the two UpdatePanel containers - one with the rendered `<input>` buttons with the two `<asp:Label>` controls rendered as `<span>` containers.</span></span> <span data-ttu-id="e9a50-168">（如果你在 FireBug 中检查 DOM 树，你会注意到标签显示为灰色，指示它们不会产生可见内容）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-168">(If you inspect the DOM tree in FireBug, you will notice that the labels are dimmed to indicate that they are not producing visible content).</span></span>

<span data-ttu-id="e9a50-169">单击 "更新此面板" 按钮，可以看到顶部的 UpdatePanel 将更新为当前服务器时间。</span><span class="sxs-lookup"><span data-stu-id="e9a50-169">Click the Update This Panel button, and notice the top UpdatePanel will be updated with the current server time.</span></span> <span data-ttu-id="e9a50-170">在 FireBug 中，选择 "控制台" 选项卡，以便可以检查请求。</span><span class="sxs-lookup"><span data-stu-id="e9a50-170">In FireBug, choose the Console tab so that you can examine the request.</span></span> <span data-ttu-id="e9a50-171">首先检查 POST 请求参数：</span><span class="sxs-lookup"><span data-stu-id="e9a50-171">Examine the POST request parameters first:</span></span>

[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image5.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image4.png)

<span data-ttu-id="e9a50-172">（[单击以查看完全大小的映像](understanding-asp-net-ajax-updatepanel-triggers/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="e9a50-172">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image6.png))</span></span>

<span data-ttu-id="e9a50-173">请注意，UpdatePanel 通过 ScriptManager1 参数（`UpdatePanel1` 控件 `Button1`）准确指出了服务器端 AJAX 代码所触发的控制树。</span><span class="sxs-lookup"><span data-stu-id="e9a50-173">Note that the UpdatePanel has indicated to the server-side AJAX code precisely which control tree was fired via the ScriptManager1 parameter: `Button1` of the `UpdatePanel1` control.</span></span> <span data-ttu-id="e9a50-174">现在，单击 "更新两个面板" 按钮。</span><span class="sxs-lookup"><span data-stu-id="e9a50-174">Now, click on the Update Both Panels button.</span></span> <span data-ttu-id="e9a50-175">然后，检查响应，我们将看到一个在字符串中设置的管道分隔的一系列变量;具体而言，我们看到的是最热门的 UpdatePanel `UpdatePanel1`，它将整个 HTML 发送到浏览器。</span><span class="sxs-lookup"><span data-stu-id="e9a50-175">Then, examining the response, we see a pipe-delimited series of variables set in a string; specifically, we see the top UpdatePanel, `UpdatePanel1`, has the entirety of its HTML sent to the browser.</span></span> <span data-ttu-id="e9a50-176">AJAX 客户端脚本库通过 `.innerHTML` 属性将 UpdatePanel 的原始 HTML 内容替换为新内容，因此服务器以 HTML 格式从服务器发送更改的内容。</span><span class="sxs-lookup"><span data-stu-id="e9a50-176">The AJAX client script library substitutes the UpdatePanel's original HTML content with the new content via the `.innerHTML` property, and so the server sends the changed content from the server as HTML.</span></span>

<span data-ttu-id="e9a50-177">现在，单击 "更新两个面板" 按钮，然后检查服务器的结果。</span><span class="sxs-lookup"><span data-stu-id="e9a50-177">Now, click on the Update Both Panels button and examine the results from the server.</span></span> <span data-ttu-id="e9a50-178">结果非常相似-两个 UpdatePanels 从服务器接收新的 HTML。</span><span class="sxs-lookup"><span data-stu-id="e9a50-178">The results are very similar - both UpdatePanels receive new HTML from the server.</span></span> <span data-ttu-id="e9a50-179">与上一次回调一样，将发送额外的页面状态。</span><span class="sxs-lookup"><span data-stu-id="e9a50-179">As with the previous callback, additional page state is sent.</span></span>

<span data-ttu-id="e9a50-180">正如我们所看到的，因为没有使用特殊代码执行 AJAX 回发，所以 AJAX 客户端脚本库能够截获窗体回发，而无需任何其他代码。</span><span class="sxs-lookup"><span data-stu-id="e9a50-180">As we can see, because no special code is utilized to perform an AJAX postback, the AJAX client script library is able to intercept form postbacks without any additional code.</span></span> <span data-ttu-id="e9a50-181">服务器控件自动利用 JavaScript，使其不会自动提交窗体-ASP.NET 自动注入用于窗体验证和状态的代码，主要通过自动脚本资源包含、PostBackOptions 类和 ClientScriptManager 类。</span><span class="sxs-lookup"><span data-stu-id="e9a50-181">Server controls automatically utilize JavaScript so that they do not automatically submit the form - ASP.NET automatically injects code for form validation and state already, primarily achieved by automatic script resource inclusion, the PostBackOptions class, and the ClientScriptManager class.</span></span>

<span data-ttu-id="e9a50-182">例如，请考虑一个 CheckBox 控件;在 .NET 反射器中检查类反汇编。</span><span class="sxs-lookup"><span data-stu-id="e9a50-182">For instance, consider a CheckBox control; examine the class disassembly in .NET Reflector.</span></span> <span data-ttu-id="e9a50-183">为此，请确保已打开 System.web 程序集，然后导航到 `System.Web.UI.WebControls.CheckBox` 类，打开 `RenderInputTag` 方法。</span><span class="sxs-lookup"><span data-stu-id="e9a50-183">To do so, ensure that your System.Web assembly is open, and navigate to the `System.Web.UI.WebControls.CheckBox` class, opening the `RenderInputTag` method.</span></span> <span data-ttu-id="e9a50-184">查找检查 `AutoPostBack` 属性的条件：</span><span class="sxs-lookup"><span data-stu-id="e9a50-184">Look for a conditional that checks the `AutoPostBack` property:</span></span>

[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image8.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image7.png)

<span data-ttu-id="e9a50-185">（[单击以查看完全大小的映像](understanding-asp-net-ajax-updatepanel-triggers/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="e9a50-185">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image9.png))</span></span>

<span data-ttu-id="e9a50-186">如果对 `CheckBox` 控件启用了自动回发（通过 AutoPostBack 属性设置为 true），则生成的 `<input>` 标记将使用其 `onclick` 属性中的 ASP.NET 事件处理脚本来呈现。</span><span class="sxs-lookup"><span data-stu-id="e9a50-186">When automatic postback is enabled on a `CheckBox` control (via the AutoPostBack property being true), the resultant `<input>` tag is therefore rendered with an ASP.NET event handling script in its `onclick` attribute.</span></span> <span data-ttu-id="e9a50-187">然后，截获窗体的提交，将 ASP.NET AJAX 注入到页面 nonintrusively，这有助于避免利用可能不精确的字符串替换可能发生的任何潜在重大更改。</span><span class="sxs-lookup"><span data-stu-id="e9a50-187">The interception of the form's submission, then, allows ASP.NET AJAX to be injected into the page nonintrusively, helping to avoid any potential breaking changes that might occur by utilizing a possibly-imprecise string replacement.</span></span> <span data-ttu-id="e9a50-188">此外，这使得*任何*自定义 ASP.NET 控件都可以利用 ASP.NET AJAX 的强大功能，而无需任何其他代码即可支持其在 UpdatePanel 容器中的使用。</span><span class="sxs-lookup"><span data-stu-id="e9a50-188">Furthermore, this enables *any* custom ASP.NET control to utilize the power of ASP.NET AJAX without any additional code to support its use within an UpdatePanel container.</span></span>

<span data-ttu-id="e9a50-189">`<triggers>` 功能对应于对 \_updateControls 的 PageRequestManager 调用中初始化的值（请注意，ASP.NET AJAX 客户端脚本库利用了以下划线开头的方法、事件和字段名称被标记为内部，并且不是在库本身的外部使用的约定）。</span><span class="sxs-lookup"><span data-stu-id="e9a50-189">The `<triggers>` functionality corresponds to the values initialized in the PageRequestManager call to \_updateControls (note that the ASP.NET AJAX client script library utilizes the convention that methods, events, and field names that begin with an underscore are marked as internal, and are not meant for use outside of the library itself).</span></span> <span data-ttu-id="e9a50-190">在此示例中，我们可以观察哪些控件旨在导致 AJAX 回发。</span><span class="sxs-lookup"><span data-stu-id="e9a50-190">With it, we can observe which controls are intended to cause AJAX postbacks.</span></span>

<span data-ttu-id="e9a50-191">例如，让我们将两个附加控件添加到页面，使一个控件完全在 UpdatePanels 之外，并在 UpdatePanel 中留下一个控件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-191">For example, let's add two additional controls to the page, leaving one control outside of the UpdatePanels entirely, and leaving one within an UpdatePanel.</span></span> <span data-ttu-id="e9a50-192">我们将在上方的 UpdatePanel 中添加 CheckBox 控件，并删除 DropDownList，其中包含在列表中定义的一些颜色。</span><span class="sxs-lookup"><span data-stu-id="e9a50-192">We will add a CheckBox control within the upper UpdatePanel, and drop a DropDownList with a number of colors defined within the list.</span></span> <span data-ttu-id="e9a50-193">下面是新标记：</span><span class="sxs-lookup"><span data-stu-id="e9a50-193">Here is the new markup:</span></span>

<span data-ttu-id="e9a50-194">**列表3：新标记**</span><span class="sxs-lookup"><span data-stu-id="e9a50-194">**Listing 3: New Markup**</span></span>

[!code-aspx[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample3.aspx)]

<span data-ttu-id="e9a50-195">下面是新的代码隐藏：</span><span class="sxs-lookup"><span data-stu-id="e9a50-195">And here is the new code-behind:</span></span>

<span data-ttu-id="e9a50-196">**列表4：代码隐藏**</span><span class="sxs-lookup"><span data-stu-id="e9a50-196">**Listing 4: Codebehind**</span></span>

[!code-csharp[Main](understanding-asp-net-ajax-updatepanel-triggers/samples/sample4.cs)]

<span data-ttu-id="e9a50-197">此页面背后的理念是：下拉列表中选择三种颜色之一来显示第二个标签，复选框确定是否为粗体以及标签是否显示日期和时间。</span><span class="sxs-lookup"><span data-stu-id="e9a50-197">The idea behind this page is that the drop-down list selects one of three colors to show the second label, that the check box determines both whether it is bold, and whether the labels display the date as well as the time.</span></span> <span data-ttu-id="e9a50-198">该复选框不会导致 AJAX 更新，但下拉列表应为，即使它不在 UpdatePanel 中。</span><span class="sxs-lookup"><span data-stu-id="e9a50-198">The check box should not cause an AJAX update, but the drop-down list should, even though it is not housed within an UpdatePanel.</span></span>

[![](understanding-asp-net-ajax-updatepanel-triggers/_static/image11.png)](understanding-asp-net-ajax-updatepanel-triggers/_static/image10.png)

<span data-ttu-id="e9a50-199">（[单击以查看完全大小的映像](understanding-asp-net-ajax-updatepanel-triggers/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="e9a50-199">([Click to view full-size image](understanding-asp-net-ajax-updatepanel-triggers/_static/image12.png))</span></span>

<span data-ttu-id="e9a50-200">正如上面的屏幕截图中所示，要单击的最新按钮是更新此面板的右侧按钮，该按钮更新了与底部时间无关的顶层时间。</span><span class="sxs-lookup"><span data-stu-id="e9a50-200">As is apparent in the above screen shot, the most-recent button to be clicked was the right button Update This Panel, which updated the top time independent of the bottom time.</span></span> <span data-ttu-id="e9a50-201">此日期在单击之间也处于关闭状态，因为日期在底部标签中可见。</span><span class="sxs-lookup"><span data-stu-id="e9a50-201">The date was also switched off between clicks, as the date is visible in the bottom label.</span></span> <span data-ttu-id="e9a50-202">要点是底部标签的颜色：它比标签文本更新了更近，这说明控件状态很重要，用户希望通过 AJAX 回发来保留控件状态。</span><span class="sxs-lookup"><span data-stu-id="e9a50-202">Finally of interest is the bottom label's color: it was updated more recently than the label's text, which demonstrates that control state is important, and users expect it to be preserved through AJAX postbacks.</span></span> <span data-ttu-id="e9a50-203">*但*未更新时间。</span><span class="sxs-lookup"><span data-stu-id="e9a50-203">*However*, the time was not updated.</span></span> <span data-ttu-id="e9a50-204">在服务器上重新呈现控件时，通过 ASP.NET 运行时所解释的页的 \_\_VIEWSTATE 字段的持久性，自动重新填充该时间。</span><span class="sxs-lookup"><span data-stu-id="e9a50-204">The time was automatically repopulated through the persistence of the \_\_VIEWSTATE field of the page being interpreted by the ASP.NET runtime when the control was being re-rendered on the server.</span></span> <span data-ttu-id="e9a50-205">ASP.NET AJAX 服务器代码无法识别控件所更改的状态的方法;它只是从视图状态中重新填充，然后运行相应的事件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-205">The ASP.NET AJAX server code does not recognize in which methods the controls are changing state; it simply repopulates from view state and then runs the events that are appropriate.</span></span>

<span data-ttu-id="e9a50-206">但应指出的是，我已在页面\_Load 事件中初始化时间，该时间已正确递增。</span><span class="sxs-lookup"><span data-stu-id="e9a50-206">It should be pointed out, however, that had I initialized the time within the Page\_Load event, the time would have been incremented correctly.</span></span> <span data-ttu-id="e9a50-207">因此，开发人员应小心地确保适当的代码在相应的事件处理程序中运行，并在适当的时候避免使用页面\_负载。</span><span class="sxs-lookup"><span data-stu-id="e9a50-207">Consequently, developers should be wary that the appropriate code is being run during the appropriate event handlers, and avoid use of Page\_Load when a control event handler would be appropriate.</span></span>

## <a name="summary"></a><span data-ttu-id="e9a50-208">总结</span><span class="sxs-lookup"><span data-stu-id="e9a50-208">Summary</span></span>

<span data-ttu-id="e9a50-209">ASP.NET AJAX Extensions UpdatePanel 控件是通用的，可以利用多种方法来识别应导致其更新的控件事件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-209">The ASP.NET AJAX Extensions UpdatePanel control is versatile, and can utilize a number of methods for identifying control events that should cause it to be updated.</span></span> <span data-ttu-id="e9a50-210">它支持由其子控件自动更新，但也可以响应页面上其他位置的控件事件。</span><span class="sxs-lookup"><span data-stu-id="e9a50-210">It supports being updated automatically by its child controls, but can also respond to control events elsewhere on the page.</span></span>

<span data-ttu-id="e9a50-211">为了降低服务器处理负载的可能，建议将 UpdatePanel 的 `ChildrenAsTriggers` 属性设置为 `false`，并选择该事件，而不是在默认情况下包括在内。</span><span class="sxs-lookup"><span data-stu-id="e9a50-211">To reduce potential for server processing load, it is recommended that the `ChildrenAsTriggers` property of an UpdatePanel be set to `false`, and that events be opted-into rather than included by default.</span></span> <span data-ttu-id="e9a50-212">这也会阻止任何不需要的事件引起可能不需要的影响，包括验证和输入字段更改。</span><span class="sxs-lookup"><span data-stu-id="e9a50-212">This also prevents any unneeded events from causing potentially-unwanted effects, including validation, and changes to input fields.</span></span> <span data-ttu-id="e9a50-213">这些类型的错误可能很难隔离，因为页面会以透明方式对用户进行更新，因此可能不会立即出现这种情况。</span><span class="sxs-lookup"><span data-stu-id="e9a50-213">These types of bugs may be difficult to isolate, because the page updates transparently to the user, and the cause may therefore not be immediately obvious.</span></span>

<span data-ttu-id="e9a50-214">通过检查 ASP.NET AJAX 窗体发布截获模型的内部工作原理，我们能够确定它是否利用了 ASP.NET 已提供的框架。</span><span class="sxs-lookup"><span data-stu-id="e9a50-214">By examining the inner workings of the ASP.NET AJAX form post interception model, we were able to determine that it utilizes the framework already provided by ASP.NET.</span></span> <span data-ttu-id="e9a50-215">在此过程中，它会保持与使用相同框架设计的控件的最大兼容性，并且干扰在为该页编写的任何附加 JavaScript 上最低。</span><span class="sxs-lookup"><span data-stu-id="e9a50-215">In doing so, it preserves maximum compatibility with controls designed using the same framework, and intrudes minimally on any additional JavaScript written for the page.</span></span>

## <a name="bio"></a><span data-ttu-id="e9a50-216">Bio</span><span class="sxs-lookup"><span data-stu-id="e9a50-216">Bio</span></span>

<span data-ttu-id="e9a50-217">抢 Paveza 是 Terralever （[www.terralever.com](http://www.terralever.com)）的高级 .net 应用程序开发人员，TEMPE，AZ 中领先的交互式营销公司。</span><span class="sxs-lookup"><span data-stu-id="e9a50-217">Rob Paveza is a senior .NET application developer at Terralever ([www.terralever.com](http://www.terralever.com)), a leading interactive marketing firm in Tempe, AZ.</span></span> <span data-ttu-id="e9a50-218">他可以[robpaveza@gmail.com](mailto:robpaveza@gmail.com)联系，他的博客位于[http://geekswithblogs.net/robp/](http://geekswithblogs.net/robp/)。</span><span class="sxs-lookup"><span data-stu-id="e9a50-218">He can be reached at [robpaveza@gmail.com](mailto:robpaveza@gmail.com), and his blog is located at [http://geekswithblogs.net/robp/](http://geekswithblogs.net/robp/).</span></span>

<span data-ttu-id="e9a50-219">Scott Cate 一直在使用 Microsoft Web 技术，因为1997，是 myKB.com （[www.myKB.com](http://www.myKB.com)）的总裁，他致力于编写基于知识库软件解决方案的基于 ASP.NET 的应用程序。</span><span class="sxs-lookup"><span data-stu-id="e9a50-219">Scott Cate has been working with Microsoft Web technologies since 1997 and is the President of myKB.com ([www.myKB.com](http://www.myKB.com)) where he specializes in writing ASP.NET based applications focused on Knowledge Base Software solutions.</span></span> <span data-ttu-id="e9a50-220">可以通过电子邮件联系 Scott [scott.cate@myKB.com](mailto:scott.cate@myKB.com)或[ScottCate.com](http://ScottCate.com)上的博客</span><span class="sxs-lookup"><span data-stu-id="e9a50-220">Scott can be contacted via email at [scott.cate@myKB.com](mailto:scott.cate@myKB.com) or his blog at [ScottCate.com](http://ScottCate.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="e9a50-221">[上一页](understanding-partial-page-updates-with-asp-net-ajax.md)
> [下一页](understanding-asp-net-ajax-authentication-and-profile-application-services.md)</span><span class="sxs-lookup"><span data-stu-id="e9a50-221">[Previous](understanding-partial-page-updates-with-asp-net-ajax.md)
[Next](understanding-asp-net-ajax-authentication-and-profile-application-services.md)</span></span>

---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs
title: 处理未经处理的异常 (C#) |Microsoft Docs
author: rick-anderson
description: 出现运行时错误，则在生产环境中的 web 应用程序时，若要通知开发人员，以记录该错误，以便它可以在诊断，a la 一定...
ms.author: riande
ms.date: 06/09/2009
ms.assetid: 5bc1afd5-2484-4528-b158-ab218ba150e8
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs
msc.type: authoredcontent
ms.openlocfilehash: 0a048527aeaa44a452324530625583c00239d6f2
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/06/2019
ms.locfileid: "65109291"
---
# <a name="processing-unhandled-exceptions-c"></a><span data-ttu-id="15300-103">处理未经处理的异常 (C#)</span><span class="sxs-lookup"><span data-stu-id="15300-103">Processing Unhandled Exceptions (C#)</span></span>

<span data-ttu-id="15300-104">通过[Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="15300-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="15300-105">[查看或下载示例代码](https://github.com/aspnet/AspNetDocs/tree/master/aspnet/web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs/samples)（[如何下载](/aspnet/core/tutorials/index#how-to-download-a-sample)）</span><span class="sxs-lookup"><span data-stu-id="15300-105">[View or download sample code](https://github.com/aspnet/AspNetDocs/tree/master/aspnet/web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs/samples) ([how to download](/aspnet/core/tutorials/index#how-to-download-a-sample))</span></span>

> <span data-ttu-id="15300-106">出现运行时错误，则在生产环境中的 web 应用程序时，通知开发人员以及记录错误，以便它可以诊断在以后的时间很重要。</span><span class="sxs-lookup"><span data-stu-id="15300-106">When a runtime error occurs on a web application in production it is important to notify a developer and to log the error so that it may be diagnosed at a later point in time.</span></span> <span data-ttu-id="15300-107">本教程概述 ASP.NET 如何处理运行时错误时，并探讨一种方法的自定义代码执行时由 ASP.NET 运行时未处理的异常气泡。</span><span class="sxs-lookup"><span data-stu-id="15300-107">This tutorial provides an overview of how ASP.NET processes runtime errors and looks at one way to have custom code execute whenever an unhandled exception bubbles up to the ASP.NET runtime.</span></span>

## <a name="introduction"></a><span data-ttu-id="15300-108">介绍</span><span class="sxs-lookup"><span data-stu-id="15300-108">Introduction</span></span>

<span data-ttu-id="15300-109">在 ASP.NET 应用程序中未经处理的异常时，冒泡到 ASP.NET 运行时，将引发`Error`事件，并显示相应的错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-109">When an unhandled exception occurs in an ASP.NET application, it bubbles up to the ASP.NET runtime, which raises the `Error` event and displays the appropriate error page.</span></span> <span data-ttu-id="15300-110">有三种不同类型的错误页： 运行时错误黄色屏幕的死亡 (YSOD);异常详细信息 YSOD;和自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-110">There are three different types of error pages: the Runtime Error Yellow Screen of Death (YSOD); the Exception Details YSOD; and custom error pages.</span></span> <span data-ttu-id="15300-111">在中[前面的教程](displaying-a-custom-error-page-cs.md)我们配置了应用程序的远程用户和用户访问本地异常详细信息 YSOD 使用自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-111">In the [preceding tutorial](displaying-a-custom-error-page-cs.md) we configured the application to use a custom error page for remote users and the Exception Details YSOD for users visiting locally.</span></span>

<span data-ttu-id="15300-112">使用用户友好的自定义错误页相匹配的站点的外观和感觉是优先于默认运行时错误 YSOD，但显示自定义错误页只有一个全面的错误处理解决方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="15300-112">Using a human-friendly custom error page that matches the look and feel of the site is preferred to the default Runtime Error YSOD, but displaying a custom error page is only one part of a comprehensive error handling solution.</span></span> <span data-ttu-id="15300-113">在生产环境中的应用程序中发生错误时, 非常重要，以便他们可以发现异常的原因和解决方法，开发人员将收到的错误。</span><span class="sxs-lookup"><span data-stu-id="15300-113">When an error occurs in an application in production, it is important that the developers are notified of the error so that they can unearth the cause of the exception and address it.</span></span> <span data-ttu-id="15300-114">此外，应记录错误的详细信息，以便可以检查错误和诊断在稍后的时间。</span><span class="sxs-lookup"><span data-stu-id="15300-114">Furthermore, the error's details should be logged so that the error can be examined and diagnosed at a later point in time.</span></span>

<span data-ttu-id="15300-115">本教程演示如何访问未经处理的异常的详细信息，以便可以记录和开发人员收到通知。</span><span class="sxs-lookup"><span data-stu-id="15300-115">This tutorial shows how to access the details of an unhandled exception so that they can be logged and a developer notified.</span></span> <span data-ttu-id="15300-116">以下此其中两个教程探索错误日志记录库，之后的配置中，将会自动通知开发人员的运行时错误，并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="15300-116">The two tutorials following this one explore error logging libraries that, after a bit of configuration, will automatically notify developers of runtime errors and log their details.</span></span>

> [!NOTE]
> <span data-ttu-id="15300-117">在本教程中检查的信息是最有用，如果您需要某种唯一或自定义的方式处理未处理的异常。</span><span class="sxs-lookup"><span data-stu-id="15300-117">The information examined in this tutorial is most useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="15300-118">在其中你只需记录异常并通知开发人员的情况下，使用错误日志记录库是转的方法。</span><span class="sxs-lookup"><span data-stu-id="15300-118">In cases where you only need to log the exception and notify a developer, using an error logging library is the way to go.</span></span> <span data-ttu-id="15300-119">接下来两个教程提供了两个这样的库的概述。</span><span class="sxs-lookup"><span data-stu-id="15300-119">The next two tutorials provide an overview of two such libraries.</span></span>

## <a name="executing-code-when-theerrorevent-is-raised"></a><span data-ttu-id="15300-120">执行代码时`Error`引发事件</span><span class="sxs-lookup"><span data-stu-id="15300-120">Executing Code When The`Error`Event Is Raised</span></span>

<span data-ttu-id="15300-121">事件提供一个对象发出信号，一些有趣的事情发生，以及另一个对象以执行代码以响应一种机制。</span><span class="sxs-lookup"><span data-stu-id="15300-121">Events provide an object a mechanism for signaling that something interesting has occurred, and for another object to execute code in response.</span></span> <span data-ttu-id="15300-122">作为 ASP.NET 开发人员您习惯于考虑事件。</span><span class="sxs-lookup"><span data-stu-id="15300-122">As an ASP.NET developer you are accustomed to thinking in terms of events.</span></span> <span data-ttu-id="15300-123">如果你想要访问者单击特定按钮时运行某些代码，为该按钮创建一个事件处理程序`Click`事件和放置您的代码。</span><span class="sxs-lookup"><span data-stu-id="15300-123">If you want to run some code when the visitor clicks a particular Button, you create an event handler for that Button's `Click` event and put your code there.</span></span> <span data-ttu-id="15300-124">考虑到 ASP.NET 运行时将引发其[`Error`事件](https://msdn.microsoft.com/library/system.web.httpapplication.error.aspx)每当未处理的异常发生时，它遵循的原则用于记录错误的详细信息的代码将进入事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-124">Given that the ASP.NET runtime raises its [`Error` event](https://msdn.microsoft.com/library/system.web.httpapplication.error.aspx) whenever an unhandled exception occurs, it follows that the code for logging the error's details would go in an event handler.</span></span> <span data-ttu-id="15300-125">如何创建事件处理程序，但`Error`事件？</span><span class="sxs-lookup"><span data-stu-id="15300-125">But how do you create an event handler for the `Error` event?</span></span>

<span data-ttu-id="15300-126">`Error`事件是中的多个事件之一[`HttpApplication`类](https://msdn.microsoft.com/library/system.web.httpapplication.aspx)请求的生存期期间，会引发在 HTTP 管道中的某些阶段。</span><span class="sxs-lookup"><span data-stu-id="15300-126">The `Error` event is one of many events in the [`HttpApplication` class](https://msdn.microsoft.com/library/system.web.httpapplication.aspx) that are raised at certain stages in the HTTP pipeline during the lifetime of a request.</span></span> <span data-ttu-id="15300-127">例如，`HttpApplication`类的[`BeginRequest`事件](https://msdn.microsoft.com/library/system.web.httpapplication.beginrequest.aspx); 的每个请求开始时引发其[`AuthenticateRequest`事件](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx)安全模块已标识请求者时引发。</span><span class="sxs-lookup"><span data-stu-id="15300-127">For example, the `HttpApplication` class's [`BeginRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.beginrequest.aspx) is raised at the start of every request; its [`AuthenticateRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx) is raised when a security module has identified the requestor.</span></span> <span data-ttu-id="15300-128">这些`HttpApplication`事件为页面开发人员提供了一种方法来执行请求的生存期内的不同位置的自定义逻辑。</span><span class="sxs-lookup"><span data-stu-id="15300-128">These `HttpApplication` events give the page developer a means to execute custom logic at the various points in the lifetime of a request.</span></span>

<span data-ttu-id="15300-129">事件处理程序`HttpApplication`事件可以放在名为的特殊文件`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="15300-129">Event handlers for the `HttpApplication` events can be placed in a special file named `Global.asax`.</span></span> <span data-ttu-id="15300-130">若要在你的网站中创建此文件，向您的网站名称中使用全局应用程序类模板的根添加新项`Global.asax`。</span><span class="sxs-lookup"><span data-stu-id="15300-130">To create this file in your website, add a new item to the root of your website using the Global Application Class template with the name `Global.asax`.</span></span>

[![](processing-unhandled-exceptions-cs/_static/image2.png)](processing-unhandled-exceptions-cs/_static/image1.png)

<span data-ttu-id="15300-131">**图 1**:添加`Global.asax`对 Web 应用程序</span><span class="sxs-lookup"><span data-stu-id="15300-131">**Figure 1**: Add `Global.asax` To Your Web Application</span></span>  
<span data-ttu-id="15300-132">([单击此项可查看原尺寸图像](processing-unhandled-exceptions-cs/_static/image3.png))</span><span class="sxs-lookup"><span data-stu-id="15300-132">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image3.png))</span></span>

<span data-ttu-id="15300-133">内容和结构`Global.asax`略有根据使用的 Web 应用程序项目 (WAP) 或网站项目 (WSP) 由 Visual Studio 创建的文件会有所不同。</span><span class="sxs-lookup"><span data-stu-id="15300-133">The contents and structure of the `Global.asax` file created by Visual Studio differ slightly based on whether you are using a Web Application Project (WAP) or Web Site Project (WSP).</span></span> <span data-ttu-id="15300-134">使用 WAP`Global.asax`实现作为两个单独的文件-`Global.asax`和`Global.asax.cs`。</span><span class="sxs-lookup"><span data-stu-id="15300-134">With a WAP, the `Global.asax` is implemented as two separate files - `Global.asax` and `Global.asax.cs`.</span></span> <span data-ttu-id="15300-135">`Global.asax`文件不包含任何内容，但`@Application`指令，它引用`.cs`文件; 所需的处理程序中定义的事件`Global.asax.cs`文件。</span><span class="sxs-lookup"><span data-stu-id="15300-135">The `Global.asax` file contains nothing but an `@Application` directive that references the `.cs` file; the event handlers of interest are defined in the `Global.asax.cs` file.</span></span> <span data-ttu-id="15300-136">对于 Wsp，都会创建一个文件， `Global.asax`，并在中定义的事件处理程序`<script runat="server">`块。</span><span class="sxs-lookup"><span data-stu-id="15300-136">For WSPs, only a single file is created, `Global.asax`, and the event handlers are defined in a `<script runat="server">` block.</span></span>

<span data-ttu-id="15300-137">`Global.asax` WAP 中创建由 Visual Studio 的应用程序的全局类模板文件包含名为事件处理程序`Application_BeginRequest`， `Application_AuthenticateRequest`，和`Application_Error`，这是事件处理程序`HttpApplication`事件`BeginRequest`， `AuthenticateRequest`，和`Error`分别。</span><span class="sxs-lookup"><span data-stu-id="15300-137">The `Global.asax` file created in a WAP by Visual Studio's Global Application Class template includes event handlers named `Application_BeginRequest`, `Application_AuthenticateRequest`, and `Application_Error`, which are event handlers for the `HttpApplication` events `BeginRequest`, `AuthenticateRequest`, and `Error`, respectively.</span></span> <span data-ttu-id="15300-138">此外，还有名为事件处理程序`Application_Start`， `Session_Start`， `Application_End`，和`Session_End`，这是事件处理程序触发的 web 应用程序启动时，当新的会话启动后，应用程序结束时，以及当会话结束时，分别。</span><span class="sxs-lookup"><span data-stu-id="15300-138">There are also event handlers named `Application_Start`, `Session_Start`, `Application_End`, and `Session_End`, which are event handlers that fire when the web application starts, when a new session starts, when the application ends, and when a session ends, respectively.</span></span> <span data-ttu-id="15300-139">`Global.asax`文件的 Visual Studio 中加入 WSP 创建只包含`Application_Error`， `Application_Start`， `Session_Start`， `Application_End`，并`Session_End`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-139">The `Global.asax` file created in a WSP by Visual Studio contains just the `Application_Error`, `Application_Start`, `Session_Start`, `Application_End`, and `Session_End` event handlers.</span></span>

> [!NOTE]
> <span data-ttu-id="15300-140">部署 ASP.NET 应用程序时需要将复制`Global.asax`到生产环境的文件。</span><span class="sxs-lookup"><span data-stu-id="15300-140">When deploying the ASP.NET application you need to copy the `Global.asax` file to the production environment.</span></span> <span data-ttu-id="15300-141">`Global.asax.cs`文件，在 WAP 中创建的是，不需要将复制到生产环境，因为此代码编译到项目的程序集。</span><span class="sxs-lookup"><span data-stu-id="15300-141">The `Global.asax.cs` file, which is created in the WAP, does not need to be copied to production because this code is compiled into the project's assembly.</span></span>

<span data-ttu-id="15300-142">Visual Studio 的应用程序的全局类模板创建的事件处理程序并不详尽。</span><span class="sxs-lookup"><span data-stu-id="15300-142">The event handlers created by Visual Studio's Global Application Class template are not exhaustive.</span></span> <span data-ttu-id="15300-143">可以将事件处理程序添加的任何`HttpApplication`通过命名事件处理程序的事件`Application_EventName`。</span><span class="sxs-lookup"><span data-stu-id="15300-143">You can add an event handler for any `HttpApplication` event by naming the event handler `Application_EventName`.</span></span> <span data-ttu-id="15300-144">例如，可以添加以下代码`Global.asax`文件以创建的事件处理程序[`AuthorizeRequest`事件](https://msdn.microsoft.com/library/system.web.httpapplication.authorizerequest.aspx):</span><span class="sxs-lookup"><span data-stu-id="15300-144">For example, you could add the following code to the `Global.asax` file to create an event handler for the [`AuthorizeRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.authorizerequest.aspx):</span></span>

[!code-cs[Main](processing-unhandled-exceptions-cs/samples/sample1.cs)]

<span data-ttu-id="15300-145">同样，您可以删除应用程序的全局类模板创建的任何事件处理程序，则不需要。</span><span class="sxs-lookup"><span data-stu-id="15300-145">Likewise, you can remove any event handlers created by the Global Application Class template that are not needed.</span></span> <span data-ttu-id="15300-146">本教程中我们只需要的事件处理程序`Error`事件; 请随时删除从其他事件处理程序`Global.asax`文件。</span><span class="sxs-lookup"><span data-stu-id="15300-146">For this tutorial we only require an event handler for the `Error` event; feel free to remove the other event handlers from the `Global.asax` file.</span></span>

> [!NOTE]
> <span data-ttu-id="15300-147">*HTTP 模块*提供了另一种方法来定义事件处理程序`HttpApplication`事件。</span><span class="sxs-lookup"><span data-stu-id="15300-147">*HTTP Modules* offer another way to define event handlers for `HttpApplication` events.</span></span> <span data-ttu-id="15300-148">HTTP 模块创建为类文件中，可以直接在 web 应用程序项目中放置或者被分隔到单独的类库。</span><span class="sxs-lookup"><span data-stu-id="15300-148">HTTP Modules are created as a class file that can be placed directly within the web application project or separated out into a separate class library.</span></span> <span data-ttu-id="15300-149">因为它们可以分离到一个类库，HTTP 模块提供用于创建更灵活且可重复使用模型`HttpApplication`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-149">Because they can be separated out into a class library, HTTP Modules offer a more flexible and reusable model for creating `HttpApplication` event handlers.</span></span> <span data-ttu-id="15300-150">而`Global.asax`文件是特定于它所在的 web 应用，HTTP 模块可以编译到程序集，此时将 HTTP 模块添加到网站非常简单，只将该程序集放入适当`Bin`文件夹和注册中的模块`Web.config`。</span><span class="sxs-lookup"><span data-stu-id="15300-150">Whereas the `Global.asax` file is specific to the web application where it resides, HTTP Modules can be compiled into assemblies, at which point adding the HTTP Module to a website is as simple as dropping the assembly in the `Bin` folder and registering the Module in `Web.config`.</span></span> <span data-ttu-id="15300-151">本教程不会查找在创建和使用的 HTTP 模块，但在以下两个教程中使用的两个错误日志记录库作为 HTTP 模块实现的。</span><span class="sxs-lookup"><span data-stu-id="15300-151">This tutorial does not look at creating and using HTTP Modules, but the two error logging libraries used in the following two tutorials are implemented as HTTP Modules.</span></span> <span data-ttu-id="15300-152">有关更多背景 HTTP 模块的优势，请参阅[使用 HTTP 模块和处理程序创建可插入 ASP.NET 组件](https://msdn.microsoft.com/library/aa479332.aspx)。</span><span class="sxs-lookup"><span data-stu-id="15300-152">For more background on the benefits of HTTP Modules refer to [Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components](https://msdn.microsoft.com/library/aa479332.aspx).</span></span>

## <a name="retrieving-information-about-the-unhandled-exception"></a><span data-ttu-id="15300-153">检索未处理的异常有关的信息</span><span class="sxs-lookup"><span data-stu-id="15300-153">Retrieving Information About the Unhandled Exception</span></span>

<span data-ttu-id="15300-154">现在我们有的 Global.asax 文件`Application_Error`事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-154">At this point we have a Global.asax file with an `Application_Error` event handler.</span></span> <span data-ttu-id="15300-155">此事件处理程序执行时我们需要通知的错误的开发人员并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="15300-155">When this event handler executes we need to notify a developer of the error and log its details.</span></span> <span data-ttu-id="15300-156">若要完成这些任务我们首先需要确定所引发的异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="15300-156">To accomplish these tasks we first need to determine the details of the exception that was raised.</span></span> <span data-ttu-id="15300-157">使用服务器对象的[`GetLastError`方法](https://msdn.microsoft.com/library/system.web.httpserverutility.getlasterror.aspx)来检索导致的未处理异常的详细信息`Error`激发的事件。</span><span class="sxs-lookup"><span data-stu-id="15300-157">Use the Server object's [`GetLastError` method](https://msdn.microsoft.com/library/system.web.httpserverutility.getlasterror.aspx) to retrieve details of the unhandled exception that caused the `Error` event to fire.</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample2.cs)]

<span data-ttu-id="15300-158">`GetLastError`方法返回类型的对象`Exception`，这是.NET Framework 中的所有异常的基类型。</span><span class="sxs-lookup"><span data-stu-id="15300-158">The `GetLastError` method returns an object of type `Exception`, which is the base type for all exceptions in the .NET Framework.</span></span> <span data-ttu-id="15300-159">但是，在上面的代码中我将强制转换返回的异常对象`GetLastError`到`HttpException`对象。</span><span class="sxs-lookup"><span data-stu-id="15300-159">However, in the code above I am casting the Exception object returned by `GetLastError` into an `HttpException` object.</span></span> <span data-ttu-id="15300-160">如果`Error`因为引发了异常处理 ASP.NET 资源期间引发的异常包装中，然后触发事件`HttpException`。</span><span class="sxs-lookup"><span data-stu-id="15300-160">If the `Error` event is being fired because an exception was thrown during the processing of an ASP.NET resource then the exception that was thrown is wrapped within an `HttpException`.</span></span> <span data-ttu-id="15300-161">若要获取实际的异常引发错误事件使用`InnerException`属性。</span><span class="sxs-lookup"><span data-stu-id="15300-161">To get the actual exception that precipitated the Error event use the `InnerException` property.</span></span> <span data-ttu-id="15300-162">如果`Error`由于基于 HTTP 的异常，例如不存在页的请求而引发事件`HttpException`引发，但它不具有内部异常。</span><span class="sxs-lookup"><span data-stu-id="15300-162">If the `Error` event was raised because of an HTTP-based exception, such as a request for a non-existent page, an `HttpException` is thrown, but it does not have an inner exception.</span></span>

<span data-ttu-id="15300-163">下面的代码使用`GetLastErrormessage`来检索有关触发异常的信息`Error`事件，存储`HttpException`在名为`lastErrorWrapper`。</span><span class="sxs-lookup"><span data-stu-id="15300-163">The following code uses the `GetLastErrormessage` to retrieve information about the exception that triggered the `Error` event, storing the `HttpException` in a variable named `lastErrorWrapper`.</span></span> <span data-ttu-id="15300-164">它然后将存储类型、 消息和原始异常堆栈跟踪在三个字符串变量中，检查是否`lastErrorWrapper`实际异常在触发`Error`事件 （对于基于 HTTP 的异常） 或是否只是处理请求时引发的异常的包装器。</span><span class="sxs-lookup"><span data-stu-id="15300-164">It then stores the type, message, and stack trace of the originating exception in three string variables, checking to see if the `lastErrorWrapper` is the actual exception that triggered the `Error` event (in the case of HTTP-based exceptions) or if it's merely a wrapper for an exception that was thrown while processing the request.</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample3.cs)]

<span data-ttu-id="15300-165">此时您具有所需编写代码，会将记录到数据库表的异常的详细信息的所有信息。</span><span class="sxs-lookup"><span data-stu-id="15300-165">At this point you have all the information you need to write code that will log the exception's details to a database table.</span></span> <span data-ttu-id="15300-166">为每个感兴趣的类型、 消息、 堆栈跟踪等-以及其他有用的信息，如请求的页面的 URL 和当前登录用户的名称部分的错误详细信息，可以使用列创建一个数据库表。</span><span class="sxs-lookup"><span data-stu-id="15300-166">You could create a database table with columns for each of the error details of interest - the type, the message, the stack trace, and so on - along with other useful pieces of information, such as the URL of the requested page and the name of the currently logged on user.</span></span> <span data-ttu-id="15300-167">在`Application_Error`然后连接到数据库，并向表插入记录的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-167">In the `Application_Error` event handler you would then connect to the database and insert a record into the table.</span></span> <span data-ttu-id="15300-168">同样，可以添加代码以提醒开发人员通过电子邮件错误。</span><span class="sxs-lookup"><span data-stu-id="15300-168">Likewise, you could add code to alert a developer of the error via email.</span></span>

<span data-ttu-id="15300-169">在接下来两个教程中检查错误日志记录库提供默认情况下，此类功能，因此无需自行生成此错误日志记录和通知。</span><span class="sxs-lookup"><span data-stu-id="15300-169">The error logging libraries examined in the next two tutorials provide such functionality out of the box, so there's no need to build this error logging and notification yourself.</span></span> <span data-ttu-id="15300-170">但是，为了说明这一点`Error`引发事件，`Application_Error`事件处理程序可用于记录错误详细信息和通知开发人员，让我们添加当发生错误时通知开发人员的代码。</span><span class="sxs-lookup"><span data-stu-id="15300-170">However, to illustrate that the `Error` event is being raised and that the `Application_Error` event handler can be used to log error details and notify a developer, let's add code that notifies a developer when an error occurs.</span></span>

## <a name="notifying-a-developer-when-an-unhandled-exception-occurs"></a><span data-ttu-id="15300-171">未经处理的异常发生时通知开发人员</span><span class="sxs-lookup"><span data-stu-id="15300-171">Notifying a Developer When an Unhandled Exception Occurs</span></span>

<span data-ttu-id="15300-172">在生产环境中发生未经处理的异常时，一定向开发团队发出警报，以便它们可以评估该错误并确定需要采取的操作。</span><span class="sxs-lookup"><span data-stu-id="15300-172">When an unhandled exception occurs in the production environment it is important to alert the development team so that they can assess the error and determine what actions need to be taken.</span></span> <span data-ttu-id="15300-173">例如，如果没有连接到数据库，则需要为双精度值中的错误检查连接字符串和，这样一来，与您的 web 托管公司开具支持票证。</span><span class="sxs-lookup"><span data-stu-id="15300-173">For example, if there is an error in connecting to the database then you'll need to double check your connection string and, perhaps, open a support ticket with your web hosting company.</span></span> <span data-ttu-id="15300-174">如果由于编程错误导致出现异常，可能需要额外的代码或验证逻辑添加以防止将来出现此类错误。</span><span class="sxs-lookup"><span data-stu-id="15300-174">If the exception occurred because of a programming error, additional code or validation logic may need to be added to prevent such errors in the future.</span></span>

<span data-ttu-id="15300-175">.NET Framework 中的类[`System.Net.Mail`命名空间](https://msdn.microsoft.com/library/system.net.mail.aspx)轻松地将发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="15300-175">The .NET Framework classes in the [`System.Net.Mail` namespace](https://msdn.microsoft.com/library/system.net.mail.aspx) make it easy to send an email.</span></span> <span data-ttu-id="15300-176">[ `MailMessage`类](https://msdn.microsoft.com/library/system.net.mail.mailmessage.aspx)表示一封电子邮件并具有属性，如`To`， `From`， `Subject`， `Body`，和`Attachments`。</span><span class="sxs-lookup"><span data-stu-id="15300-176">The [`MailMessage` class](https://msdn.microsoft.com/library/system.net.mail.mailmessage.aspx) represents an email message and has properties like `To`, `From`, `Subject`, `Body`, and `Attachments`.</span></span> <span data-ttu-id="15300-177">`SmtpClass`用于发送`MailMessage`对象使用指定的 SMTP 服务器; 可以以编程方式或以声明方式在指定的 SMTP 服务器设置[`<system.net>`元素](https://msdn.microsoft.com/library/6484zdc1.aspx)中`Web.config file`。</span><span class="sxs-lookup"><span data-stu-id="15300-177">The `SmtpClass` is used to send a `MailMessage` object using a specified SMTP server; the SMTP server settings can be specified programmatically or declaratively in the [`<system.net>` element](https://msdn.microsoft.com/library/6484zdc1.aspx) in the `Web.config file`.</span></span> <span data-ttu-id="15300-178">有关发送电子邮件的详细信息中的 ASP.NET 应用程序的消息查看我的文章[在 ASP.NET 中发送电子邮件](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)，并[System.Net.Mail 常见问题解答](http://systemnetmail.com/)。</span><span class="sxs-lookup"><span data-stu-id="15300-178">For more information on sending email messages in an ASP.NET application check out my article, [Sending Email in ASP.NET](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx), and the [System.Net.Mail FAQ](http://systemnetmail.com/).</span></span>

> [!NOTE]
> <span data-ttu-id="15300-179">`<system.net>`元素包含使用的 SMTP 服务器设置`SmtpClient`类时发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="15300-179">The `<system.net>` element contains the SMTP server settings used by the `SmtpClient` class when sending an email.</span></span> <span data-ttu-id="15300-180">您的 web 托管公司可能具有可用于从您的应用程序发送电子邮件的 SMTP 服务器。</span><span class="sxs-lookup"><span data-stu-id="15300-180">Your web hosting company likely has an SMTP server that you can use to send email from your application.</span></span> <span data-ttu-id="15300-181">有关应在 web 应用程序中使用的 SMTP 服务器设置的信息，请参阅 web 主机的支持部分。</span><span class="sxs-lookup"><span data-stu-id="15300-181">Consult your web host's support section for information on the SMTP server settings you should use in your web application.</span></span>

<span data-ttu-id="15300-182">将以下代码添加到`Application_Error`事件处理程序发送的一名开发人员电子邮件时出现错误：</span><span class="sxs-lookup"><span data-stu-id="15300-182">Add the following code to the `Application_Error` event handler to send a developer an email when an error occurs:</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample4.cs)]

<span data-ttu-id="15300-183">虽然上面的代码是非常长，它的大容量创建显示的 HTML 发送到开发人员的电子邮件中。</span><span class="sxs-lookup"><span data-stu-id="15300-183">While the above code is quite lengthy, the bulk of it creates the HTML that appears in the email sent to the developer.</span></span> <span data-ttu-id="15300-184">该代码以引用`HttpException`返回的`GetLastError`方法 (`lastErrorWrapper`)。</span><span class="sxs-lookup"><span data-stu-id="15300-184">The code starts by referencing the `HttpException` returned by the `GetLastError` method (`lastErrorWrapper`).</span></span> <span data-ttu-id="15300-185">通过检索实际请求由引发的异常`lastErrorWrapper.InnerException`并分配给变量`lastError`。</span><span class="sxs-lookup"><span data-stu-id="15300-185">The actual exception that was raised by the request is retrieved via `lastErrorWrapper.InnerException` and is assigned to the variable `lastError`.</span></span> <span data-ttu-id="15300-186">类型、 消息和堆栈跟踪信息检索从`lastError`，存储在三个字符串变量。</span><span class="sxs-lookup"><span data-stu-id="15300-186">The type, message, and stack trace information is retrieved from `lastError` and stored in three string variables.</span></span>

<span data-ttu-id="15300-187">下一步，`MailMessage`名为对象`mm`创建。</span><span class="sxs-lookup"><span data-stu-id="15300-187">Next, a `MailMessage` object named `mm` is created.</span></span> <span data-ttu-id="15300-188">电子邮件正文为 HTML 格式，并显示请求的页面的 URL、 当前登录的用户，以及有关异常 （类型、 消息和堆栈跟踪） 信息的名称。</span><span class="sxs-lookup"><span data-stu-id="15300-188">The email body is HTML formatted and displays the URL of the requested page, the name of the currently logged on user, and information about the exception (the type, message, and stack trace).</span></span> <span data-ttu-id="15300-189">有关很酷的事情之一`HttpException`类是可以生成用于创建异常的详细信息黄色屏幕的死亡 (YSOD) 通过调用的 HTML [GetHtmlErrorMessage 方法](https://msdn.microsoft.com/library/system.web.httpexception.gethtmlerrormessage.aspx)。</span><span class="sxs-lookup"><span data-stu-id="15300-189">One of the cool things about the `HttpException` class is that you can generate the HTML used to create the Exception Details Yellow Screen of Death (YSOD) by calling the [GetHtmlErrorMessage method](https://msdn.microsoft.com/library/system.web.httpexception.gethtmlerrormessage.aspx).</span></span> <span data-ttu-id="15300-190">此处使用此方法检索异常详细信息 YSOD 标记并将其添加到的电子邮件的附件。</span><span class="sxs-lookup"><span data-stu-id="15300-190">This method is used here to retrieve the Exception Details YSOD markup and add it to the email as an attachment.</span></span> <span data-ttu-id="15300-191">一句警告： 如果该异常的触发`Error`事件，基于 HTTP 的异常 （如不存在页的请求），然后`GetHtmlErrorMessage`方法将返回`null`。</span><span class="sxs-lookup"><span data-stu-id="15300-191">One word of caution: if the exception that triggered the `Error` event was an HTTP-based exception (such as a request for a non-existent page) then the `GetHtmlErrorMessage` method will return `null`.</span></span>

<span data-ttu-id="15300-192">最后一步是发送`MailMessage`。</span><span class="sxs-lookup"><span data-stu-id="15300-192">The final step is to send the `MailMessage`.</span></span> <span data-ttu-id="15300-193">这是通过创建一个新`SmtpClient`方法，并调用其`Send`方法。</span><span class="sxs-lookup"><span data-stu-id="15300-193">This is done by creating a new `SmtpClient` method and calling its `Send` method.</span></span>

> [!NOTE]
> <span data-ttu-id="15300-194">在 web 应用程序中使用此代码之前你将想要更改中的值`ToAddress`并`FromAddress`常量从support@example.com对任何电子邮件地址错误通知电子邮件应发送到和来自。</span><span class="sxs-lookup"><span data-stu-id="15300-194">Before using this code in your web application you'll want to change the values in the `ToAddress` and `FromAddress` constants from support@example.com to whatever email address the error notification email should be sent to and originate from.</span></span> <span data-ttu-id="15300-195">您还需要指定在 SMTP 服务器设置`<system.net>`主题中`Web.config`。</span><span class="sxs-lookup"><span data-stu-id="15300-195">You'll also need to specify SMTP server settings in the `<system.net>` section in `Web.config`.</span></span> <span data-ttu-id="15300-196">请咨询你的 web 主机提供商，以确定要使用的 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="15300-196">Consult your web host provider to determine the SMTP server settings to use.</span></span>

<span data-ttu-id="15300-197">利用此代码存在由错误的任何时间开发人员是发送汇总了错误并且包括 YSOD 的电子邮件。</span><span class="sxs-lookup"><span data-stu-id="15300-197">With this code in place anytime there's an error the developer is sent an email message that summarizes the error and includes the YSOD.</span></span> <span data-ttu-id="15300-198">前面的教程演示运行时错误通过访问 Genre.aspx 并传入无效`ID`通过在查询字符串，如值`Genre.aspx?ID=foo`。</span><span class="sxs-lookup"><span data-stu-id="15300-198">In the preceding tutorial we demonstrated a runtime error by visiting Genre.aspx and passing in an invalid `ID` value through the querystring, like `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="15300-199">访问与页面`Global.asax`文件后的生成相同的用户体验与在前面的教程-在开发环境中你将继续查看异常详细信息黄色屏幕死机，而在生产环境中，你就请参阅自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-199">Visiting the page with the `Global.asax` file in place produces the same user experience as in the preceding tutorial - in the development environment you'll continue to see the Exception Details Yellow Screen of Death, while in the production environment you'll see the custom error page.</span></span> <span data-ttu-id="15300-200">除了此现有行为，开发人员会发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="15300-200">In addition to this existing behavior, the developer is sent an email.</span></span>

<span data-ttu-id="15300-201">**图 2**显示了访问时收到的电子邮件`Genre.aspx?ID=foo`。</span><span class="sxs-lookup"><span data-stu-id="15300-201">**Figure 2** shows the email received when visiting `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="15300-202">电子邮件正文总结了异常的信息，而`YSOD.htm`附件显示的异常详细信息 YSOD 中所示的内容 (请参阅**图 3**)。</span><span class="sxs-lookup"><span data-stu-id="15300-202">The email body summarizes the exception information, while the `YSOD.htm` attachment displays the content that is shown in the Exception Details YSOD (see **Figure 3**).</span></span>

[![](processing-unhandled-exceptions-cs/_static/image5.png)](processing-unhandled-exceptions-cs/_static/image4.png)

<span data-ttu-id="15300-203">**图 2**:开发人员在未经处理的异常时发送电子邮件通知</span><span class="sxs-lookup"><span data-stu-id="15300-203">**Figure 2**: The Developer Is Sent An Email Notification Whenever There's An Unhandled Exception</span></span>  
<span data-ttu-id="15300-204">([单击此项可查看原尺寸图像](processing-unhandled-exceptions-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="15300-204">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image6.png))</span></span>

[![](processing-unhandled-exceptions-cs/_static/image8.png)](processing-unhandled-exceptions-cs/_static/image7.png)

<span data-ttu-id="15300-205">**图 3**:电子邮件通知以附件的形式包括异常详细信息 YSOD</span><span class="sxs-lookup"><span data-stu-id="15300-205">**Figure 3**: The Email Notification Includes the Exception Details YSOD As An Attachment</span></span>  
<span data-ttu-id="15300-206">([单击此项可查看原尺寸图像](processing-unhandled-exceptions-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="15300-206">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image9.png))</span></span>

## <a name="what-about-using-the-custom-error-page"></a><span data-ttu-id="15300-207">使用自定义错误页怎么样呢？</span><span class="sxs-lookup"><span data-stu-id="15300-207">What About Using the Custom Error Page?</span></span>

<span data-ttu-id="15300-208">本教程介绍了如何使用`Global.asax`和`Application_Error`事件处理程序以未经处理的异常发生时执行代码。</span><span class="sxs-lookup"><span data-stu-id="15300-208">This tutorial showed how to use `Global.asax` and the `Application_Error` event handler to execute code when an unhandled exception occurs.</span></span> <span data-ttu-id="15300-209">具体而言，我们使用此事件处理程序通知的错误，开发人员我们可以扩展它还在数据库中记录错误详细信息。</span><span class="sxs-lookup"><span data-stu-id="15300-209">Specifically, we used this event handler to notify a developer of an error; we could extend it to also log the error details in a database.</span></span> <span data-ttu-id="15300-210">是否存在`Application_Error`事件处理程序不会影响最终用户体验。</span><span class="sxs-lookup"><span data-stu-id="15300-210">The presence of the `Application_Error` event handler does not affect the end user's experience.</span></span> <span data-ttu-id="15300-211">它们仍看到配置的错误页，比如错误详细信息 YSOD、 运行时错误 YSOD 或自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-211">They still see the configured error page, be it the Error Details YSOD, the Runtime Error YSOD, or the custom error page.</span></span>

<span data-ttu-id="15300-212">很自然地想知道是否`Global.asax`文件和`Application_Error`事件时是必需的使用自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-212">It's natural to wonder whether the `Global.asax` file and `Application_Error` event is necessary when using a custom error page.</span></span> <span data-ttu-id="15300-213">当出错时向用户显示自定义错误页因此为什么不能我们的代码以通知开发人员并登录到自定义错误页的代码隐藏类的错误详细信息？</span><span class="sxs-lookup"><span data-stu-id="15300-213">When an error occurs the user is shown the custom error page so why can't we put the code to notify the developer and log the error details into the code-behind class of the custom error page?</span></span> <span data-ttu-id="15300-214">虽然当然可以将代码添加到自定义错误页的代码隐藏类没有访问触发异常的详细信息`Error`使用我们在前面的教程中探讨了该技术时的事件。</span><span class="sxs-lookup"><span data-stu-id="15300-214">While you can certainly add code to the custom error page's code-behind class you do not have access to the details of the exception that triggered the `Error` event when using the technique we explored in the preceding tutorial.</span></span> <span data-ttu-id="15300-215">调用`GetLastError`从自定义错误页的方法将返回`Nothing`。</span><span class="sxs-lookup"><span data-stu-id="15300-215">Calling the `GetLastError` method from the custom error page returns `Nothing`.</span></span>

<span data-ttu-id="15300-216">此行为的原因是因为通过重定向访问自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-216">The reason for this behavior is because the custom error page is reached via a redirect.</span></span> <span data-ttu-id="15300-217">当未经处理的异常到达 ASP.NET 运行时 ASP.NET 引擎引发其`Error`事件 (它将执行`Application_Error`事件处理程序)，然后*将重定向*用户可以通过发出自定义错误页`Response.Redirect(customErrorPageUrl)`.</span><span class="sxs-lookup"><span data-stu-id="15300-217">When an unhandled exception reaches the ASP.NET runtime the ASP.NET engine raises its `Error` event (which executes the `Application_Error` event handler) and then *redirects* the user to the custom error page by issuing a `Response.Redirect(customErrorPageUrl)`.</span></span> <span data-ttu-id="15300-218">`Response.Redirect`方法将发送到客户端使用 HTTP 302 状态代码，指示浏览器请求新的 URL，即自定义错误页的响应。</span><span class="sxs-lookup"><span data-stu-id="15300-218">The `Response.Redirect` method sends a response to the client with an HTTP 302 status code, instructing the browser to request a new URL, namely the custom error page.</span></span> <span data-ttu-id="15300-219">然后，在浏览器会自动请求这一新页面。</span><span class="sxs-lookup"><span data-stu-id="15300-219">The browser then automatically requests this new page.</span></span> <span data-ttu-id="15300-220">您所见，从页面中自定义错误页分别请求错误源于何处因为浏览器地址栏更改为自定义错误页面的 URL (请参阅**图 4**)。</span><span class="sxs-lookup"><span data-stu-id="15300-220">You can tell that the custom error page was requested separately from the page where the error originated because the browser's Address bar changes to the custom error page URL (see **Figure 4**).</span></span>

[![](processing-unhandled-exceptions-cs/_static/image11.png)](processing-unhandled-exceptions-cs/_static/image10.png)

<span data-ttu-id="15300-221">**图 4**:发生错误时在浏览器获取重定向到自定义错误页 URL</span><span class="sxs-lookup"><span data-stu-id="15300-221">**Figure 4**: When an Error Occurs the Browser Gets Redirected to the Custom Error Page URL</span></span>  
<span data-ttu-id="15300-222">([单击此项可查看原尺寸图像](processing-unhandled-exceptions-cs/_static/image12.png))</span><span class="sxs-lookup"><span data-stu-id="15300-222">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image12.png))</span></span>

<span data-ttu-id="15300-223">实际效果是未经处理的异常发生位置请求结束时服务器的响应使用 HTTP 302 重定向。</span><span class="sxs-lookup"><span data-stu-id="15300-223">The net effect is that the request where the unhandled exception occurred ends when the server responds with the HTTP 302 redirect.</span></span> <span data-ttu-id="15300-224">对自定义错误页的后续请求是全新的请求;此时 ASP.NET 引擎已丢弃的错误信息和，此外，有没有办法将上一个请求中未经处理的异常与自定义错误页的新请求相关联。</span><span class="sxs-lookup"><span data-stu-id="15300-224">The subsequent request to the custom error page is a brand new request; by this point the ASP.NET engine has discarded the error information and, moreover, has no way to associate the unhandled exception in the previous request with the new request for the custom error page.</span></span> <span data-ttu-id="15300-225">这就是为什么`GetLastError`返回`null`时从自定义错误页调用。</span><span class="sxs-lookup"><span data-stu-id="15300-225">This is why `GetLastError` returns `null` when called from the custom error page.</span></span>

<span data-ttu-id="15300-226">但是，很可能有导致该错误在同一个请求期间执行的自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-226">However, it is possible to have the custom error page executed during the same request that caused the error.</span></span> <span data-ttu-id="15300-227">[ `Server.Transfer(url)` ](https://msdn.microsoft.com/library/system.web.httpserverutility.transfer.aspx)方法将执行转移到指定的 URL，并在同一请求中对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="15300-227">The [`Server.Transfer(url)`](https://msdn.microsoft.com/library/system.web.httpserverutility.transfer.aspx) method transfers execution to the specified URL and processes it within the same request.</span></span> <span data-ttu-id="15300-228">您可以将代码移动`Application_Error`事件处理程序替换中的自定义错误页的代码隐藏类`Global.asax`使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="15300-228">You could move the code in the `Application_Error` event handler to the custom error page's code-behind class, replacing it in `Global.asax` with the following code:</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample5.cs)]

<span data-ttu-id="15300-229">未经处理的异常发生时现在`Application_Error`事件处理程序将控制转移到基于 HTTP 状态代码的相应的自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-229">Now when an unhandled exception occurs the `Application_Error` event handler transfers control to the appropriate custom error page based on the HTTP status code.</span></span> <span data-ttu-id="15300-230">自定义错误页传输控件，因为有权访问的未处理的异常信息通过`Server.GetLastError`和可以通知开发人员的错误并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="15300-230">Because control was transferred, the custom error page has access to the unhandled exception information via `Server.GetLastError` and can notify a developer of the error and log its details.</span></span> <span data-ttu-id="15300-231">`Server.Transfer`调用停止 ASP.NET 引擎从将用户重定向到自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-231">The `Server.Transfer` call stops the ASP.NET engine from redirecting the user to the custom error page.</span></span> <span data-ttu-id="15300-232">相反，作为对生成错误的页的响应返回自定义错误页的内容。</span><span class="sxs-lookup"><span data-stu-id="15300-232">Instead, the custom error page's content is returned as the response to the page that generated the error.</span></span>

## <a name="summary"></a><span data-ttu-id="15300-233">总结</span><span class="sxs-lookup"><span data-stu-id="15300-233">Summary</span></span>

<span data-ttu-id="15300-234">ASP.NET 运行时将 ASP.NET web 应用程序中发生未经处理的异常时引发`Error`事件，并显示配置的错误页。</span><span class="sxs-lookup"><span data-stu-id="15300-234">When an unhandled exception occurs in an ASP.NET web application the ASP.NET runtime raises the `Error` event and displays the configured error page.</span></span> <span data-ttu-id="15300-235">我们可以通知开发人员的错误，记录其详细信息，或以某种其他方式处理它通过创建错误事件的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="15300-235">We can notify the developer of the error, log its details, or process it in some other fashion, by creating an event handler for the Error event.</span></span> <span data-ttu-id="15300-236">有两种方法创建的事件处理程序`HttpApplication`事件，如`Error`： 在`Global.asax`文件或从 HTTP 模块。</span><span class="sxs-lookup"><span data-stu-id="15300-236">There are two ways to create an event handler for `HttpApplication` events like `Error`: in the `Global.asax` file or from an HTTP Module.</span></span> <span data-ttu-id="15300-237">本教程介绍了如何创建`Error`中的事件处理程序`Global.asax`通过电子邮件通知的错误的开发人员的文件。</span><span class="sxs-lookup"><span data-stu-id="15300-237">This tutorial showed how to create an `Error` event handler in the `Global.asax` file that notifies developers of an error by means of an email message.</span></span>

<span data-ttu-id="15300-238">创建`Error`事件处理程序需要某种唯一或自定义的方式处理未处理的异常的情况下很有用。</span><span class="sxs-lookup"><span data-stu-id="15300-238">Creating an `Error` event handler is useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="15300-239">但是，创建你自己`Error`事件处理程序来记录异常或通知开发人员不是最有效地利用您的时间，因为存在已存在免费且易于使用的错误日志记录库，可以在几分钟内设置。</span><span class="sxs-lookup"><span data-stu-id="15300-239">However, creating your own `Error` event handler to log the exception or to notify a developer is not the most efficient use of your time as there already exist free and easy to use error logging libraries that can be setup in a matter of minutes.</span></span> <span data-ttu-id="15300-240">接下来两个教程检查两个这样的库。</span><span class="sxs-lookup"><span data-stu-id="15300-240">The next two tutorials examine two such libraries.</span></span>

<span data-ttu-id="15300-241">快乐编程 ！</span><span class="sxs-lookup"><span data-stu-id="15300-241">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="15300-242">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="15300-242">Further Reading</span></span>

<span data-ttu-id="15300-243">在本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="15300-243">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="15300-244">ASP.NET HTTP 模块和 HTTP 处理程序概述</span><span class="sxs-lookup"><span data-stu-id="15300-244">ASP.NET HTTP Modules and HTTP Handlers Overview</span></span>](https://support.microsoft.com/kb/307985)
- [<span data-ttu-id="15300-245">适当地响应未经处理的异常的处理未经处理的异常</span><span class="sxs-lookup"><span data-stu-id="15300-245">Gracefully Responding to Unhandled Exceptions - Processing Unhandled Exceptions</span></span>](http://aspnet.4guysfromrolla.com/articles/091306-1.aspx)
- [<span data-ttu-id="15300-246">`HttpApplication` 类和 ASP.NET 应用程序对象</span><span class="sxs-lookup"><span data-stu-id="15300-246">`HttpApplication` Class and the ASP.NET Application Object</span></span>](http://www.eggheadcafe.com/articles/20030211.asp)
- [<span data-ttu-id="15300-247">HTTP 处理程序和 ASP.NET 中的 HTTP 模块</span><span class="sxs-lookup"><span data-stu-id="15300-247">HTTP Handlers and HTTP Modules in ASP.NET</span></span>](http://www.15seconds.com/Issue/020417.htm)
- [<span data-ttu-id="15300-248">在 ASP.NET 中发送电子邮件</span><span class="sxs-lookup"><span data-stu-id="15300-248">Sending Email in ASP.NET</span></span>](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)
- [<span data-ttu-id="15300-249">了解`Global.asax`文件</span><span class="sxs-lookup"><span data-stu-id="15300-249">Understanding the `Global.asax` File</span></span>](http://aspalliance.com/1114_Understanding_the_Globalasax_file.all)
- [<span data-ttu-id="15300-250">使用 HTTP 模块和处理程序来创建可插入的 ASP.NET 组件</span><span class="sxs-lookup"><span data-stu-id="15300-250">Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components</span></span>](https://msdn.microsoft.com/library/aa479332.aspx)
- [<span data-ttu-id="15300-251">使用 ASP.NET`Global.asax`文件</span><span class="sxs-lookup"><span data-stu-id="15300-251">Working with the ASP.NET `Global.asax` File</span></span>](http://articles.techrepublic.com.com/5100-10878_11-5771721.html)
- [<span data-ttu-id="15300-252">使用`HttpApplication`实例</span><span class="sxs-lookup"><span data-stu-id="15300-252">Working with `HttpApplication` Instances</span></span>](https://msdn.microsoft.com/library/a0xez8f2.aspx)

> [!div class="step-by-step"]
> <span data-ttu-id="15300-253">[上一页](displaying-a-custom-error-page-cs.md)
> [下一页](logging-error-details-with-asp-net-health-monitoring-cs.md)</span><span class="sxs-lookup"><span data-stu-id="15300-253">[Previous](displaying-a-custom-error-page-cs.md)
[Next](logging-error-details-with-asp-net-health-monitoring-cs.md)</span></span>

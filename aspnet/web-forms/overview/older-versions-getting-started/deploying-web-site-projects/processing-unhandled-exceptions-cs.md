---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs
title: 处理未经处理的C#异常（） |Microsoft Docs
author: rick-anderson
description: 在生产环境中的 web 应用程序上发生运行时错误时，请务必通知开发人员并记录错误，以便可以在 la 上诊断 。
ms.author: riande
ms.date: 06/09/2009
ms.assetid: 5bc1afd5-2484-4528-b158-ab218ba150e8
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs
msc.type: authoredcontent
ms.openlocfilehash: 27d827238d944f86cd913d2b8ecd12729b99f391
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78510656"
---
# <a name="processing-unhandled-exceptions-c"></a><span data-ttu-id="deb71-103">处理未经处理的异常 (C#)</span><span class="sxs-lookup"><span data-stu-id="deb71-103">Processing Unhandled Exceptions (C#)</span></span>

<span data-ttu-id="deb71-104">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="deb71-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="deb71-105">[查看或下载示例代码](https://github.com/dotnet/AspNetDocs/tree/master/aspnet/web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs/samples)（[如何下载](/aspnet/core/tutorials/index#how-to-download-a-sample)）</span><span class="sxs-lookup"><span data-stu-id="deb71-105">[View or download sample code](https://github.com/dotnet/AspNetDocs/tree/master/aspnet/web-forms/overview/older-versions-getting-started/deploying-web-site-projects/processing-unhandled-exceptions-cs/samples) ([how to download](/aspnet/core/tutorials/index#how-to-download-a-sample))</span></span>

> <span data-ttu-id="deb71-106">在生产环境中的 web 应用程序上发生运行时错误时，请务必通知开发人员并记录错误，以便在以后的某个时间点进行诊断。</span><span class="sxs-lookup"><span data-stu-id="deb71-106">When a runtime error occurs on a web application in production it is important to notify a developer and to log the error so that it may be diagnosed at a later point in time.</span></span> <span data-ttu-id="deb71-107">本教程概述了 ASP.NET 如何处理运行时错误，并探讨了每当未处理的异常冒泡到 ASP.NET 运行时，将执行自定义代码的一种方法。</span><span class="sxs-lookup"><span data-stu-id="deb71-107">This tutorial provides an overview of how ASP.NET processes runtime errors and looks at one way to have custom code execute whenever an unhandled exception bubbles up to the ASP.NET runtime.</span></span>

## <a name="introduction"></a><span data-ttu-id="deb71-108">简介</span><span class="sxs-lookup"><span data-stu-id="deb71-108">Introduction</span></span>

<span data-ttu-id="deb71-109">当 ASP.NET 应用程序中发生未经处理的异常时，它将冒泡到 ASP.NET 运行时，这会引发 `Error` 事件并显示相应的错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-109">When an unhandled exception occurs in an ASP.NET application, it bubbles up to the ASP.NET runtime, which raises the `Error` event and displays the appropriate error page.</span></span> <span data-ttu-id="deb71-110">有三种不同类型的错误页：运行时错误黄色屏幕死亡（YSOD）;异常详细信息 YSOD;和自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-110">There are three different types of error pages: the Runtime Error Yellow Screen of Death (YSOD); the Exception Details YSOD; and custom error pages.</span></span> <span data-ttu-id="deb71-111">在[前面的教程](displaying-a-custom-error-page-cs.md)中，我们将应用程序配置为使用远程用户的自定义错误页，并 YSOD 用户访问本地的用户的异常详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-111">In the [preceding tutorial](displaying-a-custom-error-page-cs.md) we configured the application to use a custom error page for remote users and the Exception Details YSOD for users visiting locally.</span></span>

<span data-ttu-id="deb71-112">对于默认的运行时错误 YSOD，使用与站点的外观匹配的用户友好自定义错误页是首选的，但是显示自定义错误页只是综合性错误处理解决方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="deb71-112">Using a human-friendly custom error page that matches the look and feel of the site is preferred to the default Runtime Error YSOD, but displaying a custom error page is only one part of a comprehensive error handling solution.</span></span> <span data-ttu-id="deb71-113">如果在生产环境中出现错误，开发人员会收到错误通知，以便他们能够发现异常的原因并解决该错误。</span><span class="sxs-lookup"><span data-stu-id="deb71-113">When an error occurs in an application in production, it is important that the developers are notified of the error so that they can unearth the cause of the exception and address it.</span></span> <span data-ttu-id="deb71-114">此外，还应记录错误的详细信息，以便在以后的某个时间点检查和诊断错误。</span><span class="sxs-lookup"><span data-stu-id="deb71-114">Furthermore, the error's details should be logged so that the error can be examined and diagnosed at a later point in time.</span></span>

<span data-ttu-id="deb71-115">本教程演示如何访问未经处理的异常的详细信息，以便可以记录这些异常，并通知开发人员。</span><span class="sxs-lookup"><span data-stu-id="deb71-115">This tutorial shows how to access the details of an unhandled exception so that they can be logged and a developer notified.</span></span> <span data-ttu-id="deb71-116">此教程后面的两个教程将探讨错误日志记录库，这些库在配置后将自动通知开发人员运行时错误并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-116">The two tutorials following this one explore error logging libraries that, after a bit of configuration, will automatically notify developers of runtime errors and log their details.</span></span>

> [!NOTE]
> <span data-ttu-id="deb71-117">如果需要以某种独特的方式处理未经处理的异常，则本教程中检查的信息最有用。</span><span class="sxs-lookup"><span data-stu-id="deb71-117">The information examined in this tutorial is most useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="deb71-118">如果只需要记录异常并通知开发人员，则使用错误日志记录库是一种方法。</span><span class="sxs-lookup"><span data-stu-id="deb71-118">In cases where you only need to log the exception and notify a developer, using an error logging library is the way to go.</span></span> <span data-ttu-id="deb71-119">接下来的两个教程概括介绍了两个库。</span><span class="sxs-lookup"><span data-stu-id="deb71-119">The next two tutorials provide an overview of two such libraries.</span></span>

## <a name="executing-code-when-theerrorevent-is-raised"></a><span data-ttu-id="deb71-120">引发`Error`事件时执行代码</span><span class="sxs-lookup"><span data-stu-id="deb71-120">Executing Code When The`Error`Event Is Raised</span></span>

<span data-ttu-id="deb71-121">事件为对象提供了一种机制，用于指示发生了一些有趣的事情，以及另一个对象执行代码以响应。</span><span class="sxs-lookup"><span data-stu-id="deb71-121">Events provide an object a mechanism for signaling that something interesting has occurred, and for another object to execute code in response.</span></span> <span data-ttu-id="deb71-122">作为 ASP.NET 开发人员，您习惯于考虑到事件。</span><span class="sxs-lookup"><span data-stu-id="deb71-122">As an ASP.NET developer you are accustomed to thinking in terms of events.</span></span> <span data-ttu-id="deb71-123">如果希望在访问者单击特定按钮时运行某些代码，请为该按钮的 `Click` 事件创建事件处理程序，并将代码放在此处。</span><span class="sxs-lookup"><span data-stu-id="deb71-123">If you want to run some code when the visitor clicks a particular Button, you create an event handler for that Button's `Click` event and put your code there.</span></span> <span data-ttu-id="deb71-124">假设每当发生未经处理的异常时，ASP.NET 运行时都会引发其[`Error` 事件](https://msdn.microsoft.com/library/system.web.httpapplication.error.aspx)，随后会在事件处理程序中记录错误的详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-124">Given that the ASP.NET runtime raises its [`Error` event](https://msdn.microsoft.com/library/system.web.httpapplication.error.aspx) whenever an unhandled exception occurs, it follows that the code for logging the error's details would go in an event handler.</span></span> <span data-ttu-id="deb71-125">但如何为 `Error` 事件创建事件处理程序呢？</span><span class="sxs-lookup"><span data-stu-id="deb71-125">But how do you create an event handler for the `Error` event?</span></span>

<span data-ttu-id="deb71-126">`Error` 事件是[`HttpApplication` 类](https://msdn.microsoft.com/library/system.web.httpapplication.aspx)中的多个事件之一，这些事件在请求的生存期内在 HTTP 管道中的特定阶段引发。</span><span class="sxs-lookup"><span data-stu-id="deb71-126">The `Error` event is one of many events in the [`HttpApplication` class](https://msdn.microsoft.com/library/system.web.httpapplication.aspx) that are raised at certain stages in the HTTP pipeline during the lifetime of a request.</span></span> <span data-ttu-id="deb71-127">例如，在每个请求开始时引发 `HttpApplication` 类的[`BeginRequest` 事件](https://msdn.microsoft.com/library/system.web.httpapplication.beginrequest.aspx);当安全模块识别请求程序时，将引发其[`AuthenticateRequest` 事件](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx)。</span><span class="sxs-lookup"><span data-stu-id="deb71-127">For example, the `HttpApplication` class's [`BeginRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.beginrequest.aspx) is raised at the start of every request; its [`AuthenticateRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.authenticaterequest.aspx) is raised when a security module has identified the requestor.</span></span> <span data-ttu-id="deb71-128">这些 `HttpApplication` 事件使页面开发人员能够在请求生存期的各个点上执行自定义逻辑。</span><span class="sxs-lookup"><span data-stu-id="deb71-128">These `HttpApplication` events give the page developer a means to execute custom logic at the various points in the lifetime of a request.</span></span>

<span data-ttu-id="deb71-129">可以将 `HttpApplication` 事件的事件处理程序放置在一个名为 `Global.asax`的特殊文件中。</span><span class="sxs-lookup"><span data-stu-id="deb71-129">Event handlers for the `HttpApplication` events can be placed in a special file named `Global.asax`.</span></span> <span data-ttu-id="deb71-130">若要在网站中创建此文件，请使用名为 `Global.asax`的全局应用程序类模板将新项添加到网站的根目录。</span><span class="sxs-lookup"><span data-stu-id="deb71-130">To create this file in your website, add a new item to the root of your website using the Global Application Class template with the name `Global.asax`.</span></span>

[![](processing-unhandled-exceptions-cs/_static/image2.png)](processing-unhandled-exceptions-cs/_static/image1.png)

<span data-ttu-id="deb71-131">**图 1**：将 `Global.asax` 添加到 Web 应用程序</span><span class="sxs-lookup"><span data-stu-id="deb71-131">**Figure 1**: Add `Global.asax` To Your Web Application</span></span>  
<span data-ttu-id="deb71-132">（[单击以查看完全大小的映像](processing-unhandled-exceptions-cs/_static/image3.png)）</span><span class="sxs-lookup"><span data-stu-id="deb71-132">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image3.png))</span></span>

<span data-ttu-id="deb71-133">根据你使用的是 Web 应用程序项目（WAP）还是网站项目（WSP），Visual Studio 创建的 `Global.asax` 文件的内容和结构略有不同。</span><span class="sxs-lookup"><span data-stu-id="deb71-133">The contents and structure of the `Global.asax` file created by Visual Studio differ slightly based on whether you are using a Web Application Project (WAP) or Web Site Project (WSP).</span></span> <span data-ttu-id="deb71-134">对于 WAP，`Global.asax` 作为两个单独的文件实现 `Global.asax` 和 `Global.asax.cs`。</span><span class="sxs-lookup"><span data-stu-id="deb71-134">With a WAP, the `Global.asax` is implemented as two separate files - `Global.asax` and `Global.asax.cs`.</span></span> <span data-ttu-id="deb71-135">`Global.asax` 文件只包含一个引用 `.cs` 文件的 `@Application` 指令;相关事件处理程序在 `Global.asax.cs` 文件中定义。</span><span class="sxs-lookup"><span data-stu-id="deb71-135">The `Global.asax` file contains nothing but an `@Application` directive that references the `.cs` file; the event handlers of interest are defined in the `Global.asax.cs` file.</span></span> <span data-ttu-id="deb71-136">对于 WSPs，只会创建一个文件，`Global.asax`，并在 `<script runat="server">` 块中定义事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-136">For WSPs, only a single file is created, `Global.asax`, and the event handlers are defined in a `<script runat="server">` block.</span></span>

<span data-ttu-id="deb71-137">在 WAP by Visual Studio 的全局应用程序类模板中创建的 `Global.asax` 文件包括名为 `Application_BeginRequest`、`Application_AuthenticateRequest`和 `Application_Error`的事件处理程序，这些事件处理程序分别是 `HttpApplication` 事件的事件处理程序 `BeginRequest`、`AuthenticateRequest`和 `Error`。</span><span class="sxs-lookup"><span data-stu-id="deb71-137">The `Global.asax` file created in a WAP by Visual Studio's Global Application Class template includes event handlers named `Application_BeginRequest`, `Application_AuthenticateRequest`, and `Application_Error`, which are event handlers for the `HttpApplication` events `BeginRequest`, `AuthenticateRequest`, and `Error`, respectively.</span></span> <span data-ttu-id="deb71-138">还有名为 `Application_Start`、`Session_Start`、`Application_End`和 `Session_End`的事件处理程序，这些事件处理程序是在 web 应用程序启动、新会话启动时、应用程序结束时以及会话结束时触发的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-138">There are also event handlers named `Application_Start`, `Session_Start`, `Application_End`, and `Session_End`, which are event handlers that fire when the web application starts, when a new session starts, when the application ends, and when a session ends, respectively.</span></span> <span data-ttu-id="deb71-139">在 WSP 中通过 Visual Studio 创建的 `Global.asax` 文件只包含 `Application_Error`、`Application_Start`、`Session_Start`、`Application_End`和 `Session_End` 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-139">The `Global.asax` file created in a WSP by Visual Studio contains just the `Application_Error`, `Application_Start`, `Session_Start`, `Application_End`, and `Session_End` event handlers.</span></span>

> [!NOTE]
> <span data-ttu-id="deb71-140">部署 ASP.NET 应用程序时，需要将 `Global.asax` 文件复制到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="deb71-140">When deploying the ASP.NET application you need to copy the `Global.asax` file to the production environment.</span></span> <span data-ttu-id="deb71-141">不需要将在 WAP 中创建的 `Global.asax.cs` 文件复制到生产，因为此代码编译到项目的程序集中。</span><span class="sxs-lookup"><span data-stu-id="deb71-141">The `Global.asax.cs` file, which is created in the WAP, does not need to be copied to production because this code is compiled into the project's assembly.</span></span>

<span data-ttu-id="deb71-142">Visual Studio 的全局应用程序类模板创建的事件处理程序并不详尽。</span><span class="sxs-lookup"><span data-stu-id="deb71-142">The event handlers created by Visual Studio's Global Application Class template are not exhaustive.</span></span> <span data-ttu-id="deb71-143">可以通过将事件处理程序命名为 `Application_EventName`，为任何 `HttpApplication` 事件添加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-143">You can add an event handler for any `HttpApplication` event by naming the event handler `Application_EventName`.</span></span> <span data-ttu-id="deb71-144">例如，可以将以下代码添加到 `Global.asax` 文件中，以便为[`AuthorizeRequest` 事件](https://msdn.microsoft.com/library/system.web.httpapplication.authorizerequest.aspx)创建事件处理程序：</span><span class="sxs-lookup"><span data-stu-id="deb71-144">For example, you could add the following code to the `Global.asax` file to create an event handler for the [`AuthorizeRequest` event](https://msdn.microsoft.com/library/system.web.httpapplication.authorizerequest.aspx):</span></span>

[!code-cs[Main](processing-unhandled-exceptions-cs/samples/sample1.cs)]

<span data-ttu-id="deb71-145">同样，您可以删除任何不需要的全局应用程序类模板创建的事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-145">Likewise, you can remove any event handlers created by the Global Application Class template that are not needed.</span></span> <span data-ttu-id="deb71-146">对于本教程，我们只需 `Error` 事件的事件处理程序;可以随意删除 `Global.asax` 文件中的其他事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-146">For this tutorial we only require an event handler for the `Error` event; feel free to remove the other event handlers from the `Global.asax` file.</span></span>

> [!NOTE]
> <span data-ttu-id="deb71-147">*HTTP 模块*提供了另一种为 `HttpApplication` 事件定义事件处理程序的方法。</span><span class="sxs-lookup"><span data-stu-id="deb71-147">*HTTP Modules* offer another way to define event handlers for `HttpApplication` events.</span></span> <span data-ttu-id="deb71-148">HTTP 模块是作为类文件创建的，它可以直接放置在 web 应用程序项目中或分成单独的类库。</span><span class="sxs-lookup"><span data-stu-id="deb71-148">HTTP Modules are created as a class file that can be placed directly within the web application project or separated out into a separate class library.</span></span> <span data-ttu-id="deb71-149">由于可以将它们分为一个类库，因此 HTTP 模块提供了更灵活且可重复使用的模型，可用于创建 `HttpApplication` 事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="deb71-149">Because they can be separated out into a class library, HTTP Modules offer a more flexible and reusable model for creating `HttpApplication` event handlers.</span></span> <span data-ttu-id="deb71-150">`Global.asax` 文件特定于其所在的 web 应用程序，因此可以将 HTTP 模块编译成程序集，此时将 HTTP 模块添加到网站中就像将程序集放在 `Bin` 文件夹中，并在 `Web.config`注册模块一样简单。</span><span class="sxs-lookup"><span data-stu-id="deb71-150">Whereas the `Global.asax` file is specific to the web application where it resides, HTTP Modules can be compiled into assemblies, at which point adding the HTTP Module to a website is as simple as dropping the assembly in the `Bin` folder and registering the Module in `Web.config`.</span></span> <span data-ttu-id="deb71-151">本教程不介绍如何创建和使用 HTTP 模块，但以下两个教程中使用的两个错误日志记录库是作为 HTTP 模块实现的。</span><span class="sxs-lookup"><span data-stu-id="deb71-151">This tutorial does not look at creating and using HTTP Modules, but the two error logging libraries used in the following two tutorials are implemented as HTTP Modules.</span></span> <span data-ttu-id="deb71-152">有关 HTTP 模块的优点的更多背景信息，请参阅[使用 Http 模块和处理程序创建可插入的 ASP.NET 组件](https://msdn.microsoft.com/library/aa479332.aspx)。</span><span class="sxs-lookup"><span data-stu-id="deb71-152">For more background on the benefits of HTTP Modules refer to [Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components](https://msdn.microsoft.com/library/aa479332.aspx).</span></span>

## <a name="retrieving-information-about-the-unhandled-exception"></a><span data-ttu-id="deb71-153">检索有关未经处理的异常的信息</span><span class="sxs-lookup"><span data-stu-id="deb71-153">Retrieving Information About the Unhandled Exception</span></span>

<span data-ttu-id="deb71-154">此时，我们有一个带有 `Application_Error` 事件处理程序的 global.asax 文件。</span><span class="sxs-lookup"><span data-stu-id="deb71-154">At this point we have a Global.asax file with an `Application_Error` event handler.</span></span> <span data-ttu-id="deb71-155">在此事件处理程序执行时，需要通知开发人员此错误并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-155">When this event handler executes we need to notify a developer of the error and log its details.</span></span> <span data-ttu-id="deb71-156">若要完成这些任务，我们首先需要确定所引发异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-156">To accomplish these tasks we first need to determine the details of the exception that was raised.</span></span> <span data-ttu-id="deb71-157">使用服务器对象的[`GetLastError` 方法](https://msdn.microsoft.com/library/system.web.httpserverutility.getlasterror.aspx)可以检索导致引发 `Error` 事件的未处理异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-157">Use the Server object's [`GetLastError` method](https://msdn.microsoft.com/library/system.web.httpserverutility.getlasterror.aspx) to retrieve details of the unhandled exception that caused the `Error` event to fire.</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample2.cs)]

<span data-ttu-id="deb71-158">`GetLastError` 方法返回 `Exception`类型的对象，该对象是 .NET Framework 中所有异常的基类型。</span><span class="sxs-lookup"><span data-stu-id="deb71-158">The `GetLastError` method returns an object of type `Exception`, which is the base type for all exceptions in the .NET Framework.</span></span> <span data-ttu-id="deb71-159">但是，在上面的代码中，我将 `GetLastError` 返回的异常对象强制转换为 `HttpException` 的对象。</span><span class="sxs-lookup"><span data-stu-id="deb71-159">However, in the code above I am casting the Exception object returned by `GetLastError` into an `HttpException` object.</span></span> <span data-ttu-id="deb71-160">如果 `Error` 事件正在激发，因为在 ASP.NET 资源的处理过程中引发了异常，则会将引发的异常包装在 `HttpException`中。</span><span class="sxs-lookup"><span data-stu-id="deb71-160">If the `Error` event is being fired because an exception was thrown during the processing of an ASP.NET resource then the exception that was thrown is wrapped within an `HttpException`.</span></span> <span data-ttu-id="deb71-161">若要获取被错误事件的实际异常，请使用 `InnerException` 属性。</span><span class="sxs-lookup"><span data-stu-id="deb71-161">To get the actual exception that precipitated the Error event use the `InnerException` property.</span></span> <span data-ttu-id="deb71-162">如果由于基于 HTTP 的异常引发了 `Error` 事件（例如，对不存在的页的请求），则会引发 `HttpException`，但不会出现内部异常。</span><span class="sxs-lookup"><span data-stu-id="deb71-162">If the `Error` event was raised because of an HTTP-based exception, such as a request for a non-existent page, an `HttpException` is thrown, but it does not have an inner exception.</span></span>

<span data-ttu-id="deb71-163">下面的代码使用 `GetLastErrormessage` 检索有关触发 `Error` 事件的异常的信息，并将 `HttpException` 存储在名为 `lastErrorWrapper`的变量中。</span><span class="sxs-lookup"><span data-stu-id="deb71-163">The following code uses the `GetLastErrormessage` to retrieve information about the exception that triggered the `Error` event, storing the `HttpException` in a variable named `lastErrorWrapper`.</span></span> <span data-ttu-id="deb71-164">然后，它将原始异常的类型、消息和堆栈跟踪存储在三个字符串变量中，检查 `lastErrorWrapper` 是触发 `Error` 事件的实际异常（对于基于 HTTP 的异常），还是只是在处理请求时引发的异常的包装器。</span><span class="sxs-lookup"><span data-stu-id="deb71-164">It then stores the type, message, and stack trace of the originating exception in three string variables, checking to see if the `lastErrorWrapper` is the actual exception that triggered the `Error` event (in the case of HTTP-based exceptions) or if it's merely a wrapper for an exception that was thrown while processing the request.</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample3.cs)]

<span data-ttu-id="deb71-165">此时，您需要编写代码，以便将异常的详细信息记录到数据库表中。</span><span class="sxs-lookup"><span data-stu-id="deb71-165">At this point you have all the information you need to write code that will log the exception's details to a database table.</span></span> <span data-ttu-id="deb71-166">您可以为相关的每个错误详细信息（类型、消息、堆栈跟踪等）和其他有用的信息（例如请求的页面的 URL 和当前登录的用户的名称）创建包含列的数据库表。</span><span class="sxs-lookup"><span data-stu-id="deb71-166">You could create a database table with columns for each of the error details of interest - the type, the message, the stack trace, and so on - along with other useful pieces of information, such as the URL of the requested page and the name of the currently logged on user.</span></span> <span data-ttu-id="deb71-167">然后，在 `Application_Error` 事件处理程序中，连接到数据库并将记录插入到表中。</span><span class="sxs-lookup"><span data-stu-id="deb71-167">In the `Application_Error` event handler you would then connect to the database and insert a record into the table.</span></span> <span data-ttu-id="deb71-168">同样，您可以添加代码以通过电子邮件向开发人员发出错误消息。</span><span class="sxs-lookup"><span data-stu-id="deb71-168">Likewise, you could add code to alert a developer of the error via email.</span></span>

<span data-ttu-id="deb71-169">接下来的两个教程中所述的错误日志记录库提供了此类功能，因此无需自行生成此错误日志记录和通知。</span><span class="sxs-lookup"><span data-stu-id="deb71-169">The error logging libraries examined in the next two tutorials provide such functionality out of the box, so there's no need to build this error logging and notification yourself.</span></span> <span data-ttu-id="deb71-170">但是，为了说明引发 `Error` 事件，并且 `Application_Error` 事件处理程序可用于记录错误详细信息并通知开发人员，我们将添加代码，以便在发生错误时通知开发人员。</span><span class="sxs-lookup"><span data-stu-id="deb71-170">However, to illustrate that the `Error` event is being raised and that the `Application_Error` event handler can be used to log error details and notify a developer, let's add code that notifies a developer when an error occurs.</span></span>

## <a name="notifying-a-developer-when-an-unhandled-exception-occurs"></a><span data-ttu-id="deb71-171">在发生未经处理的异常时通知开发人员</span><span class="sxs-lookup"><span data-stu-id="deb71-171">Notifying a Developer When an Unhandled Exception Occurs</span></span>

<span data-ttu-id="deb71-172">当生产环境中发生未处理的异常时，请务必向开发团队发出警报，以便他们可以评估错误并确定需要采取哪些操作。</span><span class="sxs-lookup"><span data-stu-id="deb71-172">When an unhandled exception occurs in the production environment it is important to alert the development team so that they can assess the error and determine what actions need to be taken.</span></span> <span data-ttu-id="deb71-173">例如，如果在连接到数据库时出错，则需要仔细检查连接字符串，或许还需要与 web 托管公司建立支持票证。</span><span class="sxs-lookup"><span data-stu-id="deb71-173">For example, if there is an error in connecting to the database then you'll need to double check your connection string and, perhaps, open a support ticket with your web hosting company.</span></span> <span data-ttu-id="deb71-174">如果异常是由于编程错误而发生的，则可能需要添加其他代码或验证逻辑，以防以后出现此类错误。</span><span class="sxs-lookup"><span data-stu-id="deb71-174">If the exception occurred because of a programming error, additional code or validation logic may need to be added to prevent such errors in the future.</span></span>

<span data-ttu-id="deb71-175">使用[`System.Net.Mail` 命名空间](https://msdn.microsoft.com/library/system.net.mail.aspx)中的 .NET Framework 类可以轻松地发送电子邮件。</span><span class="sxs-lookup"><span data-stu-id="deb71-175">The .NET Framework classes in the [`System.Net.Mail` namespace](https://msdn.microsoft.com/library/system.net.mail.aspx) make it easy to send an email.</span></span> <span data-ttu-id="deb71-176">[`MailMessage` 类](https://msdn.microsoft.com/library/system.net.mail.mailmessage.aspx)表示一封电子邮件，其属性如 `To`、`From`、`Subject`、`Body`和 `Attachments`。</span><span class="sxs-lookup"><span data-stu-id="deb71-176">The [`MailMessage` class](https://msdn.microsoft.com/library/system.net.mail.mailmessage.aspx) represents an email message and has properties like `To`, `From`, `Subject`, `Body`, and `Attachments`.</span></span> <span data-ttu-id="deb71-177">`SmtpClass` 用于使用指定的 SMTP 服务器发送 `MailMessage` 对象;可以通过编程方式或在 `Web.config file`的[`<system.net>` 元素](https://msdn.microsoft.com/library/6484zdc1.aspx)中以编程方式指定 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="deb71-177">The `SmtpClass` is used to send a `MailMessage` object using a specified SMTP server; the SMTP server settings can be specified programmatically or declaratively in the [`<system.net>` element](https://msdn.microsoft.com/library/6484zdc1.aspx) in the `Web.config file`.</span></span> <span data-ttu-id="deb71-178">有关在 ASP.NET 应用程序中发送电子邮件的详细信息，请参阅我的文章、[在 ASP.NET 中发送电子邮件](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)和[系统 .NET. Mail 常见问题解答](http://systemnetmail.com/)。</span><span class="sxs-lookup"><span data-stu-id="deb71-178">For more information on sending email messages in an ASP.NET application check out my article, [Sending Email in ASP.NET](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx), and the [System.Net.Mail FAQ](http://systemnetmail.com/).</span></span>

> [!NOTE]
> <span data-ttu-id="deb71-179">`<system.net>` 元素包含 `SmtpClient` 类在发送电子邮件时使用的 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="deb71-179">The `<system.net>` element contains the SMTP server settings used by the `SmtpClient` class when sending an email.</span></span> <span data-ttu-id="deb71-180">Web 托管公司可能有可用于从应用程序发送电子邮件的 SMTP 服务器。</span><span class="sxs-lookup"><span data-stu-id="deb71-180">Your web hosting company likely has an SMTP server that you can use to send email from your application.</span></span> <span data-ttu-id="deb71-181">有关应在 web 应用程序中使用的 SMTP 服务器设置的信息，请参阅 web 宿主的支持部分。</span><span class="sxs-lookup"><span data-stu-id="deb71-181">Consult your web host's support section for information on the SMTP server settings you should use in your web application.</span></span>

<span data-ttu-id="deb71-182">将以下代码添加到 `Application_Error` 事件处理程序，以便在发生错误时向开发人员发送电子邮件：</span><span class="sxs-lookup"><span data-stu-id="deb71-182">Add the following code to the `Application_Error` event handler to send a developer an email when an error occurs:</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample4.cs)]

<span data-ttu-id="deb71-183">尽管上面的代码非常冗长，但大部分代码会创建在发送给开发人员的电子邮件中显示的 HTML。</span><span class="sxs-lookup"><span data-stu-id="deb71-183">While the above code is quite lengthy, the bulk of it creates the HTML that appears in the email sent to the developer.</span></span> <span data-ttu-id="deb71-184">代码首先引用 `GetLastError` 方法（`lastErrorWrapper`）返回的 `HttpException`。</span><span class="sxs-lookup"><span data-stu-id="deb71-184">The code starts by referencing the `HttpException` returned by the `GetLastError` method (`lastErrorWrapper`).</span></span> <span data-ttu-id="deb71-185">通过 `lastErrorWrapper.InnerException` 检索请求引发的实际异常，并将其分配给变量 `lastError`。</span><span class="sxs-lookup"><span data-stu-id="deb71-185">The actual exception that was raised by the request is retrieved via `lastErrorWrapper.InnerException` and is assigned to the variable `lastError`.</span></span> <span data-ttu-id="deb71-186">类型、消息和堆栈跟踪信息是从 `lastError` 检索的，并存储在三个字符串变量中。</span><span class="sxs-lookup"><span data-stu-id="deb71-186">The type, message, and stack trace information is retrieved from `lastError` and stored in three string variables.</span></span>

<span data-ttu-id="deb71-187">接下来，创建一个名为 `mm` 的 `MailMessage` 对象。</span><span class="sxs-lookup"><span data-stu-id="deb71-187">Next, a `MailMessage` object named `mm` is created.</span></span> <span data-ttu-id="deb71-188">电子邮件正文为 HTML 格式，并显示请求的页面的 URL、当前登录用户的名称以及有关异常的信息（类型、消息和堆栈跟踪）。</span><span class="sxs-lookup"><span data-stu-id="deb71-188">The email body is HTML formatted and displays the URL of the requested page, the name of the currently logged on user, and information about the exception (the type, message, and stack trace).</span></span> <span data-ttu-id="deb71-189">`HttpException` 类的一个很酷的问题是，你可以通过调用[GetHtmlErrorMessage 方法](https://msdn.microsoft.com/library/system.web.httpexception.gethtmlerrormessage.aspx)来生成用于创建异常详细信息的 HTML。</span><span class="sxs-lookup"><span data-stu-id="deb71-189">One of the cool things about the `HttpException` class is that you can generate the HTML used to create the Exception Details Yellow Screen of Death (YSOD) by calling the [GetHtmlErrorMessage method](https://msdn.microsoft.com/library/system.web.httpexception.gethtmlerrormessage.aspx).</span></span> <span data-ttu-id="deb71-190">此处使用此方法检索异常详细信息 YSOD 标记，并将其作为附件添加到电子邮件中。</span><span class="sxs-lookup"><span data-stu-id="deb71-190">This method is used here to retrieve the Exception Details YSOD markup and add it to the email as an attachment.</span></span> <span data-ttu-id="deb71-191">注意：如果触发 `Error` 事件的异常是基于 HTTP 的异常（例如，对不存在的页的请求），则 `GetHtmlErrorMessage` 方法将返回 `null`。</span><span class="sxs-lookup"><span data-stu-id="deb71-191">One word of caution: if the exception that triggered the `Error` event was an HTTP-based exception (such as a request for a non-existent page) then the `GetHtmlErrorMessage` method will return `null`.</span></span>

<span data-ttu-id="deb71-192">最后一步是发送 `MailMessage`。</span><span class="sxs-lookup"><span data-stu-id="deb71-192">The final step is to send the `MailMessage`.</span></span> <span data-ttu-id="deb71-193">这是通过创建新的 `SmtpClient` 方法并调用其 `Send` 方法来完成的。</span><span class="sxs-lookup"><span data-stu-id="deb71-193">This is done by creating a new `SmtpClient` method and calling its `Send` method.</span></span>

> [!NOTE]
> <span data-ttu-id="deb71-194">在您的 web 应用程序中使用此代码之前，您需要更改 "`ToAddress` 中的值并 `FromAddress` 常量从 support@example.com 发送到错误通知电子邮件应发送到的电子邮件地址，并从该地址发起。</span><span class="sxs-lookup"><span data-stu-id="deb71-194">Before using this code in your web application you'll want to change the values in the `ToAddress` and `FromAddress` constants from support@example.com to whatever email address the error notification email should be sent to and originate from.</span></span> <span data-ttu-id="deb71-195">还需要在 `Web.config`的 "`<system.net>`" 部分中指定 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="deb71-195">You'll also need to specify SMTP server settings in the `<system.net>` section in `Web.config`.</span></span> <span data-ttu-id="deb71-196">请咨询 web 主机提供商以确定要使用的 SMTP 服务器设置。</span><span class="sxs-lookup"><span data-stu-id="deb71-196">Consult your web host provider to determine the SMTP server settings to use.</span></span>

<span data-ttu-id="deb71-197">无论何时出现错误，开发人员都会向开发人员发送一封电子邮件，该电子邮件汇总了错误并包含 YSOD。</span><span class="sxs-lookup"><span data-stu-id="deb71-197">With this code in place anytime there's an error the developer is sent an email message that summarizes the error and includes the YSOD.</span></span> <span data-ttu-id="deb71-198">在前面的教程中，我们通过访问流派来演示了运行时错误，并通过 querystring 传入了无效的 `ID` 值，如 `Genre.aspx?ID=foo`。</span><span class="sxs-lookup"><span data-stu-id="deb71-198">In the preceding tutorial we demonstrated a runtime error by visiting Genre.aspx and passing in an invalid `ID` value through the querystring, like `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="deb71-199">如果在开发环境中访问与 `Global.asax` 文件相同的用户体验，则在开发环境中，将继续看到异常详细信息黄色屏幕死亡，而在生产环境中，你会看到自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-199">Visiting the page with the `Global.asax` file in place produces the same user experience as in the preceding tutorial - in the development environment you'll continue to see the Exception Details Yellow Screen of Death, while in the production environment you'll see the custom error page.</span></span> <span data-ttu-id="deb71-200">除了此现有行为外，开发人员还将发送一封电子邮件。</span><span class="sxs-lookup"><span data-stu-id="deb71-200">In addition to this existing behavior, the developer is sent an email.</span></span>

<span data-ttu-id="deb71-201">**图 2**显示访问 `Genre.aspx?ID=foo`时收到的电子邮件。</span><span class="sxs-lookup"><span data-stu-id="deb71-201">**Figure 2** shows the email received when visiting `Genre.aspx?ID=foo`.</span></span> <span data-ttu-id="deb71-202">电子邮件正文汇总了异常信息，而 `YSOD.htm` 附件显示了异常详细信息 YSOD 中显示的内容（请参阅**图 3**）。</span><span class="sxs-lookup"><span data-stu-id="deb71-202">The email body summarizes the exception information, while the `YSOD.htm` attachment displays the content that is shown in the Exception Details YSOD (see **Figure 3**).</span></span>

[![](processing-unhandled-exceptions-cs/_static/image5.png)](processing-unhandled-exceptions-cs/_static/image4.png)

<span data-ttu-id="deb71-203">**图 2**：每当出现未经处理的异常时，开发人员都会收到电子邮件通知</span><span class="sxs-lookup"><span data-stu-id="deb71-203">**Figure 2**: The Developer Is Sent An Email Notification Whenever There's An Unhandled Exception</span></span>  
<span data-ttu-id="deb71-204">（[单击以查看完全大小的映像](processing-unhandled-exceptions-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="deb71-204">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image6.png))</span></span>

[![](processing-unhandled-exceptions-cs/_static/image8.png)](processing-unhandled-exceptions-cs/_static/image7.png)

<span data-ttu-id="deb71-205">**图 3**：电子邮件通知包括异常详细信息 YSOD 作为附件</span><span class="sxs-lookup"><span data-stu-id="deb71-205">**Figure 3**: The Email Notification Includes the Exception Details YSOD As An Attachment</span></span>  
<span data-ttu-id="deb71-206">（[单击以查看完全大小的映像](processing-unhandled-exceptions-cs/_static/image9.png)）</span><span class="sxs-lookup"><span data-stu-id="deb71-206">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image9.png))</span></span>

## <a name="what-about-using-the-custom-error-page"></a><span data-ttu-id="deb71-207">使用自定义错误页的情况如何？</span><span class="sxs-lookup"><span data-stu-id="deb71-207">What About Using the Custom Error Page?</span></span>

<span data-ttu-id="deb71-208">本教程演示了如何在发生未经处理的异常时使用 `Global.asax` 和 `Application_Error` 事件处理程序执行代码。</span><span class="sxs-lookup"><span data-stu-id="deb71-208">This tutorial showed how to use `Global.asax` and the `Application_Error` event handler to execute code when an unhandled exception occurs.</span></span> <span data-ttu-id="deb71-209">具体而言，我们使用此事件处理程序将错误通知开发人员;我们可以将其扩展为，同时记录数据库中的错误详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-209">Specifically, we used this event handler to notify a developer of an error; we could extend it to also log the error details in a database.</span></span> <span data-ttu-id="deb71-210">`Application_Error` 事件处理程序的存在不会影响最终用户的体验。</span><span class="sxs-lookup"><span data-stu-id="deb71-210">The presence of the `Application_Error` event handler does not affect the end user's experience.</span></span> <span data-ttu-id="deb71-211">它们仍会看到配置的错误页，YSOD 错误详细信息、运行时错误 YSOD 或自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-211">They still see the configured error page, be it the Error Details YSOD, the Runtime Error YSOD, or the custom error page.</span></span>

<span data-ttu-id="deb71-212">使用自定义错误页面时，很有必要知道 `Global.asax` 文件和 `Application_Error` 事件是否是必需的。</span><span class="sxs-lookup"><span data-stu-id="deb71-212">It's natural to wonder whether the `Global.asax` file and `Application_Error` event is necessary when using a custom error page.</span></span> <span data-ttu-id="deb71-213">当发生错误时，用户将显示在 "自定义错误" 页上，为什么我们不能将代码通知开发人员，并将错误详细信息记录到自定义错误页的代码隐藏类中呢？</span><span class="sxs-lookup"><span data-stu-id="deb71-213">When an error occurs the user is shown the custom error page so why can't we put the code to notify the developer and log the error details into the code-behind class of the custom error page?</span></span> <span data-ttu-id="deb71-214">虽然您当然可以将代码添加到自定义错误页的代码隐藏类，但使用我们在前面的教程中探讨的技术时，您无法访问触发 `Error` 事件的异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-214">While you can certainly add code to the custom error page's code-behind class you do not have access to the details of the exception that triggered the `Error` event when using the technique we explored in the preceding tutorial.</span></span> <span data-ttu-id="deb71-215">从自定义错误页调用 `GetLastError` 方法将返回 `Nothing`。</span><span class="sxs-lookup"><span data-stu-id="deb71-215">Calling the `GetLastError` method from the custom error page returns `Nothing`.</span></span>

<span data-ttu-id="deb71-216">此行为的原因是因为通过重定向到达了自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-216">The reason for this behavior is because the custom error page is reached via a redirect.</span></span> <span data-ttu-id="deb71-217">当未处理的异常到达 ASP.NET 运行时时，ASP.NET 引擎引发其 `Error` 事件（执行 `Application_Error` 事件处理程序），然后通过发出 `Response.Redirect(customErrorPageUrl)`将用户*重定向*到自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-217">When an unhandled exception reaches the ASP.NET runtime the ASP.NET engine raises its `Error` event (which executes the `Application_Error` event handler) and then *redirects* the user to the custom error page by issuing a `Response.Redirect(customErrorPageUrl)`.</span></span> <span data-ttu-id="deb71-218">`Response.Redirect` 方法使用 HTTP 302 状态代码将响应发送到客户端，指导浏览器请求新的 URL，即自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-218">The `Response.Redirect` method sends a response to the client with an HTTP 302 status code, instructing the browser to request a new URL, namely the custom error page.</span></span> <span data-ttu-id="deb71-219">然后，浏览器会自动请求此新页面。</span><span class="sxs-lookup"><span data-stu-id="deb71-219">The browser then automatically requests this new page.</span></span> <span data-ttu-id="deb71-220">您可以知道自定义错误页是从错误产生的页面中单独请求的，因为浏览器的地址栏更改为自定义错误页 URL （请参阅**图 4**）。</span><span class="sxs-lookup"><span data-stu-id="deb71-220">You can tell that the custom error page was requested separately from the page where the error originated because the browser's Address bar changes to the custom error page URL (see **Figure 4**).</span></span>

[![](processing-unhandled-exceptions-cs/_static/image11.png)](processing-unhandled-exceptions-cs/_static/image10.png)

<span data-ttu-id="deb71-221">**图 4**：发生错误时，浏览器将重定向到自定义错误页 URL</span><span class="sxs-lookup"><span data-stu-id="deb71-221">**Figure 4**: When an Error Occurs the Browser Gets Redirected to the Custom Error Page URL</span></span>  
<span data-ttu-id="deb71-222">（[单击以查看完全大小的映像](processing-unhandled-exceptions-cs/_static/image12.png)）</span><span class="sxs-lookup"><span data-stu-id="deb71-222">([Click to view full-size image](processing-unhandled-exceptions-cs/_static/image12.png))</span></span>

<span data-ttu-id="deb71-223">最终效果是，在服务器响应 HTTP 302 重定向时，发生未经处理的异常的请求结束。</span><span class="sxs-lookup"><span data-stu-id="deb71-223">The net effect is that the request where the unhandled exception occurred ends when the server responds with the HTTP 302 redirect.</span></span> <span data-ttu-id="deb71-224">对自定义错误页的后续请求是全新请求;此时，ASP.NET 引擎放弃了错误信息，而且还无法将上一个请求中的未处理异常与新的自定义错误页请求相关联。</span><span class="sxs-lookup"><span data-stu-id="deb71-224">The subsequent request to the custom error page is a brand new request; by this point the ASP.NET engine has discarded the error information and, moreover, has no way to associate the unhandled exception in the previous request with the new request for the custom error page.</span></span> <span data-ttu-id="deb71-225">这就是从自定义错误页调用 `GetLastError` 返回 `null` 的原因。</span><span class="sxs-lookup"><span data-stu-id="deb71-225">This is why `GetLastError` returns `null` when called from the custom error page.</span></span>

<span data-ttu-id="deb71-226">但是，可以在导致错误的同一请求期间执行自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-226">However, it is possible to have the custom error page executed during the same request that caused the error.</span></span> <span data-ttu-id="deb71-227">[`Server.Transfer(url)`](https://msdn.microsoft.com/library/system.web.httpserverutility.transfer.aspx)方法将执行转移到指定的 URL，并在同一请求中对其进行处理。</span><span class="sxs-lookup"><span data-stu-id="deb71-227">The [`Server.Transfer(url)`](https://msdn.microsoft.com/library/system.web.httpserverutility.transfer.aspx) method transfers execution to the specified URL and processes it within the same request.</span></span> <span data-ttu-id="deb71-228">可以将 `Application_Error` 事件处理程序中的代码移到自定义错误页的代码隐藏类，并在 `Global.asax` 中将其替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="deb71-228">You could move the code in the `Application_Error` event handler to the custom error page's code-behind class, replacing it in `Global.asax` with the following code:</span></span>

[!code-csharp[Main](processing-unhandled-exceptions-cs/samples/sample5.cs)]

<span data-ttu-id="deb71-229">现在，当发生未处理的异常时，`Application_Error` 事件处理程序会根据 HTTP 状态代码将控制转移到适当的自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-229">Now when an unhandled exception occurs the `Application_Error` event handler transfers control to the appropriate custom error page based on the HTTP status code.</span></span> <span data-ttu-id="deb71-230">由于已传输控制权，因此自定义错误页可以通过 `Server.GetLastError` 访问未经处理的异常信息，并可以通知开发人员出现错误并记录其详细信息。</span><span class="sxs-lookup"><span data-stu-id="deb71-230">Because control was transferred, the custom error page has access to the unhandled exception information via `Server.GetLastError` and can notify a developer of the error and log its details.</span></span> <span data-ttu-id="deb71-231">`Server.Transfer` 调用会阻止 ASP.NET 引擎将用户重定向到自定义错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-231">The `Server.Transfer` call stops the ASP.NET engine from redirecting the user to the custom error page.</span></span> <span data-ttu-id="deb71-232">相反，自定义错误页的内容将作为对生成错误的页的响应返回。</span><span class="sxs-lookup"><span data-stu-id="deb71-232">Instead, the custom error page's content is returned as the response to the page that generated the error.</span></span>

## <a name="summary"></a><span data-ttu-id="deb71-233">摘要</span><span class="sxs-lookup"><span data-stu-id="deb71-233">Summary</span></span>

<span data-ttu-id="deb71-234">当 ASP.NET web 应用程序中发生未经处理的异常时，ASP.NET 运行时会引发 `Error` 事件，并显示配置的错误页。</span><span class="sxs-lookup"><span data-stu-id="deb71-234">When an unhandled exception occurs in an ASP.NET web application the ASP.NET runtime raises the `Error` event and displays the configured error page.</span></span> <span data-ttu-id="deb71-235">通过为错误事件创建事件处理程序，我们可以通知开发人员错误、记录其详细信息或以其他方式进行处理。</span><span class="sxs-lookup"><span data-stu-id="deb71-235">We can notify the developer of the error, log its details, or process it in some other fashion, by creating an event handler for the Error event.</span></span> <span data-ttu-id="deb71-236">可以通过两种方法为 `HttpApplication` 事件创建事件处理程序，如 `Error`：在 `Global.asax` 文件中，或从 HTTP 模块。</span><span class="sxs-lookup"><span data-stu-id="deb71-236">There are two ways to create an event handler for `HttpApplication` events like `Error`: in the `Global.asax` file or from an HTTP Module.</span></span> <span data-ttu-id="deb71-237">本教程演示了如何在 `Global.asax` 文件中创建一个 `Error` 事件处理程序，该处理程序通过电子邮件通知开发人员出现错误。</span><span class="sxs-lookup"><span data-stu-id="deb71-237">This tutorial showed how to create an `Error` event handler in the `Global.asax` file that notifies developers of an error by means of an email message.</span></span>

<span data-ttu-id="deb71-238">如果需要以某种独特或自定义的方式处理未经处理的异常，则创建 `Error` 事件处理程序会很有用。</span><span class="sxs-lookup"><span data-stu-id="deb71-238">Creating an `Error` event handler is useful if you need to process unhandled exceptions in some unique or customized manner.</span></span> <span data-ttu-id="deb71-239">但是，创建自己的 `Error` 事件处理程序来记录异常或通知开发人员并不是最有效的时间，因为已存在可在几分钟内设置的免费且易于使用的错误日志记录库。</span><span class="sxs-lookup"><span data-stu-id="deb71-239">However, creating your own `Error` event handler to log the exception or to notify a developer is not the most efficient use of your time as there already exist free and easy to use error logging libraries that can be setup in a matter of minutes.</span></span> <span data-ttu-id="deb71-240">接下来的两个教程检查两个这类库。</span><span class="sxs-lookup"><span data-stu-id="deb71-240">The next two tutorials examine two such libraries.</span></span>

<span data-ttu-id="deb71-241">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="deb71-241">Happy Programming!</span></span>

### <a name="further-reading"></a><span data-ttu-id="deb71-242">其他阅读材料</span><span class="sxs-lookup"><span data-stu-id="deb71-242">Further Reading</span></span>

<span data-ttu-id="deb71-243">有关本教程中讨论的主题的详细信息，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="deb71-243">For more information on the topics discussed in this tutorial, refer to the following resources:</span></span>

- [<span data-ttu-id="deb71-244">ASP.NET HTTP 模块和 HTTP 处理程序概述</span><span class="sxs-lookup"><span data-stu-id="deb71-244">ASP.NET HTTP Modules and HTTP Handlers Overview</span></span>](https://support.microsoft.com/kb/307985)
- [<span data-ttu-id="deb71-245">正确响应未处理的异常-处理未经处理的异常</span><span class="sxs-lookup"><span data-stu-id="deb71-245">Gracefully Responding to Unhandled Exceptions - Processing Unhandled Exceptions</span></span>](http://aspnet.4guysfromrolla.com/articles/091306-1.aspx)
- [<span data-ttu-id="deb71-246">`HttpApplication` 类和 ASP.NET 应用程序对象</span><span class="sxs-lookup"><span data-stu-id="deb71-246">`HttpApplication` Class and the ASP.NET Application Object</span></span>](http://www.eggheadcafe.com/articles/20030211.asp)
- [<span data-ttu-id="deb71-247">ASP.NET 中的 HTTP 处理程序和 HTTP 模块</span><span class="sxs-lookup"><span data-stu-id="deb71-247">HTTP Handlers and HTTP Modules in ASP.NET</span></span>](http://www.15seconds.com/Issue/020417.htm)
- [<span data-ttu-id="deb71-248">在 ASP.NET 中发送电子邮件</span><span class="sxs-lookup"><span data-stu-id="deb71-248">Sending Email in ASP.NET</span></span>](http://aspnet.4guysfromrolla.com/articles/072606-1.aspx)
- [<span data-ttu-id="deb71-249">了解 `Global.asax` 文件</span><span class="sxs-lookup"><span data-stu-id="deb71-249">Understanding the `Global.asax` File</span></span>](http://aspalliance.com/1114_Understanding_the_Globalasax_file.all)
- [<span data-ttu-id="deb71-250">使用 HTTP 模块和处理程序创建可插入的 ASP.NET 组件</span><span class="sxs-lookup"><span data-stu-id="deb71-250">Using HTTP Modules and Handlers to Create Pluggable ASP.NET Components</span></span>](https://msdn.microsoft.com/library/aa479332.aspx)
- [<span data-ttu-id="deb71-251">使用 ASP.NET `Global.asax` 文件</span><span class="sxs-lookup"><span data-stu-id="deb71-251">Working with the ASP.NET `Global.asax` File</span></span>](http://articles.techrepublic.com.com/5100-10878_11-5771721.html)
- [<span data-ttu-id="deb71-252">使用 `HttpApplication` 实例</span><span class="sxs-lookup"><span data-stu-id="deb71-252">Working with `HttpApplication` Instances</span></span>](https://msdn.microsoft.com/library/a0xez8f2.aspx)

> [!div class="step-by-step"]
> <span data-ttu-id="deb71-253">[上一页](displaying-a-custom-error-page-cs.md)
> [下一页](logging-error-details-with-asp-net-health-monitoring-cs.md)</span><span class="sxs-lookup"><span data-stu-id="deb71-253">[Previous](displaying-a-custom-error-page-cs.md)
[Next](logging-error-details-with-asp-net-health-monitoring-cs.md)</span></span>

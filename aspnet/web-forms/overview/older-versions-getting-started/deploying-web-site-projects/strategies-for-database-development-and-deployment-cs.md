---
uid: web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-cs
title: 数据库开发和部署策略（C#） |Microsoft Docs
author: rick-anderson
description: 首次部署数据驱动的应用程序时，可以在开发环境中盲目地将数据库复制到生产环境中。 B. 。
ms.author: riande
ms.date: 04/23/2009
ms.assetid: 3e8b0627-3eb7-488e-807e-067cba7cec05
msc.legacyurl: /web-forms/overview/older-versions-getting-started/deploying-web-site-projects/strategies-for-database-development-and-deployment-cs
msc.type: authoredcontent
ms.openlocfilehash: 4d9dbaf41926b43af171619ee34f58da84b5dab1
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78509384"
---
# <a name="strategies-for-database-development-and-deployment-c"></a><span data-ttu-id="0c5a0-104">数据库开发和部署策略 (C#)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-104">Strategies for Database Development and Deployment (C#)</span></span>

<span data-ttu-id="0c5a0-105">作者： [Scott Mitchell](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

[<span data-ttu-id="0c5a0-106">下载 PDF</span><span class="sxs-lookup"><span data-stu-id="0c5a0-106">Download PDF</span></span>](https://download.microsoft.com/download/C/3/9/C391A649-B357-4A7B-BAA4-48C96871FEA6/aspnet_tutorial10_DBDevel_cs.pdf)

> <span data-ttu-id="0c5a0-107">首次部署数据驱动的应用程序时，可以在开发环境中盲目地将数据库复制到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-107">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="0c5a0-108">但在后续部署中执行一个直接复制将覆盖输入到生产数据库中的所有数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-108">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="0c5a0-109">相反，部署数据库需要应用自上一次部署到生产数据库后对开发数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-109">Instead, deploying a database involves applying the changes made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="0c5a0-110">本教程将探讨这些挑战，并提供各种策略来帮助 chronicling 和应用自上次部署以来对数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-110">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>

## <a name="introduction"></a><span data-ttu-id="0c5a0-111">简介</span><span class="sxs-lookup"><span data-stu-id="0c5a0-111">Introduction</span></span>

<span data-ttu-id="0c5a0-112">如前面的教程中所述，部署 ASP.NET 应用程序需要将相关内容从开发环境复制到生产环境。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-112">As discussed in previous tutorials, deploying an ASP.NET application entails copying the pertinent content from the development environment to the production environment.</span></span> <span data-ttu-id="0c5a0-113">部署不是一次性的事件，而是在每次发布软件的新版本时或发现并解决了 bug 或安全问题时出现的情况。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-113">Deployment is not a one-time event, but rather something that happens every time a new version of the software is released or when bugs or security concerns have been identified and addressed.</span></span> <span data-ttu-id="0c5a0-114">将 ASP.NET 页面、图像、JavaScript 文件和其他此类文件复制到生产环境时，无需考虑到自上次部署后这些文件如何发生更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-114">When copying ASP.NET pages, images, JavaScript files, and other such files to the production environment you do not need to concern yourself with how these file have been changed since the last deployment.</span></span> <span data-ttu-id="0c5a0-115">你可以盲目地将文件复制到生产，并覆盖现有内容。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-115">You can blindly copy the file to production, overwriting the existing content.</span></span> <span data-ttu-id="0c5a0-116">遗憾的是，这种简易性并不会扩展到部署数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-116">Unfortunately, this simplicity does not extend to deploying the database.</span></span>

<span data-ttu-id="0c5a0-117">首次部署数据驱动的应用程序时，可以在开发环境中盲目地将数据库复制到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-117">When deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="0c5a0-118">但在后续部署中执行一个直接复制将覆盖输入到生产数据库中的所有数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-118">But performing a blind copy in subsequent deployments will overwrite any data entered into the production database.</span></span> <span data-ttu-id="0c5a0-119">相反，部署数据库需要应用自上一次部署到生产数据库后对开发数据库所做的*更改*。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-119">Instead, deploying a database involves applying the *changes* made to the development database since the last deployment onto the production database.</span></span> <span data-ttu-id="0c5a0-120">本教程将探讨这些挑战，并提供各种策略来帮助 chronicling 和应用自上次部署以来对数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-120">This tutorial examines these challenges and offers various strategies to assist with chronicling and applying the changes made to the database since the last deployment.</span></span>

## <a name="the-challenges-of-deploying-a-database"></a><span data-ttu-id="0c5a0-121">部署数据库的挑战</span><span class="sxs-lookup"><span data-stu-id="0c5a0-121">The Challenges of Deploying a Database</span></span>

<span data-ttu-id="0c5a0-122">在第一次部署数据驱动的应用程序之前，只需要一个数据库（即开发环境中的数据库），这就是在第一次部署数据驱动的应用程序时，在将数据库复制到开发环境部署到生产环境。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-122">Before a data-driven application has been deployed for the first time, there is only one database, namely the database in the development environment, which is why when deploying a data-driven application for the first time you can blindly copy the database in the development environment to the production environment.</span></span> <span data-ttu-id="0c5a0-123">但在部署应用程序后，有两个数据库副本：一个在开发中，另一个在生产中。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-123">But once the application has been deployed there are two copies of the database: one in development and one in production.</span></span>

<span data-ttu-id="0c5a0-124">在部署之间，开发和生产数据库可能会变得不同步。尽管生产数据库架构保持不变，但在添加新功能时，开发数据库的架构可能会更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-124">Between deployments the development and production databases can become out of sync. While the production database s schema remains unchanged, the development database s schema may change as new features are added.</span></span> <span data-ttu-id="0c5a0-125">您可以添加或删除列、表、视图或存储过程。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-125">You might add or remove columns, tables, views, or stored procedures.</span></span> <span data-ttu-id="0c5a0-126">还可能会将重要数据添加到开发数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-126">There may also be important data that gets added to the development database.</span></span> <span data-ttu-id="0c5a0-127">许多数据驱动的应用程序包括用硬编码的、特定于应用程序的数据（不是用户可编辑的）填充的查找表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-127">Many data-driven applications include lookup tables populated with hard-coded, application-specific data that are not user-editable.</span></span> <span data-ttu-id="0c5a0-128">例如，拍卖网站可能有一个下拉列表，其中包含用于描述要 auctioned 的项的条件的选项： "新"、"好" 和 "公平"。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-128">For example, an auction website might have a drop-down list with choices that describe the condition of the item being auctioned: New, Like New, Good, and Fair.</span></span> <span data-ttu-id="0c5a0-129">通常最好将这些选项置于数据库表中，而不是直接在下拉列表中对这些选项进行硬编码。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-129">Rather than hard-coding these options directly in the drop-down list it is usually better to place them in a database table.</span></span> <span data-ttu-id="0c5a0-130">如果在开发过程中将名为 "差" 的新条件添加到表中，则在部署应用程序时，需要将此同一记录添加到生产数据库中的查找表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-130">If, during development, a new condition named Poor is added to the table then when deploying the application this same record needs to be added to the lookup table in the production database.</span></span>

<span data-ttu-id="0c5a0-131">理想情况下，部署数据库需要将数据库从开发环境复制到生产环境中。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-131">Ideally, deploying the database would involve copying the database from development to production.</span></span> <span data-ttu-id="0c5a0-132">但请记住，在部署应用程序并恢复开发后，将使用真实用户的实际数据填充生产数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-132">But keep in mind that after you have deployed the application and resumed development, the production database is being populated with real data from real users.</span></span> <span data-ttu-id="0c5a0-133">因此，如果只是在下一次部署时将数据库从开发环境复制到生产环境中，则会覆盖生产数据库，并丢失现有数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-133">Therefore, if you were to simply copy the database from development to production at the next deployment you would overwrite the production database and lose its existing data.</span></span> <span data-ttu-id="0c5a0-134">最终的结果是，部署数据库，以应用自上次部署以来对开发数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-134">The net result is that deploying the database boils down to applying the changes made to the development database since the last deployment.</span></span>

<span data-ttu-id="0c5a0-135">由于部署数据库涉及应用架构中的更改（可能是自上次部署以来的数据），因此必须维护更改的历史记录（或在部署时确定），以便可以在生产环境中应用这些更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-135">Because deploying a database involves applying the changes in the schema and, possibly, the data since the last deployment, a history of changes must be maintained (or determined at deploy-time) so that those changes can be applied on production.</span></span> <span data-ttu-id="0c5a0-136">有多种方法可用于管理和应用数据模型更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-136">There are a variety of techniques for managing and applying changes to the data model.</span></span>

### <a name="defining-the-baseline"></a><span data-ttu-id="0c5a0-137">定义基线</span><span class="sxs-lookup"><span data-stu-id="0c5a0-137">Defining the Baseline</span></span>

<span data-ttu-id="0c5a0-138">若要维护对应用程序数据库所做的更改，需要有一些开始状态，即要将更改应用到的基线。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-138">To maintain the changes to your application s database you need to have some starting state, a baseline to which the changes are applied to.</span></span> <span data-ttu-id="0c5a0-139">一种极端情况下，启动状态可以是没有表、视图或存储过程的空数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-139">At one extreme the starting state could be an empty database with no tables, views, or stored procedures.</span></span> <span data-ttu-id="0c5a0-140">此类基线将导致大更改日志，因为它必须包括创建所有数据库表、视图和存储过程，以及在初始部署之后所做的任何更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-140">Such a baseline results in a large change log because it must include the creation of all of the database s tables, views, and stored procedures along with any changes made after the initial deployment.</span></span> <span data-ttu-id="0c5a0-141">在该色谱的另一端，你可以将基线设置为最初部署到生产环境的数据库的版本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-141">At the other end of the spectrum you could set the baseline as the version of the database that is initially deployed to the production environment.</span></span> <span data-ttu-id="0c5a0-142">此选择将导致更小的更改日志，因为它仅包含在首次部署后对数据库所做的更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-142">This choice results in a much smaller change log because it only includes the changes made to the database following the first deployment.</span></span> <span data-ttu-id="0c5a0-143">这是我喜欢的方法。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-143">This is the approach I prefer.</span></span> <span data-ttu-id="0c5a0-144">当然，您可以选择一种更多的道路方法，将基线定义为在最初创建数据库与首次部署数据库之间的某个时间点。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-144">And of course you can choose a more middle of the road approach, defining the baseline as some point between the initial creation of the database and when the database is first deployed.</span></span>

<span data-ttu-id="0c5a0-145">选择基线后，可考虑生成可执行的 SQL 脚本来重新创建基线版本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-145">Once you have chosen a baseline consider generating a SQL script that can be executed to recreate the baseline version.</span></span> <span data-ttu-id="0c5a0-146">利用此类脚本，可以快速重新创建数据库的基准版本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-146">Such a script makes it possible to quickly recreate the baseline version of the database.</span></span> <span data-ttu-id="0c5a0-147">此功能在大型项目中特别有用，其中可能有多个开发人员在使用项目或其他环境（如测试或过渡），每个开发人员都需要自己的数据库副本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-147">This functionality is especially useful in larger projects, where there may be multiple developers working on the project or additional environments, such as testing or staging, that each need their own copy of the database.</span></span>

<span data-ttu-id="0c5a0-148">有多种工具可用于生成基线版本的 SQL 脚本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-148">There are a variety of tools at your disposal to generate a SQL script of the baseline version.</span></span> <span data-ttu-id="0c5a0-149">从 SQL Server Management Studio （SSMS）中，可以右键单击数据库，然后单击 "任务" 子菜单，然后选择 "生成脚本" 选项。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-149">From SQL Server Management Studio (SSMS) you can right-click on the database, go to the Tasks submenu, and choose the Generate Scripts option.</span></span> <span data-ttu-id="0c5a0-150">这将启动脚本向导，您可以通过该向导来生成包含用于创建数据库对象的 SQL 命令的文件。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-150">This launches the Script Wizard, which you can instruct to generate a file that contains the SQL commands to create your database s objects.</span></span> <span data-ttu-id="0c5a0-151">另一种方法是数据库发布向导，它可以生成 SQL 命令，不仅可以创建数据库架构，还可以生成数据库表中的数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-151">Another option is the Database Publishing Wizard, which can generate the SQL commands to not only create the database schema, but also the data in the database tables.</span></span> <span data-ttu-id="0c5a0-152">"数据库发布向导" 已详细介绍了 "*部署数据库*" 教程。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-152">The Database Publishing Wizard was examined in detail back in the *Deploying a Database* tutorial.</span></span> <span data-ttu-id="0c5a0-153">不管使用哪种工具，最终都应该有一个可用于重新创建数据库基准版本的脚本文件（如果需要）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-153">Regardless of what tool you use, in the end you should have a script file that you can use to recreate the baseline version of your database, should the need arise.</span></span>

## <a name="documenting-the-database-changes-in-prose"></a><span data-ttu-id="0c5a0-154">记录 Prose 中的数据库更改</span><span class="sxs-lookup"><span data-stu-id="0c5a0-154">Documenting the Database Changes in Prose</span></span>

<span data-ttu-id="0c5a0-155">在开发阶段维护数据模型更改日志的最简单方法是在 prose 中记录更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-155">The simplest way to maintain a log of changes to the data model during the development phase is to record the changes in prose.</span></span> <span data-ttu-id="0c5a0-156">例如，如果在开发已部署的应用程序的过程中，将一个新列添加到 `Employees` 表中，从 `Orders` 表中删除一列，然后添加一个新表（`ProductCategories`），则需要维护包含以下历史记录的文本文件或 Microsoft Word 文档：</span><span class="sxs-lookup"><span data-stu-id="0c5a0-156">For example, if during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`), you would maintain a text file or Microsoft Word document with the following history:</span></span>

<a id="0.4_table01"></a>

| <span data-ttu-id="0c5a0-157">**更改日期**</span><span class="sxs-lookup"><span data-stu-id="0c5a0-157">**Change Date**</span></span> | <span data-ttu-id="0c5a0-158">**更改详细信息**</span><span class="sxs-lookup"><span data-stu-id="0c5a0-158">**Change Details**</span></span> |
| --- | --- |
| <span data-ttu-id="0c5a0-159">2009-02-03:</span><span class="sxs-lookup"><span data-stu-id="0c5a0-159">2009-02-03:</span></span> | <span data-ttu-id="0c5a0-160">向 `Employees` 表中添加了列 `DepartmentID` （`int`，而非 NULL）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-160">Added column `DepartmentID` (`int`, NOT NULL) to the `Employees` table.</span></span> <span data-ttu-id="0c5a0-161">向 `Employees.DepartmentID`添加了 `Departments.DepartmentID` 的外键约束。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-161">Added a foreign key constraint from `Departments.DepartmentID` to `Employees.DepartmentID`.</span></span> |
| <span data-ttu-id="0c5a0-162">2009-02-05:</span><span class="sxs-lookup"><span data-stu-id="0c5a0-162">2009-02-05:</span></span> | <span data-ttu-id="0c5a0-163">从 `Orders` 表中删除了列 `TotalWeight`。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-163">Removed column `TotalWeight` from the `Orders` table.</span></span> <span data-ttu-id="0c5a0-164">已在关联的 `OrderDetails` 记录中捕获的数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-164">Data already captured in associated `OrderDetails` records.</span></span> |
| <span data-ttu-id="0c5a0-165">2009-02-12:</span><span class="sxs-lookup"><span data-stu-id="0c5a0-165">2009-02-12:</span></span> | <span data-ttu-id="0c5a0-166">已创建 `ProductCategories` 表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-166">Created the `ProductCategories` table.</span></span> <span data-ttu-id="0c5a0-167">有三列： `ProductCategoryID` （`int`、`IDENTITY`、`NOT NULL`）、`CategoryName` （`nvarchar(50)`、`NOT NULL`）和 `Active` （`bit`、`NOT NULL`）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-167">There are three columns: `ProductCategoryID` (`int`, `IDENTITY`, `NOT NULL`), `CategoryName` (`nvarchar(50)`, `NOT NULL`), and `Active` (`bit`, `NOT NULL`).</span></span> <span data-ttu-id="0c5a0-168">已将 primary key 约束添加到 `ProductCategoryID`，将默认值1添加到 `Active`。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-168">Added a primary key constraint to `ProductCategoryID`, and a default value of 1 to `Active`.</span></span> |

<span data-ttu-id="0c5a0-169">此方法有许多缺点。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-169">There are a number of drawbacks to this approach.</span></span> <span data-ttu-id="0c5a0-170">对于初学者来说，无希望自动化。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-170">For starters, there is no hope for automation.</span></span> <span data-ttu-id="0c5a0-171">无论何时需要将这些更改应用到数据库（例如，在部署应用程序时），开发人员都必须手动实现每个更改（一次一个）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-171">Anytime these changes need to be applied to a database - such as when the application is deployed - a developer must manually implement each change, one at a time.</span></span> <span data-ttu-id="0c5a0-172">此外，如果您需要使用更改日志重构基线中的特定版本的数据库，则执行此操作将需要更多的时间，因为日志大小会增长。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-172">Moreover, if you need to reconstruct a particular version of the database from the baseline using the change log, doing so will take more and more time as the size of the log grows.</span></span> <span data-ttu-id="0c5a0-173">此方法的另一个缺点是，每个更改日志条目的清晰度和详细程度会留给记录更改的人员。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-173">Another drawback to this method is that the clarity and level of detail of each change log entry is left to the person recording the change.</span></span> <span data-ttu-id="0c5a0-174">在具有多个开发人员的团队中，某些开发人员可能会提供比其他开发人员更详细、更具可读性或更精确的条目。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-174">In a team with multiple developers some may make more detailed, more readable, or more precise entries than others.</span></span> <span data-ttu-id="0c5a0-175">此外，还可能会出现打字错误和其他与人工相关的数据输入错误。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-175">Also, typos and other human-related data entry errors are possible.</span></span>

<span data-ttu-id="0c5a0-176">在 prose 中记录数据库更改的主要好处是简单。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-176">The primary benefit of documenting the database changes in prose is simplicity.</span></span> <span data-ttu-id="0c5a0-177">你不需要熟悉用于创建和更改数据库对象的 SQL 语法。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-177">You don t need familiarity with the SQL syntax for creating and altering database objects.</span></span> <span data-ttu-id="0c5a0-178">相反，可以在 prose 中记录更改，并通过 SQL Server Management Studio s 图形用户界面实现这些更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-178">Instead, you can record the changes in prose and implement them through SQL Server Management Studio s graphical user interface.</span></span>

<span data-ttu-id="0c5a0-179">在 prose 中维护您的更改日志是不可否认的，不是非常复杂的，也不能很好地用于某些项目，例如很大范围内的项目、经常更改数据模型，或者涉及多个开发人员。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-179">Maintaining your change log in prose is, admittedly, not very sophisticated and won't work well with certain projects, such as ones that are large in scope, have frequent changes to the data model, or involve multiple developers.</span></span> <span data-ttu-id="0c5a0-180">但我已经了解，这种方法在仅对数据模型进行了偶尔更改的小型单 man 项目中非常有效，而在 SQL 语法中，在创建和更改数据库对象的情况下，有条件的开发人员没有更好的背景。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-180">But I have seen this approach work quite well in small, one-man projects that have only occasional changes to the data model and where the solo developer does not have a strong background in the SQL syntax for creating and altering database objects.</span></span>

> [!NOTE]
> <span data-ttu-id="0c5a0-181">尽管更改日志中的信息在技术上是在部署时才需要，但建议保留更改的历史记录。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-181">While the information in the change log is, technically, only needed until deploy-time, I recommend keeping a history of changes.</span></span> <span data-ttu-id="0c5a0-182">不过，请考虑为每个数据库版本提供不同的更改日志文件，而不是保留一个不断增长的更改日志文件。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-182">But rather than maintaining a single, ever growing change log file, consider having a different change log file for each database version.</span></span> <span data-ttu-id="0c5a0-183">通常，每次部署数据库时，您都需要对数据库进行版本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-183">Typically you will want to version the database each time it is deployed.</span></span> <span data-ttu-id="0c5a0-184">通过维护更改日志的日志，你可以从基线开始，通过执行从版本1开始的更改日志脚本来重新创建任何数据库版本，并继续，直到你到达需要重新创建的版本为止。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-184">By maintaining a log of change logs you can, starting from the baseline, recreate any database version by executing the change log scripts starting from version 1 and continuing until you reach the version you need to recreate.</span></span>

## <a name="recording-the-sql-change-statements"></a><span data-ttu-id="0c5a0-185">记录 SQL Change 语句</span><span class="sxs-lookup"><span data-stu-id="0c5a0-185">Recording the SQL Change Statements</span></span>

<span data-ttu-id="0c5a0-186">在 prose 中维护更改日志的主要缺点是缺乏自动化。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-186">The primary drawback of maintaining the change log in prose is the lack of automation.</span></span> <span data-ttu-id="0c5a0-187">理想情况下，在部署时实施对生产数据库的数据库更改很简单，只需单击一个按钮即可执行脚本，而无需手动执行指令列表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-187">Ideally, implementing the database changes to the production database at deploy-time would be as easy as clicking a button to execute a script rather than having to manually perform a list of instructions.</span></span> <span data-ttu-id="0c5a0-188">通过维护包含用于更改数据模型的 SQL 命令的更改日志，可以实现这种自动化。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-188">Such automation is possible by maintaining a change log that contains those SQL commands used to alter the data model.</span></span>

<span data-ttu-id="0c5a0-189">SQL 语法包含多个用于创建和修改各种数据库对象的语句。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-189">The SQL syntax includes a number of statements for creating and modifying various database objects.</span></span> <span data-ttu-id="0c5a0-190">例如，执行时[*CREATE TABLE 语句*](https://msdn.microsoft.com/library/ms174979.aspx)将创建具有指定列和约束的新表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-190">For example, the [*CREATE TABLE statement*](https://msdn.microsoft.com/library/ms174979.aspx), when executed, creates a new table with the specified columns and constraints.</span></span> <span data-ttu-id="0c5a0-191">[*ALTER TABLE 语句*](https://msdn.microsoft.com/library/ms190273.aspx)修改现有的表，添加、删除或修改其列或约束。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-191">The [*ALTER TABLE statement*](https://msdn.microsoft.com/library/ms190273.aspx) modifies an existing table, adding, removing, or modifying its columns or constraints.</span></span> <span data-ttu-id="0c5a0-192">还提供了用于创建、修改和删除索引、视图、用户定义函数、存储过程、触发器和其他数据库对象的语句。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-192">There are also statements to create, modify, and drop indexes, views, user-defined functions, stored procedures, triggers, and other database objects.</span></span>

<span data-ttu-id="0c5a0-193">返回到我们之前的示例，在开发已部署的应用程序的过程中，会将一个新列添加到 `Employees` 表中，从 `Orders` 表中删除一列，然后添加一个新表（`ProductCategories`）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-193">Returning to our earlier example, image that during development of an already-deployed application you add a new column to the `Employees` table, remove a column from the `Orders` table, and add a new table (`ProductCategories`).</span></span> <span data-ttu-id="0c5a0-194">此类操作会导致更改日志文件包含以下 SQL 命令：</span><span class="sxs-lookup"><span data-stu-id="0c5a0-194">Such actions would result in a change log file with the following SQL commands:</span></span>

[!code-sql[Main](strategies-for-database-development-and-deployment-cs/samples/sample1.sql)]

<span data-ttu-id="0c5a0-195">在部署时将这些更改推送到生产数据库的操作是单击操作：打开 SQL Server Management Studio，连接到生产数据库，打开新的查询窗口，粘贴更改日志的内容，然后单击 "执行" 以运行脚本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-195">Pushing these changes to the production database at deploy-time is a one-click operation: open SQL Server Management Studio, connect to your production database, open a New Query window, paste the contents of the change log, and click Execute to run the script.</span></span>

## <a name="using-a-comparison-tool-to-synchronize-the-data-models"></a><span data-ttu-id="0c5a0-196">使用比较工具同步数据模型</span><span class="sxs-lookup"><span data-stu-id="0c5a0-196">Using a Comparison Tool to Synchronize the Data Models</span></span>

<span data-ttu-id="0c5a0-197">在 prose 中记录数据库更改很简单，但实施更改需要开发人员每次对生产数据库进行一次更改;记录更改 SQL 命令，就像单击按钮一样简单快捷地在生产数据库上实现这些更改，但需要学习和掌握用于创建和更改数据库对象的 SQL 语句和语法。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-197">Documenting database changes in prose is easy, but implementing the changes requires a developer to make each change on the production database one at a time; documenting the change SQL commands makes implementing those changes on the production database as easy and quick as clicking a button, but requires learning and mastering the SQL statements and syntax for creating and altering database objects.</span></span> <span data-ttu-id="0c5a0-198">数据库比较工具最适用于这两种方法，并放弃最差。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-198">Database comparison tools take the best from both approaches and discard the worst.</span></span>

<span data-ttu-id="0c5a0-199">数据库比较工具比较两个数据库的架构或数据，并显示摘要报告，其中显示了数据库的不同之处。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-199">A database comparison tool compares the schema or data of two databases and displays a summary report showing you how the databases differ.</span></span> <span data-ttu-id="0c5a0-200">然后，单击按钮即可生成用于同步一个或多个数据库对象的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-200">Then, with the click of a button, you can generate the SQL commands for synchronizing one or more database objects.</span></span> <span data-ttu-id="0c5a0-201">简而言之，可以在部署时使用数据库比较工具比较开发数据库和生产数据库，生成包含 SQL 命令的文件，该文件在执行时将应用对生产数据库 s 架构的更改，使其镜像开发数据库架构。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-201">In a nutshell, you can use a database comparison tool to compare the development and production databases at deploy-time, generating a file that contains the SQL commands that, when executed, will apply the changes to the production database s schema so that it mirrors the development database s schema.</span></span>

<span data-ttu-id="0c5a0-202">许多不同的供应商提供了各种第三方数据库比较工具。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-202">There are a variety of third-party database comparison tools offered by many different vendors.</span></span> <span data-ttu-id="0c5a0-203">其中一个例子就是[*SQL 比较*](http://www.red-gate.com/products/SQL_Compare/)（[*红色入口软件*](http://www.red-gate.com/)）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-203">One such example is [*SQL Compare*](http://www.red-gate.com/products/SQL_Compare/), by [*Red Gate Software*](http://www.red-gate.com/).</span></span> <span data-ttu-id="0c5a0-204">让我们逐步完成使用 SQL 比较来比较和同步开发和生产数据库架构的过程。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-204">Let s walk through the process of using SQL Compare to compare and synchronize the development and production databases schemas.</span></span>

> [!NOTE]
> <span data-ttu-id="0c5a0-205">撰写本文时，SQL 比较的当前版本是版本7.1，标准版的成本为 $395。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-205">At the time of this writing the current version of SQL Compare was version 7.1, with the Standard Edition costing $395.</span></span> <span data-ttu-id="0c5a0-206">可以通过下载为期14天的免费试用版进行跟踪。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-206">You can follow along by downloading a free 14-day trial.</span></span>

<span data-ttu-id="0c5a0-207">当 SQL 比较开始时，将打开 "比较项目" 对话框，其中显示了已保存的 SQL 比较项目。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-207">When SQL Compare starts the Comparison Projects dialog box opens, showing the saved SQL Compare projects.</span></span> <span data-ttu-id="0c5a0-208">创建新项目。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-208">Create a new project.</span></span> <span data-ttu-id="0c5a0-209">这会启动项目配置向导，该向导会提示输入要比较的数据库的有关信息（请参阅图1）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-209">This launches the Project Configuration wizard, which prompts for information about the databases to compare (see Figure 1).</span></span> <span data-ttu-id="0c5a0-210">输入用于开发和生产环境数据库的信息。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-210">Enter the information for the development and production environment databases.</span></span>

<span data-ttu-id="0c5a0-211">[![比较开发和生产数据库](strategies-for-database-development-and-deployment-cs/_static/image2.jpg)](strategies-for-database-development-and-deployment-cs/_static/image1.jpg)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-211">[![Compare the Development and Production Databases](strategies-for-database-development-and-deployment-cs/_static/image2.jpg)](strategies-for-database-development-and-deployment-cs/_static/image1.jpg)</span></span>

<span data-ttu-id="0c5a0-212">**图 1**：比较开发和生产数据库（[单击以查看完全大小的图像](strategies-for-database-development-and-deployment-cs/_static/image3.jpg)）</span><span class="sxs-lookup"><span data-stu-id="0c5a0-212">**Figure 1**: Compare the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image3.jpg))</span></span>

> [!NOTE]
> <span data-ttu-id="0c5a0-213">如果你的开发环境数据库是网站的 `App_Data` 文件夹中的 SQL Express Edition 数据库文件，则需要在 SQL Server Express 数据库服务器中注册数据库，以便从图1所示的对话框中选择该数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-213">If your development environment database is a SQL Express Edition database file in the `App_Data` folder of your website you will need to register the database in the SQL Server Express database server in order to select it from the dialog box shown in Figure 1.</span></span> <span data-ttu-id="0c5a0-214">实现此目的的最简单方法是打开 SQL Server Management Studio （SSMS），连接到 SQL Server Express 数据库服务器，然后附加数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-214">The easiest way to accomplish this is to open SQL Server Management Studio (SSMS), connect to the SQL Server Express database server, and attach the database.</span></span> <span data-ttu-id="0c5a0-215">如果你的计算机上未安装 SSMS，则可以下载并安装免费[*SQL Server 2008 Management Studio Basic 版本*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en)。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-215">If you do not have SSMS installed on your computer you can download and install the free [*SQL Server 2008 Management Studio Basic version*](https://www.microsoft.com/downloads/details.aspx?FamilyId=7522A683-4CB2-454E-B908-E805E9BD4E28&amp;displaylang=en).</span></span>

<span data-ttu-id="0c5a0-216">除了选择要比较的数据库之外，还可以在 "选项" 选项卡中指定各种比较设置。你可能想要启用的一个选项是 "忽略约束和索引名称"。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-216">In addition to selecting the databases to compare, you can also specify a variety of comparison settings from the Options tab. One option you may want to turn on is the "Ignore constraint and index names."</span></span> <span data-ttu-id="0c5a0-217">请记住，在前面的教程中，我们将应用程序服务数据库对象添加到了开发和生产数据库中。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-217">Recall that in the preceding tutorial we added the application services database objects to the development and production databases.</span></span> <span data-ttu-id="0c5a0-218">如果使用 `aspnet_regsql.exe` 工具在生产数据库上创建这些对象，则会发现在开发数据库和生产数据库之间，主键和唯一约束名称有所不同。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-218">If you used the `aspnet_regsql.exe` tool to create these objects on the production database then you will find that the primary key and unique constraint names differ between the development and production databases.</span></span> <span data-ttu-id="0c5a0-219">因此，SQL 比较会将所有应用程序服务表标记为不同。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-219">Consequently, SQL Compare will flag all of the application services tables as differing.</span></span> <span data-ttu-id="0c5a0-220">您可以取消选中 "忽略约束和索引名称" 并同步约束名称，或指示 SQL 比较忽略这些差异。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-220">You can either leave the "Ignore constraint and index names" unchecked and synchronize the constraint names, or instruct SQL Compare to ignore these differences.</span></span>

<span data-ttu-id="0c5a0-221">选择要比较的数据库（并查看比较选项）后，单击 "立即比较" 按钮开始比较。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-221">After selecting the databases to compare (and reviewing the comparison options), click the Compare Now button to begin the comparison.</span></span> <span data-ttu-id="0c5a0-222">在接下来的几秒内，SQL 比较会检查两个数据库的架构，并生成有关它们之间的差异的报告。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-222">Over the next several seconds, SQL Compare examines the schemas of the two databases and generates a report of how they differ.</span></span> <span data-ttu-id="0c5a0-223">我有意对开发数据库进行了一些修改，以显示 SQL 比较接口中如何注明此类差异。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-223">I ve purposefully made some modifications to the development database to show how such discrepancies are noted in the SQL Compare interface.</span></span> <span data-ttu-id="0c5a0-224">如图2所示，我将 `BirthDate` 列添加到 `Authors` 表中，从 `Books` 表中删除了 `ISBN` 列，并添加了一个新的表 `Ratings`，这旨在让用户访问站点速率审阅的书籍。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-224">As Figure 2 shows, I ve added a `BirthDate` column to the `Authors` table, removed the `ISBN` column from the `Books` table, and added a new table, `Ratings`, which is meant to let users visiting the site rate the reviewed books.</span></span>

> [!NOTE]
> <span data-ttu-id="0c5a0-225">本教程中所做的数据模型更改已完成，可以使用数据库比较工具进行说明。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-225">The data model changes made in this tutorial were done to illustrate using a database comparison tool.</span></span> <span data-ttu-id="0c5a0-226">以后的教程中将不会在数据库中发现这些更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-226">You will not find these changes in the database in future tutorials.</span></span>

<span data-ttu-id="0c5a0-227">[![SQL 比较列出了开发数据库和生产数据库之间的差异](strategies-for-database-development-and-deployment-cs/_static/image5.jpg)](strategies-for-database-development-and-deployment-cs/_static/image4.jpg)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-227">[![SQL Compare Lists the Differences Between the Development and Production Databases](strategies-for-database-development-and-deployment-cs/_static/image5.jpg)](strategies-for-database-development-and-deployment-cs/_static/image4.jpg)</span></span>

<span data-ttu-id="0c5a0-228">**图 2**： SQL 比较列出了开发数据库和生产数据库之间的差异（[单击查看完全大小的映像](strategies-for-database-development-and-deployment-cs/_static/image6.jpg)）</span><span class="sxs-lookup"><span data-stu-id="0c5a0-228">**Figure 2**: SQL Compare Lists the Differences Between the Development and Production Databases ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image6.jpg))</span></span>

<span data-ttu-id="0c5a0-229">SQL 比较将数据库对象分解为多个组，快速显示两个数据库中存在的对象，但它们不同，其中的对象存在于一个数据库中，而不存在于另一个数据库中，哪些对象是相同的。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-229">SQL Compare breaks down the database objects into groups, quickly showing you what objects exist in both databases but are different, which objects exist in one database but not the other, and which objects are identical.</span></span> <span data-ttu-id="0c5a0-230">正如您所看到的，两个数据库中都存在两个对象，但两者不同：添加了列的 `Authors` 表和已删除一个列的 `Books` 表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-230">As you can see, there are two objects that exist in both databases but are different: the `Authors` table, which had a column added, and the `Books` table, which had one removed.</span></span> <span data-ttu-id="0c5a0-231">只有开发数据库存在一个对象，即新创建的 `Ratings` 表。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-231">There is one object that exists only in the development database, namely the newly created `Ratings` table.</span></span> <span data-ttu-id="0c5a0-232">这两个数据库中的对象都是相同的。117</span><span class="sxs-lookup"><span data-stu-id="0c5a0-232">And there are 117 objects that are identical in both databases.</span></span>

<span data-ttu-id="0c5a0-233">选择数据库对象将显示 "SQL 差异" 窗口，其中显示了这些对象的不同之处。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-233">Selecting a database object displays the SQL Differences window, which shows how these objects differ.</span></span> <span data-ttu-id="0c5a0-234">"SQL 差异" 窗口（如图2所示）突出显示了开发数据库中的 `Authors` 表具有 `BirthDate` 列，该列在生产数据库的 `Authors` 表中找不到。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-234">The SQL Differences window, displayed at the bottom in Figure 2, highlights that the `Authors` table in the development database has the `BirthDate` column, which is not found in the `Authors` table on the production database.</span></span>

<span data-ttu-id="0c5a0-235">查看差异并选择想要同步的对象后，下一步是生成更新生产数据库架构以匹配开发数据库所需的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-235">After reviewing the differences and selecting which objects you want to synchronize, the next step is to generate the SQL commands needed to update the production database s schema to match the development database.</span></span> <span data-ttu-id="0c5a0-236">这是通过同步向导实现的。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-236">This is accomplished through the Synchronization Wizard.</span></span> <span data-ttu-id="0c5a0-237">同步向导可确认要同步的对象并概述操作计划（请参阅图3）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-237">The Synchronization Wizard confirms what objects to synchronize and summarizes the action plan (see Figure 3).</span></span> <span data-ttu-id="0c5a0-238">可以立即同步数据库，也可以生成包含可随时运行的 SQL 命令的脚本。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-238">You can synchronize the databases immediately or generate a script with the SQL commands that can be run at your leisure.</span></span>

<span data-ttu-id="0c5a0-239">[![使用同步向导同步数据库架构](strategies-for-database-development-and-deployment-cs/_static/image8.jpg)](strategies-for-database-development-and-deployment-cs/_static/image7.jpg)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-239">[![Use the Synchronization Wizard to Synchronize Your Databases Schemas](strategies-for-database-development-and-deployment-cs/_static/image8.jpg)](strategies-for-database-development-and-deployment-cs/_static/image7.jpg)</span></span>

<span data-ttu-id="0c5a0-240">**图 3**：使用同步向导同步数据库架构（[单击查看完全大小的映像](strategies-for-database-development-and-deployment-cs/_static/image9.jpg)）</span><span class="sxs-lookup"><span data-stu-id="0c5a0-240">**Figure 3**: Use the Synchronization Wizard to Synchronize Your Databases Schemas ([Click to view full-size image](strategies-for-database-development-and-deployment-cs/_static/image9.jpg))</span></span>

<span data-ttu-id="0c5a0-241">数据库比较工具（如红色入口软件的 SQL 比较）会将对开发数据库架构所做的更改应用到生产数据库，就像点击一样简单。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-241">Database comparison tools like Red Gate Software s SQL Compare make applying the changes to the development database schema to the production database as easy as point and click.</span></span>

> [!NOTE]
> <span data-ttu-id="0c5a0-242">SQL 比较比较并同步两个数据库*架构*。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-242">SQL Compare compares and synchronizes two databases *schemas*.</span></span> <span data-ttu-id="0c5a0-243">遗憾的是，它不比较和同步两个数据库表中的数据。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-243">Unfortunately, it does not compare and synchronize the data within two databases tables.</span></span> <span data-ttu-id="0c5a0-244">红色入口软件提供了一种名为[*Sql 数据比较*](http://www.red-gate.com/products/SQL_Data_Compare/)的产品，它在两个数据库之间比较并同步数据，但它是不同于 SQL 比较的一种产品，另一种是 $395。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-244">Red Gate Software does offer a product named [*SQL Data Compare*](http://www.red-gate.com/products/SQL_Data_Compare/) that compares and synchronizes the data between two databases, but it is a separate product from SQL Compare and costs another $395.</span></span>

## <a name="taking-the-application-offline-during-deployment"></a><span data-ttu-id="0c5a0-245">在部署过程中使应用程序脱机</span><span class="sxs-lookup"><span data-stu-id="0c5a0-245">Taking the Application Offline During Deployment</span></span>

<span data-ttu-id="0c5a0-246">正如我们在这些教程中所见到的，部署是涉及多个步骤的过程：将 ASP.NET 页面、母版页、CSS 文件、JavaScript 文件、图像和其他必要的内容从开发环境复制到生产环境环境如果需要，复制特定于生产环境的配置信息;并将更改应用到自上一次部署以来的数据模型。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-246">As we ve seen throughout these tutorials, deployment is a process that involves multiple steps: copying the ASP.NET pages, master pages, CSS files, JavaScript files, images, and other necessary content from the development environment to the production environment; copying up the production environment-specific configuration information, if needed; and applying the changes to the data model since the last deployment.</span></span> <span data-ttu-id="0c5a0-247">根据文件的数量和数据库的复杂性，可能需要几秒钟到几分钟的时间才能完成这些步骤。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-247">Depending on the number of files and the complexity of your database changes, these steps can take anywhere from a few seconds to several minutes to complete.</span></span> <span data-ttu-id="0c5a0-248">在此窗口中，web 应用程序位于 flux 中，访问站点的用户可能会遇到错误或意外行为。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-248">During this window the web application is in flux and users visiting the site may experience errors or unexpected behavior.</span></span>

<span data-ttu-id="0c5a0-249">部署网站时，最好是在部署完成之前使 web 应用程序 "脱机"。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-249">When deploying a website it is best to take the web application "offline" until deployment has completed.</span></span> <span data-ttu-id="0c5a0-250">使应用程序脱机（并在部署过程完成后进行备份）非常简单，只需上传文件，然后将其删除即可。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-250">Taking the application offline (and bringing it back up once the deployment process has finished) is as easy as uploading a file and then deleting it.</span></span> <span data-ttu-id="0c5a0-251">从 ASP.NET 2.0 开始，应用程序根目录中的一个名为 `app_offline.htm` 的文件在整个网站中 "脱机"。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-251">Starting with ASP.NET 2.0, the mere presence of a file named `app_offline.htm` in the application s root directory takes the entire website "offline."</span></span> <span data-ttu-id="0c5a0-252">对该站点上的 ASP.NET 页面的任何请求都将自动使用 `app_offline.htm` 文件的内容进行响应。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-252">Any request to an ASP.NET page on that site is automatically responded with the contents of the `app_offline.htm` file.</span></span> <span data-ttu-id="0c5a0-253">删除该文件后，应用程序将重新联机。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-253">Once that file is removed, the application comes back online.</span></span>

<span data-ttu-id="0c5a0-254">在部署过程中使应用程序脱机，就像在开始部署过程之前将 `app_offline.htm` 文件上传到生产环境的根目录一样简单，然后在部署完成后将其删除（或将其重命名为其他内容）。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-254">Taking an application offline during deployment, then, is as simple as uploading an `app_offline.htm` file to the production environment s root directory prior to beginning the deployment process and then deleting it (or renaming it to something else) once deployment is complete.</span></span> <span data-ttu-id="0c5a0-255">有关此技术的详细信息，请参阅 John Peterson 一文，使[*ASP.NET 应用程序脱机*](http://www.15seconds.com/issue/061207.htm)。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-255">For more information on this technique refer to John Peterson s article, Taking an [*ASP.NET Application Offline*](http://www.15seconds.com/issue/061207.htm).</span></span>

## <a name="summary"></a><span data-ttu-id="0c5a0-256">摘要</span><span class="sxs-lookup"><span data-stu-id="0c5a0-256">Summary</span></span>

<span data-ttu-id="0c5a0-257">在部署数据库时部署数据驱动的应用程序中心的主要挑战。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-257">The main challenge in deploying a data-driven application centers around deploying the database.</span></span> <span data-ttu-id="0c5a0-258">因为有两个版本的数据库-一个在开发环境中，另一个在生产环境中，因此在开发中添加新功能后，这两个数据库架构可能会变得不同步。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-258">Because there are two versions of the database - one in the development environment and one in the production environment - these two databases schemas can become out of sync as new features are added in development.</span></span> <span data-ttu-id="0c5a0-259">更多是，因为生产数据库是用真实用户的实际数据填充的，所以你不能用修改后的开发数据库覆盖生产数据库，就像部署构成应用程序的文件（ASP.NET 页）时，图像文件等。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-259">What s more, because the production database as being populated with real data from real users, you cannot overwrite the production database with the modified development database like you can when deploying the files that make up the application (the ASP.NET pages, image files, and so forth).</span></span> <span data-ttu-id="0c5a0-260">相反，部署数据库需要实现自上次部署以来对生产数据库中的开发数据库所做的一系列更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-260">Instead, deploying a database entails implementing the precise set of changes made to the development database on the production database since the last deployment.</span></span>

<span data-ttu-id="0c5a0-261">本教程介绍了用于维护和应用数据库更改日志的三种方法。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-261">This tutorial looked at three techniques for maintaining and applying a log of database changes.</span></span> <span data-ttu-id="0c5a0-262">最简单的方法是在 prose 中记录更改。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-262">The simplest approach is to record the changes in prose.</span></span> <span data-ttu-id="0c5a0-263">虽然这种策略使得在生产数据库上实现这些更改是一个手动过程，但它不需要了解用于创建和更改数据库对象的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-263">While this tactic makes implementing these changes on the production database a manual process, it does not require knowledge of the SQL commands for creating and altering database objects.</span></span> <span data-ttu-id="0c5a0-264">更复杂的方法，以及在具有多个开发人员的大型项目或项目中更愉快的方法，是将更改记录为一系列 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-264">A more sophisticated approach, and one that is much more palatable in larger projects or projects with multiple developers, is to record the changes as a series of SQL commands.</span></span> <span data-ttu-id="0c5a0-265">这极大地 hastens 将这些更改部署到目标数据库。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-265">This greatly hastens rolling out these changes to the target database.</span></span> <span data-ttu-id="0c5a0-266">这两种方法的最佳方法都可以通过使用数据库比较工具来实现，例如，Red 关口 Software SQL 比较。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-266">The best of both approaches can be achieved by using a database comparison tool, such as Red Gate Software s SQL Compare.</span></span>

<span data-ttu-id="0c5a0-267">本教程将重点介绍如何部署数据驱动的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-267">This tutorial concludes our focus on deploying a data-driven application.</span></span> <span data-ttu-id="0c5a0-268">下一组教程介绍了如何在生产环境中响应错误。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-268">The next set of tutorials looks at how to respond to errors in the production environment.</span></span> <span data-ttu-id="0c5a0-269">我们将介绍如何显示友好错误页面，而不显示死亡的黄屏。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-269">We'll look at how to display a friendly error page rather instead of the Yellow Screen of Death.</span></span> <span data-ttu-id="0c5a0-270">我们将了解如何记录错误的详细信息以及如何在发生此类错误时发出警报。</span><span class="sxs-lookup"><span data-stu-id="0c5a0-270">And we'll see how to log the error s details and how to alert you when such errors occur.</span></span>

<span data-ttu-id="0c5a0-271">很高兴编程！</span><span class="sxs-lookup"><span data-stu-id="0c5a0-271">Happy Programming!</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0c5a0-272">[上一页](configuring-a-website-that-uses-application-services-cs.md)
> [下一页](displaying-a-custom-error-page-cs.md)</span><span class="sxs-lookup"><span data-stu-id="0c5a0-272">[Previous](configuring-a-website-that-uses-application-services-cs.md)
[Next](displaying-a-custom-error-page-cs.md)</span></span>

---
uid: aspnet/overview/owin-and-katana/an-overview-of-project-katana
title: 项目 Katana 概述 |Microsoft Docs
author: howarddierking
description: ASP.NET 框架已超过10年，平台已经实现了无数个网站和服务的开发。 作为 Web 应用程序 。
ms.author: riande
ms.date: 08/30/2013
ms.assetid: 0ee21741-c1bf-4025-a9b0-24580cae24bc
msc.legacyurl: /aspnet/overview/owin-and-katana/an-overview-of-project-katana
msc.type: authoredcontent
ms.openlocfilehash: 1f28db822930cdfd2ebf4cf9bb27d173f4aa4201
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78500342"
---
# <a name="an-overview-of-project-katana"></a><span data-ttu-id="5ab4d-104">项目 Katana 概述</span><span class="sxs-lookup"><span data-stu-id="5ab4d-104">An Overview of Project Katana</span></span>

<span data-ttu-id="5ab4d-105">作者： [Howard Dierking](https://github.com/howarddierking)</span><span class="sxs-lookup"><span data-stu-id="5ab4d-105">by [Howard Dierking](https://github.com/howarddierking)</span></span>

> <span data-ttu-id="5ab4d-106">ASP.NET 框架已超过10年，平台已经实现了无数个网站和服务的开发。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-106">The ASP.NET Framework has been around for over ten years, and the platform has enabled the development of countless Web sites and services.</span></span> <span data-ttu-id="5ab4d-107">随着 Web 应用程序开发策略的发展，框架能够在 ASP.NET MVC 和 ASP.NET Web API 等技术中逐步发展。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-107">As Web application development strategies have evolved, the framework has been able to evolve in step with technologies like ASP.NET MVC and ASP.NET Web API.</span></span> <span data-ttu-id="5ab4d-108">由于 Web 应用程序开发将其下一个发展步骤带入云计算领域，project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)提供了 ASP.NET 应用程序的基础组件集，使应用程序能够灵活、可移植、轻便并提供更好的性能–另外一种方法是，project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud 优化 ASP.NET 应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-108">As Web application development takes its next evolutionary step into the world of cloud computing, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) provides the underlying set of components to ASP.NET applications, enabling them to be flexible, portable, lightweight, and provide better performance – put another way, project [Katana](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET) cloud optimizes your ASP.NET applications.</span></span>

## <a name="why-katana--why-now"></a><span data-ttu-id="5ab4d-109">为什么 Katana –为什么要这样做呢？</span><span class="sxs-lookup"><span data-stu-id="5ab4d-109">Why Katana – Why Now?</span></span>

 <span data-ttu-id="5ab4d-110">无论是讨论开发人员框架还是最终用户产品，都必须了解用于创建产品的基础动机，这一点很重要，其中包括了解产品的创建者。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-110">Regardless whether one is discussing a developer framework or end-user product, it's important to understand the underlying motivations for creating the product – and part of that includes knowing who the product was created for.</span></span> <span data-ttu-id="5ab4d-111">ASP.NET 最初是在两个客户中创建的。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-111">ASP.NET was originally created with two customers in mind.</span></span>   
  
<span data-ttu-id="5ab4d-112">**第一组客户是经典 ASP 开发人员。**</span><span class="sxs-lookup"><span data-stu-id="5ab4d-112">**The first group of customers was classic ASP developers.**</span></span> <span data-ttu-id="5ab4d-113">目前，ASP 是通过 interweaving 标记和服务器端脚本创建动态、数据驱动的网站和应用程序的一项主要技术。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-113">At the time, ASP was one of the primary technologies for creating dynamic, data-driven Web sites and applications by interweaving markup and server-side script.</span></span> <span data-ttu-id="5ab4d-114">ASP 运行时为服务器端脚本提供了一组对象，这些对象抽象了基础 HTTP 协议和 Web 服务器的核心方面，并提供了对其他服务（如会话和应用程序状态管理、缓存等）的访问权限。虽然功能强大、经典的 ASP 应用程序在不断增长的同时也是一项挑战。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-114">The ASP runtime supplied server-side script with a set of objects that abstracted core aspects of the underlying HTTP protocol and Web server and provided access to additional services such session and application state management, cache, etc. While powerful, classic ASP applications became a challenge to manage as they grew in size and complexity.</span></span> <span data-ttu-id="5ab4d-115">这在很大程度上是因为在脚本环境中找不到与代码和标记交错产生的代码重复的结构。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-115">This was largely due to the lack of structure found in scripting environments coupled with the duplication of code resulting from the interleaving of code and markup.</span></span> <span data-ttu-id="5ab4d-116">为了充分利用经典 ASP 的优势，同时应对其中一些挑战，ASP.NET 充分利用了由 .NET Framework 面向对象的语言提供的代码组织，同时还保留了服务器端编程模型经典 ASP 开发人员熟悉的。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-116">In order to capitalize on the strengths of classic ASP while addressing some of its challenges, ASP.NET took advantage of the code organization provided by the object-oriented languages of the .NET Framework while also preserving the server-side programming model to which classic ASP developers had grown accustomed.</span></span>

<span data-ttu-id="5ab4d-117">**ASP.NET 的第二组目标客户是 Windows 业务应用程序开发人员。**</span><span class="sxs-lookup"><span data-stu-id="5ab4d-117">**The second group of target customers for ASP.NET was Windows business application developers.**</span></span> <span data-ttu-id="5ab4d-118">与经典 ASP 开发人员一样，熟悉编写 HTML 标记和代码以生成更多 HTML 标记，WinForms 开发人员（如他们之前的 VB6 开发人员）熟悉了包含画布和丰富用户集的设计时体验。接口控件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-118">Unlike classic ASP developers, who were accustomed to writing HTML markup and the code to generate more HTML markup, WinForms developers (like the VB6 developers before them) were accustomed to a design time experience that included a canvas and a rich set of user interface controls.</span></span> <span data-ttu-id="5ab4d-119">第一个版本的 ASP.NET （也称为 "Web 窗体"）提供了类似的设计时体验，同时提供了用户界面组件的服务器端事件模型和一组基础结构功能（如 ViewState）来创建无缝的开发人员体验在客户端和服务器端编程之间。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-119">The first version of ASP.NET – also known as "Web Forms" provided a similar design time experience along with a server-side event model for user interface components and a set of infrastructure features (such as ViewState) to create a seamless developer experience between client and server side programming.</span></span> <span data-ttu-id="5ab4d-120">Web 窗体在 WinForms 开发人员熟悉的有状态事件模型下有效地隐藏了 Web 的无状态特性。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-120">Web Forms effectively hid the Web's stateless nature under a stateful event model that was familiar to WinForms developers.</span></span>

### <a name="challenges-raised-by-the-historical-model"></a><span data-ttu-id="5ab4d-121">历史模型引发的质询</span><span class="sxs-lookup"><span data-stu-id="5ab4d-121">Challenges Raised by the Historical Model</span></span>

<span data-ttu-id="5ab4d-122">**最终结果是一个功能丰富、功能丰富的运行时和开发人员编程模型。**</span><span class="sxs-lookup"><span data-stu-id="5ab4d-122">**The net result was a mature, feature-rich runtime and developer programming model.**</span></span> <span data-ttu-id="5ab4d-123">但是，使用该功能，有几个值得注意的问题。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-123">However, with that feature-richness came a couple notable challenges.</span></span> <span data-ttu-id="5ab4d-124">首先，该框架是**单一**的，它具有逻辑上不同的功能单元，它们在同一个 system.web 程序集（例如，包含 Web 窗体框架的核心 HTTP 对象）中紧密耦合。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-124">Firstly, the framework was **monolithic**, with logically disparate units of functionality being tightly coupled in the same System.Web.dll assembly (for example, the core HTTP objects with the Web forms framework).</span></span> <span data-ttu-id="5ab4d-125">其次，ASP.NET 是较大 .NET Framework 的一部分，这意味着各**版本之间的时间将按年的顺序进行。**</span><span class="sxs-lookup"><span data-stu-id="5ab4d-125">Secondly, ASP.NET was included as a part of the larger .NET Framework, which meant that the **time between releases was on the order of years.**</span></span> <span data-ttu-id="5ab4d-126">这样，ASP.NET 就难以跟上不断发展的 Web 开发所发生的所有更改。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-126">This made it difficult for ASP.NET to keep pace with all of the changes happening in rapidly evolving Web development.</span></span> <span data-ttu-id="5ab4d-127">最后，使用几种不同方式为特定的 Web 宿主选项耦合了 System.web： Internet Information Services （IIS）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-127">Finally, System.Web.dll itself was coupled in a few different ways to a specific Web hosting option: Internet Information Services (IIS).</span></span>

### <a name="evolutionary-steps-aspnet-mvc-and-aspnet-web-api"></a><span data-ttu-id="5ab4d-128">进化步骤： ASP.NET MVC 和 ASP.NET Web API</span><span class="sxs-lookup"><span data-stu-id="5ab4d-128">Evolutionary steps: ASP.NET MVC and ASP.NET Web API</span></span>

<span data-ttu-id="5ab4d-129">Web 开发中发生了很多更改！</span><span class="sxs-lookup"><span data-stu-id="5ab4d-129">And lots of change was happening in Web development!</span></span> <span data-ttu-id="5ab4d-130">Web 应用程序越来越多地开发成一系列小型、集中的组件，而不是大型框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-130">Web applications were increasingly being developed as a series of small, focused components rather than large frameworks.</span></span> <span data-ttu-id="5ab4d-131">组件数量以及它们的发布频率在不断提高的速度。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-131">The number of components as well as the frequency with which they were released was increasing at an ever faster rate.</span></span> <span data-ttu-id="5ab4d-132">保持 Web 的步调非常明显，需要框架才能获得更小、更分离、更集中而不是更富丰富的功能，因此， **ASP.NET 团队采取了几个发展的步骤，将 ASP.NET 作为可插入 Web 组件系列，而不是单一框架**。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-132">It was clear that keeping pace with the Web would require frameworks to get smaller, decoupled and more focused rather than larger and more feature-rich, therefore the **ASP.NET team took several evolutionary steps to enable ASP.NET as a family of pluggable Web components rather than a single framework**.</span></span>

<span data-ttu-id="5ab4d-133">最早的变化之一是众所周知的模型视图-控制器（MVC）设计模式的普及，这归功于 Web 开发框架，如 Ruby on Rails。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-133">One of the early changes was the rise in popularity of the well-known model-view-controller (MVC) design pattern thanks to Web development frameworks like Ruby on Rails.</span></span> <span data-ttu-id="5ab4d-134">构建 Web 应用程序的这种样式使开发人员可以更好地控制其应用程序的标记，同时仍然保留标记和业务逻辑的分离，这是 ASP.NET 的初始卖点之一。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-134">This style of building Web applications gave the developer greater control over her application's markup while still preserving the separation of markup and business logic, which was one of the initial selling points for ASP.NET.</span></span> <span data-ttu-id="5ab4d-135">为了满足此样式的 Web 应用程序开发的需求，Microsoft 通过**开发 ASP.NET MVC** （而不是将其包含在 .NET Framework 中）来更好地定位自身。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-135">To meet the demand for this style of Web application development, Microsoft took the opportunity to position itself better for the future by **developing ASP.NET MVC out of band** (and not including it in the .NET Framework).</span></span> <span data-ttu-id="5ab4d-136">ASP.NET MVC 作为独立下载发布。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-136">ASP.NET MVC was released as an independent download.</span></span> <span data-ttu-id="5ab4d-137">这使工程团队能够比以前可能更频繁地交付更新。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-137">This gave the engineering team the flexibility to deliver updates much more frequently than had been previously possible.</span></span>

<span data-ttu-id="5ab4d-138">Web 应用程序开发的另一个主要转变是从动态的服务器生成的网页过渡到静态初始标记，并在客户端脚本中生成的页面的动态部分**通过 AJAX 请求与后端 Web api**进行通信。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-138">Another major shift in Web application development was the shift from dynamic, server-generated Web pages to static initial markup with dynamic sections of the page generated from client-side script communicating **with backend Web APIs through AJAX requests**.</span></span> <span data-ttu-id="5ab4d-139">这种体系结构转换有助于 propel Web Api 的发展和开发 ASP.NET Web API 框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-139">This architectural shift helped propel the rise of Web APIs, and the development of the ASP.NET Web API framework.</span></span> <span data-ttu-id="5ab4d-140">就 ASP.NET MVC 而言，ASP.NET Web API 的版本提供了另一种机会进一步发展 ASP.NET，作为一个更具模块化的框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-140">As in the case of ASP.NET MVC, the release of ASP.NET Web API provided another opportunity to evolve ASP.NET further as a more modular framework.</span></span> <span data-ttu-id="5ab4d-141">工程团队利用机会和**生成的 ASP.NET Web API，使其不依赖于 system.web 中的任何一种核心框架类型**。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-141">The engineering team took advantage of the opportunity and **built ASP.NET Web API such that it had no dependencies on any of the core framework types found in System.Web.dll**.</span></span> <span data-ttu-id="5ab4d-142">这两个方面已经实现了：首先，它意味着 ASP.NET Web API 可以完全独立地进行发展（并且它可以继续快速循环，因为它是通过 NuGet 提供的）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-142">This enabled two things: first, it meant that ASP.NET Web API could evolve in a completely self-contained manner (and it could continue to iterate quickly because it is delivered via NuGet).</span></span> <span data-ttu-id="5ab4d-143">其次，由于不存在对 System.web 的外部依赖关系，因此没有 IIS 的依赖项，ASP.NET Web API 包括在自定义主机（例如，控制台应用程序、Windows 服务等）中运行的功能。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-143">Second, because there were no external dependencies to System.Web.dll, and therefore, no dependencies to IIS, ASP.NET Web API included the capability to run in a custom host (for example, a console application, Windows service, etc.)</span></span>

### <a name="the-future-a-nimble-framework"></a><span data-ttu-id="5ab4d-144">未来：灵活框架</span><span class="sxs-lookup"><span data-stu-id="5ab4d-144">The Future: A Nimble Framework</span></span>

<span data-ttu-id="5ab4d-145">通过将框架组件彼此分离，然后在 NuGet 上发布它们，框架现在可以**更快速地循环访问**。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-145">By decoupling framework components from one another and then releasing them on NuGet, frameworks could now **iterate more independently and more quickly**.</span></span> <span data-ttu-id="5ab4d-146">此外，对于需要**小型轻型主机**作为其服务的开发人员，Web API 的自承载功能的强大功能和灵活性也非常吸引人。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-146">Additionally, the power and flexibility of Web API's self-hosting capability proved very attractive to developers who wanted a **small, lightweight host** for their services.</span></span> <span data-ttu-id="5ab4d-147">事实上，这是一个很好的方法，实际上，其他框架也需要此功能，而这种新的挑战是，每个框架都在其自己的主机进程中运行，并且需要独立管理（启动、停止等）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-147">It proved so attractive, in fact, that other frameworks also wanted this capability, and this surfaced a new challenge in that each framework ran in its own host process on its own base address and needed to be managed (started, stopped, etc.) independently.</span></span> <span data-ttu-id="5ab4d-148">新式 Web 应用程序通常支持静态文件服务、动态页面生成、Web API 以及最近的实时/推送通知。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-148">A modern Web application generally supports static file serving, dynamic page generation, Web API, and more recently real-time/push notifications.</span></span> <span data-ttu-id="5ab4d-149">应该单独运行和管理其中每个服务的情况并不是真实的。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-149">Expecting that each of these services should be run and managed independently was simply not realistic.</span></span>

<span data-ttu-id="5ab4d-150">需要的是单一托管抽象，使开发人员能够从各种不同的组件和框架中编写应用程序，然后在支持的主机上运行该应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-150">What was needed was a single hosting abstraction that would enable a developer to compose an application from a variety of different components and frameworks, and then run that application on a supporting host.</span></span>

## <a name="the-open-web-interface-for-net-owin"></a><span data-ttu-id="5ab4d-151">.NET 的开放 Web 接口（OWIN）</span><span class="sxs-lookup"><span data-stu-id="5ab4d-151">The Open Web Interface for .NET (OWIN)</span></span>

 <span data-ttu-id="5ab4d-152">通过 Ruby 社区中的[货架](http://rack.github.io/)实现的优点，.net 社区的若干成员设置为在 Web 服务器和框架组件之间创建抽象。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-152">Inspired by the benefits achieved by [Rack](http://rack.github.io/) in the Ruby community, several members of the .NET community set out to create an abstraction between Web servers and framework components.</span></span> <span data-ttu-id="5ab4d-153">OWIN 抽象的两个设计目标是非常简单，并且可能会在其他框架类型上占用最少的依赖项。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-153">Two design goals for the OWIN abstraction were that it was simple and that it took the fewest possible dependencies on other framework types.</span></span> <span data-ttu-id="5ab4d-154">这两个目标有助于确保：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-154">These two goals help ensure:</span></span>

- <span data-ttu-id="5ab4d-155">可以更轻松地开发和使用新组件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-155">New components could be more easily developed and consumed.</span></span>
- <span data-ttu-id="5ab4d-156">应用程序可以更轻松地在主机和可能的整个平台/操作系统之间移植。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-156">Applications could be more easily ported between hosts and potentially entire platforms/operating systems.</span></span>

<span data-ttu-id="5ab4d-157">生成的抽象包括两个核心元素。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-157">The resulting abstraction consists of two core elements.</span></span> <span data-ttu-id="5ab4d-158">第一个是环境字典。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-158">The first is the environment dictionary.</span></span> <span data-ttu-id="5ab4d-159">此数据结构负责存储处理 HTTP 请求和响应所需的所有状态以及任何相关的服务器状态。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-159">This data structure is responsible for storing all of the state necessary for processing an HTTP request and response, as well as any relevant server state.</span></span> <span data-ttu-id="5ab4d-160">环境字典定义如下：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-160">The environment dictionary is defined as follows:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample1.cmd)]

<span data-ttu-id="5ab4d-161">与 OWIN 兼容的 Web 服务器负责使用数据（如 HTTP 请求和响应的正文流和标头集合）填充环境字典。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-161">An OWIN-compatible Web server is responsible for populating the environment dictionary with data such as the body streams and header collections for an HTTP request and response.</span></span> <span data-ttu-id="5ab4d-162">然后，应用程序或框架组件负责用其他值填充或更新字典，并写入响应正文流。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-162">It is then the responsibility of the application or framework components to populate or update the dictionary with additional values and write to the response body stream.</span></span>

<span data-ttu-id="5ab4d-163">除了指定环境字典的类型外，OWIN 规范还定义了一系列核心字典键值对。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-163">In addition to specifying the type for the environment dictionary, the OWIN specification defines a list of core dictionary key value pairs.</span></span> <span data-ttu-id="5ab4d-164">例如，下表显示了 HTTP 请求所需的字典密钥：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-164">For example, the following table shows the required dictionary keys for an HTTP request:</span></span>

| <span data-ttu-id="5ab4d-165">键名</span><span class="sxs-lookup"><span data-stu-id="5ab4d-165">Key Name</span></span> | <span data-ttu-id="5ab4d-166">值说明</span><span class="sxs-lookup"><span data-stu-id="5ab4d-166">Value Description</span></span> |
| --- | --- |
| `"owin.RequestBody"` | <span data-ttu-id="5ab4d-167">包含请求正文的流（如果有）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-167">A Stream with the request body, if any.</span></span> <span data-ttu-id="5ab4d-168">如果没有请求正文，则 Null 可用作占位符。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-168">Stream.Null MAY be used as a placeholder if there is no request body.</span></span> <span data-ttu-id="5ab4d-169">请参阅[请求正文](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-169">See [Request Body](http://owin.org/html/owin.html#34-request-body-100-continue-and-completed-semantics).</span></span> |
| `"owin.RequestHeaders"` | <span data-ttu-id="5ab4d-170">请求标头的 `IDictionary<string, string[]>`。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-170">An `IDictionary<string, string[]>` of request headers.</span></span> <span data-ttu-id="5ab4d-171">请参阅[标头](http://owin.org/html/owin.html#3-3-headers)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-171">See [Headers](http://owin.org/html/owin.html#3-3-headers).</span></span> |
| `"owin.RequestMethod"` | <span data-ttu-id="5ab4d-172">包含请求的 HTTP 请求方法的 `string` （例如，`"GET"`、`"POST"`）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-172">A `string` containing the HTTP request method of the request (e.g., `"GET"`, `"POST"`).</span></span> |
| `"owin.RequestPath"` | <span data-ttu-id="5ab4d-173">包含请求路径的 `string`。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-173">A `string` containing the request path.</span></span> <span data-ttu-id="5ab4d-174">路径必须相对于应用程序委托的 "根";请参阅[路径](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-174">The path MUST be relative to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestPathBase"` | <span data-ttu-id="5ab4d-175">一个 `string`，其中包含与应用程序委托的 "根" 对应的请求路径部分;请参阅[路径](http://owin.org/html/owin.html#5-3-paths)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-175">A `string` containing the portion of the request path corresponding to the "root" of the application delegate; see [Paths](http://owin.org/html/owin.html#5-3-paths).</span></span> |
| `"owin.RequestProtocol"` | <span data-ttu-id="5ab4d-176">包含协议名称和版本的 `string` （例如 `"HTTP/1.0"` 或 `"HTTP/1.1"`）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-176">A `string` containing the protocol name and version (e.g. `"HTTP/1.0"` or `"HTTP/1.1"`).</span></span> |
| `"owin.RequestQueryString"` | <span data-ttu-id="5ab4d-177">包含 HTTP 请求 URI 的查询字符串组件的 `string`，没有前导 "？"（例如 `"foo=bar&baz=quux"`）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-177">A `string` containing the query string component of the HTTP request URI, without the leading "?" (e.g., `"foo=bar&baz=quux"`).</span></span> <span data-ttu-id="5ab4d-178">该值可以是空字符串。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-178">The value may be an empty string.</span></span> |
| `"owin.RequestScheme"` | <span data-ttu-id="5ab4d-179">包含用于请求的 URI 方案的 `string` （例如，`"http"`、`"https"`）;请参阅[URI 方案](http://owin.org/html/owin.html#5-1-uri-scheme)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-179">A `string` containing the URI scheme used for the request (e.g., `"http"`, `"https"`); see [URI Scheme](http://owin.org/html/owin.html#5-1-uri-scheme).</span></span> |

<span data-ttu-id="5ab4d-180">OWIN 的第二个关键元素是应用程序委托。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-180">The second key element of OWIN is the application delegate.</span></span> <span data-ttu-id="5ab4d-181">这是一个函数签名，用作 OWIN 应用程序中所有组件之间的主接口。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-181">This is a function signature which serves as the primary interface between all components in an OWIN application.</span></span> <span data-ttu-id="5ab4d-182">应用程序委托的定义如下所示：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-182">The definition for the application delegate is as follows:</span></span>

`Func<IDictionary<string, object>, Task>;`

<span data-ttu-id="5ab4d-183">然后，应用程序委托只是 Func 委托类型的实现，其中函数接受环境字典作为输入并返回一个任务。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-183">The application delegate then is simply an implementation of the Func delegate type where the function accepts the environment dictionary as input and returns a Task.</span></span> <span data-ttu-id="5ab4d-184">对于开发人员而言，此设计具有多个含义：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-184">This design has several implications for developers:</span></span>

- <span data-ttu-id="5ab4d-185">编写 OWIN 组件需要的类型依赖项非常少。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-185">There are a very small number of type dependencies required in order to write OWIN components.</span></span> <span data-ttu-id="5ab4d-186">这极大地提高了开发人员 OWIN 的可访问性。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-186">This greatly increases the accessibility of OWIN to developers.</span></span>
- <span data-ttu-id="5ab4d-187">异步设计使抽象能够通过其处理计算资源来高效，尤其是在更多的 i/o 密集型操作中。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-187">The asynchronous design enables the abstraction to be efficient with its handling of computing resources, particularly in more I/O intensive operations.</span></span>
- <span data-ttu-id="5ab4d-188">由于应用程序委托是执行的原子单元，并且环境字典作为委托的参数来执行，因此，OWIN 组件可以轻松地链接在一起以创建复杂的 HTTP 处理管道。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-188">Because the application delegate is an atomic unit of execution and because the environment dictionary is carried as a parameter on the delegate, OWIN components can be easily chained together to create complex HTTP processing pipelines.</span></span>

<span data-ttu-id="5ab4d-189">从实现的角度来看，OWIN 是规范（[http://owin.org/html/owin.html](http://owin.org/html/owin.html)）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-189">From an implementation perspective, OWIN is a specification ([http://owin.org/html/owin.html](http://owin.org/html/owin.html)).</span></span> <span data-ttu-id="5ab4d-190">它的目标不是下一 Web 框架，而是有关 Web 框架和 Web 服务器如何交互的规范。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-190">Its goal is not to be the next Web framework, but rather a specification for how Web frameworks and Web servers interact.</span></span>

<span data-ttu-id="5ab4d-191">如果已调查[OWIN](http://owin.org/)或[Katana](https://github.com/aspnet/AspNetKatana/wiki)，还可能注意到[OWIN NuGet 包](http://nuget.org/packages/Owin)和 OWIN。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-191">If you've investigated [OWIN](http://owin.org/) or [Katana](https://github.com/aspnet/AspNetKatana/wiki), you may also have noticed the [Owin NuGet package](http://nuget.org/packages/Owin) and Owin.dll.</span></span> <span data-ttu-id="5ab4d-192">此库包含单个 interface [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)，它可将整理的启动序列作为 OWIN 规范第[4 节](http://owin.org/html/owin.html#4-application-startup)中所述的启动顺序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-192">This library contains a single interface, [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs), which formalizes and codifies the startup sequence described in [section 4](http://owin.org/html/owin.html#4-application-startup) of the OWIN specification.</span></span> <span data-ttu-id="5ab4d-193">尽管不需要生成 OWIN 服务器，但[IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs)接口提供了一个具体的参考点，并且由 Katana 项目组件使用。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-193">While not required in order to build OWIN servers, the [IAppBuilder](https://github.com/owin/owin/blob/master/src/Owin/IAppBuilder.cs) interface provides a concrete reference point, and it is used by the Katana project components.</span></span>

## <a name="project-katana"></a><span data-ttu-id="5ab4d-194">项目 Katana</span><span class="sxs-lookup"><span data-stu-id="5ab4d-194">Project Katana</span></span>

<span data-ttu-id="5ab4d-195">尽管[OWIN](http://owin.org/html/owin.html)规范和*OWIN*都是社区拥有的，并且社区运行开源工作，但[Katana](https://github.com/aspnet/AspNetKatana/wiki)项目表示由 Microsoft 构建和发布的一组 OWIN 组件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-195">Whereas both the [OWIN](http://owin.org/html/owin.html) specification and *Owin.dll* are community owned and community run open source efforts, the [Katana](https://github.com/aspnet/AspNetKatana/wiki) project represents the set of OWIN components that, while still open source, are built and released by Microsoft.</span></span> <span data-ttu-id="5ab4d-196">这些组件包括基础结构组件（例如主机和服务器）以及功能组件（例如身份验证组件）以及到框架（如[SignalR](../../../signalr/index.md)和[ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md)）的绑定。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-196">These components include both infrastructure components, such as hosts and servers, as well as functional components, such as authentication components and bindings to frameworks such as [SignalR](../../../signalr/index.md) and [ASP.NET Web API](../../../web-api/overview/getting-started-with-aspnet-web-api/index.md).</span></span> <span data-ttu-id="5ab4d-197">项目具有以下三个高级别目标：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-197">The project has the following three high level goals:</span></span> 

- <span data-ttu-id="5ab4d-198">**可移植**–当新组件可用时，组件应该能够轻松地替代它们。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-198">**Portable** – Components should be able to be easily substituted for new components as they become available.</span></span> <span data-ttu-id="5ab4d-199">这包括从框架到服务器和主机的所有类型的组件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-199">This includes all types of components, from the framework to the server and host.</span></span> <span data-ttu-id="5ab4d-200">此目标的含义是，第三方框架可以在 Microsoft 服务器上无缝运行，而 Microsoft framework 可能在第三方服务器和主机上运行。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-200">The implication of this goal is that third party frameworks can seamlessly run on Microsoft servers while Microsoft frameworks can potentially run on third party servers and hosts.</span></span>
- <span data-ttu-id="5ab4d-201">**模块化/灵活**–不同于许多框架，其中包括默认情况下打开的多种功能，Katana 项目组件应很小且具有针对性，并使应用程序开发人员能够控制应用程序中要使用的组件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-201">**Modular/flexible**– Unlike many frameworks which include a myriad of features that are turned on by default, Katana project components should be small and focused, giving control over to the application developer in determining which components to use in her application.</span></span>
- <span data-ttu-id="5ab4d-202">**轻型/高性能/可缩放**性-通过将框架的传统概念分解为一组由应用程序开发人员显式添加的小型、集中的组件，生成的 Katana 应用程序可以消耗更少的计算资源，因此可以处理更多的负载，而不是使用其他类型的服务器和框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-202">**Lightweight/performant/scalable** – By breaking the traditional notion of a framework into a set of small, focused components which are added explicitly by the application developer, a resulting Katana application can consume fewer computing resources, and as a result, handle more load, than with other types of servers and frameworks.</span></span> <span data-ttu-id="5ab4d-203">由于应用程序的要求需要底层基础结构中的更多功能，因此可以将这些功能添加到 OWIN 管道，但这应该是应用程序开发人员的一个明确决定。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-203">As the requirements of the application demand more features from the underlying infrastructure, those can be added to the OWIN pipeline, but that should be an explicit decision on the part of the application developer.</span></span> <span data-ttu-id="5ab4d-204">此外，可代替性的较低级别的组件意味着，当它们可用时，可以无缝引入新的高性能服务器来提高 OWIN 应用程序的性能，而无需中断这些应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-204">Additionally, the substitutability of lower level components means that as they become available, new high performance servers can seamlessly be introduced to improve the performance of OWIN applications without breaking those applications.</span></span>

## <a name="getting-started-with-katana-components"></a><span data-ttu-id="5ab4d-205">入门 Katana 组件</span><span class="sxs-lookup"><span data-stu-id="5ab4d-205">Getting Started with Katana Components</span></span>

<span data-ttu-id="5ab4d-206">首次引入时， [node.js](http://nodejs.org/)框架的一个方面是立即吸引人们的注意力，这就是一种简单的方法，即可以创作和运行 Web 服务器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-206">When it was first introduced, one aspect of the [Node.js](http://nodejs.org/) framework that immediately drew people's attention was the simplicity with which one could author and run a Web server.</span></span> <span data-ttu-id="5ab4d-207">如果 Katana 目标[以 node.js 为形式显示，则](http://nodejs.org/)可以通过指出 Katana 带来了 node.js （及其类似框架[）的许多](http://nodejs.org/)好处，而不会强制开发人员提供有关开发 ASP.NET Web 应用程序的所有内容。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-207">If Katana goals were framed in light of [Node.js](http://nodejs.org/), one might summarize them by saying that Katana brings many of the benefits of [Node.js](http://nodejs.org/) (and frameworks like it) without forcing the developer to throw out everything she knows about developing ASP.NET Web applications.</span></span> <span data-ttu-id="5ab4d-208">若要使此语句保持为 true，Katana 项目的入门在本质上[与 node.js 一样简单。](http://nodejs.org/)</span><span class="sxs-lookup"><span data-stu-id="5ab4d-208">For this statement to hold true, getting started with the Katana project should be equally simple in nature to [Node.js](http://nodejs.org/).</span></span>

## <a name="creating-hello-world"></a><span data-ttu-id="5ab4d-209">正在创建 "Hello World！"</span><span class="sxs-lookup"><span data-stu-id="5ab4d-209">Creating "Hello World!"</span></span>

<span data-ttu-id="5ab4d-210">JavaScript 和 .NET 开发的一个明显的区别在于编译器的存在（或不存在）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-210">One notable difference between JavaScript and .NET development is the presence (or absence) of a compiler.</span></span> <span data-ttu-id="5ab4d-211">因此，简单的 Katana 服务器的起点是 Visual Studio 项目。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-211">As such, the starting point for a simple Katana server is a Visual Studio project.</span></span> <span data-ttu-id="5ab4d-212">但是，我们可以从最小的项目类型开始：空的 ASP.NET Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-212">However, we can start with the most minimal of project types: the Empty ASP.NET Web Application.</span></span>

[![](an-overview-of-project-katana/_static/image1.png)](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)

<span data-ttu-id="5ab4d-213">接下来，我们将在项目中安装[Owin](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-213">Next, we will install the [Microsoft.Owin.Host.SystemWeb](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) NuGet package into the project.</span></span> <span data-ttu-id="5ab4d-214">此包提供在 ASP.NET 请求管道中运行的 OWIN 服务器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-214">This package provides an OWIN server that runs in the ASP.NET request pipeline.</span></span> <span data-ttu-id="5ab4d-215">它可以在[NuGet 库](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb)中找到，并且可以使用 Visual Studio 包管理器对话框或程序包管理器控制台通过以下命令进行安装：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-215">It can be found on the [NuGet gallery](http://nuget.org/packages/Microsoft.Owin.Host.SystemWeb) and can be installed using either the Visual Studio package manager dialog or the package manager console with the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample2.cmd)]

<span data-ttu-id="5ab4d-216">安装 `Microsoft.Owin.Host.SystemWeb` 包将安装其他一些包作为依赖项。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-216">Installing the `Microsoft.Owin.Host.SystemWeb` package will install a few additional packages as dependencies.</span></span> <span data-ttu-id="5ab4d-217">其中一个依赖项是 `Microsoft.Owin`，这是一个库，提供若干帮助器类型和用于开发 OWIN 应用程序的方法。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-217">One of those dependencies is `Microsoft.Owin`, a library which provides several helper types and methods for developing OWIN applications.</span></span> <span data-ttu-id="5ab4d-218">我们可以使用这些类型快速编写下面的 "hello world" 服务器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-218">We can use those types to quickly write the following "hello world" server.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample3.cs)]

<span data-ttu-id="5ab4d-219">此非常简单的 Web 服务器现在可以使用 Visual Studio 的**F5**命令运行，并提供对调试的完全支持。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-219">This very simple Web server can now be run using Visual Studio's **F5** command and includes full support for debugging.</span></span>

## <a name="switching-hosts"></a><span data-ttu-id="5ab4d-220">切换主机</span><span class="sxs-lookup"><span data-stu-id="5ab4d-220">Switching hosts</span></span>

<span data-ttu-id="5ab4d-221">默认情况下，前面的 "hello world" 示例在 ASP.NET 请求管道中运行，后者在 IIS 上下文中使用 System.web。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-221">By default, the previous "hello world" example runs in the ASP.NET request pipeline, which uses System.Web in the context of IIS.</span></span> <span data-ttu-id="5ab4d-222">这种方法本身可能会带来巨大的价值，因为它使我们能够利用 OWIN 管道的灵活性和可组合性以及 IIS 的总体成熟度。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-222">This can by itself add tremendous value as it enables us to benefit from the flexibility and composability of an OWIN pipeline with the management capabilities and overall maturity of IIS.</span></span> <span data-ttu-id="5ab4d-223">但是，在某些情况下，IIS 提供的权益不是必需的，而需要的则是更小、更轻型的主机。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-223">However, there may be cases where the benefits provided by IIS are not required and the desire is for a smaller, more lightweight host.</span></span> <span data-ttu-id="5ab4d-224">如果要在 IIS 和 system.web 之外运行简单的 Web 服务器，需要执行哪些操作？</span><span class="sxs-lookup"><span data-stu-id="5ab4d-224">What is needed, then, to run our simple Web server outside of IIS and System.Web?</span></span>

<span data-ttu-id="5ab4d-225">为了说明可移植性目标，从 Web 服务器主机移到命令行主机时，只需将新的服务器和主机依赖项添加到项目的输出文件夹，然后启动主机即可。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-225">To illustrate the portability goal, moving from a Web-server host to a command line host requires simply adding the new server and host dependencies to project's output folder and then starting the host.</span></span> <span data-ttu-id="5ab4d-226">在此示例中，我们将在名为 `OwinHost.exe` 的 Katana 主机中托管 Web 服务器，并将使用基于 Katana HttpListener 的服务器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-226">In this example, we'll host our Web server in a Katana host called `OwinHost.exe` and will use the Katana HttpListener-based server.</span></span> <span data-ttu-id="5ab4d-227">与其他 Katana 组件类似，这些组件将使用以下命令从 NuGet 获取：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-227">Similarly to the other Katana components, these will be acquired from NuGet using the following command:</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample4.cmd)]

<span data-ttu-id="5ab4d-228">然后，可以从命令行导航到项目根文件夹，只需运行 `OwinHost.exe` （安装在其各自 NuGet 包的 tools 文件夹中）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-228">From the command line, we can then navigate to the project root folder and simply run the `OwinHost.exe` (which was installed in the tools folder of its respective NuGet package).</span></span> <span data-ttu-id="5ab4d-229">默认情况下，`OwinHost.exe` 配置为查找基于 HttpListener 的服务器，因此不需要其他配置。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-229">By default, `OwinHost.exe` is configured to look for the HttpListener-based server and so no additional configuration is needed.</span></span> <span data-ttu-id="5ab4d-230">在 Web 浏览器中导航到 `http://localhost:5000/` 显示现在通过控制台运行的应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-230">Navigating in a Web browser to `http://localhost:5000/` shows the application now running through the console.</span></span>

![](an-overview-of-project-katana/_static/image2.png)

## <a name="katana-architecture"></a><span data-ttu-id="5ab4d-231">Katana 体系结构</span><span class="sxs-lookup"><span data-stu-id="5ab4d-231">Katana Architecture</span></span>

 <span data-ttu-id="5ab4d-232">Katana 组件体系结构将应用程序划分为四个逻辑层，如下所示：*主机、服务器、中间件*和*应用程序*。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-232">The Katana component architecture divides an application into four logical layers, as depicted below: *host, server, middleware,* and *application*.</span></span> <span data-ttu-id="5ab4d-233">组件体系结构的分解方式是，在许多情况下，可以轻松地替换这些层的实现，而无需重新编译应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-233">The component architecture is factored in such a way that implementations of these layers can be easily substituted, in many cases, without requiring recompilation of the application.</span></span>   

![](an-overview-of-project-katana/_static/image3.png)

## <a name="host"></a><span data-ttu-id="5ab4d-234">Host</span><span class="sxs-lookup"><span data-stu-id="5ab4d-234">Host</span></span>

 <span data-ttu-id="5ab4d-235">主机负责以下操作：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-235">The host is responsible for:</span></span>

- <span data-ttu-id="5ab4d-236">管理基础进程。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-236">Managing the underlying process.</span></span>
- <span data-ttu-id="5ab4d-237">协调导致选择服务器的工作流，并对将处理请求的 OWIN 管道的构造进行处理。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-237">Orchestrating the workflow that results in the selection of a server and the construction of an OWIN pipeline through which requests will be handled.</span></span>

  <span data-ttu-id="5ab4d-238">目前，对于基于 Katana 的应用程序，有3种主要托管选项：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-238">At present, there are 3 primary hosting options for Katana-based applications:</span></span>  
  
<span data-ttu-id="5ab4d-239">**Iis/ASP. .net**：使用标准 HttpModule 和 HttpHandler 类型，OWIN 管道可在 IIS 上作为 ASP.NET 请求流的一部分运行。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-239">**IIS/ASP.NET**: Using the standard HttpModule and HttpHandler types, OWIN pipelines can run on IIS as a part of an ASP.NET request flow.</span></span> <span data-ttu-id="5ab4d-240">ASP.NET 托管支持通过将 SystemWeb NuGet 包安装到 Web 应用程序项目中来启用。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-240">ASP.NET hosting support is enabled by installing the Microsoft.AspNet.Host.SystemWeb NuGet package into a Web application project.</span></span> <span data-ttu-id="5ab4d-241">此外，由于 IIS 既充当主机又充当服务器，因此在此 NuGet 包中 OWIN 服务器/主机的区别是与父的，这意味着，如果使用 SystemWeb 主机，开发人员不能替换备用服务器实现。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-241">Additionally, because IIS acts as both a host and a server, the OWIN server/host distinction is conflated in this NuGet package, meaning that if using the SystemWeb host, a developer cannot substitute an alternate server implementation.</span></span>  
  
<span data-ttu-id="5ab4d-242">**自定义主机**： Katana 组件套件允许开发人员在自己的自定义进程中托管应用程序，无论该应用程序是控制台应用程序、Windows 服务，等等。此功能类似于 Web API 提供的自承载功能。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-242">**Custom Host**: The Katana component suite gives a developer the ability to host applications in her own custom process, whether that is a console application, Windows service, etc. This capability looks similar to the self-host capability provided by Web API.</span></span> <span data-ttu-id="5ab4d-243">下面的示例演示了 Web API 代码的自定义宿主：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-243">The following example shows a custom host of Web API code:</span></span>  

[!code-csharp[Main](an-overview-of-project-katana/samples/sample5.cs)]

<span data-ttu-id="5ab4d-244">Katana 应用程序的自主机设置类似于：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-244">The self-host setup for a Katana application is similar:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample6.cs)]

<span data-ttu-id="5ab4d-245">Web API 和 Katana 自承载示例之间的一个明显区别是，Katana 自托管示例中缺少 Web API 配置代码。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-245">One notable difference between the Web API and Katana self-host examples is that the Web API configuration code is missing from the Katana self-host example.</span></span> <span data-ttu-id="5ab4d-246">为了同时启用可移植性和可组合性，Katana 将启动服务器的代码与配置请求处理管道的代码分开。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-246">In order to enable both portability and composability, Katana separates the code that starts the server from the code that configures the request processing pipeline.</span></span> <span data-ttu-id="5ab4d-247">配置 Web API 的代码，则包含在类启动中，这在 WebApplication 中另外指定为类型参数。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-247">The code that configures Web API, then is contained in the class Startup, which is additionally specified as the type parameter in WebApplication.Start.</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample7.cs)]

<span data-ttu-id="5ab4d-248">本文稍后将更详细地讨论 startup 类。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-248">The startup class will be discussed in greater detail later in the article.</span></span> <span data-ttu-id="5ab4d-249">但是，启动 Katana 自宿主进程所需的代码看起来与您今天在 ASP.NET Web API 自宿主应用程序中使用的代码类似。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-249">However, the code required to start a Katana self-host process looks strikingly similar to the code that you may be using today in ASP.NET Web API self-host applications.</span></span>

<span data-ttu-id="5ab4d-250">**Owinhost.exe**：尽管有些需要编写自定义进程来运行 Katana Web 应用程序，但很多情况下，只需启动一个预生成的可执行文件，就可以启动服务器并运行其应用程序。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-250">**OwinHost.exe**: While some will want to write a custom process to run Katana Web applications, many would prefer to simply launch a pre-built executable that can start a server and run their application.</span></span> <span data-ttu-id="5ab4d-251">对于此方案，Katana 组件套件包括 `OwinHost.exe`。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-251">For this scenario, the Katana component suite includes `OwinHost.exe`.</span></span> <span data-ttu-id="5ab4d-252">从项目的根目录中运行时，此可执行文件将启动服务器（默认情况下使用 HttpListener 服务器），并使用约定来查找和运行用户的启动类。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-252">When run from within a project's root directory, this executable will start a server (it uses the HttpListener server by default) and use conventions to find and run the user's startup class.</span></span> <span data-ttu-id="5ab4d-253">若要进行更精细的控制，可执行文件提供了许多其他命令行参数。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-253">For more granular control, the executable provides a number of additional command line parameters.</span></span>

![](an-overview-of-project-katana/_static/image4.png)

## <a name="server"></a><span data-ttu-id="5ab4d-254">服务器</span><span class="sxs-lookup"><span data-stu-id="5ab4d-254">Server</span></span>

 <span data-ttu-id="5ab4d-255">尽管主机负责启动和维护应用程序在其中运行的进程，但服务器的责任是打开网络套接字，倾听请求，然后通过用户指定的 OWIN 组件的管道发送它们（可能已注意到，此管道是在应用程序开发人员的 Startup 类中指定的。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-255">While the host is responsible for starting and maintaining process within which the application runs, the responsibility of the server is to open a network socket, listen for requests, and send them through the pipeline of OWIN components specified by the user (as you may have already noticed, this pipeline is specified in the application developer's Startup class).</span></span> <span data-ttu-id="5ab4d-256">目前，Katana 项目包含两个服务器实现：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-256">Currently, the Katana project includes two server implementations:</span></span> 

- <span data-ttu-id="5ab4d-257">**Owin**：正如前文所述，IIS 与 ASP.NET 管道共同充当了主机和服务器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-257">**Microsoft.Owin.Host.SystemWeb**: As previously mentioned, IIS in concert with the ASP.NET pipeline acts as both a host and a server.</span></span> <span data-ttu-id="5ab4d-258">因此，在选择此宿主选项时，IIS 都管理宿主级别的问题，例如进程激活和侦听 HTTP 请求。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-258">Therefore, when choosing this hosting option, IIS both manages host-level concerns such as process activation and listens for HTTP requests.</span></span> <span data-ttu-id="5ab4d-259">对于 ASP.NET Web 应用程序，它会将请求发送到 ASP.NET 管道。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-259">For ASP.NET Web applications, it then sends the requests into the ASP.NET pipeline.</span></span> <span data-ttu-id="5ab4d-260">Katana SystemWeb 主机将注册 ASP.NET HttpModule 和 HttpHandler，以便在请求流过 HTTP 管道时截获请求，并通过用户指定的 OWIN 管道发送请求。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-260">The Katana SystemWeb host registers an ASP.NET HttpModule and HttpHandler to intercept requests as they flow through the HTTP pipeline and send them through the user-specified OWIN pipeline.</span></span>
- <span data-ttu-id="5ab4d-261">**Owin HttpListener**：作为其名称，此 Katana 服务器使用 .NET Framework 的 HttpListener 类打开套接字，并将请求发送到开发人员指定的 Owin 管道。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-261">**Microsoft.Owin.Host.HttpListener**: As its name indicates, this Katana server uses the .NET Framework's HttpListener class to open a socket and send requests into a developer-specified OWIN pipeline.</span></span> <span data-ttu-id="5ab4d-262">这当前是 Katana 自承载 API 和 Owinhost.exe 的默认服务器选择。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-262">This is currently the default server selection for both the Katana self-host API and OwinHost.exe.</span></span>

## <a name="middlewareframework"></a><span data-ttu-id="5ab4d-263">中间件/框架</span><span class="sxs-lookup"><span data-stu-id="5ab4d-263">Middleware/framework</span></span>

 <span data-ttu-id="5ab4d-264">如前所述，当服务器接受来自客户端的请求时，它负责通过 OWIN 组件（由开发人员的启动代码指定）的管道传递它。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-264">As previously mentioned, when the server accepts a request from a client, it is responsible for passing it through a pipeline of OWIN components, which are specified by the developer's startup code.</span></span> <span data-ttu-id="5ab4d-265">这些管道组件称为中间件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-265">These pipeline components are known as middleware.</span></span>  
 <span data-ttu-id="5ab4d-266">在非常基本的层面上，OWIN 中间件组件只需实现 OWIN 应用程序委托即可调用该委托。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-266">At a very basic level, an OWIN middleware component simply needs to implement the OWIN application delegate so that it is callable.</span></span>

[!code-console[Main](an-overview-of-project-katana/samples/sample8.cmd)]

<span data-ttu-id="5ab4d-267">但是，为了简化中间件组件的开发和组合，Katana 支持用于中间件组件的少量约定和帮助器类型。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-267">However, in order to simplify the development and composition of middleware components, Katana supports a handful of conventions and helper types for middleware components.</span></span> <span data-ttu-id="5ab4d-268">最常见的是 `OwinMiddleware` 类。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-268">The most common of these is the `OwinMiddleware` class.</span></span> <span data-ttu-id="5ab4d-269">使用此类生成的自定义中间件组件如下所示：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-269">A custom middleware component built using this class would look similar to the following:</span></span> 

[!code-csharp[Main](an-overview-of-project-katana/samples/sample9.cs)]

 <span data-ttu-id="5ab4d-270">此类派生自 `OwinMiddleware`，实现一个将管道中的下一个中间件的实例作为其参数之一的构造函数，然后将其传递给基构造函数。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-270">This class derives from `OwinMiddleware`, implements a constructor that accepts an instance of the next middleware in the pipeline as one of its arguments, and then passes it to the base constructor.</span></span> <span data-ttu-id="5ab4d-271">用于配置中间件的其他参数也会在下一个中间件参数之后声明为构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-271">Additional arguments used to configure the middleware are also declared as constructor parameters after the next middleware parameter.</span></span>   
  
<span data-ttu-id="5ab4d-272">在运行时，中间件通过重写的 `Invoke` 方法执行。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-272">At runtime, the middleware is executed via the overridden `Invoke` method.</span></span> <span data-ttu-id="5ab4d-273">此方法使用 `OwinContext`类型的单个自变量。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-273">This method takes a single argument of type `OwinContext`.</span></span> <span data-ttu-id="5ab4d-274">此上下文对象由前面所述的 `Microsoft.Owin` NuGet 包提供，并提供对请求、响应和环境字典的强类型访问，以及一些其他的帮助器类型。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-274">This context object is provided by the `Microsoft.Owin` NuGet package described earlier and provides strongly-typed access to the request, response and environment dictionary, along with a few additional helper types.</span></span>   
  
<span data-ttu-id="5ab4d-275">可以在应用程序启动代码中轻松地将中间件类添加到 OWIN 管道，如下所示：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-275">The middleware class can be easily added to the OWIN pipeline in the application startup code as follows:</span></span>   

[!code-csharp[Main](an-overview-of-project-katana/samples/sample10.cs)]

<span data-ttu-id="5ab4d-276">由于 Katana 基础结构只是构建 OWIN 中间件组件的管道，并且组件只需支持应用程序委托即可参与管道，因此中间件组件的复杂性可能会很大，从简单记录器到整个框架（如 ASP.NET、Web API 或[SignalR](../../../signalr/index.md)）。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-276">Because the Katana infrastructure simply builds up a pipeline of OWIN middleware components, and because the components simply need to support the application delegate to participate in the pipeline, middleware components can range in complexity from simple loggers to entire frameworks like ASP.NET, Web API, or [SignalR](../../../signalr/index.md).</span></span> <span data-ttu-id="5ab4d-277">例如，将 ASP.NET Web API 添加到以前的 OWIN 管道需要添加以下启动代码：</span><span class="sxs-lookup"><span data-stu-id="5ab4d-277">For example, adding ASP.NET Web API to the previous OWIN pipeline requires adding the following startup code:</span></span>

[!code-csharp[Main](an-overview-of-project-katana/samples/sample11.cs)]

<span data-ttu-id="5ab4d-278">Katana 基础结构将基于在配置方法中将中间件组件添加到 IAppBuilder 对象的顺序生成该组件的管道。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-278">The Katana infrastructure will build the pipeline of middleware components based on the order in which they were added to the IAppBuilder object in the Configuration method.</span></span> <span data-ttu-id="5ab4d-279">在我们的示例中，LoggerMiddleware 可以处理流过管道的所有请求，而不考虑这些请求的最终处理方式。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-279">In our example, then, LoggerMiddleware can handle all requests that flow through the pipeline, regardless of how those requests are ultimately handled.</span></span> <span data-ttu-id="5ab4d-280">这使得中间件组件（例如身份验证组件）能够处理包含多个组件和框架（例如 ASP.NET Web API、SignalR 和静态文件服务器）的管道的请求。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-280">This enables powerful scenarios where a middleware component (e.g. an authentication component) can process requests for a pipeline that includes multiple components and frameworks (e.g. ASP.NET Web API, SignalR, and a static file server).</span></span>
 
## <a name="applications"></a><span data-ttu-id="5ab4d-281">应用程序</span><span class="sxs-lookup"><span data-stu-id="5ab4d-281">Applications</span></span>

<span data-ttu-id="5ab4d-282">如前面的示例所示，OWIN 和 Katana 项目不应视为新的应用程序编程模型，而是作为一种抽象方式，用于从服务器和托管基础结构分离应用程序编程模型和框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-282">As illustrated by the previous examples, OWIN and the Katana project should not be thought of as a new application programming model, but rather as an abstraction to decouple application programming models and frameworks from server and hosting infrastructure.</span></span> <span data-ttu-id="5ab4d-283">例如，在生成 Web API 应用程序时，无论应用程序是否使用 Katana 项目中的组件在 OWIN 管道中运行，开发人员框架都将继续使用 ASP.NET Web API 框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-283">For example, when building Web API applications, the developer framework will continue to use the ASP.NET Web API framework, irrespective of whether or not the application runs in an OWIN pipeline using components from the Katana project.</span></span> <span data-ttu-id="5ab4d-284">对于应用程序开发人员来说，与 OWIN 相关的代码的一个位置就是应用程序的启动代码，开发人员可以在其中撰写 OWIN 管道。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-284">The one place where OWIN-related code will be visible to the application developer will be the application startup code, where the developer composes the OWIN pipeline.</span></span> <span data-ttu-id="5ab4d-285">在启动代码中，开发人员将注册一系列 UseXx 语句，通常是每个要处理传入请求的中间件组件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-285">In the startup code, the developer will register a series of UseXx statements, generally one for each middleware component that will process incoming requests.</span></span> <span data-ttu-id="5ab4d-286">此体验与在当前系统中注册 HTTP 模块的效果相同。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-286">This experience will have the same effect as registering HTTP modules in the current System.Web world.</span></span> <span data-ttu-id="5ab4d-287">通常，较大的框架中间件（如 ASP.NET Web API 或[SignalR](../../../signalr/index.md) ）将在管道末尾进行注册。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-287">Typically, a larger framework middleware, such as ASP.NET Web API or [SignalR](../../../signalr/index.md) will be registered at the end of the pipeline.</span></span> <span data-ttu-id="5ab4d-288">交叉切削中间件组件（如用于身份验证或缓存的组件）通常注册到管道的开头，以便它们处理在管道中稍后注册的所有框架和组件的请求。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-288">Cross-cutting middleware components, such as those for authentication or caching, are generally registered towards the beginning of the pipeline so that they will process requests for all of the frameworks and components registered later in the pipeline.</span></span> <span data-ttu-id="5ab4d-289">这种不同的中间件组件和基础结构组件之间的分离使组件能够在不同的速度中发展，同时确保整体系统保持稳定。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-289">This separation of the middleware components from each other and from the underlying infrastructure components enables the components to evolve at different velocities while ensuring that the overall system remains stable.</span></span>

## <a name="components--nuget-packages"></a><span data-ttu-id="5ab4d-290">组件-NuGet 包</span><span class="sxs-lookup"><span data-stu-id="5ab4d-290">Components – NuGet Packages</span></span>

<span data-ttu-id="5ab4d-291">与许多当前库和框架一样，Katana 项目组件以一组 NuGet 包的形式提供。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-291">Like many current libraries and frameworks, the Katana project components are delivered as a set of NuGet packages.</span></span> <span data-ttu-id="5ab4d-292">在即将推出的版本2.0 中，Katana 包依赖关系图如下所示。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-292">For the upcoming version 2.0, the Katana package dependency graph looks as follows.</span></span> <span data-ttu-id="5ab4d-293">（单击图像查看大图。）</span><span class="sxs-lookup"><span data-stu-id="5ab4d-293">(Click on image for larger view.)</span></span>

[![](an-overview-of-project-katana/_static/image6.png)](an-overview-of-project-katana/_static/image5.png)

<span data-ttu-id="5ab4d-294">几乎 Katana 项目中的每个包都在 Owin 包上直接或间接依赖于。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-294">Nearly every package in the Katana project depends, directly or indirectly, on the Owin package.</span></span> <span data-ttu-id="5ab4d-295">你可能会记住，这是包含 IAppBuilder 接口的包，它提供了 OWIN 规范的第4节中所述的应用程序启动序列的具体实现。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-295">You may remember that this is the package that contains the IAppBuilder interface, which provides a concrete implementation of the application startup sequence described in section 4 of the OWIN specification.</span></span> <span data-ttu-id="5ab4d-296">此外，许多包都依赖于 Owin，后者提供了一组帮助器类型用于处理 HTTP 请求和响应。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-296">Additionally, many of the packages depend on Microsoft.Owin, which provides a set of helper types for working with HTTP requests and responses.</span></span> <span data-ttu-id="5ab4d-297">包的其余部分可分类为托管基础结构包（服务器或主机）或中间件。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-297">The remainder of the package can be classified as either hosting infrastructure packages (servers or hosts) or middleware.</span></span> <span data-ttu-id="5ab4d-298">Katana 项目外部的包和依赖项显示为橙色。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-298">Packages and dependencies that are external to the Katana project are displayed in orange.</span></span>

<span data-ttu-id="5ab4d-299">Katana 2.0 的托管基础结构包括基于 SystemWeb 和 HttpListener 的服务器、使用 OWIN 运行 OWINHOST.EXE 应用程序的 Owinhost.exe 包以及用于自承载 OWIN 应用程序的 OWIN 包自定义主机（例如，控制台应用程序、Windows 服务等）</span><span class="sxs-lookup"><span data-stu-id="5ab4d-299">The hosting infrastructure for Katana 2.0 includes both the SystemWeb and HttpListener-based servers, the OwinHost package for running OWIN applications using OwinHost.exe, and the Microsoft.Owin.Hosting package for self-hosting OWIN applications in a custom host (e.g. console application, Windows service, etc.)</span></span>

<span data-ttu-id="5ab4d-300">对于 Katana 2.0，中间件组件主要侧重于提供不同的身份验证方法。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-300">For Katana 2.0, the middleware components are primarily focused on providing different means of authentication.</span></span> <span data-ttu-id="5ab4d-301">还提供了一个用于诊断的附加中间件组件，它支持启动和错误页。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-301">One additional middleware component for diagnostics is provided, which enables support for a start and error page.</span></span> <span data-ttu-id="5ab4d-302">随着 OWIN 的不断发展，中间件组件的生态系统和第三方开发的生态系统组件的生态系统也会增长。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-302">As OWIN grows into the de facto hosting abstraction, the ecosystem of middleware components, both those developed by Microsoft and third parties, will also grow in number.</span></span>

## <a name="conclusion"></a><span data-ttu-id="5ab4d-303">结束语</span><span class="sxs-lookup"><span data-stu-id="5ab4d-303">Conclusion</span></span>

 <span data-ttu-id="5ab4d-304">从一开始，Katana 项目的目标尚未创建，因此迫使开发人员了解另一个 Web 框架。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-304">From its beginning, the Katana project's goal has not been to create and thereby force developers to learn yet another Web framework.</span></span> <span data-ttu-id="5ab4d-305">相反，目标是创建一个抽象来向 .NET Web 应用程序开发人员提供比以前更多的选择。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-305">Rather, the goal has been to create an abstraction to give .NET Web application developers more choice than has previously been possible.</span></span> <span data-ttu-id="5ab4d-306">通过将典型 Web 应用程序堆栈的逻辑层分解为一组可替换的组件，Katana 项目可在整个堆栈中启用组件，以对这些组件有意义的速度进行改进。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-306">By breaking up the logical layers of a typical Web application stack into a set of replaceable components, the Katana project enables components throughout the stack to improve at whatever rate makes sense for those components.</span></span> <span data-ttu-id="5ab4d-307">通过构建简单的 OWIN 抽象的所有组件，Katana 使框架和构建在这些框架之上的应用程序可在各种不同的服务器和主机之间移植。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-307">By building all components around the simple OWIN abstraction, Katana enables frameworks and the applications built on top of them to be portable across a variety of different servers and hosts.</span></span> <span data-ttu-id="5ab4d-308">通过使开发人员能够控制堆栈，Katana 可确保开发人员对其 Web 堆栈的轻型或功能的丰富程度做出最佳选择。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-308">By putting the developer in control of the stack, Katana ensures that the developer makes the ultimate choice about how lightweight or how feature-rich her Web stack should be.</span></span>  

## <a name="for-more-information-about-katana"></a><span data-ttu-id="5ab4d-309">有关 Katana 的详细信息</span><span class="sxs-lookup"><span data-stu-id="5ab4d-309">For more information about Katana</span></span>

- <span data-ttu-id="5ab4d-310">GitHub 上的 Katana 项目： [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/)。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-310">The Katana project on GitHub: [https://github.com/aspnet/AspNetKatana/](https://github.com/aspnet/AspNetKatana/).</span></span>
- <span data-ttu-id="5ab4d-311">视频： [Katana 项目-OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET)，By Howard Dierking。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-311">Video: [The Katana Project - OWIN for ASP.NET](https://channel9.msdn.com/Shows/Web+Camps+TV/The-Katana-Project-OWIN-for-ASPNET), by Howard Dierking.</span></span>

## <a name="acknowledgements"></a><span data-ttu-id="5ab4d-312">致谢</span><span class="sxs-lookup"><span data-stu-id="5ab4d-312">Acknowledgements</span></span>

- <span data-ttu-id="5ab4d-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/)：（twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ） rick 是 Microsoft 专注于 Azure 和 MVC 的高级编程编写器。</span><span class="sxs-lookup"><span data-stu-id="5ab4d-313">[Rick Anderson](https://blogs.msdn.com/b/rickandy/): (twitter [@RickAndMSFT](http://twitter.com/RickAndMSFT) ) Rick is a senior programming writer for Microsoft focusing on Azure and MVC.</span></span>
- <span data-ttu-id="5ab4d-314">[Scott Hanselman](http://www.hanselman.com/blog/)：（twitter [@shanselman](https://twitter.com/shanselman) ）</span><span class="sxs-lookup"><span data-stu-id="5ab4d-314">[Scott Hanselman](http://www.hanselman.com/blog/): (twitter [@shanselman](https://twitter.com/shanselman) )</span></span>
- <span data-ttu-id="5ab4d-315">[吴建 Galloway](https://weblogs.asp.net/jgalloway/default.aspx)：（twitter [@jongalloway](https://twitter.com/jongalloway) ）</span><span class="sxs-lookup"><span data-stu-id="5ab4d-315">[Jon Galloway](https://weblogs.asp.net/jgalloway/default.aspx): (twitter [@jongalloway](https://twitter.com/jongalloway) )</span></span>

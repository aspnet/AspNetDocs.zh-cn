---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: 分布式缓存（通过 Azure 构建实际的云应用） |Microsoft Docs
author: MikeWasson
description: 使用 Azure 电子书构建真实的云应用基于 Scott Guthrie 开发的演示文稿。 它介绍了13种模式和实践，
ms.author: riande
ms.date: 07/20/2015
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: c66187b990a828c53bd2f8115e3c9660fc6022ed
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74582813"
---
# <a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="89a7f-104">分布式缓存（通过 Azure 构建实际的云应用）</span><span class="sxs-lookup"><span data-stu-id="89a7f-104">Distributed Caching (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="89a7f-105">作者： [Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson]((https://twitter.com/RickAndMSFT))， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="89a7f-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson]((https://twitter.com/RickAndMSFT)), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="89a7f-106">[下载 Fix It 项目](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下载电子书](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="89a7f-106">[Download Fix It Project](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="89a7f-107">**使用 Azure 电子书构建真实的云应用**基于 Scott Guthrie 开发的演示文稿。</span><span class="sxs-lookup"><span data-stu-id="89a7f-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="89a7f-108">它介绍了可帮助你成功开发云的 web 应用的13种模式和实践。</span><span class="sxs-lookup"><span data-stu-id="89a7f-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="89a7f-109">有关电子书的信息，请参阅[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>

<span data-ttu-id="89a7f-110">上一章介绍了暂时性故障处理，并将所述缓存视为断路器策略。</span><span class="sxs-lookup"><span data-stu-id="89a7f-110">The previous chapter looked at transient fault handling and mentioned caching as a circuit breaker strategy.</span></span> <span data-ttu-id="89a7f-111">本章提供有关缓存的更多背景知识，包括何时使用它、使用它的常用模式，以及如何在 Azure 中实现它。</span><span class="sxs-lookup"><span data-stu-id="89a7f-111">This chapter gives more background about caching, including when to use it, common patterns for using it, and how to implement it in Azure.</span></span>

## <a name="what-is-distributed-caching"></a><span data-ttu-id="89a7f-112">什么是分布式缓存</span><span class="sxs-lookup"><span data-stu-id="89a7f-112">What is distributed caching</span></span>

<span data-ttu-id="89a7f-113">缓存通过将数据存储在内存中，为经常访问的应用程序数据提供高吞吐量、低延迟的访问。</span><span class="sxs-lookup"><span data-stu-id="89a7f-113">A cache provides high throughput, low-latency access to commonly accessed application data, by storing the data in memory.</span></span> <span data-ttu-id="89a7f-114">对于云应用，最有用的缓存类型为分布式缓存，这意味着，数据不会存储在单独的 web 服务器的内存中，而是存储在其他云资源上，并且缓存的数据可供所有应用程序的 web 服务器（或 ar 的其他云 Vm）使用。e，由应用程序使用）。</span><span class="sxs-lookup"><span data-stu-id="89a7f-114">For a cloud app the most useful type of cache is distributed cache, which means the data is not stored on the individual web server's memory but on other cloud resources, and the cached data is made available to all of an application's web servers (or other cloud VMs that are used by the application).</span></span>

![显示访问同一缓存服务器的多个 web 服务器的图示](distributed-caching/_static/image1.png)

<span data-ttu-id="89a7f-116">当应用程序通过添加或删除服务器进行缩放，或由于升级或故障而替换服务器时，每个运行应用程序的服务器都可以访问缓存的数据。</span><span class="sxs-lookup"><span data-stu-id="89a7f-116">When the application scales by adding or removing servers, or when servers are replaced due to upgrades or faults, the cached data remains accessible to every server that runs the application.</span></span>

<span data-ttu-id="89a7f-117">通过避免永久性数据存储的高延迟数据访问，缓存可以显著提高应用程序的响应能力。</span><span class="sxs-lookup"><span data-stu-id="89a7f-117">By avoiding the high latency data access of a persistent data store, caching can dramatically improve application responsiveness.</span></span> <span data-ttu-id="89a7f-118">例如，从缓存中检索数据比从关系数据库检索数据快得多。</span><span class="sxs-lookup"><span data-stu-id="89a7f-118">For example, retrieving data from cache is much faster than retrieving it from a relational database.</span></span>

<span data-ttu-id="89a7f-119">缓存的一个优点是，将流量降低到持久数据存储，这可能会导致在发生永久性数据存储的数据传出费用时降低成本。</span><span class="sxs-lookup"><span data-stu-id="89a7f-119">A side benefit of caching is reduced traffic to the persistent data store, which may result in lower costs when there are data egress charges for the persistent data store.</span></span>

## <a name="when-to-use-distributed-caching"></a><span data-ttu-id="89a7f-120">何时使用分布式缓存</span><span class="sxs-lookup"><span data-stu-id="89a7f-120">When to use distributed caching</span></span>

<span data-ttu-id="89a7f-121">缓存最适用于比写入数据更多的应用程序工作负荷，以及当数据模型支持用于在缓存中存储和检索数据的键/值组织时。</span><span class="sxs-lookup"><span data-stu-id="89a7f-121">Caching works best for application workloads that do more reading than writing of data, and when the data model supports the key/value organization that you use to store and retrieve data in cache.</span></span> <span data-ttu-id="89a7f-122">当应用程序用户共享很多常见数据时，此方法也更有用。例如，如果每个用户通常检索特定于该用户的数据，则缓存不会提供很多好处。</span><span class="sxs-lookup"><span data-stu-id="89a7f-122">It's also more useful when application users share a lot of common data; for example, cache would not provide as many benefits if each user typically retrieves data unique to that user.</span></span> <span data-ttu-id="89a7f-123">缓存可能非常有用的示例是产品目录，因为数据不经常更改，并且所有客户都要查看相同的数据。</span><span class="sxs-lookup"><span data-stu-id="89a7f-123">An example where caching could be very beneficial is a product catalog, because the data does not change frequently, and all customers are looking at the same data.</span></span>

<span data-ttu-id="89a7f-124">由于持久数据存储区的吞吐量限制和延迟延迟对应用程序性能的影响更大，因此缓存的优点会越来越大。</span><span class="sxs-lookup"><span data-stu-id="89a7f-124">The benefit of caching becomes increasingly measurable the more an application scales, as the throughput limits and latency delays of the persistent data store become more of a limit on overall application performance.</span></span> <span data-ttu-id="89a7f-125">但是，你可能会出于其他原因而不是性能来实现缓存。</span><span class="sxs-lookup"><span data-stu-id="89a7f-125">However, you might implement caching for other reasons than performance as well.</span></span> <span data-ttu-id="89a7f-126">对于在向用户显示时不需要完全更新的数据，在永久数据存储无响应或不可用的情况下，缓存访问可用作断路器。</span><span class="sxs-lookup"><span data-stu-id="89a7f-126">For data that doesn't have to be perfectly up-to-date when shown to the user, cache access can serve as a circuit breaker for when the persistent data store is unresponsive or unavailable.</span></span>

## <a name="popular-cache-population-strategies"></a><span data-ttu-id="89a7f-127">常用缓存填充策略</span><span class="sxs-lookup"><span data-stu-id="89a7f-127">Popular cache population strategies</span></span>

<span data-ttu-id="89a7f-128">为了能够从缓存中检索数据，必须先将数据存储在此处。</span><span class="sxs-lookup"><span data-stu-id="89a7f-128">In order to be able to retrieve data from cache, you have to store it there first.</span></span> <span data-ttu-id="89a7f-129">有多个策略可用于在缓存中获取所需的数据：</span><span class="sxs-lookup"><span data-stu-id="89a7f-129">There are several strategies for getting data that you need into a cache:</span></span>

- <span data-ttu-id="89a7f-130">按需/缓存</span><span class="sxs-lookup"><span data-stu-id="89a7f-130">On Demand / Cache Aside</span></span>

    <span data-ttu-id="89a7f-131">应用程序尝试从缓存中检索数据，当缓存没有数据（"未命中"）时，应用程序将数据存储在缓存中，以便在下次可用时使用。</span><span class="sxs-lookup"><span data-stu-id="89a7f-131">The application tries to retrieve data from cache, and when the cache doesn't have the data (a "miss"), the application stores the data in the cache so that it will be available the next time.</span></span> <span data-ttu-id="89a7f-132">下次应用程序尝试获取相同数据时，它会查找在缓存中查找的内容（"命中"）。</span><span class="sxs-lookup"><span data-stu-id="89a7f-132">The next time the application tries to get the same data, it finds what it's looking for in the cache (a "hit").</span></span> <span data-ttu-id="89a7f-133">若要防止提取数据库中已更改的缓存数据，请在对数据存储进行更改时使缓存无效。</span><span class="sxs-lookup"><span data-stu-id="89a7f-133">To prevent fetching cached data that has changed on the database, you invalidate the cache when making changes to the data store.</span></span>
- <span data-ttu-id="89a7f-134">后台数据推送</span><span class="sxs-lookup"><span data-stu-id="89a7f-134">Background Data Push</span></span>

    <span data-ttu-id="89a7f-135">后台服务定期将数据推入缓存，应用始终从缓存中提取数据。</span><span class="sxs-lookup"><span data-stu-id="89a7f-135">Background services push data into the cache on a regular schedule, and the app always pulls from the cache.</span></span> <span data-ttu-id="89a7f-136">此方法非常适用于不要求始终返回最新数据的高延迟数据源。</span><span class="sxs-lookup"><span data-stu-id="89a7f-136">This approach works great with high latency data sources that don't require you always return the latest data.</span></span>
- <span data-ttu-id="89a7f-137">断路器</span><span class="sxs-lookup"><span data-stu-id="89a7f-137">Circuit Breaker</span></span>

    <span data-ttu-id="89a7f-138">应用程序通常直接与永久性数据存储进行通信，但当永久性数据存储具有可用性问题时，应用程序将从缓存中检索数据。</span><span class="sxs-lookup"><span data-stu-id="89a7f-138">The application normally communicates directly with the persistent data store, but when the persistent data store has availability problems, the application retrieves data from cache.</span></span> <span data-ttu-id="89a7f-139">数据可能已使用缓存留出或后台数据推送策略放入缓存中。</span><span class="sxs-lookup"><span data-stu-id="89a7f-139">Data may have been put in cache using either the cache aside or background data push strategy.</span></span> <span data-ttu-id="89a7f-140">这是一种错误处理策略，而不是提高性能。</span><span class="sxs-lookup"><span data-stu-id="89a7f-140">This is a fault handling strategy rather than a performance enhancing strategy.</span></span>

<span data-ttu-id="89a7f-141">为了使缓存中的数据保持最新，可以在应用程序创建、更新或删除数据时删除相关的缓存条目。</span><span class="sxs-lookup"><span data-stu-id="89a7f-141">In order to keep data in the cache current, you can delete related cache entries when your application creates, updates, or deletes data.</span></span> <span data-ttu-id="89a7f-142">如果您的应用程序有时会获得略微过期的数据，则可以依赖于可配置的过期时间来设置旧缓存数据的可以使用的限制。</span><span class="sxs-lookup"><span data-stu-id="89a7f-142">If it's alright for your application to sometimes get data that is slightly out-of-date, you can rely on a configurable expiration time to set a limit on how old cache data can be.</span></span>

<span data-ttu-id="89a7f-143">你可以配置绝对过期时间（自创建缓存项后的时间量）或可调过期时间（自上次访问缓存项后经过的时间量）。</span><span class="sxs-lookup"><span data-stu-id="89a7f-143">You can configure absolute expiration (amount of time since the cache item was created) or sliding expiration (amount of time since the last time a cache item was accessed).</span></span> <span data-ttu-id="89a7f-144">当你根据缓存过期机制阻止数据变得太过时，将使用绝对过期。</span><span class="sxs-lookup"><span data-stu-id="89a7f-144">Absolute expiration is used when you are depending on the cache expiration mechanism to prevent the data from becoming too stale.</span></span> <span data-ttu-id="89a7f-145">在 Fix It 应用程序中，我们将手动逐出过时缓存项，并使用滑动过期将最新的数据保留在缓存中。</span><span class="sxs-lookup"><span data-stu-id="89a7f-145">In the Fix It app, we'll manually evict stale cache items and we'll use sliding expiration to keep the most current data in cache.</span></span> <span data-ttu-id="89a7f-146">无论选择哪种过期策略，当达到缓存的内存限制时，缓存都会自动逐出最早的（最近最少使用或 LRU）的项。</span><span class="sxs-lookup"><span data-stu-id="89a7f-146">Regardless of the expiration policy you choose, the cache will automatically evict the oldest (Least Recently Used or LRU) items when the cache's memory limit is reached.</span></span>

## <a name="sample-cache-aside-code-for-fix-it-app"></a><span data-ttu-id="89a7f-147">示例缓存-用于修复 It 应用的代码</span><span class="sxs-lookup"><span data-stu-id="89a7f-147">Sample cache-aside code for Fix It app</span></span>

<span data-ttu-id="89a7f-148">在下面的示例代码中，我们会在检索到 Fix It 任务时先检查缓存。</span><span class="sxs-lookup"><span data-stu-id="89a7f-148">In the following sample code, we check the cache first when retrieving a Fix It task.</span></span> <span data-ttu-id="89a7f-149">如果在缓存中找到该任务，则返回它;如果找不到，则从数据库获取该数据库，并将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="89a7f-149">If the task is found in cache, we return it; if not found, we get it from the database and store it in the cache.</span></span> <span data-ttu-id="89a7f-150">将突出显示将缓存添加到 `FindTaskByIdAsync` 方法所做的更改。</span><span class="sxs-lookup"><span data-stu-id="89a7f-150">The changes you'd make to add caching to the `FindTaskByIdAsync` method are highlighted.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

<span data-ttu-id="89a7f-151">更新或删除 Fix It task 时，必须使缓存任务无效（删除）。</span><span class="sxs-lookup"><span data-stu-id="89a7f-151">When you update or delete a Fix It task, you have to invalidate (remove) the cached task.</span></span> <span data-ttu-id="89a7f-152">否则，将来尝试读取该任务将继续获取缓存中的旧数据。</span><span class="sxs-lookup"><span data-stu-id="89a7f-152">Otherwise, future attempts to read that task will continue to get the old data from the cache.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

<span data-ttu-id="89a7f-153">下面是用于阐释简单缓存代码的示例;在可下载的 Fix It 项目中未实现缓存。</span><span class="sxs-lookup"><span data-stu-id="89a7f-153">These are samples to illustrate simple caching code; caching has not been implemented in the downloadable Fix It project.</span></span>

## <a name="azure-caching-services"></a><span data-ttu-id="89a7f-154">Azure 缓存服务</span><span class="sxs-lookup"><span data-stu-id="89a7f-154">Azure caching services</span></span>

<span data-ttu-id="89a7f-155">Azure 提供以下缓存服务： [Azure Redis 缓存](https://msdn.microsoft.com/library/dn690523.aspx)和[azure 托管缓存](https://msdn.microsoft.com/library/dn386094.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-155">Azure offers the following caching services: [Azure Redis Cache](https://msdn.microsoft.com/library/dn690523.aspx) and [Azure Managed Cache](https://msdn.microsoft.com/library/dn386094.aspx).</span></span> <span data-ttu-id="89a7f-156">Azure Redis 缓存基于流行的[开放源代码 Redis 缓存](http://redis.io/)，是大多数缓存方案的第一种选择。</span><span class="sxs-lookup"><span data-stu-id="89a7f-156">Azure Redis cache is based on the popular [open source Redis Cache](http://redis.io/) and is the first choice for most caching scenarios.</span></span>

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a><span data-ttu-id="89a7f-157">使用缓存提供程序的 ASP.NET 会话状态</span><span class="sxs-lookup"><span data-stu-id="89a7f-157">ASP.NET session state using a cache provider</span></span>

<span data-ttu-id="89a7f-158">如[web 开发最佳实践一章](web-development-best-practices.md)中所述，最佳做法是避免使用会话状态。</span><span class="sxs-lookup"><span data-stu-id="89a7f-158">As mentioned in the [web development best practices chapter](web-development-best-practices.md), a best practice is to avoid using session state.</span></span> <span data-ttu-id="89a7f-159">如果应用程序需要会话状态，则下一种最佳做法是避免默认的内存中提供程序，因为这不会启用 scale out （web 服务器的多个实例）。</span><span class="sxs-lookup"><span data-stu-id="89a7f-159">If your application requires session state, the next best practice is to avoid the default in-memory provider because that doesn't enable scale out (multiple instances of the web server).</span></span> <span data-ttu-id="89a7f-160">ASP.NET SQL Server 的会话状态提供程序允许在多个 web 服务器上运行的站点使用会话状态，但与内存中提供程序相比，这会产生较高的延迟成本。</span><span class="sxs-lookup"><span data-stu-id="89a7f-160">The ASP.NET SQL Server session state provider enables a site that runs on multiple web servers to use session state, but it incurs a high latency cost compared to an in-memory provider.</span></span> <span data-ttu-id="89a7f-161">如果必须使用会话状态，最佳解决方案是使用缓存提供程序，例如[Azure 缓存的会话状态提供程序](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-161">The best solution if you have to use session state is to use a cache provider, such as the [Session State Provider for Azure Cache](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="89a7f-162">总结</span><span class="sxs-lookup"><span data-stu-id="89a7f-162">Summary</span></span>

<span data-ttu-id="89a7f-163">您已经了解了 Fix It 应用程序可以如何实现缓存，以便提高响应时间和伸缩性，并使应用程序在数据库不可用时继续响应读取操作。</span><span class="sxs-lookup"><span data-stu-id="89a7f-163">You've seen how the Fix It app could implement caching in order to improve response time and scalability, and to enable the app to continue to be responsive for read operations when the database is unavailable.</span></span> <span data-ttu-id="89a7f-164">在[下一章](queue-centric-work-pattern.md)中，我们将演示如何进一步提高可伸缩性，并使应用程序继续响应写入操作。</span><span class="sxs-lookup"><span data-stu-id="89a7f-164">In the [next chapter](queue-centric-work-pattern.md) we'll show how to further improve scalability and make the app continue to be responsive for write operations.</span></span>

## <a name="resources"></a><span data-ttu-id="89a7f-165">资源</span><span class="sxs-lookup"><span data-stu-id="89a7f-165">Resources</span></span>

<span data-ttu-id="89a7f-166">有关缓存的详细信息，请参阅以下资源。</span><span class="sxs-lookup"><span data-stu-id="89a7f-166">For more information about caching, see the following resources.</span></span>

<span data-ttu-id="89a7f-167">Documentation</span><span class="sxs-lookup"><span data-stu-id="89a7f-167">Documentation</span></span>

- <span data-ttu-id="89a7f-168">[Azure 缓存](https://msdn.microsoft.com/library/gg278356.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-168">[Azure Cache](https://msdn.microsoft.com/library/gg278356.aspx).</span></span> <span data-ttu-id="89a7f-169">有关 Azure 中的缓存的官方 MSDN 文档。</span><span class="sxs-lookup"><span data-stu-id="89a7f-169">Official MSDN documentation on caching in Azure.</span></span>
- <span data-ttu-id="89a7f-170">[Microsoft 模式和实践-Azure 指南](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-170">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="89a7f-171">请参阅缓存指南和缓存端模式。</span><span class="sxs-lookup"><span data-stu-id="89a7f-171">See Caching guidance and Cache-Aside pattern.</span></span>
- <span data-ttu-id="89a7f-172">[防故障：弹性云体系结构的指南](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-172">[Failsafe: Guidance for Resilient Cloud Architectures](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx).</span></span> <span data-ttu-id="89a7f-173">白皮书 by Marc Mercuri、Ulrich Homann 和 Andrew Townhill。</span><span class="sxs-lookup"><span data-stu-id="89a7f-173">White paper by Marc Mercuri, Ulrich Homann, and Andrew Townhill.</span></span> <span data-ttu-id="89a7f-174">请参阅有关缓存的部分。</span><span class="sxs-lookup"><span data-stu-id="89a7f-174">See the section on Caching.</span></span>
- <span data-ttu-id="89a7f-175">[在 Azure 云服务上设计大规模服务的最佳实践](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-175">[Best Practices for the Design of Large-Scale Services on Azure Cloud Services](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx).</span></span> <span data-ttu-id="89a7f-176">水平.</span><span class="sxs-lookup"><span data-stu-id="89a7f-176">W.</span></span> <span data-ttu-id="89a7f-177">通过标记 Simm 和 Michael Thomassy 的白皮书。</span><span class="sxs-lookup"><span data-stu-id="89a7f-177">White paper by Mark Simms and Michael Thomassy.</span></span> <span data-ttu-id="89a7f-178">请参阅有关分布式缓存的部分。</span><span class="sxs-lookup"><span data-stu-id="89a7f-178">See the section on distributed caching.</span></span>
- <span data-ttu-id="89a7f-179">[可伸缩性的路径上的分布式缓存](https://msdn.microsoft.com/magazine/dd942840.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-179">[Distributed Caching On The Path To Scalability](https://msdn.microsoft.com/magazine/dd942840.aspx).</span></span> <span data-ttu-id="89a7f-180">一篇较早（2009）的 MSDN 杂志文章，但在一般情况下编写了分布式缓存简介;与故障和最佳做法白皮书中的缓存部分相比，更深入。</span><span class="sxs-lookup"><span data-stu-id="89a7f-180">An older (2009) MSDN Magazine article, but a clearly written introduction to distributed caching in general; goes into more depth than the caching sections of the FailSafe and Best Practices white papers.</span></span>

<span data-ttu-id="89a7f-181">视频</span><span class="sxs-lookup"><span data-stu-id="89a7f-181">Videos</span></span>

- <span data-ttu-id="89a7f-182">[故障安全：构建可缩放且可复原的云服务](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-182">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="89a7f-183">九部分系列： Ulrich Homann、Marc Mercuri 和 Mark Simm。</span><span class="sxs-lookup"><span data-stu-id="89a7f-183">Nine-part series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="89a7f-184">显示了一个关于如何构建云应用程序的400级别视图。</span><span class="sxs-lookup"><span data-stu-id="89a7f-184">Presents a 400-level view of how to architect cloud apps.</span></span> <span data-ttu-id="89a7f-185">此系列重点介绍理论和原因;有关详细操作方法的详细信息，请参阅通过标记 Simm 构建大系列。</span><span class="sxs-lookup"><span data-stu-id="89a7f-185">This series focuses on theory and reasons why; for more how-to details, see the Building Big series by Mark Simms.</span></span> <span data-ttu-id="89a7f-186">请参阅从1:24:14 开始的剧集3中的缓存讨论。</span><span class="sxs-lookup"><span data-stu-id="89a7f-186">See the caching discussion in episode 3 starting at 1:24:14.</span></span>
- <span data-ttu-id="89a7f-187">[构建大：从 Azure 客户那里学习的课程-第 I 部分](https://channel9.msdn.com/Events/Build/2012/3-029)。Simon Davies 讨论了从46:00 开始的分布式缓存。</span><span class="sxs-lookup"><span data-stu-id="89a7f-187">[Building Big: Lessons learned from Azure customers - Part I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Davies discusses distributed caching starting at 46:00.</span></span> <span data-ttu-id="89a7f-188">与故障保护系列类似，但更详细地介绍了更多操作方法。</span><span class="sxs-lookup"><span data-stu-id="89a7f-188">Similar to the Failsafe series but goes into more how-to details.</span></span> <span data-ttu-id="89a7f-189">此演示已于2012年10月31日提供，因此它不会涵盖2013中引入 Azure App Service 的 Web 应用的缓存服务。</span><span class="sxs-lookup"><span data-stu-id="89a7f-189">The presentation was given October 31, 2012, so it does not cover caching service of Web Apps in Azure App Service that was introduced in 2013.</span></span>

<span data-ttu-id="89a7f-190">代码示例</span><span class="sxs-lookup"><span data-stu-id="89a7f-190">Code sample</span></span>

- <span data-ttu-id="89a7f-191">[Azure 中的云服务基础知识](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-191">[Cloud Service Fundamentals in Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649).</span></span> <span data-ttu-id="89a7f-192">实现分布式缓存的示例应用程序。</span><span class="sxs-lookup"><span data-stu-id="89a7f-192">Sample application that implements distributed caching.</span></span> <span data-ttu-id="89a7f-193">请参阅随附的博客文章[云服务基础知识-缓存基础知识](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx)。</span><span class="sxs-lookup"><span data-stu-id="89a7f-193">See the accompanying blog post [Cloud Service Fundamentals – Caching Basics](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="89a7f-194">[上一页](transient-fault-handling.md)
> [下一页](queue-centric-work-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="89a7f-194">[Previous](transient-fault-handling.md)
[Next](queue-centric-work-pattern.md)</span></span>

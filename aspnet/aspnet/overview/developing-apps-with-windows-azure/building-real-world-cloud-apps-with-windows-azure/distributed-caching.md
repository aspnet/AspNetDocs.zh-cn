---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: 分布式缓存 （使用 Azure 构建实际云应用） |Microsoft Docs
author: MikeWasson
description: 构建真实世界云应用与 Azure 的电子书基于由 Scott Guthrie 开发的演示文稿。 它还说明了 13 模式和实践可以他...
ms.author: riande
ms.date: 07/20/2015
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: 61837d0087a297b6a677eb3503ce3e6c13d5e0ac
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2019
ms.locfileid: "59397469"
---
# <a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="8fbe9-104">分布式缓存 （构建实际云应用程序与 Azure）</span><span class="sxs-lookup"><span data-stu-id="8fbe9-104">Distributed Caching (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="8fbe9-105">通过[Mike Wasson](https://github.com/MikeWasson)， [Rick Anderson]((https://twitter.com/RickAndMSFT))， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="8fbe9-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson]((https://twitter.com/RickAndMSFT)), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="8fbe9-106">[下载修复此错误项目](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下载电子书](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="8fbe9-106">[Download Fix It Project](http://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](http://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="8fbe9-107">**构建真实世界云应用，使用 Azure**电子书基于由 Scott Guthrie 开发的演示文稿。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="8fbe9-108">它还说明了 13 模式和实践，从而帮助您获得成功开发适用于在云中的 web 应用。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="8fbe9-109">有关电子书的信息，请参阅[的第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>


<span data-ttu-id="8fbe9-110">上一章介绍了暂时性故障处理和提到缓存作为断路器策略。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-110">The previous chapter looked at transient fault handling and mentioned caching as a circuit breaker strategy.</span></span> <span data-ttu-id="8fbe9-111">本章给出了更多背景有关缓存，包括何时使用它的使用情况，常见模式，以及如何在 Azure 中实现。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-111">This chapter gives more background about caching, including when to use it, common patterns for using it, and how to implement it in Azure.</span></span>

## <a name="what-is-distributed-caching"></a><span data-ttu-id="8fbe9-112">什么被分布式缓存</span><span class="sxs-lookup"><span data-stu-id="8fbe9-112">What is distributed caching</span></span>

<span data-ttu-id="8fbe9-113">缓存提供高吞吐量、 低延迟访问经常访问的应用程序数据，通过在内存中存储的数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-113">A cache provides high throughput, low-latency access to commonly accessed application data, by storing the data in memory.</span></span> <span data-ttu-id="8fbe9-114">对于云应用程序最有用的缓存类型是分布式的缓存，这意味着数据不会存储在单独的 web 服务器的内存，但对其他云资源，以及缓存的数据可供所有应用程序的 web 服务器 （或其他云 Vm 该 are 应用程序使用的)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-114">For a cloud app the most useful type of cache is distributed cache, which means the data is not stored on the individual web server's memory but on other cloud resources, and the cached data is made available to all of an application's web servers (or other cloud VMs that are used by the application).</span></span>

![显示访问相同的缓存服务器的多个 web 服务器的关系图](distributed-caching/_static/image1.png)

<span data-ttu-id="8fbe9-116">当通过添加或删除服务器，来缩放应用程序或服务器替换由于升级或故障时，缓存的数据仍然可供运行该应用程序的每个服务器访问。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-116">When the application scales by adding or removing servers, or when servers are replaced due to upgrades or faults, the cached data remains accessible to every server that runs the application.</span></span>

<span data-ttu-id="8fbe9-117">通过避免永久性数据存储的高延迟数据访问，缓存可以显著提高应用程序响应能力。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-117">By avoiding the high latency data access of a persistent data store, caching can dramatically improve application responsiveness.</span></span> <span data-ttu-id="8fbe9-118">例如，从缓存中检索数据是从关系数据库中检索它比快得多。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-118">For example, retrieving data from cache is much faster than retrieving it from a relational database.</span></span>

<span data-ttu-id="8fbe9-119">缓存的一个额外的好处减少为永久性数据存储到永久性数据存储，数据流出量时，可能会导致较低的成本的流量费用。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-119">A side benefit of caching is reduced traffic to the persistent data store, which may result in lower costs when there are data egress charges for the persistent data store.</span></span>

## <a name="when-to-use-distributed-caching"></a><span data-ttu-id="8fbe9-120">何时使用分布式缓存</span><span class="sxs-lookup"><span data-stu-id="8fbe9-120">When to use distributed caching</span></span>

<span data-ttu-id="8fbe9-121">最适合应用程序工作负荷执行多个读取与写入数据，并当数据模型支持的键/值组织的使用来存储和检索缓存中的数据的缓存工作原理。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-121">Caching works best for application workloads that do more reading than writing of data, and when the data model supports the key/value organization that you use to store and retrieve data in cache.</span></span> <span data-ttu-id="8fbe9-122">如果应用程序的用户共享的常见数据; 很多，此选项也更有用例如，缓存会提供尽可能多的好处，如果每个用户通常检索到该用户的唯一数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-122">It's also more useful when application users share a lot of common data; for example, cache would not provide as many benefits if each user typically retrieves data unique to that user.</span></span> <span data-ttu-id="8fbe9-123">产品目录是的示例其中缓存可能会非常非常有用，因为数据不会频繁更改和所有客户都查看相同的数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-123">An example where caching could be very beneficial is a product catalog, because the data does not change frequently, and all customers are looking at the same data.</span></span>

<span data-ttu-id="8fbe9-124">缓存的好处变得越来越多地可用测量应用程序的横向越多，随着的吞吐量限制和延迟延迟的持久数据存储区的总体应用程序性能的限制的详细信息。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-124">The benefit of caching becomes increasingly measurable the more an application scales, as the throughput limits and latency delays of the persistent data store become more of a limit on overall application performance.</span></span> <span data-ttu-id="8fbe9-125">但是，您可以实现缓存的性能以及比其他原因。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-125">However, you might implement caching for other reasons than performance as well.</span></span> <span data-ttu-id="8fbe9-126">对于不一定是完全保持最新状态时向用户显示的数据，缓存的访问时可作为有关断路器永久性数据存储已停止响应或不可用。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-126">For data that doesn't have to be perfectly up-to-date when shown to the user, cache access can serve as a circuit breaker for when the persistent data store is unresponsive or unavailable.</span></span>

## <a name="popular-cache-population-strategies"></a><span data-ttu-id="8fbe9-127">常用缓存填充策略</span><span class="sxs-lookup"><span data-stu-id="8fbe9-127">Popular cache population strategies</span></span>

<span data-ttu-id="8fbe9-128">为了能够从缓存中检索数据，必须将其第一次存储存在。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-128">In order to be able to retrieve data from cache, you have to store it there first.</span></span> <span data-ttu-id="8fbe9-129">有几种策略来到缓存中获取所需的数据：</span><span class="sxs-lookup"><span data-stu-id="8fbe9-129">There are several strategies for getting data that you need into a cache:</span></span>

- <span data-ttu-id="8fbe9-130">按需 / 缓存预留</span><span class="sxs-lookup"><span data-stu-id="8fbe9-130">On Demand / Cache Aside</span></span>

    <span data-ttu-id="8fbe9-131">应用程序尝试从缓存检索数据，当缓存中无数据 ("miss")，该应用程序将数据存储在缓存中，以便它将提供下一次。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-131">The application tries to retrieve data from cache, and when the cache doesn't have the data (a "miss"), the application stores the data in the cache so that it will be available the next time.</span></span> <span data-ttu-id="8fbe9-132">它会查找下一次应用程序尝试获取相同的数据，它查找的内容缓存 （"射击"） 中。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-132">The next time the application tries to get the same data, it finds what it's looking for in the cache (a "hit").</span></span> <span data-ttu-id="8fbe9-133">若要防止对数据库中提取已更改的缓存的数据，您使缓存失效的到数据存储进行更改时。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-133">To prevent fetching cached data that has changed on the database, you invalidate the cache when making changes to the data store.</span></span>
- <span data-ttu-id="8fbe9-134">后台数据推送</span><span class="sxs-lookup"><span data-stu-id="8fbe9-134">Background Data Push</span></span>

    <span data-ttu-id="8fbe9-135">后台服务将数据推送到缓存定期计划和应用程序始终提取从缓存。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-135">Background services push data into the cache on a regular schedule, and the app always pulls from the cache.</span></span> <span data-ttu-id="8fbe9-136">此方法的工作原理很好地与不总是需要您的高延迟数据源返回的最新数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-136">This approach works great with high latency data sources that don't require you always return the latest data.</span></span>
- <span data-ttu-id="8fbe9-137">断路器</span><span class="sxs-lookup"><span data-stu-id="8fbe9-137">Circuit Breaker</span></span>

    <span data-ttu-id="8fbe9-138">在应用程序通常传播直接与永久性数据存储，但应用程序时永久性数据存储存在可用性问题，从缓存检索数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-138">The application normally communicates directly with the persistent data store, but when the persistent data store has availability problems, the application retrieves data from cache.</span></span> <span data-ttu-id="8fbe9-139">可能使用缓存到某个位置或背景的数据推送策略的缓存中放置数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-139">Data may have been put in cache using either the cache aside or background data push strategy.</span></span> <span data-ttu-id="8fbe9-140">这是错误处理策略而不是性能增强策略。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-140">This is a fault handling strategy rather than a performance enhancing strategy.</span></span>

<span data-ttu-id="8fbe9-141">为了使缓存中的数据当前，你的应用程序创建、 更新、 或删除数据时，可以删除相关的缓存项。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-141">In order to keep data in the cache current, you can delete related cache entries when your application creates, updates, or deletes data.</span></span> <span data-ttu-id="8fbe9-142">如果你的应用程序有时会略有过时的数据是好了，您可以借助以多久缓存数据可以是上设置的限制可配置的过期时间。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-142">If it's alright for your application to sometimes get data that is slightly out-of-date, you can rely on a configurable expiration time to set a limit on how old cache data can be.</span></span>

<span data-ttu-id="8fbe9-143">你可以配置绝对过期 （自创建后的缓存项的时间量） 或可调过期 （自从上次访问缓存项的时间量）。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-143">You can configure absolute expiration (amount of time since the cache item was created) or sliding expiration (amount of time since the last time a cache item was accessed).</span></span> <span data-ttu-id="8fbe9-144">具体取决于缓存过期机制来防止数据而言太过时上时，使用绝对到期。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-144">Absolute expiration is used when you are depending on the cache expiration mechanism to prevent the data from becoming too stale.</span></span> <span data-ttu-id="8fbe9-145">在修复其应用中，我们将手动逐出陈旧缓存项和我们将使用可调到期的最新数据保留在缓存中。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-145">In the Fix It app, we'll manually evict stale cache items and we'll use sliding expiration to keep the most current data in cache.</span></span> <span data-ttu-id="8fbe9-146">无论你选择的过期策略，缓存将自动逐出最旧的 （最近最少使用或 LRU） 项目时达到缓存的内存限制。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-146">Regardless of the expiration policy you choose, the cache will automatically evict the oldest (Least Recently Used or LRU) items when the cache's memory limit is reached.</span></span>

## <a name="sample-cache-aside-code-for-fix-it-app"></a><span data-ttu-id="8fbe9-147">Fix It 应用程序的示例缓存端代码</span><span class="sxs-lookup"><span data-stu-id="8fbe9-147">Sample cache-aside code for Fix It app</span></span>

<span data-ttu-id="8fbe9-148">在下面的示例代码中，我们在缓存中检查首先检索 Fix It 任务时。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-148">In the following sample code, we check the cache first when retrieving a Fix It task.</span></span> <span data-ttu-id="8fbe9-149">如果在缓存中找到该任务，我们将返回它;如果未找到，我们从数据库获取并将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-149">If the task is found in cache, we return it; if not found, we get it from the database and store it in the cache.</span></span> <span data-ttu-id="8fbe9-150">所做的更改将添加到缓存`FindTaskByIdAsync`方法会突出显示。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-150">The changes you'd make to add caching to the `FindTaskByIdAsync` method are highlighted.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

<span data-ttu-id="8fbe9-151">当你更新或删除 Fix It 任务时，必须要使之无效 （删除） 的已缓存任务。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-151">When you update or delete a Fix It task, you have to invalidate (remove) the cached task.</span></span> <span data-ttu-id="8fbe9-152">否则，未来尝试读取该任务将继续从缓存中获取旧的数据。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-152">Otherwise, future attempts to read that task will continue to get the old data from the cache.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

<span data-ttu-id="8fbe9-153">这些是示例来演示简单的缓存代码;缓存尚未实现的可下载 Fix It 项目中。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-153">These are samples to illustrate simple caching code; caching has not been implemented in the downloadable Fix It project.</span></span>

## <a name="azure-caching-services"></a><span data-ttu-id="8fbe9-154">Azure 缓存服务</span><span class="sxs-lookup"><span data-stu-id="8fbe9-154">Azure caching services</span></span>

<span data-ttu-id="8fbe9-155">Azure 提供以下缓存服务：[Azure Redis 缓存](https://msdn.microsoft.com/library/dn690523.aspx)并[Azure 托管缓存](https://msdn.microsoft.com/library/dn386094.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-155">Azure offers the following caching services: [Azure Redis Cache](https://msdn.microsoft.com/library/dn690523.aspx) and [Azure Managed Cache](https://msdn.microsoft.com/library/dn386094.aspx).</span></span> <span data-ttu-id="8fbe9-156">Azure Redis 缓存基于热门[开放源代码 Redis 缓存](http://redis.io/)和大多数的第一个选项缓存方案。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-156">Azure Redis cache is based on the popular [open source Redis Cache](http://redis.io/) and is the first choice for most caching scenarios.</span></span>

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a><span data-ttu-id="8fbe9-157">使用缓存提供程序的 ASP.NET 会话状态</span><span class="sxs-lookup"><span data-stu-id="8fbe9-157">ASP.NET session state using a cache provider</span></span>

<span data-ttu-id="8fbe9-158">如中所述[web 开发最佳实践一章](web-development-best-practices.md)，最佳做法是避免使用会话状态。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-158">As mentioned in the [web development best practices chapter](web-development-best-practices.md), a best practice is to avoid using session state.</span></span> <span data-ttu-id="8fbe9-159">如果你的应用程序需要会话状态下, 一步最佳做法是避免默认内存中提供程序，因为它不会启用 scale out （web 服务器的多个实例）。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-159">If your application requires session state, the next best practice is to avoid the default in-memory provider because that doesn't enable scale out (multiple instances of the web server).</span></span> <span data-ttu-id="8fbe9-160">ASP.NET SQL Server 会话状态提供程序启用要使用会话状态的多个 web 服务器运行的站点，但它会导致相比于内存中提供程序的高延迟成本。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-160">The ASP.NET SQL Server session state provider enables a site that runs on multiple web servers to use session state, but it incurs a high latency cost compared to an in-memory provider.</span></span> <span data-ttu-id="8fbe9-161">如果您必须使用会话状态的最佳解决方案是使用缓存提供程序，如[用于 Azure Cache 的会话状态提供程序](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-161">The best solution if you have to use session state is to use a cache provider, such as the [Session State Provider for Azure Cache](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="8fbe9-162">总结</span><span class="sxs-lookup"><span data-stu-id="8fbe9-162">Summary</span></span>

<span data-ttu-id="8fbe9-163">您已了解如何修复它应用实现缓存以提高响应时间和可伸缩性，并使应用程序继续在数据库不可用时能够读取操作的响应。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-163">You've seen how the Fix It app could implement caching in order to improve response time and scalability, and to enable the app to continue to be responsive for read operations when the database is unavailable.</span></span> <span data-ttu-id="8fbe9-164">在中[接下来的章节](queue-centric-work-pattern.md)我们将介绍如何进一步提高可伸缩性并使应用程序继续写入操作的响应速度快。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-164">In the [next chapter](queue-centric-work-pattern.md) we'll show how to further improve scalability and make the app continue to be responsive for write operations.</span></span>

## <a name="resources"></a><span data-ttu-id="8fbe9-165">资源</span><span class="sxs-lookup"><span data-stu-id="8fbe9-165">Resources</span></span>

<span data-ttu-id="8fbe9-166">有关缓存的详细信息，请参阅以下资源。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-166">For more information about caching, see the following resources.</span></span>

<span data-ttu-id="8fbe9-167">文档</span><span class="sxs-lookup"><span data-stu-id="8fbe9-167">Documentation</span></span>

- <span data-ttu-id="8fbe9-168">[Azure 缓存](https://msdn.microsoft.com/library/gg278356.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-168">[Azure Cache](https://msdn.microsoft.com/library/gg278356.aspx).</span></span> <span data-ttu-id="8fbe9-169">有关 Azure 中的缓存的官方 MSDN 文档。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-169">Official MSDN documentation on caching in Azure.</span></span>
- <span data-ttu-id="8fbe9-170">[Microsoft 模式和做法-Azure 指南](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-170">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="8fbe9-171">请参阅缓存指南和缓存端模式。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-171">See Caching guidance and Cache-Aside pattern.</span></span>
- <span data-ttu-id="8fbe9-172">[防故障：弹性云体系结构的指南](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-172">[Failsafe: Guidance for Resilient Cloud Architectures](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx).</span></span> <span data-ttu-id="8fbe9-173">Marc Mercuri、 Ulrich Homann 和 Andrew Townhill 白皮书。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-173">White paper by Marc Mercuri, Ulrich Homann, and Andrew Townhill.</span></span> <span data-ttu-id="8fbe9-174">在缓存，请参阅部分。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-174">See the section on Caching.</span></span>
- <span data-ttu-id="8fbe9-175">[Azure 云服务上的大规模服务的设计的最佳实践](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-175">[Best Practices for the Design of Large-Scale Services on Azure Cloud Services](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx).</span></span> <span data-ttu-id="8fbe9-176">W.</span><span class="sxs-lookup"><span data-stu-id="8fbe9-176">W.</span></span> <span data-ttu-id="8fbe9-177">Mark Simms 和 Michael Thomassy 白皮书。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-177">White paper by Mark Simms and Michael Thomassy.</span></span> <span data-ttu-id="8fbe9-178">在分布式缓存，请参阅部分。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-178">See the section on distributed caching.</span></span>
- <span data-ttu-id="8fbe9-179">[分布式缓存可伸缩性的路径](https://msdn.microsoft.com/magazine/dd942840.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-179">[Distributed Caching On The Path To Scalability](https://msdn.microsoft.com/magazine/dd942840.aspx).</span></span> <span data-ttu-id="8fbe9-180">较旧的 (2009) MSDN 杂志 》 文章，但一般情况下; 分布式缓存的清晰编写的简介深入比防故障和最佳实践白皮书的缓存部分。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-180">An older (2009) MSDN Magazine article, but a clearly written introduction to distributed caching in general; goes into more depth than the caching sections of the FailSafe and Best Practices white papers.</span></span>

<span data-ttu-id="8fbe9-181">视频</span><span class="sxs-lookup"><span data-stu-id="8fbe9-181">Videos</span></span>

- <span data-ttu-id="8fbe9-182">[防故障：构建可缩放、 可复原的云服务](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-182">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="8fbe9-183">包含 9 个部分组成的系列 Ulrich Homann、 Marc Mercuri 和 Mark Simms。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-183">Nine-part series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="8fbe9-184">提供了如何构建云应用的 400 级视图。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-184">Presents a 400-level view of how to architect cloud apps.</span></span> <span data-ttu-id="8fbe9-185">此系列重点介绍从理论上讲并原因原因;有关更多操作方法的详细信息，请参阅由 Mark Simms 构建大系列。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-185">This series focuses on theory and reasons why; for more how-to details, see the Building Big series by Mark Simms.</span></span> <span data-ttu-id="8fbe9-186">请参阅第 3 开始 1:24:14 中的缓存讨论。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-186">See the caching discussion in episode 3 starting at 1:24:14.</span></span>
- <span data-ttu-id="8fbe9-187">[构建大：从 Azure 客户的第 I 到的经验教训](https://channel9.msdn.com/Events/Build/2012/3-029)。Simon Davies 讨论了分布式缓存开始 46:00。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-187">[Building Big: Lessons learned from Azure customers - Part I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Davies discusses distributed caching starting at 46:00.</span></span> <span data-ttu-id="8fbe9-188">类似于防故障系列但进入操作方法的更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-188">Similar to the Failsafe series but goes into more how-to details.</span></span> <span data-ttu-id="8fbe9-189">此演示文稿提供 2012 年 10 月 31 日，因此它不涵盖 2013年中引入的 Azure 应用服务中的 Web 应用程序的缓存服务。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-189">The presentation was given October 31, 2012, so it does not cover caching service of Web Apps in Azure App Service that was introduced in 2013.</span></span>

<span data-ttu-id="8fbe9-190">代码示例</span><span class="sxs-lookup"><span data-stu-id="8fbe9-190">Code sample</span></span>

- <span data-ttu-id="8fbe9-191">[云服务在 Azure 中的基础知识](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-191">[Cloud Service Fundamentals in Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649).</span></span> <span data-ttu-id="8fbe9-192">实现分布式缓存的示例应用程序。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-192">Sample application that implements distributed caching.</span></span> <span data-ttu-id="8fbe9-193">请参阅随附的博客文章[云服务基础知识-缓存的基础知识](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx)。</span><span class="sxs-lookup"><span data-stu-id="8fbe9-193">See the accompanying blog post [Cloud Service Fundamentals – Caching Basics](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="8fbe9-194">[上一页](transient-fault-handling.md)
> [下一页](queue-centric-work-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="8fbe9-194">[Previous](transient-fault-handling.md)
[Next](queue-centric-work-pattern.md)</span></span>

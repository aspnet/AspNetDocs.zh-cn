---
uid: aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
title: 分布式缓存（使用 Azure 构建真实世界云应用） |微软文档
author: MikeWasson
description: 使用 Azure 电子书构建真实世界云应用基于 Scott Guthrie 开发的演示文稿。 它解释了13种模式和做法，他可以...
ms.author: riande
ms.date: 07/20/2015
ms.assetid: 406518e9-3817-49ce-8b90-e82bc461e2c0
msc.legacyurl: /aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/distributed-caching
msc.type: authoredcontent
ms.openlocfilehash: 87a7516415895e761d1589fd459b93e5c15c0f85
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675657"
---
# <a name="distributed-caching-building-real-world-cloud-apps-with-azure"></a><span data-ttu-id="023d1-104">分布式缓存（使用 Azure 构建真实世界云应用）</span><span class="sxs-lookup"><span data-stu-id="023d1-104">Distributed Caching (Building Real-World Cloud Apps with Azure)</span></span>

<span data-ttu-id="023d1-105">由[迈克·瓦森](https://github.com/MikeWasson)，[里克·安德森](https://twitter.com/RickAndMSFT)，[汤姆·戴克斯特拉](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="023d1-105">by [Mike Wasson](https://github.com/MikeWasson), [Rick Anderson](https://twitter.com/RickAndMSFT), [Tom Dykstra](https://github.com/tdykstra)</span></span>

<span data-ttu-id="023d1-106">[下载修复它项目](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4)或[下载电子书](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span><span class="sxs-lookup"><span data-stu-id="023d1-106">[Download Fix It Project](https://code.msdn.microsoft.com/Fix-It-app-for-Building-cdd80df4) or [Download E-book](https://blogs.msdn.com/b/microsoft_press/archive/2014/07/23/free-ebook-building-cloud-apps-with-microsoft-azure.aspx)</span></span>

> <span data-ttu-id="023d1-107">使用 Azure 电子书**构建真实世界云应用**基于 Scott Guthrie 开发的演示文稿。</span><span class="sxs-lookup"><span data-stu-id="023d1-107">The **Building Real World Cloud Apps with Azure** e-book is based on a presentation developed by Scott Guthrie.</span></span> <span data-ttu-id="023d1-108">它解释了 13 种模式和做法，这些模式和做法可以帮助您成功开发云的 Web 应用。</span><span class="sxs-lookup"><span data-stu-id="023d1-108">It explains 13 patterns and practices that can help you be successful developing web apps for the cloud.</span></span> <span data-ttu-id="023d1-109">有关电子书的信息，请参阅[第一章](introduction.md)。</span><span class="sxs-lookup"><span data-stu-id="023d1-109">For information about the e-book, see [the first chapter](introduction.md).</span></span>

<span data-ttu-id="023d1-110">上一章研究了瞬态故障处理，并提到缓存作为断路器策略。</span><span class="sxs-lookup"><span data-stu-id="023d1-110">The previous chapter looked at transient fault handling and mentioned caching as a circuit breaker strategy.</span></span> <span data-ttu-id="023d1-111">本章提供了有关缓存的更多背景，包括何时使用它、使用它的常见模式以及如何在 Azure 中实现缓存。</span><span class="sxs-lookup"><span data-stu-id="023d1-111">This chapter gives more background about caching, including when to use it, common patterns for using it, and how to implement it in Azure.</span></span>

## <a name="what-is-distributed-caching"></a><span data-ttu-id="023d1-112">什么是分布式缓存</span><span class="sxs-lookup"><span data-stu-id="023d1-112">What is distributed caching</span></span>

<span data-ttu-id="023d1-113">缓存通过将数据存储在内存中，提供对通常访问的应用程序数据的高吞吐量、低延迟访问。</span><span class="sxs-lookup"><span data-stu-id="023d1-113">A cache provides high throughput, low-latency access to commonly accessed application data, by storing the data in memory.</span></span> <span data-ttu-id="023d1-114">对于云应用，最有用的缓存类型是分布式缓存，这意味着数据不是存储在单个 Web 服务器的内存上，而是存储在其他云资源上，缓存的数据可供应用程序的所有 Web 服务器（或应用程序使用的其他云 VM）使用。</span><span class="sxs-lookup"><span data-stu-id="023d1-114">For a cloud app the most useful type of cache is distributed cache, which means the data is not stored on the individual web server's memory but on other cloud resources, and the cached data is made available to all of an application's web servers (or other cloud VMs that are used by the application).</span></span>

![显示访问同一缓存服务器的多个 Web 服务器的图表](distributed-caching/_static/image1.png)

<span data-ttu-id="023d1-116">当应用程序通过添加或删除服务器进行扩展，或者当服务器由于升级或故障而更换时，缓存的数据仍可供运行该应用程序的每个服务器访问。</span><span class="sxs-lookup"><span data-stu-id="023d1-116">When the application scales by adding or removing servers, or when servers are replaced due to upgrades or faults, the cached data remains accessible to every server that runs the application.</span></span>

<span data-ttu-id="023d1-117">通过避免持久数据存储的高延迟数据访问，缓存可以显著提高应用程序的响应能力。</span><span class="sxs-lookup"><span data-stu-id="023d1-117">By avoiding the high latency data access of a persistent data store, caching can dramatically improve application responsiveness.</span></span> <span data-ttu-id="023d1-118">例如，从缓存检索数据比从关系数据库检索数据要快得多。</span><span class="sxs-lookup"><span data-stu-id="023d1-118">For example, retrieving data from cache is much faster than retrieving it from a relational database.</span></span>

<span data-ttu-id="023d1-119">缓存的一个附带好处是减少了持久数据存储的流量，当持久数据存储需要数据出口费用时，这可能会导致更低的成本。</span><span class="sxs-lookup"><span data-stu-id="023d1-119">A side benefit of caching is reduced traffic to the persistent data store, which may result in lower costs when there are data egress charges for the persistent data store.</span></span>

## <a name="when-to-use-distributed-caching"></a><span data-ttu-id="023d1-120">何时使用分布式缓存</span><span class="sxs-lookup"><span data-stu-id="023d1-120">When to use distributed caching</span></span>

<span data-ttu-id="023d1-121">缓存最适合使用比写入数据更多的读取工作负荷，以及当数据模型支持用于在缓存中存储和检索数据的键/值组织时。</span><span class="sxs-lookup"><span data-stu-id="023d1-121">Caching works best for application workloads that do more reading than writing of data, and when the data model supports the key/value organization that you use to store and retrieve data in cache.</span></span> <span data-ttu-id="023d1-122">当应用程序用户共享大量常见数据时，它也更有用;例如，如果每个用户通常检索该用户独有的数据，则缓存不会提供尽可能多的好处。</span><span class="sxs-lookup"><span data-stu-id="023d1-122">It's also more useful when application users share a lot of common data; for example, cache would not provide as many benefits if each user typically retrieves data unique to that user.</span></span> <span data-ttu-id="023d1-123">缓存可能非常有益的一个示例是产品目录，因为数据不会频繁更改，并且所有客户都在查看相同的数据。</span><span class="sxs-lookup"><span data-stu-id="023d1-123">An example where caching could be very beneficial is a product catalog, because the data does not change frequently, and all customers are looking at the same data.</span></span>

<span data-ttu-id="023d1-124">缓存的好处越来越可衡量，应用程序越扩展，持久数据存储的吞吐量限制和延迟延迟就对整体应用程序性能造成更大的限制。</span><span class="sxs-lookup"><span data-stu-id="023d1-124">The benefit of caching becomes increasingly measurable the more an application scales, as the throughput limits and latency delays of the persistent data store become more of a limit on overall application performance.</span></span> <span data-ttu-id="023d1-125">但是，您可能出于其他原因实现缓存，而不是性能。</span><span class="sxs-lookup"><span data-stu-id="023d1-125">However, you might implement caching for other reasons than performance as well.</span></span> <span data-ttu-id="023d1-126">对于在向用户显示时不必完全最新的数据，缓存访问可以作为断路器，用于持久数据存储无响应或不可用时的数据。</span><span class="sxs-lookup"><span data-stu-id="023d1-126">For data that doesn't have to be perfectly up-to-date when shown to the user, cache access can serve as a circuit breaker for when the persistent data store is unresponsive or unavailable.</span></span>

## <a name="popular-cache-population-strategies"></a><span data-ttu-id="023d1-127">流行的缓存填充策略</span><span class="sxs-lookup"><span data-stu-id="023d1-127">Popular cache population strategies</span></span>

<span data-ttu-id="023d1-128">为了能够从缓存中检索数据，您必须先将其存储在该缓存中。</span><span class="sxs-lookup"><span data-stu-id="023d1-128">In order to be able to retrieve data from cache, you have to store it there first.</span></span> <span data-ttu-id="023d1-129">有几种策略用于将数据放入缓存中：</span><span class="sxs-lookup"><span data-stu-id="023d1-129">There are several strategies for getting data that you need into a cache:</span></span>

- <span data-ttu-id="023d1-130">按需/缓存旁</span><span class="sxs-lookup"><span data-stu-id="023d1-130">On Demand / Cache Aside</span></span>

    <span data-ttu-id="023d1-131">应用程序尝试从缓存中检索数据，当缓存没有数据（"错误"）时，应用程序将数据存储在缓存中，以便下次数据可用。</span><span class="sxs-lookup"><span data-stu-id="023d1-131">The application tries to retrieve data from cache, and when the cache doesn't have the data (a "miss"), the application stores the data in the cache so that it will be available the next time.</span></span> <span data-ttu-id="023d1-132">下次应用程序尝试获取相同的数据时，它会在缓存中找到它要查找的内容（"命中"）。</span><span class="sxs-lookup"><span data-stu-id="023d1-132">The next time the application tries to get the same data, it finds what it's looking for in the cache (a "hit").</span></span> <span data-ttu-id="023d1-133">为了防止获取数据库中已更改的缓存数据，在更改数据存储时使缓存无效。</span><span class="sxs-lookup"><span data-stu-id="023d1-133">To prevent fetching cached data that has changed on the database, you invalidate the cache when making changes to the data store.</span></span>
- <span data-ttu-id="023d1-134">后台数据推送</span><span class="sxs-lookup"><span data-stu-id="023d1-134">Background Data Push</span></span>

    <span data-ttu-id="023d1-135">后台服务会定期将数据推送到缓存中，并且应用始终从缓存中拉出。</span><span class="sxs-lookup"><span data-stu-id="023d1-135">Background services push data into the cache on a regular schedule, and the app always pulls from the cache.</span></span> <span data-ttu-id="023d1-136">此方法非常适合不需要始终返回最新数据的高延迟数据源。</span><span class="sxs-lookup"><span data-stu-id="023d1-136">This approach works great with high latency data sources that don't require you always return the latest data.</span></span>
- <span data-ttu-id="023d1-137">断路器</span><span class="sxs-lookup"><span data-stu-id="023d1-137">Circuit Breaker</span></span>

    <span data-ttu-id="023d1-138">应用程序通常直接与持久数据存储通信，但当持久数据存储存在可用性问题时，应用程序将从缓存中检索数据。</span><span class="sxs-lookup"><span data-stu-id="023d1-138">The application normally communicates directly with the persistent data store, but when the persistent data store has availability problems, the application retrieves data from cache.</span></span> <span data-ttu-id="023d1-139">数据可能已使用缓存旁或后台数据推送策略放入缓存中。</span><span class="sxs-lookup"><span data-stu-id="023d1-139">Data may have been put in cache using either the cache aside or background data push strategy.</span></span> <span data-ttu-id="023d1-140">这是一种故障处理策略，而不是性能增强策略。</span><span class="sxs-lookup"><span data-stu-id="023d1-140">This is a fault handling strategy rather than a performance enhancing strategy.</span></span>

<span data-ttu-id="023d1-141">为了保持缓存中的数据最新，可以在应用程序创建、更新或删除数据时删除相关的缓存条目。</span><span class="sxs-lookup"><span data-stu-id="023d1-141">In order to keep data in the cache current, you can delete related cache entries when your application creates, updates, or deletes data.</span></span> <span data-ttu-id="023d1-142">如果应用程序有时可以获取稍微过时的数据，则可以依靠可配置的过期时间来设置缓存数据可能有多旧的限制。</span><span class="sxs-lookup"><span data-stu-id="023d1-142">If it's alright for your application to sometimes get data that is slightly out-of-date, you can rely on a configurable expiration time to set a limit on how old cache data can be.</span></span>

<span data-ttu-id="023d1-143">您可以配置绝对过期（自创建缓存项以来的时间量）或滑动过期（自上次访问缓存项以来的时间量）。</span><span class="sxs-lookup"><span data-stu-id="023d1-143">You can configure absolute expiration (amount of time since the cache item was created) or sliding expiration (amount of time since the last time a cache item was accessed).</span></span> <span data-ttu-id="023d1-144">当您依赖于缓存过期机制以防止数据变得过于陈旧时，将使用绝对过期。</span><span class="sxs-lookup"><span data-stu-id="023d1-144">Absolute expiration is used when you are depending on the cache expiration mechanism to prevent the data from becoming too stale.</span></span> <span data-ttu-id="023d1-145">在 Fix It 应用中，我们将手动驱逐陈旧的缓存项，我们将使用滑动过期来将最新的数据保存在缓存中。</span><span class="sxs-lookup"><span data-stu-id="023d1-145">In the Fix It app, we'll manually evict stale cache items and we'll use sliding expiration to keep the most current data in cache.</span></span> <span data-ttu-id="023d1-146">无论您选择哪种过期策略，当达到缓存的内存限制时，缓存将自动驱逐最旧的（最近使用或 LRU）项目。</span><span class="sxs-lookup"><span data-stu-id="023d1-146">Regardless of the expiration policy you choose, the cache will automatically evict the oldest (Least Recently Used or LRU) items when the cache's memory limit is reached.</span></span>

## <a name="sample-cache-aside-code-for-fix-it-app"></a><span data-ttu-id="023d1-147">用于修复它应用的示例缓存旁代码</span><span class="sxs-lookup"><span data-stu-id="023d1-147">Sample cache-aside code for Fix It app</span></span>

<span data-ttu-id="023d1-148">在以下示例代码中，在检索修复 It 任务时，我们首先检查缓存。</span><span class="sxs-lookup"><span data-stu-id="023d1-148">In the following sample code, we check the cache first when retrieving a Fix It task.</span></span> <span data-ttu-id="023d1-149">如果在缓存中找到任务，我们会返回它;如果任务在缓存中找到，则返回它。如果未找到，我们会从数据库中获取它并将其存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="023d1-149">If the task is found in cache, we return it; if not found, we get it from the database and store it in the cache.</span></span> <span data-ttu-id="023d1-150">要向`FindTaskByIdAsync`方法添加缓存所做的更改将突出显示。</span><span class="sxs-lookup"><span data-stu-id="023d1-150">The changes you'd make to add caching to the `FindTaskByIdAsync` method are highlighted.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample1.cs?highlight=5,9-11,13-15,19)]

<span data-ttu-id="023d1-151">更新或删除修复 It 任务时，必须使缓存的任务无效（删除）。</span><span class="sxs-lookup"><span data-stu-id="023d1-151">When you update or delete a Fix It task, you have to invalidate (remove) the cached task.</span></span> <span data-ttu-id="023d1-152">否则，将来尝试读取该任务将继续从缓存中获取旧数据。</span><span class="sxs-lookup"><span data-stu-id="023d1-152">Otherwise, future attempts to read that task will continue to get the old data from the cache.</span></span>

[!code-csharp[Main](distributed-caching/samples/sample2.cs?highlight=7)]

<span data-ttu-id="023d1-153">这些示例说明了简单的缓存代码;缓存尚未在可下载的修复 It 项目中实现。</span><span class="sxs-lookup"><span data-stu-id="023d1-153">These are samples to illustrate simple caching code; caching has not been implemented in the downloadable Fix It project.</span></span>

## <a name="azure-caching-services"></a><span data-ttu-id="023d1-154">Azure 缓存服务</span><span class="sxs-lookup"><span data-stu-id="023d1-154">Azure caching services</span></span>

<span data-ttu-id="023d1-155">Azure 提供以下缓存服务[：Azure Redis 缓存](https://msdn.microsoft.com/library/dn690523.aspx)和[Azure 托管缓存](https://msdn.microsoft.com/library/dn386094.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-155">Azure offers the following caching services: [Azure Redis Cache](https://msdn.microsoft.com/library/dn690523.aspx) and [Azure Managed Cache](https://msdn.microsoft.com/library/dn386094.aspx).</span></span> <span data-ttu-id="023d1-156">Azure Redis 缓存基于流行的[开源 Redis 缓存](http://redis.io/)，是大多数缓存方案的首选。</span><span class="sxs-lookup"><span data-stu-id="023d1-156">Azure Redis cache is based on the popular [open source Redis Cache](http://redis.io/) and is the first choice for most caching scenarios.</span></span>

<a id="sessionstate"></a>
## <a name="aspnet-session-state-using-a-cache-provider"></a><span data-ttu-id="023d1-157">使用缓存提供程序ASP.NET会话状态</span><span class="sxs-lookup"><span data-stu-id="023d1-157">ASP.NET session state using a cache provider</span></span>

<span data-ttu-id="023d1-158">如 Web[开发最佳实践章节](web-development-best-practices.md)所述，最佳做法是避免使用会话状态。</span><span class="sxs-lookup"><span data-stu-id="023d1-158">As mentioned in the [web development best practices chapter](web-development-best-practices.md), a best practice is to avoid using session state.</span></span> <span data-ttu-id="023d1-159">如果应用程序需要会话状态，则下一个最佳做法是避免默认内存中提供程序，因为这不会启用横向扩展（Web 服务器的多个实例）。</span><span class="sxs-lookup"><span data-stu-id="023d1-159">If your application requires session state, the next best practice is to avoid the default in-memory provider because that doesn't enable scale out (multiple instances of the web server).</span></span> <span data-ttu-id="023d1-160">ASP.NET SQL Server 会话状态提供程序使在多个 Web 服务器上运行的站点能够使用会话状态，但与内存中提供程序相比，它会产生较高的延迟成本。</span><span class="sxs-lookup"><span data-stu-id="023d1-160">The ASP.NET SQL Server session state provider enables a site that runs on multiple web servers to use session state, but it incurs a high latency cost compared to an in-memory provider.</span></span> <span data-ttu-id="023d1-161">如果必须使用会话状态，则最佳解决方案是使用缓存提供程序，例如[Azure 缓存的会话状态提供程序](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-161">The best solution if you have to use session state is to use a cache provider, such as the [Session State Provider for Azure Cache](https://msdn.microsoft.com/library/windowsazure/gg185668.aspx).</span></span>

## <a name="summary"></a><span data-ttu-id="023d1-162">总结</span><span class="sxs-lookup"><span data-stu-id="023d1-162">Summary</span></span>

<span data-ttu-id="023d1-163">您已经看到 Fix It 应用如何实现缓存，以提高响应时间和可伸缩性，并使应用在数据库不可用时继续为读取操作响应。</span><span class="sxs-lookup"><span data-stu-id="023d1-163">You've seen how the Fix It app could implement caching in order to improve response time and scalability, and to enable the app to continue to be responsive for read operations when the database is unavailable.</span></span> <span data-ttu-id="023d1-164">[在下一章](queue-centric-work-pattern.md)中，我们将介绍如何进一步提高可伸缩性，并使应用继续对写入操作进行响应。</span><span class="sxs-lookup"><span data-stu-id="023d1-164">In the [next chapter](queue-centric-work-pattern.md) we'll show how to further improve scalability and make the app continue to be responsive for write operations.</span></span>

## <a name="resources"></a><span data-ttu-id="023d1-165">资源</span><span class="sxs-lookup"><span data-stu-id="023d1-165">Resources</span></span>

<span data-ttu-id="023d1-166">有关缓存的详细信息，请参阅以下资源。</span><span class="sxs-lookup"><span data-stu-id="023d1-166">For more information about caching, see the following resources.</span></span>

<span data-ttu-id="023d1-167">文档</span><span class="sxs-lookup"><span data-stu-id="023d1-167">Documentation</span></span>

- <span data-ttu-id="023d1-168">[Azure 缓存](https://msdn.microsoft.com/library/gg278356.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-168">[Azure Cache](https://msdn.microsoft.com/library/gg278356.aspx).</span></span> <span data-ttu-id="023d1-169">有关 Azure 缓存的官方 MSDN 文档。</span><span class="sxs-lookup"><span data-stu-id="023d1-169">Official MSDN documentation on caching in Azure.</span></span>
- <span data-ttu-id="023d1-170">[微软模式和实践 - Azure 指南](https://msdn.microsoft.com/library/dn568099.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-170">[Microsoft Patterns and Practices - Azure Guidance](https://msdn.microsoft.com/library/dn568099.aspx).</span></span> <span data-ttu-id="023d1-171">请参阅缓存指南和缓存放置模式。</span><span class="sxs-lookup"><span data-stu-id="023d1-171">See Caching guidance and Cache-Aside pattern.</span></span>
- <span data-ttu-id="023d1-172">[故障保护：弹性云体系结构指南](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-172">[Failsafe: Guidance for Resilient Cloud Architectures](https://msdn.microsoft.com/library/windowsazure/jj853352.aspx).</span></span> <span data-ttu-id="023d1-173">马克·默库里、乌尔里希·霍曼和安德鲁·汤希尔的白皮书。</span><span class="sxs-lookup"><span data-stu-id="023d1-173">White paper by Marc Mercuri, Ulrich Homann, and Andrew Townhill.</span></span> <span data-ttu-id="023d1-174">请参阅有关缓存的部分。</span><span class="sxs-lookup"><span data-stu-id="023d1-174">See the section on Caching.</span></span>
- <span data-ttu-id="023d1-175">[Azure 云服务上大规模服务设计的最佳做法](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-175">[Best Practices for the Design of Large-Scale Services on Azure Cloud Services](https://msdn.microsoft.com/library/windowsazure/jj717232.aspx).</span></span> <span data-ttu-id="023d1-176">W.</span><span class="sxs-lookup"><span data-stu-id="023d1-176">W.</span></span> <span data-ttu-id="023d1-177">马克·西姆斯和迈克尔·托马斯的白皮书。</span><span class="sxs-lookup"><span data-stu-id="023d1-177">White paper by Mark Simms and Michael Thomassy.</span></span> <span data-ttu-id="023d1-178">请参阅有关分布式缓存的部分。</span><span class="sxs-lookup"><span data-stu-id="023d1-178">See the section on distributed caching.</span></span>
- <span data-ttu-id="023d1-179">[分布式缓存在可伸缩性路径上](https://msdn.microsoft.com/magazine/dd942840.aspx)。</span><span class="sxs-lookup"><span data-stu-id="023d1-179">[Distributed Caching On The Path To Scalability](https://msdn.microsoft.com/magazine/dd942840.aspx).</span></span> <span data-ttu-id="023d1-180">一篇较老的（2009）MSDN杂志文章，但一般对分布式缓存的清晰书面介绍;比故障安全和最佳实践白皮书的缓存部分更深入。</span><span class="sxs-lookup"><span data-stu-id="023d1-180">An older (2009) MSDN Magazine article, but a clearly written introduction to distributed caching in general; goes into more depth than the caching sections of the FailSafe and Best Practices white papers.</span></span>

<span data-ttu-id="023d1-181">视频</span><span class="sxs-lookup"><span data-stu-id="023d1-181">Videos</span></span>

- <span data-ttu-id="023d1-182">[故障安全：构建可扩展的、有弹性的云服务](https://channel9.msdn.com/Series/FailSafe)。</span><span class="sxs-lookup"><span data-stu-id="023d1-182">[FailSafe: Building Scalable, Resilient Cloud Services](https://channel9.msdn.com/Series/FailSafe).</span></span> <span data-ttu-id="023d1-183">由乌尔里希·霍曼、马克·默库里和马克·西姆斯的九集系列。</span><span class="sxs-lookup"><span data-stu-id="023d1-183">Nine-part series by Ulrich Homann, Marc Mercuri, and Mark Simms.</span></span> <span data-ttu-id="023d1-184">提供如何构建云应用的 400 级视图。</span><span class="sxs-lookup"><span data-stu-id="023d1-184">Presents a 400-level view of how to architect cloud apps.</span></span> <span data-ttu-id="023d1-185">本系列主要探讨理论和原因;有关更多如何使用的详细信息，请参阅马克·西姆斯的"建筑大"系列。</span><span class="sxs-lookup"><span data-stu-id="023d1-185">This series focuses on theory and reasons why; for more how-to details, see the Building Big series by Mark Simms.</span></span> <span data-ttu-id="023d1-186">请参阅第 3 集的缓存讨论，从 1：24：14 开始。</span><span class="sxs-lookup"><span data-stu-id="023d1-186">See the caching discussion in episode 3 starting at 1:24:14.</span></span>
- <span data-ttu-id="023d1-187">[构建大：从 Azure 客户那里吸取的教训 - 第 I 部分](https://channel9.msdn.com/Events/Build/2012/3-029)。西蒙·戴维斯讨论从46：00开始的分布式缓存。</span><span class="sxs-lookup"><span data-stu-id="023d1-187">[Building Big: Lessons learned from Azure customers - Part I](https://channel9.msdn.com/Events/Build/2012/3-029). Simon Davies discusses distributed caching starting at 46:00.</span></span> <span data-ttu-id="023d1-188">类似于故障安全系列，但进入更多如何使用的详细信息。</span><span class="sxs-lookup"><span data-stu-id="023d1-188">Similar to the Failsafe series but goes into more how-to details.</span></span> <span data-ttu-id="023d1-189">该演示文稿于 2012 年 10 月 31 日提供，因此不包括 2013 年推出的 Azure 应用服务中的 Web 应用缓存服务。</span><span class="sxs-lookup"><span data-stu-id="023d1-189">The presentation was given October 31, 2012, so it does not cover caching service of Web Apps in Azure App Service that was introduced in 2013.</span></span>

<span data-ttu-id="023d1-190">代码示例</span><span class="sxs-lookup"><span data-stu-id="023d1-190">Code sample</span></span>

- <span data-ttu-id="023d1-191">[Azure 中的云服务基础知识](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649)。</span><span class="sxs-lookup"><span data-stu-id="023d1-191">[Cloud Service Fundamentals in Azure](https://code.msdn.microsoft.com/Cloud-Service-Fundamentals-4ca72649).</span></span> <span data-ttu-id="023d1-192">实现分布式缓存的示例应用程序。</span><span class="sxs-lookup"><span data-stu-id="023d1-192">Sample application that implements distributed caching.</span></span> <span data-ttu-id="023d1-193">请参阅随附的博客文章["云服务基础知识 + 缓存基础知识](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx)"。</span><span class="sxs-lookup"><span data-stu-id="023d1-193">See the accompanying blog post [Cloud Service Fundamentals – Caching Basics](https://blogs.msdn.com/b/windowsazure/archive/2013/10/03/cloud-service-fundamentals-caching-basics.aspx).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="023d1-194">[上一页](transient-fault-handling.md)
> [下一页](queue-centric-work-pattern.md)</span><span class="sxs-lookup"><span data-stu-id="023d1-194">[Previous](transient-fault-handling.md)
[Next](queue-centric-work-pattern.md)</span></span>

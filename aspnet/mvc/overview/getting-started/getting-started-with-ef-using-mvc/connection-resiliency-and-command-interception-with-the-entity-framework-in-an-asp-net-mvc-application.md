---
uid: mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
title: 教程：与 EF 在 ASP.NET MVC 应用中使用连接复原和命令拦截
author: tdykstra
description: 在本教程介绍如何使用连接复原和命令拦截。 它们是两个重要的 Entity Framework 6 的功能。
ms.author: riande
ms.date: 01/22/2019
ms.topic: tutorial
ms.assetid: c89d809f-6c65-4425-a3fa-c9f6e8ac89f2
msc.legacyurl: /mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application
msc.type: authoredcontent
ms.openlocfilehash: 276266f8ae9df38529d44742ebe6ac0dc8e79727
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/01/2019
ms.locfileid: "57025894"
---
# <a name="tutorial-use-connection-resiliency-and-command-interception-with-entity-framework-in-an-aspnet-mvc-app"></a><span data-ttu-id="5ea0e-104">教程：与实体框架在 ASP.NET MVC 应用中使用连接复原和命令拦截</span><span class="sxs-lookup"><span data-stu-id="5ea0e-104">Tutorial: Use connection resiliency and command interception with Entity Framework in an ASP.NET MVC app</span></span>

<span data-ttu-id="5ea0e-105">到目前为止该应用程序已经运行本地 IIS Express 中在开发计算机上。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-105">So far the application has been running locally in IIS Express on your development computer.</span></span> <span data-ttu-id="5ea0e-106">若要使实际的应用程序可供其他人通过 Internet 使用，必须将其部署到 web 宿主提供程序，并需要将数据库部署到数据库服务器。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-106">To make a real application available for other people to use over the Internet, you have to deploy it to a web hosting provider, and you have to deploy the database to a database server.</span></span>

<span data-ttu-id="5ea0e-107">在本教程介绍如何使用连接复原和命令拦截。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-107">In this tutorial you'll learn how to use connection resiliency and command interception.</span></span> <span data-ttu-id="5ea0e-108">它们是两个重要功能 Entity Framework 6 部署到云环境时的特别有用： 连接复原 （自动重试的暂时性错误） 和命令截获 (catch 所有 SQL 查询都发送到数据库若要记录或更改它们。）</span><span class="sxs-lookup"><span data-stu-id="5ea0e-108">They are two important features of Entity Framework 6 that are especially valuable when you are deploying to the cloud environment: connection resiliency (automatic retries for transient errors) and command interception (catch all SQL queries sent to the database in order to log or change them).</span></span>

<span data-ttu-id="5ea0e-109">此连接复原和命令拦截教程是可选的。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-109">This connection resiliency and command interception tutorial is optional.</span></span> <span data-ttu-id="5ea0e-110">如果跳过本教程中，需要在后续教程中进行一些细微调整。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-110">If you skip this tutorial, a few minor adjustments will have to be made in subsequent tutorials.</span></span>

<span data-ttu-id="5ea0e-111">在本教程中，你将了解：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-111">In this tutorial, you:</span></span>

> [!div class="checklist"]
> * <span data-ttu-id="5ea0e-112">启用连接复原</span><span class="sxs-lookup"><span data-stu-id="5ea0e-112">Enable connection resiliency</span></span>
> * <span data-ttu-id="5ea0e-113">启用命令截获</span><span class="sxs-lookup"><span data-stu-id="5ea0e-113">Enable command interception</span></span>
> * <span data-ttu-id="5ea0e-114">测试新的配置</span><span class="sxs-lookup"><span data-stu-id="5ea0e-114">Test the new configuration</span></span>

## <a name="prerequisites"></a><span data-ttu-id="5ea0e-115">系统必备</span><span class="sxs-lookup"><span data-stu-id="5ea0e-115">Prerequisites</span></span>

* [<span data-ttu-id="5ea0e-116">排序、筛选和分页</span><span class="sxs-lookup"><span data-stu-id="5ea0e-116">Sorting, Filtering, and Paging</span></span>](sorting-filtering-and-paging-with-the-entity-framework-in-an-asp-net-mvc-application.md)

## <a name="enable-connection-resiliency"></a><span data-ttu-id="5ea0e-117">启用连接复原</span><span class="sxs-lookup"><span data-stu-id="5ea0e-117">Enable connection resiliency</span></span>

<span data-ttu-id="5ea0e-118">在部署到 Windows Azure 应用程序时，你将部署到 Windows Azure SQL 数据库、 云数据库服务数据库。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-118">When you deploy the application to Windows Azure, you'll deploy the database to Windows Azure SQL Database, a cloud database service.</span></span> <span data-ttu-id="5ea0e-119">连接到比你的 web 服务器和数据库服务器直接连接时一起位于同一数据中心的云数据库服务时，暂时性连接错误是通常更频繁。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-119">Transient connection errors are typically more frequent when you connect to a cloud database service than when your web server and your database server are directly connected together in the same data center.</span></span> <span data-ttu-id="5ea0e-120">即使在同一数据中心托管的云 web 服务器和云数据库服务，有更多的网络连接，它们可以出现问题，例如负载均衡器之间。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-120">Even if a cloud web server and a cloud database service are hosted in the same data center, there are more network connections between them that can have problems, such as load balancers.</span></span>

<span data-ttu-id="5ea0e-121">此外云服务是通常由其他用户共享，这意味着其响应能力可能受到它们。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-121">Also a cloud service is typically shared by other users, which means its responsiveness can be affected by them.</span></span> <span data-ttu-id="5ea0e-122">并且您对数据库访问权限可能会受到限制。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-122">And your access to the database might be subject to throttling.</span></span> <span data-ttu-id="5ea0e-123">当您尝试超过了允许在服务级别协议 (SLA) 中经常访问更多限制意味着数据库服务会引发异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-123">Throttling means the database service throws exceptions when you try to access it more frequently than is allowed in your Service Level Agreement (SLA).</span></span>

<span data-ttu-id="5ea0e-124">许多或大多数连接问题时正在访问云服务是暂时的也就是说，他们自身解决在短时间的时间。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-124">Many or most connection problems when you're accessing a cloud service are transient, that is, they resolve themselves in a short period of time.</span></span> <span data-ttu-id="5ea0e-125">因此在重试数据库操作并获得一种类型的通常是暂时的错误，稍等片刻，该操作可能会成功后无法重试该操作。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-125">So when you try a database operation and get a type of error that is typically transient, you could try the operation again after a short wait, and the operation might be successful.</span></span> <span data-ttu-id="5ea0e-126">如果通过自动尝试再次，处理暂时性错误，可以为用户提供更好的体验使其中的大多数客户不可见。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-126">You can provide a much better experience for your users if you handle transient errors by automatically trying again, making most of them invisible to the customer.</span></span> <span data-ttu-id="5ea0e-127">连接复原功能在 Entity Framework 6 中的自动执行的重试过程失败的 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-127">The connection resiliency feature in Entity Framework 6 automates that process of retrying failed SQL queries.</span></span>

<span data-ttu-id="5ea0e-128">针对特定数据库服务，必须适当地配置连接复原功能：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-128">The connection resiliency feature must be configured appropriately for a particular database service:</span></span>

- <span data-ttu-id="5ea0e-129">它必须知道哪些异常可能是暂时的。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-129">It has to know which exceptions are likely to be transient.</span></span> <span data-ttu-id="5ea0e-130">你想要重试错误引起暂时失去网络连接中不由程序 bug，例如引起的错误。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-130">You want to retry errors caused by a temporary loss in network connectivity, not errors caused by program bugs, for example.</span></span>
- <span data-ttu-id="5ea0e-131">它必须等待适当的重试的失败的操作之间的时间。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-131">It has to wait an appropriate amount of time between retries of a failed operation.</span></span> <span data-ttu-id="5ea0e-132">你可以等待更长时间进行批处理的重试之间不是可以在线网页用户正在等待响应。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-132">You can wait longer between retries for a batch process than you can for an online web page where a user is waiting for a response.</span></span>
- <span data-ttu-id="5ea0e-133">它具有重试的次数之前放弃适当数量。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-133">It has to retry an appropriate number of times before it gives up.</span></span> <span data-ttu-id="5ea0e-134">您可能想要重试更多次，就像在一个在线应用程序中的批处理中。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-134">You might want to retry more times in a batch process that you would in an online application.</span></span>

<span data-ttu-id="5ea0e-135">可以配置手动为任何数据库环境中支持实体框架提供程序，这些设置，但通常适用于使用 Windows Azure SQL 数据库的联机应用程序的默认值已为你配置和这些是你将实现为 Contoso 大学应用程序的设置。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-135">You can configure these settings manually for any database environment supported by an Entity Framework provider, but default values that typically work well for an online application that uses Windows Azure SQL Database have already been configured for you, and those are the settings you'll implement for the Contoso University application.</span></span>

<span data-ttu-id="5ea0e-136">只需启用连接复原能力是中派生自程序集创建一个类[DbConfiguration](https://msdn.microsoft.com/data/jj680699.aspx)类，并在该类中设置 SQL 数据库*执行策略*，即 EF 中另一种说法*重试策略*。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-136">All you have to do to enable connection resiliency is create a class in your assembly that derives from the [DbConfiguration](https://msdn.microsoft.com/data/jj680699.aspx) class, and in that class set the SQL Database *execution strategy*, which in EF is another term for *retry policy*.</span></span>

1. <span data-ttu-id="5ea0e-137">在 DAL 文件夹中，添加名为的类文件*SchoolConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-137">In the DAL folder, add a class file named *SchoolConfiguration.cs*.</span></span>
2. <span data-ttu-id="5ea0e-138">将模板代码替换为以下代码：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-138">Replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample1.cs)]

    <span data-ttu-id="5ea0e-139">实体框架将自动运行的代码在派生类中找到`DbConfiguration`。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-139">The Entity Framework automatically runs the code it finds in a class that derives from `DbConfiguration`.</span></span> <span data-ttu-id="5ea0e-140">可以使用`DbConfiguration`类，以执行在中否则所执行的操作的代码中的配置任务*Web.config*文件。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-140">You can use the `DbConfiguration` class to do configuration tasks in code that you would otherwise do in the *Web.config* file.</span></span> <span data-ttu-id="5ea0e-141">有关详细信息，请参阅[EntityFramework 基于代码的配置](https://msdn.microsoft.com/data/jj680699)。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-141">For more information, see [EntityFramework Code-Based Configuration](https://msdn.microsoft.com/data/jj680699).</span></span>
3. <span data-ttu-id="5ea0e-142">在中*StudentController.cs*，添加`using`语句`System.Data.Entity.Infrastructure`。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-142">In *StudentController.cs*, add a `using` statement for `System.Data.Entity.Infrastructure`.</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample2.cs)]
4. <span data-ttu-id="5ea0e-143">将所有更改`catch`阻止该 catch`DataException`异常，以便它们捕获`RetryLimitExceededException`异常相反。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-143">Change all of the `catch` blocks that catch `DataException` exceptions so that they catch `RetryLimitExceededException` exceptions instead.</span></span> <span data-ttu-id="5ea0e-144">例如：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-144">For example:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample3.cs?highlight=1)]

    <span data-ttu-id="5ea0e-145">已使用`DataException`来尝试标识可能是为了提供友好的"重试"消息暂时性的错误。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-145">You were using `DataException` to try to identify errors that might be transient in order to give a friendly "try again" message.</span></span> <span data-ttu-id="5ea0e-146">但现在，你已启用了重试策略，可能是暂时性的唯一错误将已尝试并失败几次，返回的实际异常将包装在`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-146">But now that you've turned on a retry policy, the only errors likely to be transient will already have been tried and failed several times and the actual exception returned will be wrapped in the `RetryLimitExceededException` exception.</span></span>

<span data-ttu-id="5ea0e-147">有关详细信息，请参阅[实体框架连接复原 / 重试逻辑](https://msdn.microsoft.com/data/dn456835)。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-147">For more information, see [Entity Framework Connection Resiliency / Retry Logic](https://msdn.microsoft.com/data/dn456835).</span></span>

## <a name="enable-command-interception"></a><span data-ttu-id="5ea0e-148">启用命令截获</span><span class="sxs-lookup"><span data-stu-id="5ea0e-148">Enable command interception</span></span>

<span data-ttu-id="5ea0e-149">现在，你已启用了重试策略，如何你测试以验证它是否按预期工作？</span><span class="sxs-lookup"><span data-stu-id="5ea0e-149">Now that you've turned on a retry policy, how do you test to verify that it is working as expected?</span></span> <span data-ttu-id="5ea0e-150">不可以十分轻松地强制暂时性错误发生，尤其是当您在本地，运行和会特别难以将实际的暂时性错误集成到自动化的单元测试。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-150">It's not so easy to force a transient error to happen, especially when you're running locally, and it would be especially difficult to integrate actual transient errors into an automated unit test.</span></span> <span data-ttu-id="5ea0e-151">若要测试连接复原功能，您需要一种方法截获 Entity Framework 将发送到 SQL Server 的查询和 SQL Server 响应替换通常是暂时异常类型。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-151">To test the connection resiliency feature, you need a way to intercept queries that Entity Framework sends to SQL Server and replace the SQL Server response with an exception type that is typically transient.</span></span>

<span data-ttu-id="5ea0e-152">此外可以使用查询拦截，为了实现云应用程序的最佳做法：[记录的延迟和成功或失败的所有调用的外部服务](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log)如数据库服务。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-152">You can also use query interception in order to implement a best practice for cloud applications: [log the latency and success or failure of all calls to external services](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) such as database services.</span></span> <span data-ttu-id="5ea0e-153">EF6 提供[专用日志记录 API](https://msdn.microsoft.com/data/dn469464) ，可以使其更轻松地执行日志记录，但在本教程的本部分中，您将学习如何使用实体框架[拦截功能](https://msdn.microsoft.com/data/dn469464)直接，均适用日志记录和用于模拟暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-153">EF6 provides a [dedicated logging API](https://msdn.microsoft.com/data/dn469464) that can make it easier to do logging, but in this section of the tutorial you'll learn how to use the Entity Framework's [interception feature](https://msdn.microsoft.com/data/dn469464) directly, both for logging and for simulating transient errors.</span></span>

### <a name="create-a-logging-interface-and-class"></a><span data-ttu-id="5ea0e-154">创建日志记录接口和类</span><span class="sxs-lookup"><span data-stu-id="5ea0e-154">Create a logging interface and class</span></span>

<span data-ttu-id="5ea0e-155">一个[最佳做法进行日志记录](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log)操作和使用接口而不是硬编码调用 System.Diagnostics.Trace 或日志记录类。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-155">A [best practice for logging](../../../../aspnet/overview/developing-apps-with-windows-azure/building-real-world-cloud-apps-with-windows-azure/monitoring-and-telemetry.md#log) is to do it by using an interface rather than hard-coding calls to System.Diagnostics.Trace or a logging class.</span></span> <span data-ttu-id="5ea0e-156">这样，更轻松地更改更高版本的日志记录机制，如果您需要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-156">That makes it easier to change your logging mechanism later if you ever need to do that.</span></span> <span data-ttu-id="5ea0e-157">因此在本部分中，您将创建日志记录接口和类来实现它。 / p ></span><span class="sxs-lookup"><span data-stu-id="5ea0e-157">So in this section you'll create the logging interface and a class to implement it./p></span></span>

1. <span data-ttu-id="5ea0e-158">在项目中创建一个文件夹并将其命名*日志记录*。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-158">Create a folder in the project and name it *Logging*.</span></span>
2. <span data-ttu-id="5ea0e-159">在中*日志记录*文件夹中，创建名为的类文件*ILogger.cs*，并使用以下代码替换模板代码：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-159">In the *Logging* folder, create a class file named *ILogger.cs*, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample4.cs)]

    <span data-ttu-id="5ea0e-160">该接口提供三种跟踪级别，以指示日志的相对重要性，另一个设计为提供对等数据库查询的外部服务调用的延迟信息。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-160">The interface provides three tracing levels to indicate the relative importance of logs, and one designed to provide latency information for external service calls such as database queries.</span></span> <span data-ttu-id="5ea0e-161">日志记录方法具有重载，可传入异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-161">The logging methods have overloads that let you pass in an exception.</span></span> <span data-ttu-id="5ea0e-162">这是这样实现的接口，而不是依赖于整个应用程序每个日志记录方法调用中完成这些操作后的类可靠地记录异常信息包括堆栈跟踪和内部异常信息。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-162">This is so that exception information including stack trace and inner exceptions is reliably logged by the class that implements the interface, instead of relying on that being done in each logging method call throughout the application.</span></span>

    <span data-ttu-id="5ea0e-163">TraceApi 方法，可以跟踪 SQL 数据库等外部服务每次调用的延迟。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-163">The TraceApi methods enable you to track the latency of each call to an external service such as SQL Database.</span></span>
3. <span data-ttu-id="5ea0e-164">在中*日志记录*文件夹中，创建名为的类文件*Logger.cs*，并使用以下代码替换模板代码：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-164">In the *Logging* folder, create a class file named *Logger.cs*, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample5.cs)]

    <span data-ttu-id="5ea0e-165">该实现使用 System.Diagnostics，执行跟踪。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-165">The implementation uses System.Diagnostics to do the tracing.</span></span> <span data-ttu-id="5ea0e-166">这是.NET 可以轻松生成和使用跟踪信息的内置功能。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-166">This is a built-in feature of .NET which makes it easy to generate and use tracing information.</span></span> <span data-ttu-id="5ea0e-167">有许多"侦听器"您可以使用与 System.Diagnostics 跟踪将日志写入文件，例如，或将其写入到 blob 存储在 Azure 中。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-167">There are many "listeners" you can use with System.Diagnostics tracing, to write logs to files, for example, or to write them to blob storage in Azure.</span></span> <span data-ttu-id="5ea0e-168">了解的一些选项，以及指向其他资源的详细信息，在[Visual Studio 中进行故障排除 Azure Web Sites](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-168">See some of the options, and links to other resources for more information, in [Troubleshooting Azure Web Sites in Visual Studio](https://docs.microsoft.com/azure/app-service-web/web-sites-dotnet-troubleshoot-visual-studio).</span></span> <span data-ttu-id="5ea0e-169">您将只能看到在本教程在 Visual Studio 中的日志**输出**窗口。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-169">For this tutorial you'll only look at logs in the Visual Studio **Output** window.</span></span>

    <span data-ttu-id="5ea0e-170">在生产应用程序可能需要考虑以外 System.Diagnostics，跟踪包和 ILogger 接口可以相对轻松，若要切换到不同的跟踪机制，如果你决定要执行此操作。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-170">In a production application you might want to consider tracing packages other than System.Diagnostics, and the ILogger interface makes it relatively easy to switch to a different tracing mechanism if you decide to do that.</span></span>

### <a name="create-interceptor-classes"></a><span data-ttu-id="5ea0e-171">创建侦听器类</span><span class="sxs-lookup"><span data-stu-id="5ea0e-171">Create interceptor classes</span></span>

<span data-ttu-id="5ea0e-172">接下来将创建每次它会将查询发送到数据库，另一个来模拟暂时性错误进行日志记录时，实体框架会调用到的类。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-172">Next you'll create the classes that the Entity Framework will call into every time it is going to send a query to the database, one to simulate transient errors and one to do logging.</span></span> <span data-ttu-id="5ea0e-173">这些侦听器类必须派生自`DbCommandInterceptor`类。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-173">These interceptor classes must derive from the `DbCommandInterceptor` class.</span></span> <span data-ttu-id="5ea0e-174">在其中编写查询时要在执行时自动调用的方法重写。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-174">In them you write method overrides that are automatically called when query is about to be executed.</span></span> <span data-ttu-id="5ea0e-175">在这些方法可以检查或记录查询正被发送到数据库，并可以更改查询发送到数据库之前，也可以返回某些内容到实体框架自己而无需甚至将查询传递到数据库。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-175">In these methods you can examine or log the query that is being sent to the database, and you can change the query before it's sent to the database or return something to Entity Framework yourself without even passing the query to the database.</span></span>

1. <span data-ttu-id="5ea0e-176">若要创建将记录发送到数据库的每个 SQL 查询侦听器类，创建名为的类文件*SchoolInterceptorLogging.cs*中*DAL*文件夹，并替换模板代码使用以下代码：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-176">To create the interceptor class that will log every SQL query that is sent to the database, create a class file named *SchoolInterceptorLogging.cs* in the *DAL* folder, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample6.cs)]

    <span data-ttu-id="5ea0e-177">对于成功的查询或命令，此代码将写入延迟信息的信息的日志。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-177">For successful queries or commands, this code writes an Information log with latency information.</span></span> <span data-ttu-id="5ea0e-178">有关例外情况，它创建错误日志。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-178">For exceptions, it creates an Error log.</span></span>
2. <span data-ttu-id="5ea0e-179">若要创建在输入"引发"时，将生成虚拟的暂时性错误的侦听器类**搜索**框中，创建名为的类文件*SchoolInterceptorTransientErrors.cs*中*DAL*文件夹，并将下面的代码模板代码替换为：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-179">To create the interceptor class that will generate dummy transient errors when you enter "Throw" in the **Search** box, create a class file named *SchoolInterceptorTransientErrors.cs* in the *DAL* folder, and replace the template code with the following code:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample7.cs)]

    <span data-ttu-id="5ea0e-180">此代码仅重写`ReaderExecuting`的查询，可以返回多行数据调用的方法。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-180">This code only overrides the `ReaderExecuting` method, which is called for queries that can return multiple rows of data.</span></span> <span data-ttu-id="5ea0e-181">如果你想要检查连接复原对于其他类型的查询，还可以重写`NonQueryExecuting`和`ScalarExecuting`方法，作为日志记录侦听器执行。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-181">If you wanted to check connection resiliency for other types of queries, you could also override the `NonQueryExecuting` and `ScalarExecuting` methods, as the logging interceptor does.</span></span>

    <span data-ttu-id="5ea0e-182">当运行学生页上，并输入"引发"作为搜索字符串时，此代码将创建虚拟 SQL 数据库异常的错误号 20，确定是通常暂时性的类型。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-182">When you run the Student page and enter "Throw" as the search string, this code creates a dummy SQL Database exception for error number 20, a type known to be typically transient.</span></span> <span data-ttu-id="5ea0e-183">其他当前被识别为暂时性的错误编号均为 64、 233、 10053、 10054、 10060、 10928、 10929、 40197、 40501 和 40613，但它们是将在新版本的 SQL 数据库中进行。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-183">Other error numbers currently recognized as transient are 64, 233, 10053, 10054, 10060, 10928, 10929, 40197, 40501, and 40613, but these are subject to change in new versions of SQL Database.</span></span>

    <span data-ttu-id="5ea0e-184">该代码对实体框架，而不是运行查询并传递后的查询结果中返回的异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-184">The code returns the exception to Entity Framework instead of running the query and passing back query results.</span></span> <span data-ttu-id="5ea0e-185">暂时性异常返回四次，之后代码恢复为将查询传递给数据库的正常过程。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-185">The transient exception is returned four times, and then the code reverts to the normal procedure of passing the query to the database.</span></span>

    <span data-ttu-id="5ea0e-186">记录所有内容，因为您可以查看实体框架会尝试执行查询四次之后才最后成功，并在应用程序中唯一的区别是，花费更长时间才能呈现的页面包含查询结果。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-186">Because everything is logged, you'll be able to see that Entity Framework tries to execute the query four times before finally succeeding, and the only difference in the application is that it takes longer to render a page with query results.</span></span>

    <span data-ttu-id="5ea0e-187">实体框架将重试次数是可配置;该代码指定四次，因为这是 SQL 数据库执行策略的默认值。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-187">The number of times the Entity Framework will retry is configurable; the code specifies four times because that's the default value for the SQL Database execution policy.</span></span> <span data-ttu-id="5ea0e-188">如果更改执行策略，则必须也更改的代码，指定生成暂时性错误的次数。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-188">If you change the execution policy, you'd also change the code here that specifies how many times transient errors are generated.</span></span> <span data-ttu-id="5ea0e-189">您也可以更改代码以生成更多的异常，因此，实体框架将引发`RetryLimitExceededException`异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-189">You could also change the code to generate more exceptions so that Entity Framework will throw the `RetryLimitExceededException` exception.</span></span>

    <span data-ttu-id="5ea0e-190">在搜索框中输入的值将用`command.Parameters[0]`和`command.Parameters[1]`（一个用于第一个名称，一个用于最后一个名称）。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-190">The value you enter in the Search box will be in `command.Parameters[0]` and `command.Parameters[1]` (one is used for the first name and one for the last name).</span></span> <span data-ttu-id="5ea0e-191">当找到值"%throw%"时，"引发"将替换为这些参数在"an"，因此将找到一些学生，并将其返回。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-191">When the value "%Throw%" is found, "Throw" is replaced in those parameters by "an" so that some students will be found and returned.</span></span>

    <span data-ttu-id="5ea0e-192">这是只需测试根据不断变化的应用程序 UI 的一些输入的连接复原能力的简便方法。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-192">This is just a convenient way to test connection resiliency based on changing some input to the application UI.</span></span> <span data-ttu-id="5ea0e-193">此外可以编写生成的所有查询或更新，暂时性错误的代码如下所述的评论的更高版本中有关*DbInterception.Add*方法。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-193">You can also write code that generates transient errors for all queries or updates, as explained later in the comments about the *DbInterception.Add* method.</span></span>
3. <span data-ttu-id="5ea0e-194">在中*Global.asax*，添加以下`using`语句：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-194">In *Global.asax*, add the following `using` statements:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample8.cs)]
4. <span data-ttu-id="5ea0e-195">添加突出显示的行`Application_Start`方法：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-195">Add the highlighted lines to the `Application_Start` method:</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample9.cs?highlight=7-8)]

    <span data-ttu-id="5ea0e-196">以下几行代码是哪些因素会导致在 Entity Framework 将查询发送到数据库时要运行的侦听器代码。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-196">These lines of code are what causes your interceptor code to be run when Entity Framework sends queries to the database.</span></span> <span data-ttu-id="5ea0e-197">请注意，因为创建单独的侦听器类进行模拟暂时性错误和日志记录，你可以单独启用和禁用它们。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-197">Notice that because you created separate interceptor classes for transient error simulation and logging, you can independently enable and disable them.</span></span>

    <span data-ttu-id="5ea0e-198">您可以添加使用侦听器`DbInterception.Add`你的代码; 中的任意位置的方法其实不一定要在`Application_Start`方法。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-198">You can add interceptors using the `DbInterception.Add` method anywhere in your code; it doesn't have to be in the `Application_Start` method.</span></span> <span data-ttu-id="5ea0e-199">另一种方法是将此代码放入你前面创建配置执行策略的 DbConfiguration 类。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-199">Another option is to put this code in the DbConfiguration class that you created earlier to configure the execution policy.</span></span>

    [!code-csharp[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample10.cs?highlight=6-7)]

    <span data-ttu-id="5ea0e-200">只要您将此代码中，请注意不要执行`DbInterception.Add`相同的侦听器的时间超过一次，或者你将获得其他侦听器实例。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-200">Wherever you put this code, be careful not to execute `DbInterception.Add` for the same interceptor more than once, or you'll get additional interceptor instances.</span></span> <span data-ttu-id="5ea0e-201">例如，如果两次添加日志记录的侦听器，将看到两个日志对于每个 SQL 查询。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-201">For example, if you add the logging interceptor twice, you'll see two logs for every SQL query.</span></span>

    <span data-ttu-id="5ea0e-202">侦听器执行以注册顺序 (依据的顺序`DbInterception.Add`调用方法)。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-202">Interceptors are executed in the order of registration (the order in which the `DbInterception.Add` method is called).</span></span> <span data-ttu-id="5ea0e-203">顺序可能重要具体取决于你在侦听器中所执行的操作。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-203">The order might matter depending on what you're doing in the interceptor.</span></span> <span data-ttu-id="5ea0e-204">例如，侦听器可能会更改 SQL 命令可获取中`CommandText`属性。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-204">For example, an interceptor might change the SQL command that it gets in the `CommandText` property.</span></span> <span data-ttu-id="5ea0e-205">如果它确实发生更改的 SQL 命令下, 一步侦听器将获取已更改的 SQL 命令，而不是原始的 SQL 命令。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-205">If it does change the SQL command, the next interceptor will get the changed SQL command, not the original SQL command.</span></span>

    <span data-ttu-id="5ea0e-206">您已编写的暂时性错误模拟代码可以通过在 UI 中输入一个不同的值导致暂时性错误的方式。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-206">You've written the transient error simulation code in a way that lets you cause transient errors by entering a different value in the UI.</span></span> <span data-ttu-id="5ea0e-207">或者，可以编写以始终生成暂时性异常的序列，而检查特定的参数值的侦听器代码。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-207">As an alternative, you could write the interceptor code to always generate the sequence of transient exceptions without checking for a particular parameter value.</span></span> <span data-ttu-id="5ea0e-208">然后，仅当你想要生成暂时性错误时，可以添加侦听器。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-208">You could then add the interceptor only when you want to generate transient errors.</span></span> <span data-ttu-id="5ea0e-209">如果这样做，但是，数据库初始化完成后不添加到侦听器。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-209">If you do this, however, don't add the interceptor until after database initialization has completed.</span></span> <span data-ttu-id="5ea0e-210">换而言之，执行如查询一个实体集上的至少一个数据库操作，然后开始生成暂时性错误。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-210">In other words, do at least one database operation such as a query on one of your entity sets before you start generating transient errors.</span></span> <span data-ttu-id="5ea0e-211">实体框架在数据库初始化期间执行多个查询和它们在事务中，因此在初始化期间的错误可能会导致上下文才能进入不一致的状态不会执行。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-211">The Entity Framework executes several queries during database initialization, and they aren't executed in a transaction, so errors during initialization could cause the context to get into an inconsistent state.</span></span>

## <a name="test-the-new-configuration"></a><span data-ttu-id="5ea0e-212">测试新的配置</span><span class="sxs-lookup"><span data-stu-id="5ea0e-212">Test the new configuration</span></span>

1. <span data-ttu-id="5ea0e-213">按**F5**若要在调试模式下运行应用程序，然后单击**学生**选项卡。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-213">Press **F5** to run the application in debug mode, and then click the **Students** tab.</span></span>
2. <span data-ttu-id="5ea0e-214">查看 Visual Studio**输出**窗口以查看跟踪输出。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-214">Look at the Visual Studio **Output** window to see the tracing output.</span></span> <span data-ttu-id="5ea0e-215">您可能需要向上滚动过去的某些 JavaScript 错误以获取到记录器所写入的日志。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-215">You might have to scroll up past some JavaScript errors to get to the logs written by your logger.</span></span>

    <span data-ttu-id="5ea0e-216">请注意，您可以看到实际的 SQL 查询发送到数据库。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-216">Notice that you can see the actual SQL queries sent to the database.</span></span> <span data-ttu-id="5ea0e-217">您看到的一些初始查询和实体框架执行的操作以开始，请检查数据库版本的命令和迁移历史记录表 （你将了解如何迁移下一个教程中）。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-217">You see some initial queries and commands that Entity Framework does to get started, checking the database version and migration history table (you'll learn about migrations in the next tutorial).</span></span> <span data-ttu-id="5ea0e-218">和查看分页，以找出多少名学生的查询，最后您会看到获取学生数据的查询。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-218">And you see a query for paging, to find out how many students there are, and finally you see the query that gets the student data.</span></span>

    ![常规查询日志记录](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image1.png)
3. <span data-ttu-id="5ea0e-220">在中**学生**页上，输入"引发"作为搜索字符串，然后单击**搜索**。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-220">In the **Students** page, enter "Throw" as the search string, and click **Search**.</span></span>

    ![引发搜索字符串](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image2.png)

    <span data-ttu-id="5ea0e-222">您会注意到浏览器看起来时实体框架重试查询多次挂起数秒钟的时间。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-222">You'll notice that the browser seems to hang for several seconds while Entity Framework is retrying the query several times.</span></span> <span data-ttu-id="5ea0e-223">第一个重试速度非常快，然后发生之前增加每个额外的重试之前等待。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-223">The first retry happens very quickly, then the wait before increases before each additional retry.</span></span> <span data-ttu-id="5ea0e-224">此过程的调用每次重试之前再等待*指数退避算法*。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-224">This process of waiting longer before each retry is called *exponential backoff*.</span></span>

    <span data-ttu-id="5ea0e-225">当页面显示时，显示学生都有"的"在其名称中，查看输出窗口中，并你将看到相同的查询已尝试五次，第一次四次返回暂时性异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-225">When the page displays, showing students who have "an" in their names, look at the output window, and you'll see that the same query was attempted five times, the first four times returning transient exceptions.</span></span> <span data-ttu-id="5ea0e-226">对于每个暂时性错误，你将看到您在生成中的暂时性错误时编写的日志`SchoolInterceptorTransientErrors`类 （"Returning 暂时性错误命令..."），将会看到写入时的日志`SchoolInterceptorLogging`获取的异常。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-226">For each transient error you'll see the log that you write when generating the transient error in the `SchoolInterceptorTransientErrors` class ("Returning transient error for command...") and you'll see the log written when `SchoolInterceptorLogging` gets the exception.</span></span>

    ![日志记录输出显示了重试次数](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image3.png)

    <span data-ttu-id="5ea0e-228">因为您输入的搜索字符串，返回学生数据的查询已参数化：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-228">Since you entered a search string, the query that returns student data is parameterized:</span></span>

    [!code-sql[Main](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/samples/sample11.sql)]

    <span data-ttu-id="5ea0e-229">不日志记录的值的参数，但您可以这样做。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-229">You're not logging the value of the parameters, but you could do that.</span></span> <span data-ttu-id="5ea0e-230">如果想要查看参数值，则可以编写日志记录代码获取参数值从`Parameters`属性的`DbCommand`侦听器方法中获取的对象。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-230">If you want to see the parameter values, you can write logging code to get parameter values from the `Parameters` property of the `DbCommand` object that you get in the interceptor methods.</span></span>

    <span data-ttu-id="5ea0e-231">请注意，不能重复此测试，除非停止应用程序并重新启动它。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-231">Note that you can't repeat this test unless you stop the application and restart it.</span></span> <span data-ttu-id="5ea0e-232">如果你想要能够测试应用程序的单次运行中的连接复原多次，您可以编写代码来重置中的错误计数器`SchoolInterceptorTransientErrors`。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-232">If you wanted to be able to test connection resiliency multiple times in a single run of the application, you could write code to reset the error counter in `SchoolInterceptorTransientErrors`.</span></span>
4. <span data-ttu-id="5ea0e-233">若要查看不同之处执行策略 （重试策略） 发出，注释`SetExecutionStrategy`行中*SchoolConfiguration.cs*，同样，在调试模式下运行学生页上，并再次搜索"Throw"。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-233">To see the difference the execution strategy (retry policy) makes, comment out the `SetExecutionStrategy` line in *SchoolConfiguration.cs*, run the Students page in debug mode again, and search for "Throw" again.</span></span>

    <span data-ttu-id="5ea0e-234">这一次调试器停止上第一个生成的异常后尝试执行第一次的查询，将立即。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-234">This time the debugger stops on the first generated exception immediately when it tries to execute the query the first time.</span></span>

    ![虚拟异常](connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application/_static/image4.png)
5. <span data-ttu-id="5ea0e-236">取消注释*SetExecutionStrategy*行中*SchoolConfiguration.cs*。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-236">Uncomment the *SetExecutionStrategy* line in *SchoolConfiguration.cs*.</span></span>

## <a name="get-the-code"></a><span data-ttu-id="5ea0e-237">获取代码</span><span class="sxs-lookup"><span data-stu-id="5ea0e-237">Get the code</span></span>

[<span data-ttu-id="5ea0e-238">下载已完成的项目</span><span class="sxs-lookup"><span data-stu-id="5ea0e-238">Download Completed Project</span></span>](https://webpifeed.blob.core.windows.net/webpifeed/Partners/ASP.NET%20MVC%20Application%20Using%20Entity%20Framework%20Code%20First.zip)

## <a name="additional-resources"></a><span data-ttu-id="5ea0e-239">其他资源</span><span class="sxs-lookup"><span data-stu-id="5ea0e-239">Additional resources</span></span>

<span data-ttu-id="5ea0e-240">其他实体框架资源的链接可在[ASP.NET 数据访问-推荐的资源](../../../../whitepapers/aspnet-data-access-content-map.md)。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-240">Links to other Entity Framework resources can be found in [ASP.NET Data Access - Recommended Resources](../../../../whitepapers/aspnet-data-access-content-map.md).</span></span>

## <a name="next-steps"></a><span data-ttu-id="5ea0e-241">后续步骤</span><span class="sxs-lookup"><span data-stu-id="5ea0e-241">Next steps</span></span>

<span data-ttu-id="5ea0e-242">在本教程中，你将了解：</span><span class="sxs-lookup"><span data-stu-id="5ea0e-242">In this tutorial, you:</span></span>

> [!div class="checklist"]
> * <span data-ttu-id="5ea0e-243">已启用的连接复原</span><span class="sxs-lookup"><span data-stu-id="5ea0e-243">Enabled connection resiliency</span></span>
> * <span data-ttu-id="5ea0e-244">已启用的命令截获</span><span class="sxs-lookup"><span data-stu-id="5ea0e-244">Enabled command interception</span></span>
> * <span data-ttu-id="5ea0e-245">测试新的配置</span><span class="sxs-lookup"><span data-stu-id="5ea0e-245">Tested the new configuration</span></span>

<span data-ttu-id="5ea0e-246">转到下一步的文章，了解有关 Code First 迁移和 Azure 部署信息。</span><span class="sxs-lookup"><span data-stu-id="5ea0e-246">Advance to the next article to learn about Code First migrations and Azure deployment.</span></span>
> [!div class="nextstepaction"]
> [<span data-ttu-id="5ea0e-247">Code First 迁移和 Azure 部署</span><span class="sxs-lookup"><span data-stu-id="5ea0e-247">Code First migrations and Azure deployment</span></span>](migrations-and-deployment-with-the-entity-framework-in-an-asp-net-mvc-application.md)

---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: 迭代 5 — 创建单元测试 (C#) |Microsoft Docs
author: microsoft
description: 在第五个迭代中，我们使我们的应用程序更轻松地监视和修改通过添加单元测试。 我们模拟我们数据模型类和构建 o 的单元测试...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 32e81cce34a0e0b1f6b01934334e1b66dce89651
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/06/2019
ms.locfileid: "65123920"
---
# <a name="iteration-5--create-unit-tests-c"></a><span data-ttu-id="73393-104">迭代 5 — 创建单元测试 (C#)</span><span class="sxs-lookup"><span data-stu-id="73393-104">Iteration #5 – Create unit tests (C#)</span></span>

<span data-ttu-id="73393-105">by [Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="73393-105">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="73393-106">下载代码</span><span class="sxs-lookup"><span data-stu-id="73393-106">Download Code</span></span>](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> <span data-ttu-id="73393-107">在第五个迭代中，我们使我们的应用程序更轻松地监视和修改通过添加单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-107">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="73393-108">我们模拟我们数据模型类，并生成为控制器和验证逻辑单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-108">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a><span data-ttu-id="73393-109">生成联系人管理 ASP.NET MVC 应用程序 (C#)</span><span class="sxs-lookup"><span data-stu-id="73393-109">Building a Contact Management ASP.NET MVC Application (C#)</span></span>

<span data-ttu-id="73393-110">在本系列教程，我们构建整个联系人管理应用程序从头到尾完成。</span><span class="sxs-lookup"><span data-stu-id="73393-110">In this series of tutorials, we build an entire Contact Management application from start to finish.</span></span> <span data-ttu-id="73393-111">联系人管理器应用程序，可存储联系人信息的名称，电话号码和电子邮件地址的人的列表。</span><span class="sxs-lookup"><span data-stu-id="73393-111">The Contact Manager application enables you to store contact information - names, phone numbers and email addresses - for a list of people.</span></span>

<span data-ttu-id="73393-112">我们通过多个迭代中生成应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-112">We build the application over multiple iterations.</span></span> <span data-ttu-id="73393-113">每次迭代时，我们逐渐提高应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-113">With each iteration, we gradually improve the application.</span></span> <span data-ttu-id="73393-114">此多个迭代方法的目标是帮助你了解每个更改的原因。</span><span class="sxs-lookup"><span data-stu-id="73393-114">The goal of this multiple iteration approach is to enable you to understand the reason for each change.</span></span>

- <span data-ttu-id="73393-115">迭代 1-创建应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-115">Iteration #1 - Create the application.</span></span> <span data-ttu-id="73393-116">在第一次迭代中，我们创建联系人管理器中的最简单方法可能。</span><span class="sxs-lookup"><span data-stu-id="73393-116">In the first iteration, we create the Contact Manager in the simplest way possible.</span></span> <span data-ttu-id="73393-117">我们将添加对基本数据库操作的支持：创建、 读取、 更新和删除 (CRUD)。</span><span class="sxs-lookup"><span data-stu-id="73393-117">We add support for basic database operations: Create, Read, Update, and Delete (CRUD).</span></span>

- <span data-ttu-id="73393-118">迭代 2 – 使应用程序看上去更美观。</span><span class="sxs-lookup"><span data-stu-id="73393-118">Iteration #2 - Make the application look nice.</span></span> <span data-ttu-id="73393-119">在此迭代中，我们通过修改默认 ASP.NET MVC 视图母版页和级联样式表提高应用程序的外观。</span><span class="sxs-lookup"><span data-stu-id="73393-119">In this iteration, we improve the appearance of the application by modifying the default ASP.NET MVC view master page and cascading style sheet.</span></span>

- <span data-ttu-id="73393-120">迭代 3-添加窗体验证。</span><span class="sxs-lookup"><span data-stu-id="73393-120">Iteration #3 - Add form validation.</span></span> <span data-ttu-id="73393-121">在第三个迭代中，我们将添加基本窗体验证。</span><span class="sxs-lookup"><span data-stu-id="73393-121">In the third iteration, we add basic form validation.</span></span> <span data-ttu-id="73393-122">我们阻止用户提交窗体而无法完成所需的窗体字段。</span><span class="sxs-lookup"><span data-stu-id="73393-122">We prevent people from submitting a form without completing required form fields.</span></span> <span data-ttu-id="73393-123">我们还验证电子邮件地址和电话号码。</span><span class="sxs-lookup"><span data-stu-id="73393-123">We also validate email addresses and phone numbers.</span></span>

- <span data-ttu-id="73393-124">迭代 4-使应用程序松散耦合。</span><span class="sxs-lookup"><span data-stu-id="73393-124">Iteration #4 - Make the application loosely coupled.</span></span> <span data-ttu-id="73393-125">在此第四个迭代中，我们将充分利用多个软件设计模式，以使其更轻松地监视和修改联系人管理器应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-125">In this fourth iteration, we take advantage of several software design patterns to make it easier to maintain and modify the Contact Manager application.</span></span> <span data-ttu-id="73393-126">例如，我们将重构应用程序以使用存储库模式和依赖关系注入模式。</span><span class="sxs-lookup"><span data-stu-id="73393-126">For example, we refactor our application to use the Repository pattern and the Dependency Injection pattern.</span></span>

- <span data-ttu-id="73393-127">迭代 5 — 创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-127">Iteration #5 - Create unit tests.</span></span> <span data-ttu-id="73393-128">在第五个迭代中，我们使我们的应用程序更轻松地监视和修改通过添加单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-128">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="73393-129">我们模拟我们数据模型类，并生成为控制器和验证逻辑单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-129">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

- <span data-ttu-id="73393-130">迭代 6-使用测试驱动的开发。</span><span class="sxs-lookup"><span data-stu-id="73393-130">Iteration #6 - Use test-driven development.</span></span> <span data-ttu-id="73393-131">在此第六个迭代中，我们将添加新功能到我们的应用程序通过首先编写单元测试并针对单元测试编写的代码。</span><span class="sxs-lookup"><span data-stu-id="73393-131">In this sixth iteration, we add new functionality to our application by writing unit tests first and writing code against the unit tests.</span></span> <span data-ttu-id="73393-132">在此迭代中，我们将添加联系人组。</span><span class="sxs-lookup"><span data-stu-id="73393-132">In this iteration, we add contact groups.</span></span>

- <span data-ttu-id="73393-133">迭代 7-添加 Ajax 功能。</span><span class="sxs-lookup"><span data-stu-id="73393-133">Iteration #7 - Add Ajax functionality.</span></span> <span data-ttu-id="73393-134">在第七个迭代中，我们通过添加对 Ajax 支持提高响应能力和我们的应用程序的性能。</span><span class="sxs-lookup"><span data-stu-id="73393-134">In the seventh iteration, we improve the responsiveness and performance of our application by adding support for Ajax.</span></span>

## <a name="this-iteration"></a><span data-ttu-id="73393-135">此迭代</span><span class="sxs-lookup"><span data-stu-id="73393-135">This Iteration</span></span>

<span data-ttu-id="73393-136">上一次迭代中的联系人管理器应用程序，我们可以重构要更为松散耦合的应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-136">In the previous iteration of the Contact Manager application, we refactored the application to be more loosely coupled.</span></span> <span data-ttu-id="73393-137">我们分隔到不同的控制器、 服务和存储库层应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-137">We separated the application into distinct controller, service, and repository layers.</span></span> <span data-ttu-id="73393-138">与通过接口在它下面的层交互，每个层。</span><span class="sxs-lookup"><span data-stu-id="73393-138">Each layer interacts with the layer beneath it through interfaces.</span></span>

<span data-ttu-id="73393-139">我们重构应用程序，以便更轻松地监视和修改应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-139">We refactored the application to make the application easier to maintain and modify.</span></span> <span data-ttu-id="73393-140">例如，如果我们需要使用新的数据访问技术，我们只需可以直接更改存储库层，而无需涉及控制器或服务层。</span><span class="sxs-lookup"><span data-stu-id="73393-140">For example, if we need to use a new data access technology, we can simply change the repository layer without touching the controller or service layer.</span></span> <span data-ttu-id="73393-141">松散耦合，联系人管理器发出我们进行了应用程序更具弹性，若要更改。</span><span class="sxs-lookup"><span data-stu-id="73393-141">By making the Contact Manager loosely coupled, we ve made the application more resilient to change.</span></span>

<span data-ttu-id="73393-142">但是，当我们需要将一项新功能添加到联系人管理器应用程序时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="73393-142">But, what happens when we need to add a new feature to the Contact Manager application?</span></span> <span data-ttu-id="73393-143">或者，当我们修复 bug 时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="73393-143">Or, what happens when we fix a bug?</span></span> <span data-ttu-id="73393-144">编写代码的一个很遗憾，但也经实践证明的事实是，每当改动代码创建引入新 bug 的风险。</span><span class="sxs-lookup"><span data-stu-id="73393-144">A sad, but well proven, truth of writing code is that whenever you touch code you create the risk of introducing new bugs.</span></span>

<span data-ttu-id="73393-145">例如，一个的最好时期，你的经理可能会要求你添加到联系人管理器中的一项新功能。</span><span class="sxs-lookup"><span data-stu-id="73393-145">For example, one fine day, your manager might ask you to add a new feature to the Contact Manager.</span></span> <span data-ttu-id="73393-146">她希望您将添加对联系人组的支持。</span><span class="sxs-lookup"><span data-stu-id="73393-146">She wants you to add support for Contact Groups.</span></span> <span data-ttu-id="73393-147">她希望您为了使用户能够将其联系人组织成组如朋友、 业务和等等。</span><span class="sxs-lookup"><span data-stu-id="73393-147">She wants you to enable users to organize their contacts into groups such as Friends, Business, and so on.</span></span>

<span data-ttu-id="73393-148">为了实现这一新功能，您将需要修改的联系人管理器应用程序的所有三个层。</span><span class="sxs-lookup"><span data-stu-id="73393-148">In order to implement this new feature, you'll need to modify all three layers of the Contact Manager application.</span></span> <span data-ttu-id="73393-149">你将需要将新功能添加到服务层，并在存储库的所有控制器。</span><span class="sxs-lookup"><span data-stu-id="73393-149">You'll need to add new functionality to the controllers, the service layer, and the repository.</span></span> <span data-ttu-id="73393-150">一旦您开始修改代码，则可能会破坏正常运行过的功能。</span><span class="sxs-lookup"><span data-stu-id="73393-150">As soon as you start modifying code, you risk breaking functionality that worked before.</span></span>

<span data-ttu-id="73393-151">正如我们在上一次迭代，做重构到不同的层，我们的应用程序是一件好事。</span><span class="sxs-lookup"><span data-stu-id="73393-151">Refactoring our application into separate layers, as we did in the previous iteration, was a good thing.</span></span> <span data-ttu-id="73393-152">它是一件好事，因为它使我们能够对整个层进行更改，无需接触应用程序的其余部分。</span><span class="sxs-lookup"><span data-stu-id="73393-152">It was a good thing because it enables us to make changes to entire layers without touching the rest of the application.</span></span> <span data-ttu-id="73393-153">但是，如果你想要使在层内的代码更易于维护和修改，则需要创建单元测试的代码。</span><span class="sxs-lookup"><span data-stu-id="73393-153">However, if you want to make the code within a layer easier to maintain and modify, you need to create unit tests for the code.</span></span>

<span data-ttu-id="73393-154">你使用单元测试来测试单个代码单元。</span><span class="sxs-lookup"><span data-stu-id="73393-154">You use a unit test to test an individual unit of code.</span></span> <span data-ttu-id="73393-155">这些单位代码是小于整个应用程序层。</span><span class="sxs-lookup"><span data-stu-id="73393-155">These units of code are smaller than entire application layers.</span></span> <span data-ttu-id="73393-156">通常情况下，您可以使用单元测试以验证你的代码中的特定方法的行为是否在预期的方式。</span><span class="sxs-lookup"><span data-stu-id="73393-156">Typically, you use a unit test to verify whether a particular method in your code behaves in the way that you expect.</span></span> <span data-ttu-id="73393-157">例如，将创建由 ContactManagerService 类公开的 CreateContact() 方法的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-157">For example, you would create a unit test for the CreateContact() method exposed by the ContactManagerService class.</span></span>

<span data-ttu-id="73393-158">只是应用程序工作的单元测试，如网络安全。</span><span class="sxs-lookup"><span data-stu-id="73393-158">The unit tests for an application work just like a safety net.</span></span> <span data-ttu-id="73393-159">每当修改代码的应用程序，可以运行单元测试，以检查是否修改中断现有功能的一组。</span><span class="sxs-lookup"><span data-stu-id="73393-159">Whenever you modify code in an application, you can run a set of unit tests to check whether the modification breaks existing functionality.</span></span> <span data-ttu-id="73393-160">单元测试使您的代码安全地修改。</span><span class="sxs-lookup"><span data-stu-id="73393-160">Unit tests make your code safe to modify.</span></span> <span data-ttu-id="73393-161">单元测试的所有代码中进行应用程序更具弹性，若要更改。</span><span class="sxs-lookup"><span data-stu-id="73393-161">Unit tests make all of the code in your application more resilient to change.</span></span>

<span data-ttu-id="73393-162">在此迭代中，我们将单元测试添加到我们的联系人管理器应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-162">In this iteration, we add unit tests to our Contact Manager application.</span></span> <span data-ttu-id="73393-163">这样一来，在下一个迭代中，我们可以添加联系人组对我们的应用程序而无需担心破坏现有功能。</span><span class="sxs-lookup"><span data-stu-id="73393-163">That way, in the next iteration, we can add Contact Groups to our application without worrying about breaking existing functionality.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="73393-164">多种测试框架，包括 NUnit 和 xUnit.net，MbUnit 的单元。</span><span class="sxs-lookup"><span data-stu-id="73393-164">There are a variety of unit testing frameworks including NUnit, xUnit.net, and MbUnit.</span></span> <span data-ttu-id="73393-165">在本教程中，我们使用的单元测试框架与 Visual Studio 附带。</span><span class="sxs-lookup"><span data-stu-id="73393-165">In this tutorial, we use the unit testing framework included with Visual Studio.</span></span> <span data-ttu-id="73393-166">但是，您可以轻松地使用其中一种替代框架。</span><span class="sxs-lookup"><span data-stu-id="73393-166">However, you could just as easily use one of these alternative frameworks.</span></span>

## <a name="what-gets-tested"></a><span data-ttu-id="73393-167">获取测试内容</span><span class="sxs-lookup"><span data-stu-id="73393-167">What Gets Tested</span></span>

<span data-ttu-id="73393-168">在理想情况下，所有代码将包含一些单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-168">In the perfect world, all of your code would be covered by unit tests.</span></span> <span data-ttu-id="73393-169">在理想情况下，您必须完美的网络安全。</span><span class="sxs-lookup"><span data-stu-id="73393-169">In the perfect world, you would have the perfect safety net.</span></span> <span data-ttu-id="73393-170">您可以修改应用程序中代码的任何行，并就可马上知道，通过执行单元测试，是否更改中断了现有功能。</span><span class="sxs-lookup"><span data-stu-id="73393-170">You would be able to modify any line of code in your application and know instantly, by executing your unit tests, whether the change broke existing functionality.</span></span>

<span data-ttu-id="73393-171">但是，我们并不完美的世界中的实时 t。</span><span class="sxs-lookup"><span data-stu-id="73393-171">However, we don t live in a perfect world.</span></span> <span data-ttu-id="73393-172">在实践中，编写单元测试时，您专注于编写您的业务逻辑 （例如，验证逻辑） 的测试。</span><span class="sxs-lookup"><span data-stu-id="73393-172">In practice, when writing unit tests, you concentrate on writing tests for your business logic (for example, validation logic).</span></span> <span data-ttu-id="73393-173">具体而言，你*不这样做*编写单元测试为你的数据访问逻辑或视图逻辑。</span><span class="sxs-lookup"><span data-stu-id="73393-173">In particular, you *do not* write unit tests for your data access logic or your view logic.</span></span>

<span data-ttu-id="73393-174">若要很有用，单元测试必须执行非常快速地。</span><span class="sxs-lookup"><span data-stu-id="73393-174">To be useful, unit tests must execute very quickly.</span></span> <span data-ttu-id="73393-175">您轻松地可能会累积 （成百上千台） 的应用程序的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-175">You easily can accumulate hundreds (or even thousands) of unit tests for an application.</span></span> <span data-ttu-id="73393-176">如果单元测试可能需要很长时间才能运行您要防止执行它们。</span><span class="sxs-lookup"><span data-stu-id="73393-176">If the unit tests take a long time to run then you'll avoid executing them.</span></span> <span data-ttu-id="73393-177">换而言之，长时间运行的单元测试是无用的日常编码用途。</span><span class="sxs-lookup"><span data-stu-id="73393-177">In other words, long running unit tests are useless for day to day coding purposes.</span></span>

<span data-ttu-id="73393-178">出于此原因，您通常做不编写与数据库交互的代码的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-178">For this reason, you typically do not write unit tests for code that interacts with a database.</span></span> <span data-ttu-id="73393-179">针对实时数据库运行数百个单元测试会太慢。</span><span class="sxs-lookup"><span data-stu-id="73393-179">Running hundreds of unit tests against a live database would be too slow.</span></span> <span data-ttu-id="73393-180">不过，您可以模拟你的数据库，编写与 （我们讨论模拟以下数据库） 的模拟数据库交互的代码。</span><span class="sxs-lookup"><span data-stu-id="73393-180">Instead, you mock your database and write code that interacts with the mock database (we discuss mocking a database below).</span></span>

<span data-ttu-id="73393-181">出于类似原因，您通常不写入视图的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-181">For a similar reason, you typically do not write unit tests for views.</span></span> <span data-ttu-id="73393-182">若要测试一个视图，必须启动 web 服务器。</span><span class="sxs-lookup"><span data-stu-id="73393-182">In order to test a view, you must spin up a web server.</span></span> <span data-ttu-id="73393-183">由于启动 web 服务器是一个相对较慢的过程，不建议创建单元测试您的视图。</span><span class="sxs-lookup"><span data-stu-id="73393-183">Because spinning up a web server is a relatively slow process, creating unit tests for your views is not recommended.</span></span>

<span data-ttu-id="73393-184">如果您的视图包含复杂的逻辑则应考虑将逻辑移到帮助程序方法。</span><span class="sxs-lookup"><span data-stu-id="73393-184">If your view contains complicated logic then you should consider moving the logic into Helper methods.</span></span> <span data-ttu-id="73393-185">您可以编写单元测试的执行而无需启动 web 服务器的帮助器方法。</span><span class="sxs-lookup"><span data-stu-id="73393-185">You can write unit tests for Helper methods that execute without spinning up a web server.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="73393-186">虽然编写测试的数据访问逻辑或视图逻辑不是一个不错的主意，编写单元测试时，这些测试可能会非常有价值，构建功能或集成测试时。</span><span class="sxs-lookup"><span data-stu-id="73393-186">While writing tests for data access logic or view logic is not a good idea when writing unit tests, these tests can be very valuable when building functional or integration tests.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="73393-187">ASP.NET MVC 是 Web 窗体视图引擎。</span><span class="sxs-lookup"><span data-stu-id="73393-187">ASP.NET MVC is the Web Forms View Engine.</span></span> <span data-ttu-id="73393-188">Web 窗体视图引擎依赖于 web 服务器时，可能不是其他视图引擎。</span><span class="sxs-lookup"><span data-stu-id="73393-188">While the Web Forms View Engine is dependent on a web server, other view engines might not be.</span></span>

## <a name="using-a-mock-object-framework"></a><span data-ttu-id="73393-189">使用模拟对象框架</span><span class="sxs-lookup"><span data-stu-id="73393-189">Using a Mock Object Framework</span></span>

<span data-ttu-id="73393-190">在生成单元测试时，几乎总是需要利用的模拟对象框架。</span><span class="sxs-lookup"><span data-stu-id="73393-190">When building unit tests, you almost always need to take advantage of a Mock Object framework.</span></span> <span data-ttu-id="73393-191">模拟对象框架，可在应用程序中创建模拟和存根 （stub） 的类。</span><span class="sxs-lookup"><span data-stu-id="73393-191">A Mock Object framework enables you to create mocks and stubs for the classes in your application.</span></span>

<span data-ttu-id="73393-192">例如，可以使用模拟对象框架来生成你的存储库类的模型版本。</span><span class="sxs-lookup"><span data-stu-id="73393-192">For example, you can use a Mock Object framework to generate a mock version of your repository class.</span></span> <span data-ttu-id="73393-193">这样一来，您可以使用模拟存储库类而不是实际的存储库类在单元测试中。</span><span class="sxs-lookup"><span data-stu-id="73393-193">That way, you can use the mock repository class instead of the real repository class in your unit tests.</span></span> <span data-ttu-id="73393-194">使用模拟的存储库，可避免执行数据库的代码执行单元测试时。</span><span class="sxs-lookup"><span data-stu-id="73393-194">Using the mock repository enables you to avoid executing database code when executing a unit test.</span></span>

<span data-ttu-id="73393-195">Visual Studio 不会包含模拟对象框架。</span><span class="sxs-lookup"><span data-stu-id="73393-195">Visual Studio does not include a Mock Object framework.</span></span> <span data-ttu-id="73393-196">但是，有可用于.NET framework 的多个商业和开源模拟对象框架：</span><span class="sxs-lookup"><span data-stu-id="73393-196">However, there are several commercial and open source Mock Object frameworks available for the .NET framework:</span></span>

1. <span data-ttu-id="73393-197">Moq-此框架是开放源 BSD 许可下提供。</span><span class="sxs-lookup"><span data-stu-id="73393-197">Moq - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="73393-198">您可以下载从 Moq [ https://code.google.com/p/moq/ ](https://code.google.com/p/moq/)。</span><span class="sxs-lookup"><span data-stu-id="73393-198">You can download Moq from [https://code.google.com/p/moq/](https://code.google.com/p/moq/).</span></span>
2. <span data-ttu-id="73393-199">Rhino Mocks-此框架是开放源 BSD 许可下提供。</span><span class="sxs-lookup"><span data-stu-id="73393-199">Rhino Mocks - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="73393-200">您可以下载从 Rhino Mocks [ http://ayende.com/projects/rhino-mocks.aspx ](http://ayende.com/projects/rhino-mocks.aspx)。</span><span class="sxs-lookup"><span data-stu-id="73393-200">You can download Rhino Mocks from [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).</span></span>
3. <span data-ttu-id="73393-201">Typemock Isolator-这是一个商业的框架。</span><span class="sxs-lookup"><span data-stu-id="73393-201">Typemock Isolator - This is a commercial framework.</span></span> <span data-ttu-id="73393-202">您可以下载从试用版[ http://www.typemock.com/ ](http://www.typemock.com/)。</span><span class="sxs-lookup"><span data-stu-id="73393-202">You can download a trial version from [http://www.typemock.com/](http://www.typemock.com/).</span></span>

<span data-ttu-id="73393-203">在本教程中，我决定使用 Moq。</span><span class="sxs-lookup"><span data-stu-id="73393-203">In this tutorial, I decided to use Moq.</span></span> <span data-ttu-id="73393-204">但是，您可以轻松地使用 Rhino Mocks 或 Typemock Isolator 创建 Mock 对象为联系人管理器应用程序。</span><span class="sxs-lookup"><span data-stu-id="73393-204">However, you could just as easily use Rhino Mocks or Typemock Isolator to create the Mock objects for the Contact Manager application.</span></span>

<span data-ttu-id="73393-205">可以使用 Moq 之前，需要完成以下步骤：</span><span class="sxs-lookup"><span data-stu-id="73393-205">Before you can use Moq, you need to complete the following steps:</span></span>

1. <span data-ttu-id="73393-206">.</span><span class="sxs-lookup"><span data-stu-id="73393-206">.</span></span>
2. <span data-ttu-id="73393-207">解压缩下载之前，请确保右键单击该文件，并单击标记的按钮**解除阻止**（参见图 1）。</span><span class="sxs-lookup"><span data-stu-id="73393-207">Before you unzip the download, make sure that you right-click the file and click the button labeled **Unblock** (see Figure 1).</span></span>
3. <span data-ttu-id="73393-208">解压缩下载。</span><span class="sxs-lookup"><span data-stu-id="73393-208">Unzip the download.</span></span>
4. <span data-ttu-id="73393-209">右键单击 ContactManager.Tests 项目中的引用文件夹并选择添加对 Moq 程序集的引用**添加引用**。</span><span class="sxs-lookup"><span data-stu-id="73393-209">Add a reference to the Moq assembly by right-clicking the References folder in the ContactManager.Tests project and selecting **Add Reference**.</span></span> <span data-ttu-id="73393-210">在浏览选项卡，浏览到你在其中解压缩 Moq 文件夹并选择 Moq.dll 程序集。</span><span class="sxs-lookup"><span data-stu-id="73393-210">Under the Browse tab, browse to the folder where you unzipped Moq and select the Moq.dll assembly.</span></span> <span data-ttu-id="73393-211">单击**确定**按钮。</span><span class="sxs-lookup"><span data-stu-id="73393-211">Click the **OK** button.</span></span>
5. <span data-ttu-id="73393-212">完成这些步骤后，在引用文件夹应如图 2 所示。</span><span class="sxs-lookup"><span data-stu-id="73393-212">After you complete these steps, your References folder should look like Figure 2.</span></span>

<span data-ttu-id="73393-213">[![取消阻塞 Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="73393-213">[![Unblocking Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span></span>

<span data-ttu-id="73393-214">**图 01**:取消阻塞 Moq ([单击此项可查看原尺寸图像](iteration-5-create-unit-tests-cs/_static/image2.png))</span><span class="sxs-lookup"><span data-stu-id="73393-214">**Figure 01**: Unblocking Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image2.png))</span></span>

<span data-ttu-id="73393-215">[![添加 Moq 后引用](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="73393-215">[![References after adding Moq](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span></span>

<span data-ttu-id="73393-216">**图 02**:添加 Moq 后的引用 ([单击此项可查看原尺寸图像](iteration-5-create-unit-tests-cs/_static/image4.png))</span><span class="sxs-lookup"><span data-stu-id="73393-216">**Figure 02**: References after adding Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image4.png))</span></span>

## <a name="creating-unit-tests-for-the-service-layer"></a><span data-ttu-id="73393-217">为服务层创建单元测试</span><span class="sxs-lookup"><span data-stu-id="73393-217">Creating Unit Tests for the Service Layer</span></span>

<span data-ttu-id="73393-218">让我们来首先创建一组我们联系人管理器应用程序 s 的服务层的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-218">Let s start by creating a set of unit tests for our Contact Manager application s service layer.</span></span> <span data-ttu-id="73393-219">我们将使用这些测试来验证我们的验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="73393-219">We'll use these tests to verify our validation logic.</span></span>

<span data-ttu-id="73393-220">创建 ContactManager.Tests 项目中名为 Models 的新文件夹。</span><span class="sxs-lookup"><span data-stu-id="73393-220">Create a new folder named Models in the ContactManager.Tests project.</span></span> <span data-ttu-id="73393-221">接下来，右键单击模型文件夹并选择**添加、 新测试**。</span><span class="sxs-lookup"><span data-stu-id="73393-221">Next, right-click the Models folder and select **Add, New Test**.</span></span> <span data-ttu-id="73393-222">**添加新测试**此时将显示图 3 所示的对话框。</span><span class="sxs-lookup"><span data-stu-id="73393-222">The **Add New Test** dialog shown in Figure 3 appears.</span></span> <span data-ttu-id="73393-223">选择**单元测试**模板并命名新测试 ContactManagerServiceTest.cs。</span><span class="sxs-lookup"><span data-stu-id="73393-223">Select the **Unit Test** template and name your new test ContactManagerServiceTest.cs.</span></span> <span data-ttu-id="73393-224">单击**确定**按钮将新测试添加到测试项目。</span><span class="sxs-lookup"><span data-stu-id="73393-224">Click the **OK** button to add your new test to your Test Project.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="73393-225">一般情况下，所需测试项目以匹配你的 ASP.NET MVC 项目的文件夹结构的文件夹的结构。</span><span class="sxs-lookup"><span data-stu-id="73393-225">In general, you want the folder structure of your Test Project to match the folder structure of your ASP.NET MVC project.</span></span> <span data-ttu-id="73393-226">例如，您将测试控制器放置在控制器文件夹中，在模型文件夹中，模型测试等。</span><span class="sxs-lookup"><span data-stu-id="73393-226">For example, you place controller tests in a Controllers folder, model tests in a Models folder, and so on.</span></span>

<span data-ttu-id="73393-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="73393-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span></span>

<span data-ttu-id="73393-228">**图 03**:Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="73393-228">**Figure 03**: Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span></span>

<span data-ttu-id="73393-229">最初，我们想要测试由 ContactManagerService 类公开的 CreateContact() 方法。</span><span class="sxs-lookup"><span data-stu-id="73393-229">Initially, we want to test the CreateContact() method exposed by the ContactManagerService class.</span></span> <span data-ttu-id="73393-230">我们将创建以下五个测试：</span><span class="sxs-lookup"><span data-stu-id="73393-230">We'll create the following five tests:</span></span>

- <span data-ttu-id="73393-231">CreateContact()-向方法传递了有效的联系人时，测试该 CreateContact() 返回值 true。</span><span class="sxs-lookup"><span data-stu-id="73393-231">CreateContact() - Tests that CreateContact() returns the value true when a valid Contact is passed to the method.</span></span>
- <span data-ttu-id="73393-232">CreateContactRequiredFirstName()-CreateContact() 方法被通过的测试，将一条错误消息添加到模型状态时缺少的名字的联系人。</span><span class="sxs-lookup"><span data-stu-id="73393-232">CreateContactRequiredFirstName() - Tests that an error message is added to model state when a Contact with a missing first name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="73393-233">CreateContactRequiredLastName()-CreateContact() 方法被通过的测试，将一条错误消息添加到模型状态时缺少姓氏的联系人。</span><span class="sxs-lookup"><span data-stu-id="73393-233">CreateContactRequiredLastName() - Tests that an error message is added to model state when a Contact with a missing last name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="73393-234">CreateContactInvalidPhone()-CreateContact() 方法被通过的测试，将一条错误消息添加到模型状态时的联系人电话号码无效。</span><span class="sxs-lookup"><span data-stu-id="73393-234">CreateContactInvalidPhone() - Tests that an error message is added to model state when a Contact with an invalid phone number is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="73393-235">CreateContactInvalidEmail()-测试，将一条错误消息添加到模型状态无效的电子邮件地址的联系人时传递给 CreateContact() 方法...</span><span class="sxs-lookup"><span data-stu-id="73393-235">CreateContactInvalidEmail() - Tests that an error message is added to model state when a Contact with an invalid email address is passed to the CreateContact() method..</span></span>

<span data-ttu-id="73393-236">第一个测试验证了有效的联系人不会生成验证错误。</span><span class="sxs-lookup"><span data-stu-id="73393-236">The first test verifies that a valid Contact does not generate a validation error.</span></span> <span data-ttu-id="73393-237">剩余测试检查每个验证规则。</span><span class="sxs-lookup"><span data-stu-id="73393-237">The remaining tests check each of the validation rules.</span></span>

<span data-ttu-id="73393-238">对于这些测试的代码包含在列表 1 中。</span><span class="sxs-lookup"><span data-stu-id="73393-238">The code for these tests is contained in Listing 1.</span></span>

<span data-ttu-id="73393-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span><span class="sxs-lookup"><span data-stu-id="73393-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

<span data-ttu-id="73393-240">由于我们在列表 1 中使用 Contact 类，我们需要将对 Microsoft 实体框架的引用添加到我们的测试项目。</span><span class="sxs-lookup"><span data-stu-id="73393-240">Because we use the Contact class in Listing 1, we need to add a reference to the Microsoft Entity Framework to our Test project.</span></span> <span data-ttu-id="73393-241">添加对 system.data.entity 的引用程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="73393-241">Add a reference to the System.Data.Entity assembly.</span></span>

<span data-ttu-id="73393-242">代码清单 1 包含一个名为使用 [TestInitialize] 特性修饰的 initialize （） 方法。</span><span class="sxs-lookup"><span data-stu-id="73393-242">Listing 1 contains a method named Initialize() that is decorated with the [TestInitialize] attribute.</span></span> <span data-ttu-id="73393-243">每个单元测试运行之前自动调用此方法 （它每个单元测试前调用 5 次）。</span><span class="sxs-lookup"><span data-stu-id="73393-243">This method is called automatically before each of the unit tests is run (it is called 5 times right before each of the unit tests).</span></span> <span data-ttu-id="73393-244">使用以下代码行，initialize （） 方法创建 mock 存储库：</span><span class="sxs-lookup"><span data-stu-id="73393-244">The Initialize() method creates a mock repository with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

<span data-ttu-id="73393-245">这行代码使用 Moq 框架来生成从 IContactManagerRepository 接口的 mock 存储库。</span><span class="sxs-lookup"><span data-stu-id="73393-245">This line of code uses the Moq framework to generate a mock repository from the IContactManagerRepository interface.</span></span> <span data-ttu-id="73393-246">Mock 存储库而不是实际 EntityContactManagerRepository 用于避免在每个单元测试运行时访问数据库。</span><span class="sxs-lookup"><span data-stu-id="73393-246">The mock repository is used instead of the actual EntityContactManagerRepository to avoid accessing the database when each unit test is run.</span></span> <span data-ttu-id="73393-247">Mock 存储库实现 IContactManagerRepository 接口的方法，但方法 don t 实际执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="73393-247">The mock repository implements the methods of the IContactManagerRepository interface, but the methods don t actually do anything.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="73393-248">使用 Moq 框架时，会区分\_mockRepository 和\_mockRepository.Object。</span><span class="sxs-lookup"><span data-stu-id="73393-248">When using the Moq framework, there is a distinction between \_mockRepository and \_mockRepository.Object.</span></span> <span data-ttu-id="73393-249">前者是指模拟&lt;IContactManagerRepository&gt;类，其中包含用于指定模拟存储库的行为方式的方法。</span><span class="sxs-lookup"><span data-stu-id="73393-249">The former refers to the Mock&lt;IContactManagerRepository&gt; class that contains methods for specifying how the mock repository will behave.</span></span> <span data-ttu-id="73393-250">后者是指实际的 mock 存储库，实现 IContactManagerRepository 接口。</span><span class="sxs-lookup"><span data-stu-id="73393-250">The latter refers to the actual mock repository that implements the IContactManagerRepository interface.</span></span>

<span data-ttu-id="73393-251">创建 ContactManagerService 类的实例时，将在 initialize （） 方法中使用模拟的存储库。</span><span class="sxs-lookup"><span data-stu-id="73393-251">The mock repository is used in the Initialize() method when creating an instance of the ContactManagerService class.</span></span> <span data-ttu-id="73393-252">所有的各个单元测试使用 ContactManagerService 类的此实例。</span><span class="sxs-lookup"><span data-stu-id="73393-252">All of the individual unit tests use this instance of the ContactManagerService class.</span></span>

<span data-ttu-id="73393-253">代码清单 1 包含五个方法对应于每个单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-253">Listing 1 contains five methods that correspond to each of the unit tests.</span></span> <span data-ttu-id="73393-254">每种方法是使用 [TestMethod] 特性修饰。</span><span class="sxs-lookup"><span data-stu-id="73393-254">Each of these methods is decorated with the [TestMethod] attribute.</span></span> <span data-ttu-id="73393-255">当您运行单元测试时，被调用具有此属性的任何方法。</span><span class="sxs-lookup"><span data-stu-id="73393-255">When you run the unit tests, any method that has this attribute is called.</span></span> <span data-ttu-id="73393-256">换而言之，任何使用 [TestMethod] 特性修饰的方法是单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-256">In other words, any method that is decorated with the [TestMethod] attribute is a unit test.</span></span>

<span data-ttu-id="73393-257">第一个单元测试，名为 CreateContact()，验证，有效 Contact 类的实例传递给方法时，调用 CreateContact() 返回值 true。</span><span class="sxs-lookup"><span data-stu-id="73393-257">The first unit test, named CreateContact(), verifies that calling CreateContact() returns the value true when a valid instance of the Contact class is passed to the method.</span></span> <span data-ttu-id="73393-258">测试创建 Contact 类的实例，调用 CreateContact() 方法，并验证 CreateContact() 返回值 true。</span><span class="sxs-lookup"><span data-stu-id="73393-258">The test creates an instance of the Contact class, calls the CreateContact() method, and verifies that CreateContact() returns the value true.</span></span>

<span data-ttu-id="73393-259">剩余测试验证，当使用无效的联系人调用 CreateContact() 方法然后方法返回 false，预期的验证错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="73393-259">The remaining tests verify that when the CreateContact() method is called with an invalid Contact then the method returns false and the expected validation error message is added to model state.</span></span> <span data-ttu-id="73393-260">例如，CreateContactRequiredFirstName() 测试与空字符串作为其 FirstName 属性创建联系人类的实例。</span><span class="sxs-lookup"><span data-stu-id="73393-260">For example, the CreateContactRequiredFirstName() test creates an instance of the Contact class with an empty string for its FirstName property.</span></span> <span data-ttu-id="73393-261">接下来，使用无效的联系人调用 CreateContact() 方法。</span><span class="sxs-lookup"><span data-stu-id="73393-261">Next, the CreateContact() method is called with the invalid Contact.</span></span> <span data-ttu-id="73393-262">最后，此测试将验证 CreateContact() 返回 false，并且模型状态包含预期的验证错误消息"名字是必填。"</span><span class="sxs-lookup"><span data-stu-id="73393-262">Finally, the test verifies that CreateContact() returns false and that model state contains the expected validation error message "First name is required."</span></span>

<span data-ttu-id="73393-263">可以通过选择菜单选项在列表 1 中运行单元测试**测试，运行，解决方案 （CTRL + R、 A） 中的所有测试**。</span><span class="sxs-lookup"><span data-stu-id="73393-263">You can run the unit tests in Listing 1 by selecting the menu option **Test, Run, All Tests in Solution (CTRL+R, A)**.</span></span> <span data-ttu-id="73393-264">在测试结果窗口中显示测试结果 （请参阅图 4）。</span><span class="sxs-lookup"><span data-stu-id="73393-264">The results of the tests are displayed in the Test Results window (see Figure 4).</span></span>

<span data-ttu-id="73393-265">[![测试结果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="73393-265">[![Test Results](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span></span>

<span data-ttu-id="73393-266">**图 04**:测试结果 ([单击此项可查看原尺寸图像](iteration-5-create-unit-tests-cs/_static/image8.png))</span><span class="sxs-lookup"><span data-stu-id="73393-266">**Figure 04**: Test Results ([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image8.png))</span></span>

## <a name="creating-unit-tests-for-controllers"></a><span data-ttu-id="73393-267">为控制器创建单元测试</span><span class="sxs-lookup"><span data-stu-id="73393-267">Creating Unit Tests for Controllers</span></span>

<span data-ttu-id="73393-268">ASP.NETMVC 应用程序控制流的用户交互。</span><span class="sxs-lookup"><span data-stu-id="73393-268">ASP.NETMVC application control the flow of user interaction.</span></span> <span data-ttu-id="73393-269">当测试控制器时，你想要测试是否将控制器返回正确的操作结果和查看数据。</span><span class="sxs-lookup"><span data-stu-id="73393-269">When testing a controller, you want to test whether the controller returns the right action result and view data.</span></span> <span data-ttu-id="73393-270">此外可能想要测试是否与预期的方式中的模型类交互，一个控制器。</span><span class="sxs-lookup"><span data-stu-id="73393-270">You also might want to test whether a controller interacts with model classes in the manner expected.</span></span>

<span data-ttu-id="73393-271">例如，代码清单 2 包含联系人控制器 create （） 方法的两个单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-271">For example, Listing 2 contains two unit tests for the Contact controller Create() method.</span></span> <span data-ttu-id="73393-272">第一个单元测试验证了有效的联系人传递给 create （） 方法，则 create （） 方法将重定向到的索引操作时。</span><span class="sxs-lookup"><span data-stu-id="73393-272">The first unit test verifies that when a valid Contact is passed to the Create() method then the Create() method redirects to the Index action.</span></span> <span data-ttu-id="73393-273">换而言之，当传递了有效的联系人，create （） 方法应返回表示索引操作 RedirectToRouteResult。</span><span class="sxs-lookup"><span data-stu-id="73393-273">In other words, when passed a valid Contact, the Create() method should return a RedirectToRouteResult that represents the Index action.</span></span>

<span data-ttu-id="73393-274">我们不想测试 ContactManager 服务层，我们将测试控制器层时。</span><span class="sxs-lookup"><span data-stu-id="73393-274">We don t want to test the ContactManager service layer when we are testing the controller layer.</span></span> <span data-ttu-id="73393-275">因此，我们模拟服务层提供的 Initialize 方法中的以下代码：</span><span class="sxs-lookup"><span data-stu-id="73393-275">Therefore, we mock the service layer with the following code in the Initialize method:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

<span data-ttu-id="73393-276">在 CreateValidContact() 单元测试中，我们模拟调用服务层具有以下代码行 CreateContact() 方法的行为：</span><span class="sxs-lookup"><span data-stu-id="73393-276">In the CreateValidContact() unit test, we mock the behavior of calling the service layer CreateContact() method with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

<span data-ttu-id="73393-277">这行代码会导致模拟的 ContactManager 服务，以调用其 CreateContact() 方法返回的值为 true。</span><span class="sxs-lookup"><span data-stu-id="73393-277">This line of code causes the mock ContactManager service to return the value true when its CreateContact() method is called.</span></span> <span data-ttu-id="73393-278">由模拟服务层，我们可以测试控制器的行为而无需执行的服务层中的任何代码。</span><span class="sxs-lookup"><span data-stu-id="73393-278">By mocking the service layer, we can test the behavior of our controller without needing to execute any code in the service layer.</span></span>

<span data-ttu-id="73393-279">第二个单元测试验证无效联系人传递给方法时，create （） 操作，返回创建视图。</span><span class="sxs-lookup"><span data-stu-id="73393-279">The second unit test verifies that the Create() action returns the Create view when an invalid contact is passed to the method.</span></span> <span data-ttu-id="73393-280">我们会导致服务层 CreateContact() 方法返回值 false，使用以下代码行：</span><span class="sxs-lookup"><span data-stu-id="73393-280">We cause the service layer CreateContact() method to return the value false with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

<span data-ttu-id="73393-281">如果 create （） 方法的行为我们预期它应在服务层，则返回值 false 时返回创建视图。</span><span class="sxs-lookup"><span data-stu-id="73393-281">If the Create() method behaves as we expect then it should return the Create view when the service layer returns the value false.</span></span> <span data-ttu-id="73393-282">这样一来，控制器可以显示验证错误消息，在创建视图和用户有机会更正该无效联系人属性。</span><span class="sxs-lookup"><span data-stu-id="73393-282">That way, the controller can display the validation error messages in the Create view and the user has a chance to correct that invalid Contact properties.</span></span>

<span data-ttu-id="73393-283">如果您计划生成你的控制器的单元测试然后您需要的控制器操作返回显式视图名称。</span><span class="sxs-lookup"><span data-stu-id="73393-283">If you plan to build unit tests for your controllers then you need to return explicit view names from your controller actions.</span></span> <span data-ttu-id="73393-284">例如，不返回此类的视图：</span><span class="sxs-lookup"><span data-stu-id="73393-284">For example, do not return a view like this:</span></span>

<span data-ttu-id="73393-285">返回 View();</span><span class="sxs-lookup"><span data-stu-id="73393-285">return View();</span></span>

<span data-ttu-id="73393-286">改为返回的视图如下：</span><span class="sxs-lookup"><span data-stu-id="73393-286">Instead, return the view like this:</span></span>

<span data-ttu-id="73393-287">返回 View("Create");</span><span class="sxs-lookup"><span data-stu-id="73393-287">return View("Create");</span></span>

<span data-ttu-id="73393-288">如果不能显式返回视图时 ViewResult.ViewName 属性将返回空字符串。</span><span class="sxs-lookup"><span data-stu-id="73393-288">If you are not explicit when returning a view then the ViewResult.ViewName property returns an empty string.</span></span>

<span data-ttu-id="73393-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span><span class="sxs-lookup"><span data-stu-id="73393-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a><span data-ttu-id="73393-290">总结</span><span class="sxs-lookup"><span data-stu-id="73393-290">Summary</span></span>

<span data-ttu-id="73393-291">在此迭代中，我们为我们的联系人管理器应用程序创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-291">In this iteration, we created unit tests for our Contact Manager application.</span></span> <span data-ttu-id="73393-292">若要验证我们的应用程序仍行为我们预期的方式在任何时候，我们可以运行这些单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-292">We can run these unit tests at any time to verify that our application still behaves in the manner that we expect.</span></span> <span data-ttu-id="73393-293">单元测试作为使应用程序，使我们能够安全地修改我们的应用程序在将来的安全网。</span><span class="sxs-lookup"><span data-stu-id="73393-293">The unit tests act as a safety net for our application enabling us to safely modify our application in the future.</span></span>

<span data-ttu-id="73393-294">我们创建了两个集的单元测试。</span><span class="sxs-lookup"><span data-stu-id="73393-294">We created two sets of unit tests.</span></span> <span data-ttu-id="73393-295">首先，我们通过创建我们的服务层的单元测试来测试我们的验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="73393-295">First, we tested our validation logic by creating unit tests for our service layer.</span></span> <span data-ttu-id="73393-296">接下来，我们通过创建我们的控制器层的单元测试来测试我们的流控制逻辑。</span><span class="sxs-lookup"><span data-stu-id="73393-296">Next, we tested our flow control logic by creating unit tests for our controller layer.</span></span> <span data-ttu-id="73393-297">当测试我们的服务层，我们独立的我们的测试为我们的服务层从我们的存储库层通过模拟我们存储库层。</span><span class="sxs-lookup"><span data-stu-id="73393-297">When testing our service layer, we isolated our tests for our service layer from our repository layer by mocking our repository layer.</span></span> <span data-ttu-id="73393-298">当测试控制器层，我们独立的我们的测试我们控制器层由模拟服务层。</span><span class="sxs-lookup"><span data-stu-id="73393-298">When testing the controller layer, we isolated our tests for our controller layer by mocking the service layer.</span></span>

<span data-ttu-id="73393-299">在下一个迭代中，我们将修改联系人管理器应用程序，以便它支持联系人组。</span><span class="sxs-lookup"><span data-stu-id="73393-299">In the next iteration, we modify the Contact Manager application so that it supports Contact Groups.</span></span> <span data-ttu-id="73393-300">我们将此新功能添加到我们的应用程序使用名为测试驱动开发的软件设计过程。</span><span class="sxs-lookup"><span data-stu-id="73393-300">We'll add this new functionality to our application using a software design process called test-driven development.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="73393-301">[上一页](iteration-4-make-the-application-loosely-coupled-cs.md)
> [下一页](iteration-6-use-test-driven-development-cs.md)</span><span class="sxs-lookup"><span data-stu-id="73393-301">[Previous](iteration-4-make-the-application-loosely-coupled-cs.md)
[Next](iteration-6-use-test-driven-development-cs.md)</span></span>

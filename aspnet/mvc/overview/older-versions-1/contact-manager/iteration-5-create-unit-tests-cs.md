---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: '迭代 #5 –创建单元测试（C#） |Microsoft Docs'
author: microsoft
description: 在第五次迭代中，通过添加单元测试使应用程序更易于维护和修改。 我们模拟了数据模型类，并生成了用于 o 的单元测试 。
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: 32e81cce34a0e0b1f6b01934334e1b66dce89651
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78437840"
---
# <a name="iteration-5--create-unit-tests-c"></a><span data-ttu-id="0d61d-104">迭代 #5 –创建单元测试（C#）</span><span class="sxs-lookup"><span data-stu-id="0d61d-104">Iteration #5 – Create unit tests (C#)</span></span>

<span data-ttu-id="0d61d-105">由[Microsoft](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="0d61d-105">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="0d61d-106">下载代码</span><span class="sxs-lookup"><span data-stu-id="0d61d-106">Download Code</span></span>](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> <span data-ttu-id="0d61d-107">在第五次迭代中，通过添加单元测试使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-107">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="0d61d-108">我们模拟数据模型类，并为控制器和验证逻辑生成单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-108">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a><span data-ttu-id="0d61d-109">构建联系人管理 ASP.NET MVC 应用程序（C#）</span><span class="sxs-lookup"><span data-stu-id="0d61d-109">Building a Contact Management ASP.NET MVC Application (C#)</span></span>

<span data-ttu-id="0d61d-110">在本系列教程中，我们从一开始就生成一个完整的联系人管理应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-110">In this series of tutorials, we build an entire Contact Management application from start to finish.</span></span> <span data-ttu-id="0d61d-111">联系人管理器应用程序允许您存储联系人信息名称、电话号码和电子邮件地址，以获取人员列表。</span><span class="sxs-lookup"><span data-stu-id="0d61d-111">The Contact Manager application enables you to store contact information - names, phone numbers and email addresses - for a list of people.</span></span>

<span data-ttu-id="0d61d-112">我们通过多个迭代生成应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-112">We build the application over multiple iterations.</span></span> <span data-ttu-id="0d61d-113">随着每次迭代，我们将逐步改进应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-113">With each iteration, we gradually improve the application.</span></span> <span data-ttu-id="0d61d-114">此多个迭代方法的目标是使您能够了解每个更改的原因。</span><span class="sxs-lookup"><span data-stu-id="0d61d-114">The goal of this multiple iteration approach is to enable you to understand the reason for each change.</span></span>

- <span data-ttu-id="0d61d-115">迭代 #1-创建应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-115">Iteration #1 - Create the application.</span></span> <span data-ttu-id="0d61d-116">在第一次迭代中，我们以尽可能简单的方式创建联系人管理器。</span><span class="sxs-lookup"><span data-stu-id="0d61d-116">In the first iteration, we create the Contact Manager in the simplest way possible.</span></span> <span data-ttu-id="0d61d-117">添加对基本数据库操作的支持：创建、读取、更新和删除（CRUD）。</span><span class="sxs-lookup"><span data-stu-id="0d61d-117">We add support for basic database operations: Create, Read, Update, and Delete (CRUD).</span></span>

- <span data-ttu-id="0d61d-118">迭代 #2-使应用程序看起来不错。</span><span class="sxs-lookup"><span data-stu-id="0d61d-118">Iteration #2 - Make the application look nice.</span></span> <span data-ttu-id="0d61d-119">在此迭代中，我们通过修改默认的 ASP.NET MVC 视图母版页和级联样式表来改善应用程序的外观。</span><span class="sxs-lookup"><span data-stu-id="0d61d-119">In this iteration, we improve the appearance of the application by modifying the default ASP.NET MVC view master page and cascading style sheet.</span></span>

- <span data-ttu-id="0d61d-120">迭代 #3-添加窗体验证。</span><span class="sxs-lookup"><span data-stu-id="0d61d-120">Iteration #3 - Add form validation.</span></span> <span data-ttu-id="0d61d-121">在第三次迭代中，我们将添加基本的窗体验证。</span><span class="sxs-lookup"><span data-stu-id="0d61d-121">In the third iteration, we add basic form validation.</span></span> <span data-ttu-id="0d61d-122">我们阻止用户提交窗体，而无需填写所需的窗体字段。</span><span class="sxs-lookup"><span data-stu-id="0d61d-122">We prevent people from submitting a form without completing required form fields.</span></span> <span data-ttu-id="0d61d-123">我们还验证了电子邮件地址和电话号码。</span><span class="sxs-lookup"><span data-stu-id="0d61d-123">We also validate email addresses and phone numbers.</span></span>

- <span data-ttu-id="0d61d-124">迭代 #4-使应用程序松散耦合。</span><span class="sxs-lookup"><span data-stu-id="0d61d-124">Iteration #4 - Make the application loosely coupled.</span></span> <span data-ttu-id="0d61d-125">在第四次迭代中，我们将利用多种软件设计模式来更轻松地维护和修改联系人管理器应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-125">In this fourth iteration, we take advantage of several software design patterns to make it easier to maintain and modify the Contact Manager application.</span></span> <span data-ttu-id="0d61d-126">例如，我们重构应用程序以使用存储库模式和依赖关系注入模式。</span><span class="sxs-lookup"><span data-stu-id="0d61d-126">For example, we refactor our application to use the Repository pattern and the Dependency Injection pattern.</span></span>

- <span data-ttu-id="0d61d-127">迭代 #5-创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-127">Iteration #5 - Create unit tests.</span></span> <span data-ttu-id="0d61d-128">在第五次迭代中，通过添加单元测试使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-128">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="0d61d-129">我们模拟数据模型类，并为控制器和验证逻辑生成单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-129">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

- <span data-ttu-id="0d61d-130">迭代 #6-使用测试驱动开发。</span><span class="sxs-lookup"><span data-stu-id="0d61d-130">Iteration #6 - Use test-driven development.</span></span> <span data-ttu-id="0d61d-131">在第六次迭代中，我们通过首先编写单元测试并针对单元测试编写代码，向应用程序添加新功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-131">In this sixth iteration, we add new functionality to our application by writing unit tests first and writing code against the unit tests.</span></span> <span data-ttu-id="0d61d-132">在此迭代中，我们添加联系人组。</span><span class="sxs-lookup"><span data-stu-id="0d61d-132">In this iteration, we add contact groups.</span></span>

- <span data-ttu-id="0d61d-133">迭代 #7-添加 Ajax 功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-133">Iteration #7 - Add Ajax functionality.</span></span> <span data-ttu-id="0d61d-134">在第七次迭代中，我们通过添加对 Ajax 的支持来提高应用程序的响应能力和性能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-134">In the seventh iteration, we improve the responsiveness and performance of our application by adding support for Ajax.</span></span>

## <a name="this-iteration"></a><span data-ttu-id="0d61d-135">此迭代</span><span class="sxs-lookup"><span data-stu-id="0d61d-135">This Iteration</span></span>

<span data-ttu-id="0d61d-136">在联系人管理器应用程序的前一次迭代中，我们重构了应用程序，使其更松耦合。</span><span class="sxs-lookup"><span data-stu-id="0d61d-136">In the previous iteration of the Contact Manager application, we refactored the application to be more loosely coupled.</span></span> <span data-ttu-id="0d61d-137">将应用程序分离到不同的控制器、服务和存储库层。</span><span class="sxs-lookup"><span data-stu-id="0d61d-137">We separated the application into distinct controller, service, and repository layers.</span></span> <span data-ttu-id="0d61d-138">每一层通过接口与其下面的层交互。</span><span class="sxs-lookup"><span data-stu-id="0d61d-138">Each layer interacts with the layer beneath it through interfaces.</span></span>

<span data-ttu-id="0d61d-139">我们重构了应用程序，使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-139">We refactored the application to make the application easier to maintain and modify.</span></span> <span data-ttu-id="0d61d-140">例如，如果需要使用新的数据访问技术，只需更改存储库层，无需接触控制器或服务层。</span><span class="sxs-lookup"><span data-stu-id="0d61d-140">For example, if we need to use a new data access technology, we can simply change the repository layer without touching the controller or service layer.</span></span> <span data-ttu-id="0d61d-141">通过使 Contact Manager 松散耦合起来，我们使应用程序更具弹性性来进行更改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-141">By making the Contact Manager loosely coupled, we ve made the application more resilient to change.</span></span>

<span data-ttu-id="0d61d-142">但当我们需要向联系人管理器应用程序添加新功能时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="0d61d-142">But, what happens when we need to add a new feature to the Contact Manager application?</span></span> <span data-ttu-id="0d61d-143">或者，修复 bug 后会出现什么情况？</span><span class="sxs-lookup"><span data-stu-id="0d61d-143">Or, what happens when we fix a bug?</span></span> <span data-ttu-id="0d61d-144">一种很好的经验证的代码编写，就是每次触摸代码时都会产生新的 bug。</span><span class="sxs-lookup"><span data-stu-id="0d61d-144">A sad, but well proven, truth of writing code is that whenever you touch code you create the risk of introducing new bugs.</span></span>

<span data-ttu-id="0d61d-145">例如，你的经理可能会要求你向联系人经理添加新功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-145">For example, one fine day, your manager might ask you to add a new feature to the Contact Manager.</span></span> <span data-ttu-id="0d61d-146">她希望你添加对联系人组的支持。</span><span class="sxs-lookup"><span data-stu-id="0d61d-146">She wants you to add support for Contact Groups.</span></span> <span data-ttu-id="0d61d-147">她希望您能够使用户能够将其联系人组织到朋友、商业等的组中。</span><span class="sxs-lookup"><span data-stu-id="0d61d-147">She wants you to enable users to organize their contacts into groups such as Friends, Business, and so on.</span></span>

<span data-ttu-id="0d61d-148">为了实现这一新功能，您将需要修改联系人管理器应用程序的所有三个层。</span><span class="sxs-lookup"><span data-stu-id="0d61d-148">In order to implement this new feature, you'll need to modify all three layers of the Contact Manager application.</span></span> <span data-ttu-id="0d61d-149">需要向控制器、服务层和存储库添加新功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-149">You'll need to add new functionality to the controllers, the service layer, and the repository.</span></span> <span data-ttu-id="0d61d-150">一旦开始修改代码，就会面临一些重大功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-150">As soon as you start modifying code, you risk breaking functionality that worked before.</span></span>

<span data-ttu-id="0d61d-151">像之前的迭代一样，将应用程序重构为单独的层是一件好事。</span><span class="sxs-lookup"><span data-stu-id="0d61d-151">Refactoring our application into separate layers, as we did in the previous iteration, was a good thing.</span></span> <span data-ttu-id="0d61d-152">这是一件好事，因为它使我们能够在不触及应用程序的其余部分的情况下对整个层进行更改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-152">It was a good thing because it enables us to make changes to entire layers without touching the rest of the application.</span></span> <span data-ttu-id="0d61d-153">但是，如果要使代码中的代码更易于维护和修改，则需要为代码创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-153">However, if you want to make the code within a layer easier to maintain and modify, you need to create unit tests for the code.</span></span>

<span data-ttu-id="0d61d-154">使用单元测试来测试单个代码单元。</span><span class="sxs-lookup"><span data-stu-id="0d61d-154">You use a unit test to test an individual unit of code.</span></span> <span data-ttu-id="0d61d-155">这些代码单元小于整个应用程序层。</span><span class="sxs-lookup"><span data-stu-id="0d61d-155">These units of code are smaller than entire application layers.</span></span> <span data-ttu-id="0d61d-156">通常，使用单元测试来验证代码中的某个特定方法的行为是否符合预期。</span><span class="sxs-lookup"><span data-stu-id="0d61d-156">Typically, you use a unit test to verify whether a particular method in your code behaves in the way that you expect.</span></span> <span data-ttu-id="0d61d-157">例如，你可以为 ContactManagerService 类公开的 CreateContact （）方法创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-157">For example, you would create a unit test for the CreateContact() method exposed by the ContactManagerService class.</span></span>

<span data-ttu-id="0d61d-158">应用程序的单元测试与安全网络的工作方式相同。</span><span class="sxs-lookup"><span data-stu-id="0d61d-158">The unit tests for an application work just like a safety net.</span></span> <span data-ttu-id="0d61d-159">每当在应用程序中修改代码时，都可以运行一组单元测试来检查修改是否会破坏现有功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-159">Whenever you modify code in an application, you can run a set of unit tests to check whether the modification breaks existing functionality.</span></span> <span data-ttu-id="0d61d-160">单元测试使代码修改安全。</span><span class="sxs-lookup"><span data-stu-id="0d61d-160">Unit tests make your code safe to modify.</span></span> <span data-ttu-id="0d61d-161">单元测试使得应用程序中的所有代码都能够更灵活地进行更改。</span><span class="sxs-lookup"><span data-stu-id="0d61d-161">Unit tests make all of the code in your application more resilient to change.</span></span>

<span data-ttu-id="0d61d-162">在此迭代中，我们向联系人管理器应用程序添加单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-162">In this iteration, we add unit tests to our Contact Manager application.</span></span> <span data-ttu-id="0d61d-163">这样，在下一次迭代中，我们可以将联系人组添加到我们的应用程序，而无需担心破坏现有功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-163">That way, in the next iteration, we can add Contact Groups to our application without worrying about breaking existing functionality.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0d61d-164">有多种单元测试框架，包括 NUnit、xUnit.net 和 MbUnit。</span><span class="sxs-lookup"><span data-stu-id="0d61d-164">There are a variety of unit testing frameworks including NUnit, xUnit.net, and MbUnit.</span></span> <span data-ttu-id="0d61d-165">在本教程中，我们将使用 Visual Studio 中包含的单元测试框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-165">In this tutorial, we use the unit testing framework included with Visual Studio.</span></span> <span data-ttu-id="0d61d-166">不过，您可以轻松地使用其中一种替代框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-166">However, you could just as easily use one of these alternative frameworks.</span></span>

## <a name="what-gets-tested"></a><span data-ttu-id="0d61d-167">测试的内容</span><span class="sxs-lookup"><span data-stu-id="0d61d-167">What Gets Tested</span></span>

<span data-ttu-id="0d61d-168">在完美的世界中，所有代码都将包含在单元测试中。</span><span class="sxs-lookup"><span data-stu-id="0d61d-168">In the perfect world, all of your code would be covered by unit tests.</span></span> <span data-ttu-id="0d61d-169">在完美的世界中，您可以获得完美的安全网络。</span><span class="sxs-lookup"><span data-stu-id="0d61d-169">In the perfect world, you would have the perfect safety net.</span></span> <span data-ttu-id="0d61d-170">可以通过执行单元测试来修改应用程序中的任何代码行，并可立即了解更改是否会破坏现有功能。</span><span class="sxs-lookup"><span data-stu-id="0d61d-170">You would be able to modify any line of code in your application and know instantly, by executing your unit tests, whether the change broke existing functionality.</span></span>

<span data-ttu-id="0d61d-171">但是，我们不会在完美的世界中生活。</span><span class="sxs-lookup"><span data-stu-id="0d61d-171">However, we don t live in a perfect world.</span></span> <span data-ttu-id="0d61d-172">在实践中，编写单元测试时，您将重点放在编写业务逻辑的测试（例如，验证逻辑）上。</span><span class="sxs-lookup"><span data-stu-id="0d61d-172">In practice, when writing unit tests, you concentrate on writing tests for your business logic (for example, validation logic).</span></span> <span data-ttu-id="0d61d-173">特别是，*不*为数据访问逻辑或视图逻辑编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-173">In particular, you *do not* write unit tests for your data access logic or your view logic.</span></span>

<span data-ttu-id="0d61d-174">若要有用，必须非常快速地执行单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-174">To be useful, unit tests must execute very quickly.</span></span> <span data-ttu-id="0d61d-175">您可以轻松地为应用程序积累数百（甚至上千个）的单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-175">You easily can accumulate hundreds (or even thousands) of unit tests for an application.</span></span> <span data-ttu-id="0d61d-176">如果单元测试需要很长时间才能运行，则可以避免执行它们。</span><span class="sxs-lookup"><span data-stu-id="0d61d-176">If the unit tests take a long time to run then you'll avoid executing them.</span></span> <span data-ttu-id="0d61d-177">换句话说，长时间运行的单元测试不能用于日常编码。</span><span class="sxs-lookup"><span data-stu-id="0d61d-177">In other words, long running unit tests are useless for day to day coding purposes.</span></span>

<span data-ttu-id="0d61d-178">出于此原因，通常不会为与数据库交互的代码编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-178">For this reason, you typically do not write unit tests for code that interacts with a database.</span></span> <span data-ttu-id="0d61d-179">对活动数据库运行数百个单元测试将会太慢。</span><span class="sxs-lookup"><span data-stu-id="0d61d-179">Running hundreds of unit tests against a live database would be too slow.</span></span> <span data-ttu-id="0d61d-180">相反，您需要模拟您的数据库，并编写与 mock 数据库交互的代码（我们在下面讨论了模拟数据库）。</span><span class="sxs-lookup"><span data-stu-id="0d61d-180">Instead, you mock your database and write code that interacts with the mock database (we discuss mocking a database below).</span></span>

<span data-ttu-id="0d61d-181">由于类似的原因，通常不会为视图编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-181">For a similar reason, you typically do not write unit tests for views.</span></span> <span data-ttu-id="0d61d-182">若要测试视图，必须启动 web 服务器。</span><span class="sxs-lookup"><span data-stu-id="0d61d-182">In order to test a view, you must spin up a web server.</span></span> <span data-ttu-id="0d61d-183">由于旋转 web 服务器的过程相对较慢，因此不建议为视图创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-183">Because spinning up a web server is a relatively slow process, creating unit tests for your views is not recommended.</span></span>

<span data-ttu-id="0d61d-184">如果视图包含复杂逻辑，则应考虑将逻辑移到帮助器方法中。</span><span class="sxs-lookup"><span data-stu-id="0d61d-184">If your view contains complicated logic then you should consider moving the logic into Helper methods.</span></span> <span data-ttu-id="0d61d-185">你可以为在不旋转 web 服务器的情况下执行的帮助器方法编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-185">You can write unit tests for Helper methods that execute without spinning up a web server.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0d61d-186">编写单元测试时，为数据访问逻辑或查看逻辑编写测试并不是一个好主意，这些测试在构建功能或集成测试时非常有用。</span><span class="sxs-lookup"><span data-stu-id="0d61d-186">While writing tests for data access logic or view logic is not a good idea when writing unit tests, these tests can be very valuable when building functional or integration tests.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0d61d-187">ASP.NET MVC 是 Web 窗体视图引擎。</span><span class="sxs-lookup"><span data-stu-id="0d61d-187">ASP.NET MVC is the Web Forms View Engine.</span></span> <span data-ttu-id="0d61d-188">尽管 Web 窗体视图引擎依赖于 web 服务器，但其他视图引擎可能不是。</span><span class="sxs-lookup"><span data-stu-id="0d61d-188">While the Web Forms View Engine is dependent on a web server, other view engines might not be.</span></span>

## <a name="using-a-mock-object-framework"></a><span data-ttu-id="0d61d-189">使用 Mock 对象框架</span><span class="sxs-lookup"><span data-stu-id="0d61d-189">Using a Mock Object Framework</span></span>

<span data-ttu-id="0d61d-190">构建单元测试时，几乎总是需要利用 Mock 对象框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-190">When building unit tests, you almost always need to take advantage of a Mock Object framework.</span></span> <span data-ttu-id="0d61d-191">Mock 对象框架使你可以为应用程序中的类创建模拟和存根。</span><span class="sxs-lookup"><span data-stu-id="0d61d-191">A Mock Object framework enables you to create mocks and stubs for the classes in your application.</span></span>

<span data-ttu-id="0d61d-192">例如，可以使用 Mock 对象框架生成存储库类的模拟版本。</span><span class="sxs-lookup"><span data-stu-id="0d61d-192">For example, you can use a Mock Object framework to generate a mock version of your repository class.</span></span> <span data-ttu-id="0d61d-193">这样，便可以在单元测试中使用 mock 存储库类，而不是实际存储库类。</span><span class="sxs-lookup"><span data-stu-id="0d61d-193">That way, you can use the mock repository class instead of the real repository class in your unit tests.</span></span> <span data-ttu-id="0d61d-194">使用 mock 存储库可以避免在执行单元测试时执行数据库代码。</span><span class="sxs-lookup"><span data-stu-id="0d61d-194">Using the mock repository enables you to avoid executing database code when executing a unit test.</span></span>

<span data-ttu-id="0d61d-195">Visual Studio 不包括 Mock 对象框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-195">Visual Studio does not include a Mock Object framework.</span></span> <span data-ttu-id="0d61d-196">但是，有几个适用于 .NET framework 的商业和开源模拟对象框架：</span><span class="sxs-lookup"><span data-stu-id="0d61d-196">However, there are several commercial and open source Mock Object frameworks available for the .NET framework:</span></span>

1. <span data-ttu-id="0d61d-197">Moq-此框架在开源 BSD 许可证下提供。</span><span class="sxs-lookup"><span data-stu-id="0d61d-197">Moq - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="0d61d-198">可以从[https://code.google.com/p/moq/](https://code.google.com/p/moq/)下载 Moq。</span><span class="sxs-lookup"><span data-stu-id="0d61d-198">You can download Moq from [https://code.google.com/p/moq/](https://code.google.com/p/moq/).</span></span>
2. <span data-ttu-id="0d61d-199">Rhino 模拟-在开源 BSD 许可证下提供此框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-199">Rhino Mocks - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="0d61d-200">可以从[http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)下载 Rhino 模拟。</span><span class="sxs-lookup"><span data-stu-id="0d61d-200">You can download Rhino Mocks from [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).</span></span>
3. <span data-ttu-id="0d61d-201">Typemock Isolator-这是一个商业框架。</span><span class="sxs-lookup"><span data-stu-id="0d61d-201">Typemock Isolator - This is a commercial framework.</span></span> <span data-ttu-id="0d61d-202">可以从[http://www.typemock.com/](http://www.typemock.com/)下载试用版。</span><span class="sxs-lookup"><span data-stu-id="0d61d-202">You can download a trial version from [http://www.typemock.com/](http://www.typemock.com/).</span></span>

<span data-ttu-id="0d61d-203">在本教程中，我决定使用 Moq。</span><span class="sxs-lookup"><span data-stu-id="0d61d-203">In this tutorial, I decided to use Moq.</span></span> <span data-ttu-id="0d61d-204">不过，您可以轻松地使用 Rhino 模拟或 Typemock Isolator 为 "联系人管理器" 应用程序创建 Mock 对象。</span><span class="sxs-lookup"><span data-stu-id="0d61d-204">However, you could just as easily use Rhino Mocks or Typemock Isolator to create the Mock objects for the Contact Manager application.</span></span>

<span data-ttu-id="0d61d-205">你需要先完成以下步骤，然后才能使用 Moq：</span><span class="sxs-lookup"><span data-stu-id="0d61d-205">Before you can use Moq, you need to complete the following steps:</span></span>

1. <span data-ttu-id="0d61d-206">.</span><span class="sxs-lookup"><span data-stu-id="0d61d-206">.</span></span>
2. <span data-ttu-id="0d61d-207">解压缩下载之前，请确保右键单击该文件，然后单击标记为 "**解除阻止**" 的按钮（参见图1）。</span><span class="sxs-lookup"><span data-stu-id="0d61d-207">Before you unzip the download, make sure that you right-click the file and click the button labeled **Unblock** (see Figure 1).</span></span>
3. <span data-ttu-id="0d61d-208">解压缩下载。</span><span class="sxs-lookup"><span data-stu-id="0d61d-208">Unzip the download.</span></span>
4. <span data-ttu-id="0d61d-209">右键单击 "ContactManager" 项目中的 "引用" 文件夹，然后选择 "**添加引用**"，添加对 Moq 程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="0d61d-209">Add a reference to the Moq assembly by right-clicking the References folder in the ContactManager.Tests project and selecting **Add Reference**.</span></span> <span data-ttu-id="0d61d-210">在 "浏览" 选项卡下，浏览到解压缩 Moq 的文件夹，并选择 Moq 程序集。</span><span class="sxs-lookup"><span data-stu-id="0d61d-210">Under the Browse tab, browse to the folder where you unzipped Moq and select the Moq.dll assembly.</span></span> <span data-ttu-id="0d61d-211">单击“确定”按钮。</span><span class="sxs-lookup"><span data-stu-id="0d61d-211">Click the **OK** button.</span></span>
5. <span data-ttu-id="0d61d-212">完成这些步骤后，"引用" 文件夹应如图2所示。</span><span class="sxs-lookup"><span data-stu-id="0d61d-212">After you complete these steps, your References folder should look like Figure 2.</span></span>

<span data-ttu-id="0d61d-213">[![取消阻止 Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="0d61d-213">[![Unblocking Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span></span>

<span data-ttu-id="0d61d-214">**图 01**：取消阻止 Moq （[单击查看完全尺寸的图像](iteration-5-create-unit-tests-cs/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="0d61d-214">**Figure 01**: Unblocking Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image2.png))</span></span>

<span data-ttu-id="0d61d-215">[添加 Moq 后的 ![引用](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="0d61d-215">[![References after adding Moq](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span></span>

<span data-ttu-id="0d61d-216">**图 02**：添加 Moq 后的引用（[单击以查看完全大小的图像](iteration-5-create-unit-tests-cs/_static/image4.png)）</span><span class="sxs-lookup"><span data-stu-id="0d61d-216">**Figure 02**: References after adding Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image4.png))</span></span>

## <a name="creating-unit-tests-for-the-service-layer"></a><span data-ttu-id="0d61d-217">为服务层创建单元测试</span><span class="sxs-lookup"><span data-stu-id="0d61d-217">Creating Unit Tests for the Service Layer</span></span>

<span data-ttu-id="0d61d-218">首先，让我们为联系人管理器应用程序的服务层创建一组单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-218">Let s start by creating a set of unit tests for our Contact Manager application s service layer.</span></span> <span data-ttu-id="0d61d-219">我们将使用这些测试来验证验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="0d61d-219">We'll use these tests to verify our validation logic.</span></span>

<span data-ttu-id="0d61d-220">在 ContactManager 项目中创建名为 "模型" 的新文件夹。</span><span class="sxs-lookup"><span data-stu-id="0d61d-220">Create a new folder named Models in the ContactManager.Tests project.</span></span> <span data-ttu-id="0d61d-221">接下来，右键单击 "模型" 文件夹，然后选择 "**添加"、"新建测试"** 。</span><span class="sxs-lookup"><span data-stu-id="0d61d-221">Next, right-click the Models folder and select **Add, New Test**.</span></span> <span data-ttu-id="0d61d-222">此时将显示如图3所示的 "**添加新测试**" 对话框。</span><span class="sxs-lookup"><span data-stu-id="0d61d-222">The **Add New Test** dialog shown in Figure 3 appears.</span></span> <span data-ttu-id="0d61d-223">选择 "**单元测试**" 模板并将新测试命名为 ContactManagerServiceTest.cs。</span><span class="sxs-lookup"><span data-stu-id="0d61d-223">Select the **Unit Test** template and name your new test ContactManagerServiceTest.cs.</span></span> <span data-ttu-id="0d61d-224">单击 **"确定"** 按钮将新测试添加到测试项目中。</span><span class="sxs-lookup"><span data-stu-id="0d61d-224">Click the **OK** button to add your new test to your Test Project.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0d61d-225">通常，你希望测试项目的文件夹结构与 ASP.NET MVC 项目的文件夹结构相匹配。</span><span class="sxs-lookup"><span data-stu-id="0d61d-225">In general, you want the folder structure of your Test Project to match the folder structure of your ASP.NET MVC project.</span></span> <span data-ttu-id="0d61d-226">例如，你将控制器测试放在控制器文件夹中，在模型文件夹中放置模型测试，依此类推。</span><span class="sxs-lookup"><span data-stu-id="0d61d-226">For example, you place controller tests in a Controllers folder, model tests in a Models folder, and so on.</span></span>

<span data-ttu-id="0d61d-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="0d61d-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span></span>

<span data-ttu-id="0d61d-228">**图 03**： Models\ContactManagerServiceTest.cs （[单击查看完全大小的图像](iteration-5-create-unit-tests-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="0d61d-228">**Figure 03**: Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span></span>

<span data-ttu-id="0d61d-229">最初，我们想要测试由 ContactManagerService 类公开的 CreateContact （）方法。</span><span class="sxs-lookup"><span data-stu-id="0d61d-229">Initially, we want to test the CreateContact() method exposed by the ContactManagerService class.</span></span> <span data-ttu-id="0d61d-230">我们会创建以下五项测试：</span><span class="sxs-lookup"><span data-stu-id="0d61d-230">We'll create the following five tests:</span></span>

- <span data-ttu-id="0d61d-231">CreateContact （）-当有效的联系人传递到方法时，CreateContact （）的测试将返回值 true。</span><span class="sxs-lookup"><span data-stu-id="0d61d-231">CreateContact() - Tests that CreateContact() returns the value true when a valid Contact is passed to the method.</span></span>
- <span data-ttu-id="0d61d-232">CreateContactRequiredFirstName （）-测试在将缺少名字的联系人传递到 CreateContact （）方法时，是否将错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="0d61d-232">CreateContactRequiredFirstName() - Tests that an error message is added to model state when a Contact with a missing first name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="0d61d-233">CreateContactRequiredLastName （）-测试当缺少姓氏的联系人传递到 CreateContact （）方法时，是否将错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="0d61d-233">CreateContactRequiredLastName() - Tests that an error message is added to model state when a Contact with a missing last name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="0d61d-234">CreateContactInvalidPhone （）-测试将包含无效电话号码的联系人传递到 CreateContact （）方法时，是否将错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="0d61d-234">CreateContactInvalidPhone() - Tests that an error message is added to model state when a Contact with an invalid phone number is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="0d61d-235">CreateContactInvalidEmail （）-测试将包含无效电子邮件地址的联系人传递到 CreateContact （）方法时，是否将错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="0d61d-235">CreateContactInvalidEmail() - Tests that an error message is added to model state when a Contact with an invalid email address is passed to the CreateContact() method..</span></span>

<span data-ttu-id="0d61d-236">第一次测试验证有效的联系人是否不产生验证错误。</span><span class="sxs-lookup"><span data-stu-id="0d61d-236">The first test verifies that a valid Contact does not generate a validation error.</span></span> <span data-ttu-id="0d61d-237">其余测试检查每个验证规则。</span><span class="sxs-lookup"><span data-stu-id="0d61d-237">The remaining tests check each of the validation rules.</span></span>

<span data-ttu-id="0d61d-238">这些测试的代码包含在列表1中。</span><span class="sxs-lookup"><span data-stu-id="0d61d-238">The code for these tests is contained in Listing 1.</span></span>

<span data-ttu-id="0d61d-239">**列表 1-Models\ContactManagerServiceTest.cs**</span><span class="sxs-lookup"><span data-stu-id="0d61d-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

<span data-ttu-id="0d61d-240">由于我们使用的是列表1中的 Contact 类，因此需要在测试项目中添加对 Microsoft 实体框架的引用。</span><span class="sxs-lookup"><span data-stu-id="0d61d-240">Because we use the Contact class in Listing 1, we need to add a reference to the Microsoft Entity Framework to our Test project.</span></span> <span data-ttu-id="0d61d-241">添加对 System.web 程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="0d61d-241">Add a reference to the System.Data.Entity assembly.</span></span>

<span data-ttu-id="0d61d-242">列表1包含一个名为 Initialize （）的方法，该方法使用 [TestInitialize] 特性修饰。</span><span class="sxs-lookup"><span data-stu-id="0d61d-242">Listing 1 contains a method named Initialize() that is decorated with the [TestInitialize] attribute.</span></span> <span data-ttu-id="0d61d-243">此方法在运行每个单元测试之前自动调用（它将在每个单元测试之前的5倍之前调用）。</span><span class="sxs-lookup"><span data-stu-id="0d61d-243">This method is called automatically before each of the unit tests is run (it is called 5 times right before each of the unit tests).</span></span> <span data-ttu-id="0d61d-244">Initialize （）方法使用以下代码行创建 mock 存储库：</span><span class="sxs-lookup"><span data-stu-id="0d61d-244">The Initialize() method creates a mock repository with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

<span data-ttu-id="0d61d-245">下面这行代码使用 Moq 框架通过 IContactManagerRepository 接口生成模拟存储库。</span><span class="sxs-lookup"><span data-stu-id="0d61d-245">This line of code uses the Moq framework to generate a mock repository from the IContactManagerRepository interface.</span></span> <span data-ttu-id="0d61d-246">使用 mock 存储库而不是实际的 EntityContactManagerRepository，以避免在运行每个单元测试时访问数据库。</span><span class="sxs-lookup"><span data-stu-id="0d61d-246">The mock repository is used instead of the actual EntityContactManagerRepository to avoid accessing the database when each unit test is run.</span></span> <span data-ttu-id="0d61d-247">Mock 存储库实现了 IContactManagerRepository 接口的方法，但方法实际上不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="0d61d-247">The mock repository implements the methods of the IContactManagerRepository interface, but the methods don t actually do anything.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="0d61d-248">使用 Moq 框架时，\_mockRepository 和 \_mockRepository 之间存在差异。</span><span class="sxs-lookup"><span data-stu-id="0d61d-248">When using the Moq framework, there is a distinction between \_mockRepository and \_mockRepository.Object.</span></span> <span data-ttu-id="0d61d-249">前者是指模拟&lt;IContactManagerRepository&gt; 类，其中包含用于指定模拟存储库的行为方式的方法。</span><span class="sxs-lookup"><span data-stu-id="0d61d-249">The former refers to the Mock&lt;IContactManagerRepository&gt; class that contains methods for specifying how the mock repository will behave.</span></span> <span data-ttu-id="0d61d-250">后者指的是实现 IContactManagerRepository 接口的实际模拟存储库。</span><span class="sxs-lookup"><span data-stu-id="0d61d-250">The latter refers to the actual mock repository that implements the IContactManagerRepository interface.</span></span>

<span data-ttu-id="0d61d-251">在创建 ContactManagerService 类的实例时，将在 Initialize （）方法中使用 mock 存储库。</span><span class="sxs-lookup"><span data-stu-id="0d61d-251">The mock repository is used in the Initialize() method when creating an instance of the ContactManagerService class.</span></span> <span data-ttu-id="0d61d-252">所有单个单元测试都使用此 ContactManagerService 类的实例。</span><span class="sxs-lookup"><span data-stu-id="0d61d-252">All of the individual unit tests use this instance of the ContactManagerService class.</span></span>

<span data-ttu-id="0d61d-253">列表1包含五个对应于每个单元测试的方法。</span><span class="sxs-lookup"><span data-stu-id="0d61d-253">Listing 1 contains five methods that correspond to each of the unit tests.</span></span> <span data-ttu-id="0d61d-254">其中每个方法都用 [TestMethod] 属性修饰。</span><span class="sxs-lookup"><span data-stu-id="0d61d-254">Each of these methods is decorated with the [TestMethod] attribute.</span></span> <span data-ttu-id="0d61d-255">运行单元测试时，将调用具有此属性的任何方法。</span><span class="sxs-lookup"><span data-stu-id="0d61d-255">When you run the unit tests, any method that has this attribute is called.</span></span> <span data-ttu-id="0d61d-256">换言之，使用 [TestMethod] 属性修饰的任何方法都是单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-256">In other words, any method that is decorated with the [TestMethod] attribute is a unit test.</span></span>

<span data-ttu-id="0d61d-257">第一个名为 CreateContact （）的单元测试验证当 Contact 类的有效实例传递给方法时，调用 CreateContact （）将返回值 true。</span><span class="sxs-lookup"><span data-stu-id="0d61d-257">The first unit test, named CreateContact(), verifies that calling CreateContact() returns the value true when a valid instance of the Contact class is passed to the method.</span></span> <span data-ttu-id="0d61d-258">该测试将创建 Contact 类的实例，调用 CreateContact （）方法，并验证 CreateContact （）是否返回值 true。</span><span class="sxs-lookup"><span data-stu-id="0d61d-258">The test creates an instance of the Contact class, calls the CreateContact() method, and verifies that CreateContact() returns the value true.</span></span>

<span data-ttu-id="0d61d-259">如果调用 CreateContact （）方法时使用了无效的联系人，则剩余的测试将验证该方法返回 false，并将预期的验证错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="0d61d-259">The remaining tests verify that when the CreateContact() method is called with an invalid Contact then the method returns false and the expected validation error message is added to model state.</span></span> <span data-ttu-id="0d61d-260">例如，CreateContactRequiredFirstName （）测试创建 Contact 类的实例，其 FirstName 属性的字符串为空。</span><span class="sxs-lookup"><span data-stu-id="0d61d-260">For example, the CreateContactRequiredFirstName() test creates an instance of the Contact class with an empty string for its FirstName property.</span></span> <span data-ttu-id="0d61d-261">接下来，将调用 CreateContact （）方法与无效的联系人。</span><span class="sxs-lookup"><span data-stu-id="0d61d-261">Next, the CreateContact() method is called with the invalid Contact.</span></span> <span data-ttu-id="0d61d-262">最后，测试验证 CreateContact （）是否返回 false，并且模型状态是否包含预期的验证错误消息 "名字是必需的"。</span><span class="sxs-lookup"><span data-stu-id="0d61d-262">Finally, the test verifies that CreateContact() returns false and that model state contains the expected validation error message "First name is required."</span></span>

<span data-ttu-id="0d61d-263">您可以通过选择 "**测试"、"运行" 解决方案中的所有测试（CTRL + R、A）** 来运行列表1中的单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-263">You can run the unit tests in Listing 1 by selecting the menu option **Test, Run, All Tests in Solution (CTRL+R, A)**.</span></span> <span data-ttu-id="0d61d-264">测试结果将显示在 "测试结果" 窗口中（参见图4）。</span><span class="sxs-lookup"><span data-stu-id="0d61d-264">The results of the tests are displayed in the Test Results window (see Figure 4).</span></span>

<span data-ttu-id="0d61d-265">[![测试结果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="0d61d-265">[![Test Results](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span></span>

<span data-ttu-id="0d61d-266">**图 04**：测试结果（[单击查看完全大小的图像](iteration-5-create-unit-tests-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="0d61d-266">**Figure 04**: Test Results ([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image8.png))</span></span>

## <a name="creating-unit-tests-for-controllers"></a><span data-ttu-id="0d61d-267">为控制器创建单元测试</span><span class="sxs-lookup"><span data-stu-id="0d61d-267">Creating Unit Tests for Controllers</span></span>

<span data-ttu-id="0d61d-268">NETMVC 应用程序控制用户交互的流。</span><span class="sxs-lookup"><span data-stu-id="0d61d-268">ASP.NETMVC application control the flow of user interaction.</span></span> <span data-ttu-id="0d61d-269">测试控制器时，需要测试控制器是否返回正确的操作结果和查看数据。</span><span class="sxs-lookup"><span data-stu-id="0d61d-269">When testing a controller, you want to test whether the controller returns the right action result and view data.</span></span> <span data-ttu-id="0d61d-270">你还可能需要测试控制器是否以预期的方式与模型类交互。</span><span class="sxs-lookup"><span data-stu-id="0d61d-270">You also might want to test whether a controller interacts with model classes in the manner expected.</span></span>

<span data-ttu-id="0d61d-271">例如，列表2包含 Contact controller Create （）方法的两个单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-271">For example, Listing 2 contains two unit tests for the Contact controller Create() method.</span></span> <span data-ttu-id="0d61d-272">第一个单元测试验证当有效的联系人传递到 Create （）方法时，Create （）方法将重定向到索引操作。</span><span class="sxs-lookup"><span data-stu-id="0d61d-272">The first unit test verifies that when a valid Contact is passed to the Create() method then the Create() method redirects to the Index action.</span></span> <span data-ttu-id="0d61d-273">换言之，当传递了有效的联系人时，Create （）方法应返回表示索引操作的 RedirectToRouteResult。</span><span class="sxs-lookup"><span data-stu-id="0d61d-273">In other words, when passed a valid Contact, the Create() method should return a RedirectToRouteResult that represents the Index action.</span></span>

<span data-ttu-id="0d61d-274">测试控制器层时，不需要测试 ContactManager 服务层。</span><span class="sxs-lookup"><span data-stu-id="0d61d-274">We don t want to test the ContactManager service layer when we are testing the controller layer.</span></span> <span data-ttu-id="0d61d-275">因此，我们会在 Initialize 方法中模拟包含以下代码的服务层：</span><span class="sxs-lookup"><span data-stu-id="0d61d-275">Therefore, we mock the service layer with the following code in the Initialize method:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

<span data-ttu-id="0d61d-276">在 CreateValidContact （）单元测试中，我们模拟了用以下代码行调用服务层 CreateContact （）方法的行为：</span><span class="sxs-lookup"><span data-stu-id="0d61d-276">In the CreateValidContact() unit test, we mock the behavior of calling the service layer CreateContact() method with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

<span data-ttu-id="0d61d-277">如果调用了 CreateContact （）方法，则这行代码会导致模拟 ContactManager 服务返回值 true。</span><span class="sxs-lookup"><span data-stu-id="0d61d-277">This line of code causes the mock ContactManager service to return the value true when its CreateContact() method is called.</span></span> <span data-ttu-id="0d61d-278">通过模拟服务层，我们可以测试控制器的行为，而无需在服务层中执行任何代码。</span><span class="sxs-lookup"><span data-stu-id="0d61d-278">By mocking the service layer, we can test the behavior of our controller without needing to execute any code in the service layer.</span></span>

<span data-ttu-id="0d61d-279">第二个单元测试验证当向方法传递无效的联系人时，Create （）操作是否返回 "创建" 视图。</span><span class="sxs-lookup"><span data-stu-id="0d61d-279">The second unit test verifies that the Create() action returns the Create view when an invalid contact is passed to the method.</span></span> <span data-ttu-id="0d61d-280">我们会使服务层 CreateContact （）方法将值 false 返回给以下代码行：</span><span class="sxs-lookup"><span data-stu-id="0d61d-280">We cause the service layer CreateContact() method to return the value false with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

<span data-ttu-id="0d61d-281">如果 Create （）方法的行为与我们所期望的一样，则它应在服务层返回值为 false 时返回 Create view。</span><span class="sxs-lookup"><span data-stu-id="0d61d-281">If the Create() method behaves as we expect then it should return the Create view when the service layer returns the value false.</span></span> <span data-ttu-id="0d61d-282">这样一来，控制器就可以在 "创建" 视图中显示验证错误消息，并且用户有机会更正无效的联系人属性。</span><span class="sxs-lookup"><span data-stu-id="0d61d-282">That way, the controller can display the validation error messages in the Create view and the user has a chance to correct that invalid Contact properties.</span></span>

<span data-ttu-id="0d61d-283">如果打算为控制器构建单元测试，则需要从控制器操作返回显式视图名称。</span><span class="sxs-lookup"><span data-stu-id="0d61d-283">If you plan to build unit tests for your controllers then you need to return explicit view names from your controller actions.</span></span> <span data-ttu-id="0d61d-284">例如，不要返回如下所示的视图：</span><span class="sxs-lookup"><span data-stu-id="0d61d-284">For example, do not return a view like this:</span></span>

<span data-ttu-id="0d61d-285">return View();</span><span class="sxs-lookup"><span data-stu-id="0d61d-285">return View();</span></span>

<span data-ttu-id="0d61d-286">相反，返回如下所示的视图：</span><span class="sxs-lookup"><span data-stu-id="0d61d-286">Instead, return the view like this:</span></span>

<span data-ttu-id="0d61d-287">返回视图（"Create"）;</span><span class="sxs-lookup"><span data-stu-id="0d61d-287">return View("Create");</span></span>

<span data-ttu-id="0d61d-288">如果在返回视图时不是显式的，则 ViewResult. ViewName 属性返回空字符串。</span><span class="sxs-lookup"><span data-stu-id="0d61d-288">If you are not explicit when returning a view then the ViewResult.ViewName property returns an empty string.</span></span>

<span data-ttu-id="0d61d-289">**列表 2-Controllers\ContactControllerTest.cs**</span><span class="sxs-lookup"><span data-stu-id="0d61d-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a><span data-ttu-id="0d61d-290">摘要</span><span class="sxs-lookup"><span data-stu-id="0d61d-290">Summary</span></span>

<span data-ttu-id="0d61d-291">在此迭代中，我们为联系人管理器应用程序创建了单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-291">In this iteration, we created unit tests for our Contact Manager application.</span></span> <span data-ttu-id="0d61d-292">我们可以随时运行这些单元测试，以验证应用程序是否仍按预期方式运行。</span><span class="sxs-lookup"><span data-stu-id="0d61d-292">We can run these unit tests at any time to verify that our application still behaves in the manner that we expect.</span></span> <span data-ttu-id="0d61d-293">单元测试可充当应用程序的安全网络，使我们能够在将来安全地修改应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-293">The unit tests act as a safety net for our application enabling us to safely modify our application in the future.</span></span>

<span data-ttu-id="0d61d-294">我们创建了两组单元测试。</span><span class="sxs-lookup"><span data-stu-id="0d61d-294">We created two sets of unit tests.</span></span> <span data-ttu-id="0d61d-295">首先，我们通过为服务层创建单元测试来测试验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="0d61d-295">First, we tested our validation logic by creating unit tests for our service layer.</span></span> <span data-ttu-id="0d61d-296">接下来，我们通过为控制器层创建单元测试来测试流控制逻辑。</span><span class="sxs-lookup"><span data-stu-id="0d61d-296">Next, we tested our flow control logic by creating unit tests for our controller layer.</span></span> <span data-ttu-id="0d61d-297">在测试我们的服务层时，我们通过模拟存储库层将我们的服务层的测试与存储库层隔离开来。</span><span class="sxs-lookup"><span data-stu-id="0d61d-297">When testing our service layer, we isolated our tests for our service layer from our repository layer by mocking our repository layer.</span></span> <span data-ttu-id="0d61d-298">测试控制器层时，我们会通过模拟服务层，将我们的控制器层的测试隔离开来。</span><span class="sxs-lookup"><span data-stu-id="0d61d-298">When testing the controller layer, we isolated our tests for our controller layer by mocking the service layer.</span></span>

<span data-ttu-id="0d61d-299">在下一次迭代中，我们修改联系人管理器应用程序，使其支持联系人组。</span><span class="sxs-lookup"><span data-stu-id="0d61d-299">In the next iteration, we modify the Contact Manager application so that it supports Contact Groups.</span></span> <span data-ttu-id="0d61d-300">我们将使用名为 "测试驱动开发" 的软件设计过程将这一新功能添加到应用程序。</span><span class="sxs-lookup"><span data-stu-id="0d61d-300">We'll add this new functionality to our application using a software design process called test-driven development.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="0d61d-301">[上一页](iteration-4-make-the-application-loosely-coupled-cs.md)
> [下一页](iteration-6-use-test-driven-development-cs.md)</span><span class="sxs-lookup"><span data-stu-id="0d61d-301">[Previous](iteration-4-make-the-application-loosely-coupled-cs.md)
[Next](iteration-6-use-test-driven-development-cs.md)</span></span>

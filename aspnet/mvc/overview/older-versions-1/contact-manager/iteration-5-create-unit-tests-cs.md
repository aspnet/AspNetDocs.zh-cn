---
uid: mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
title: 迭代#5 = 创建单元测试 （C#） |微软文档
author: rick-anderson
description: 在第五次迭代中，我们通过添加单元测试使应用程序更易于维护和修改。 我们模拟我们的数据模型类，并为 o...
ms.author: riande
ms.date: 02/20/2009
ms.assetid: 28ad8f80-b8a5-444e-b478-8b15a846060c
msc.legacyurl: /mvc/overview/older-versions-1/contact-manager/iteration-5-create-unit-tests-cs
msc.type: authoredcontent
ms.openlocfilehash: c005a8ffc3b09c126d796f2feb74d402cb784aa2
ms.sourcegitcommit: 022f79dbc1350e0c6ffaa1e7e7c6e850cdabf9af
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/17/2020
ms.locfileid: "81542347"
---
# <a name="iteration-5--create-unit-tests-c"></a><span data-ttu-id="4646b-104">迭代 5 — 创建单元测试 (C#)</span><span class="sxs-lookup"><span data-stu-id="4646b-104">Iteration #5 – Create unit tests (C#)</span></span>

<span data-ttu-id="4646b-105">由[微软](https://github.com/microsoft)</span><span class="sxs-lookup"><span data-stu-id="4646b-105">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="4646b-106">下载代码</span><span class="sxs-lookup"><span data-stu-id="4646b-106">Download Code</span></span>](iteration-5-create-unit-tests-cs/_static/contactmanager_5_cs1.zip)

> <span data-ttu-id="4646b-107">在第五次迭代中，我们通过添加单元测试使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="4646b-107">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="4646b-108">我们模拟数据模型类，并为控制器和验证逻辑构建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-108">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

## <a name="building-a-contact-management-aspnet-mvc-application-c"></a><span data-ttu-id="4646b-109">构建联系人管理ASP.NET MVC 应用程序 （C#）</span><span class="sxs-lookup"><span data-stu-id="4646b-109">Building a Contact Management ASP.NET MVC Application (C#)</span></span>

<span data-ttu-id="4646b-110">在本系列教程中，我们从头到尾构建整个联系人管理应用程序。</span><span class="sxs-lookup"><span data-stu-id="4646b-110">In this series of tutorials, we build an entire Contact Management application from start to finish.</span></span> <span data-ttu-id="4646b-111">通过联系人管理器应用程序，您可以存储联系人信息 （姓名、电话号码和电子邮件地址） 人员列表。</span><span class="sxs-lookup"><span data-stu-id="4646b-111">The Contact Manager application enables you to store contact information - names, phone numbers and email addresses - for a list of people.</span></span>

<span data-ttu-id="4646b-112">我们通过多次迭代构建应用程序。</span><span class="sxs-lookup"><span data-stu-id="4646b-112">We build the application over multiple iterations.</span></span> <span data-ttu-id="4646b-113">每次迭代时，我们都会逐步改进应用程序。</span><span class="sxs-lookup"><span data-stu-id="4646b-113">With each iteration, we gradually improve the application.</span></span> <span data-ttu-id="4646b-114">此多迭代方法的目标是使您能够了解每次更改的原因。</span><span class="sxs-lookup"><span data-stu-id="4646b-114">The goal of this multiple iteration approach is to enable you to understand the reason for each change.</span></span>

- <span data-ttu-id="4646b-115">迭代#1 - 创建应用程序。</span><span class="sxs-lookup"><span data-stu-id="4646b-115">Iteration #1 - Create the application.</span></span> <span data-ttu-id="4646b-116">在第一次迭代中，我们以最简单的方式创建联系人管理器。</span><span class="sxs-lookup"><span data-stu-id="4646b-116">In the first iteration, we create the Contact Manager in the simplest way possible.</span></span> <span data-ttu-id="4646b-117">我们添加对基本数据库操作的支持：创建、读取、更新和删除 （CRUD）。</span><span class="sxs-lookup"><span data-stu-id="4646b-117">We add support for basic database operations: Create, Read, Update, and Delete (CRUD).</span></span>

- <span data-ttu-id="4646b-118">迭代#2 - 使应用程序看起来不错。</span><span class="sxs-lookup"><span data-stu-id="4646b-118">Iteration #2 - Make the application look nice.</span></span> <span data-ttu-id="4646b-119">在此迭代中，我们通过修改默认ASP.NET MVC 视图母版页和级联样式表来改进应用程序的外观。</span><span class="sxs-lookup"><span data-stu-id="4646b-119">In this iteration, we improve the appearance of the application by modifying the default ASP.NET MVC view master page and cascading style sheet.</span></span>

- <span data-ttu-id="4646b-120">迭代#3 - 添加表单验证。</span><span class="sxs-lookup"><span data-stu-id="4646b-120">Iteration #3 - Add form validation.</span></span> <span data-ttu-id="4646b-121">在第三个迭代中，我们添加基本表单验证。</span><span class="sxs-lookup"><span data-stu-id="4646b-121">In the third iteration, we add basic form validation.</span></span> <span data-ttu-id="4646b-122">我们防止人们在未填写所需表单字段的情况下提交表单。</span><span class="sxs-lookup"><span data-stu-id="4646b-122">We prevent people from submitting a form without completing required form fields.</span></span> <span data-ttu-id="4646b-123">我们还验证电子邮件地址和电话号码。</span><span class="sxs-lookup"><span data-stu-id="4646b-123">We also validate email addresses and phone numbers.</span></span>

- <span data-ttu-id="4646b-124">迭代#4 - 使应用程序松散耦合。</span><span class="sxs-lookup"><span data-stu-id="4646b-124">Iteration #4 - Make the application loosely coupled.</span></span> <span data-ttu-id="4646b-125">在第四次迭代中，我们利用多种软件设计模式，使维护和修改联系人管理器应用程序变得更加容易。</span><span class="sxs-lookup"><span data-stu-id="4646b-125">In this fourth iteration, we take advantage of several software design patterns to make it easier to maintain and modify the Contact Manager application.</span></span> <span data-ttu-id="4646b-126">例如，我们重构应用程序以使用存储库模式和依赖项注入模式。</span><span class="sxs-lookup"><span data-stu-id="4646b-126">For example, we refactor our application to use the Repository pattern and the Dependency Injection pattern.</span></span>

- <span data-ttu-id="4646b-127">迭代#5 - 创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-127">Iteration #5 - Create unit tests.</span></span> <span data-ttu-id="4646b-128">在第五次迭代中，我们通过添加单元测试使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="4646b-128">In the fifth iteration, we make our application easier to maintain and modify by adding unit tests.</span></span> <span data-ttu-id="4646b-129">我们模拟数据模型类，并为控制器和验证逻辑构建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-129">We mock our data model classes and build unit tests for our controllers and validation logic.</span></span>

- <span data-ttu-id="4646b-130">迭代#6 - 使用测试驱动开发。</span><span class="sxs-lookup"><span data-stu-id="4646b-130">Iteration #6 - Use test-driven development.</span></span> <span data-ttu-id="4646b-131">在第六次迭代中，我们首先编写单元测试并针对单元测试编写代码，从而向应用程序添加新功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-131">In this sixth iteration, we add new functionality to our application by writing unit tests first and writing code against the unit tests.</span></span> <span data-ttu-id="4646b-132">在此迭代中，我们添加联系人组。</span><span class="sxs-lookup"><span data-stu-id="4646b-132">In this iteration, we add contact groups.</span></span>

- <span data-ttu-id="4646b-133">迭代#7 - 添加Ajax功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-133">Iteration #7 - Add Ajax functionality.</span></span> <span data-ttu-id="4646b-134">在第七次迭代中，我们通过增加对Ajax的支持来提高应用程序的响应性和性能。</span><span class="sxs-lookup"><span data-stu-id="4646b-134">In the seventh iteration, we improve the responsiveness and performance of our application by adding support for Ajax.</span></span>

## <a name="this-iteration"></a><span data-ttu-id="4646b-135">此迭代</span><span class="sxs-lookup"><span data-stu-id="4646b-135">This Iteration</span></span>

<span data-ttu-id="4646b-136">在 Contact Manager 应用程序的上一次迭代中，我们将应用程序重构为更松散耦合。</span><span class="sxs-lookup"><span data-stu-id="4646b-136">In the previous iteration of the Contact Manager application, we refactored the application to be more loosely coupled.</span></span> <span data-ttu-id="4646b-137">我们将应用程序划分为不同的控制器、服务和存储库层。</span><span class="sxs-lookup"><span data-stu-id="4646b-137">We separated the application into distinct controller, service, and repository layers.</span></span> <span data-ttu-id="4646b-138">每个层通过接口与层交互。</span><span class="sxs-lookup"><span data-stu-id="4646b-138">Each layer interacts with the layer beneath it through interfaces.</span></span>

<span data-ttu-id="4646b-139">我们重构了应用程序，使应用程序更易于维护和修改。</span><span class="sxs-lookup"><span data-stu-id="4646b-139">We refactored the application to make the application easier to maintain and modify.</span></span> <span data-ttu-id="4646b-140">例如，如果需要使用新的数据访问技术，我们可以简单地更改存储库层而不接触控制器或服务层。</span><span class="sxs-lookup"><span data-stu-id="4646b-140">For example, if we need to use a new data access technology, we can simply change the repository layer without touching the controller or service layer.</span></span> <span data-ttu-id="4646b-141">通过使联系人管理器松散耦合，我们使应用程序对更改更具弹性。</span><span class="sxs-lookup"><span data-stu-id="4646b-141">By making the Contact Manager loosely coupled, we ve made the application more resilient to change.</span></span>

<span data-ttu-id="4646b-142">但是，当我们需要向联系人管理器应用程序添加新功能时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="4646b-142">But, what happens when we need to add a new feature to the Contact Manager application?</span></span> <span data-ttu-id="4646b-143">或者，当我们修复 Bug 时会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="4646b-143">Or, what happens when we fix a bug?</span></span> <span data-ttu-id="4646b-144">编写代码的可悲但经过充分验证的事实是，每当您触摸代码时，都会产生引入新 Bug 的风险。</span><span class="sxs-lookup"><span data-stu-id="4646b-144">A sad, but well proven, truth of writing code is that whenever you touch code you create the risk of introducing new bugs.</span></span>

<span data-ttu-id="4646b-145">例如，一天好，您的经理可能会要求您向联系人管理器添加新功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-145">For example, one fine day, your manager might ask you to add a new feature to the Contact Manager.</span></span> <span data-ttu-id="4646b-146">她希望您添加对联系人组的支持。</span><span class="sxs-lookup"><span data-stu-id="4646b-146">She wants you to add support for Contact Groups.</span></span> <span data-ttu-id="4646b-147">她希望您允许用户将联系人组织成"朋友"、"业务"等组。</span><span class="sxs-lookup"><span data-stu-id="4646b-147">She wants you to enable users to organize their contacts into groups such as Friends, Business, and so on.</span></span>

<span data-ttu-id="4646b-148">为了实现此新功能，您需要修改联系人管理器应用程序的所有三个层。</span><span class="sxs-lookup"><span data-stu-id="4646b-148">In order to implement this new feature, you'll need to modify all three layers of the Contact Manager application.</span></span> <span data-ttu-id="4646b-149">您需要向控制器、服务层和存储库添加新功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-149">You'll need to add new functionality to the controllers, the service layer, and the repository.</span></span> <span data-ttu-id="4646b-150">一旦开始修改代码，您就可能会破坏以前起作用的功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-150">As soon as you start modifying code, you risk breaking functionality that worked before.</span></span>

<span data-ttu-id="4646b-151">像上次迭代中所做的那样，将应用程序重构为单独的层是一件好事。</span><span class="sxs-lookup"><span data-stu-id="4646b-151">Refactoring our application into separate layers, as we did in the previous iteration, was a good thing.</span></span> <span data-ttu-id="4646b-152">这是一件好事，因为它使我们能够对整个层进行更改，而无需接触应用程序的其余部分。</span><span class="sxs-lookup"><span data-stu-id="4646b-152">It was a good thing because it enables us to make changes to entire layers without touching the rest of the application.</span></span> <span data-ttu-id="4646b-153">但是，如果要使层中的代码更易于维护和修改，则需要为代码创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-153">However, if you want to make the code within a layer easier to maintain and modify, you need to create unit tests for the code.</span></span>

<span data-ttu-id="4646b-154">使用单元测试来测试单个代码单元。</span><span class="sxs-lookup"><span data-stu-id="4646b-154">You use a unit test to test an individual unit of code.</span></span> <span data-ttu-id="4646b-155">这些代码单位小于整个应用程序层。</span><span class="sxs-lookup"><span data-stu-id="4646b-155">These units of code are smaller than entire application layers.</span></span> <span data-ttu-id="4646b-156">通常，使用单元测试来验证代码中的特定方法的行为方式是否达到预期。</span><span class="sxs-lookup"><span data-stu-id="4646b-156">Typically, you use a unit test to verify whether a particular method in your code behaves in the way that you expect.</span></span> <span data-ttu-id="4646b-157">例如，您将为 ContactManager 服务类公开的 CreateContact（） 方法创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-157">For example, you would create a unit test for the CreateContact() method exposed by the ContactManagerService class.</span></span>

<span data-ttu-id="4646b-158">应用程序单元测试工作就像安全网一样。</span><span class="sxs-lookup"><span data-stu-id="4646b-158">The unit tests for an application work just like a safety net.</span></span> <span data-ttu-id="4646b-159">每当修改应用程序中的代码时，都可以运行一组单元测试，以检查修改是否破坏了现有功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-159">Whenever you modify code in an application, you can run a set of unit tests to check whether the modification breaks existing functionality.</span></span> <span data-ttu-id="4646b-160">单元测试使代码可以安全地修改。</span><span class="sxs-lookup"><span data-stu-id="4646b-160">Unit tests make your code safe to modify.</span></span> <span data-ttu-id="4646b-161">单元测试使应用程序中的所有代码都更具更改的弹性。</span><span class="sxs-lookup"><span data-stu-id="4646b-161">Unit tests make all of the code in your application more resilient to change.</span></span>

<span data-ttu-id="4646b-162">在此迭代中，我们将单元测试添加到我们的联系人管理器应用程序中。</span><span class="sxs-lookup"><span data-stu-id="4646b-162">In this iteration, we add unit tests to our Contact Manager application.</span></span> <span data-ttu-id="4646b-163">这样，在下一次迭代中，我们可以将联系人组添加到我们的应用程序中，而不必担心破坏现有功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-163">That way, in the next iteration, we can add Contact Groups to our application without worrying about breaking existing functionality.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="4646b-164">有多种单元测试框架，包括 NUnit、xUnit.net 和 MbUnit。</span><span class="sxs-lookup"><span data-stu-id="4646b-164">There are a variety of unit testing frameworks including NUnit, xUnit.net, and MbUnit.</span></span> <span data-ttu-id="4646b-165">在本教程中，我们使用 Visual Studio 附带的单位测试框架。</span><span class="sxs-lookup"><span data-stu-id="4646b-165">In this tutorial, we use the unit testing framework included with Visual Studio.</span></span> <span data-ttu-id="4646b-166">但是，您可以同样轻松地使用这些替代框架之一。</span><span class="sxs-lookup"><span data-stu-id="4646b-166">However, you could just as easily use one of these alternative frameworks.</span></span>

## <a name="what-gets-tested"></a><span data-ttu-id="4646b-167">测试内容</span><span class="sxs-lookup"><span data-stu-id="4646b-167">What Gets Tested</span></span>

<span data-ttu-id="4646b-168">在理想情况下，所有代码都将由单元测试覆盖。</span><span class="sxs-lookup"><span data-stu-id="4646b-168">In the perfect world, all of your code would be covered by unit tests.</span></span> <span data-ttu-id="4646b-169">在完美的世界，你会有完美的安全网。</span><span class="sxs-lookup"><span data-stu-id="4646b-169">In the perfect world, you would have the perfect safety net.</span></span> <span data-ttu-id="4646b-170">您将能够修改应用程序中的任何代码行，并通过执行单元测试立即知道更改是否中断了现有功能。</span><span class="sxs-lookup"><span data-stu-id="4646b-170">You would be able to modify any line of code in your application and know instantly, by executing your unit tests, whether the change broke existing functionality.</span></span>

<span data-ttu-id="4646b-171">然而，我们并不生活在一个完美的世界。</span><span class="sxs-lookup"><span data-stu-id="4646b-171">However, we don t live in a perfect world.</span></span> <span data-ttu-id="4646b-172">实际上，在编写单元测试时，您专注于为业务逻辑编写测试（例如，验证逻辑）。</span><span class="sxs-lookup"><span data-stu-id="4646b-172">In practice, when writing unit tests, you concentrate on writing tests for your business logic (for example, validation logic).</span></span> <span data-ttu-id="4646b-173">特别是，您*不会*为数据访问逻辑或视图逻辑编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-173">In particular, you *do not* write unit tests for your data access logic or your view logic.</span></span>

<span data-ttu-id="4646b-174">为了有用，单元测试必须非常快速地执行。</span><span class="sxs-lookup"><span data-stu-id="4646b-174">To be useful, unit tests must execute very quickly.</span></span> <span data-ttu-id="4646b-175">您可以轻松地为应用程序累积数百（甚至数千个）单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-175">You easily can accumulate hundreds (or even thousands) of unit tests for an application.</span></span> <span data-ttu-id="4646b-176">如果单元测试需要很长时间才能运行，则可以避免执行它们。</span><span class="sxs-lookup"><span data-stu-id="4646b-176">If the unit tests take a long time to run then you'll avoid executing them.</span></span> <span data-ttu-id="4646b-177">换句话说，对于日常编码目的，长时间运行单元测试是无用的。</span><span class="sxs-lookup"><span data-stu-id="4646b-177">In other words, long running unit tests are useless for day to day coding purposes.</span></span>

<span data-ttu-id="4646b-178">因此，您通常不会为与数据库交互的代码编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-178">For this reason, you typically do not write unit tests for code that interacts with a database.</span></span> <span data-ttu-id="4646b-179">对实时数据库运行数百个单元测试将太慢。</span><span class="sxs-lookup"><span data-stu-id="4646b-179">Running hundreds of unit tests against a live database would be too slow.</span></span> <span data-ttu-id="4646b-180">相反，您模拟数据库并编写与模拟数据库交互的代码（我们讨论下面嘲笑数据库）。</span><span class="sxs-lookup"><span data-stu-id="4646b-180">Instead, you mock your database and write code that interacts with the mock database (we discuss mocking a database below).</span></span>

<span data-ttu-id="4646b-181">出于类似的原因，您通常不会为视图编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-181">For a similar reason, you typically do not write unit tests for views.</span></span> <span data-ttu-id="4646b-182">为了测试视图，必须启动 Web 服务器。</span><span class="sxs-lookup"><span data-stu-id="4646b-182">In order to test a view, you must spin up a web server.</span></span> <span data-ttu-id="4646b-183">由于旋转 Web 服务器是一个相对缓慢的过程，因此不建议为视图创建单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-183">Because spinning up a web server is a relatively slow process, creating unit tests for your views is not recommended.</span></span>

<span data-ttu-id="4646b-184">如果视图包含复杂的逻辑，则应考虑将逻辑移动到帮助程序方法中。</span><span class="sxs-lookup"><span data-stu-id="4646b-184">If your view contains complicated logic then you should consider moving the logic into Helper methods.</span></span> <span data-ttu-id="4646b-185">您可以为在不旋转 Web 服务器的情况下执行的 Helper 方法编写单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-185">You can write unit tests for Helper methods that execute without spinning up a web server.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="4646b-186">虽然编写数据访问逻辑或视图逻辑的测试在编写单元测试时不是个好主意，但这些测试在构建功能或集成测试时可能非常有价值。</span><span class="sxs-lookup"><span data-stu-id="4646b-186">While writing tests for data access logic or view logic is not a good idea when writing unit tests, these tests can be very valuable when building functional or integration tests.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="4646b-187">ASP.NET MVC 是 Web 窗体视图引擎。</span><span class="sxs-lookup"><span data-stu-id="4646b-187">ASP.NET MVC is the Web Forms View Engine.</span></span> <span data-ttu-id="4646b-188">虽然 Web 窗体视图引擎依赖于 Web 服务器，但其他视图引擎可能不是。</span><span class="sxs-lookup"><span data-stu-id="4646b-188">While the Web Forms View Engine is dependent on a web server, other view engines might not be.</span></span>

## <a name="using-a-mock-object-framework"></a><span data-ttu-id="4646b-189">使用模拟对象框架</span><span class="sxs-lookup"><span data-stu-id="4646b-189">Using a Mock Object Framework</span></span>

<span data-ttu-id="4646b-190">构建单元测试时，您几乎总是需要利用模拟对象框架。</span><span class="sxs-lookup"><span data-stu-id="4646b-190">When building unit tests, you almost always need to take advantage of a Mock Object framework.</span></span> <span data-ttu-id="4646b-191">模拟对象框架使您能够为应用程序中的类创建模拟和存根。</span><span class="sxs-lookup"><span data-stu-id="4646b-191">A Mock Object framework enables you to create mocks and stubs for the classes in your application.</span></span>

<span data-ttu-id="4646b-192">例如，可以使用 Mock Object 框架生成存储库类的模拟版本。</span><span class="sxs-lookup"><span data-stu-id="4646b-192">For example, you can use a Mock Object framework to generate a mock version of your repository class.</span></span> <span data-ttu-id="4646b-193">这样，您可以在单元测试中使用模拟存储库类而不是真正的存储库类。</span><span class="sxs-lookup"><span data-stu-id="4646b-193">That way, you can use the mock repository class instead of the real repository class in your unit tests.</span></span> <span data-ttu-id="4646b-194">使用模拟存储库使您能够在执行单元测试时避免执行数据库代码。</span><span class="sxs-lookup"><span data-stu-id="4646b-194">Using the mock repository enables you to avoid executing database code when executing a unit test.</span></span>

<span data-ttu-id="4646b-195">可视化工作室不包括模拟对象框架。</span><span class="sxs-lookup"><span data-stu-id="4646b-195">Visual Studio does not include a Mock Object framework.</span></span> <span data-ttu-id="4646b-196">但是，有几种商业和开源模拟对象框架可用于 .NET 框架：</span><span class="sxs-lookup"><span data-stu-id="4646b-196">However, there are several commercial and open source Mock Object frameworks available for the .NET framework:</span></span>

1. <span data-ttu-id="4646b-197">Moq - 此框架在开源 BSD 许可证下可用。</span><span class="sxs-lookup"><span data-stu-id="4646b-197">Moq - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="4646b-198">你可以从[https://code.google.com/p/moq/](https://code.google.com/p/moq/)下载莫克。</span><span class="sxs-lookup"><span data-stu-id="4646b-198">You can download Moq from [https://code.google.com/p/moq/](https://code.google.com/p/moq/).</span></span>
2. <span data-ttu-id="4646b-199">犀牛模拟 - 此框架可在开源 BSD 许可证下提供。</span><span class="sxs-lookup"><span data-stu-id="4646b-199">Rhino Mocks - This framework is available under the open source BSD license.</span></span> <span data-ttu-id="4646b-200">你可以从[http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx)下载犀牛模拟。</span><span class="sxs-lookup"><span data-stu-id="4646b-200">You can download Rhino Mocks from [http://ayende.com/projects/rhino-mocks.aspx](http://ayende.com/projects/rhino-mocks.aspx).</span></span>
3. <span data-ttu-id="4646b-201">类型隔离器 - 这是一个商业框架。</span><span class="sxs-lookup"><span data-stu-id="4646b-201">Typemock Isolator - This is a commercial framework.</span></span> <span data-ttu-id="4646b-202">可以从 下载试用版[http://www.typemock.com/](http://www.typemock.com/)。</span><span class="sxs-lookup"><span data-stu-id="4646b-202">You can download a trial version from [http://www.typemock.com/](http://www.typemock.com/).</span></span>

<span data-ttu-id="4646b-203">在本教程中，我决定使用 Moq。</span><span class="sxs-lookup"><span data-stu-id="4646b-203">In this tutorial, I decided to use Moq.</span></span> <span data-ttu-id="4646b-204">但是，您可以同样轻松地使用 Rhino Mocks 或 Typemock 隔离器为联系人管理器应用程序创建 Mock 对象。</span><span class="sxs-lookup"><span data-stu-id="4646b-204">However, you could just as easily use Rhino Mocks or Typemock Isolator to create the Mock objects for the Contact Manager application.</span></span>

<span data-ttu-id="4646b-205">在使用 Moq 之前，您需要完成以下步骤：</span><span class="sxs-lookup"><span data-stu-id="4646b-205">Before you can use Moq, you need to complete the following steps:</span></span>

1. <span data-ttu-id="4646b-206">.</span><span class="sxs-lookup"><span data-stu-id="4646b-206">.</span></span>
2. <span data-ttu-id="4646b-207">在解压缩下载之前，请确保右键单击文件并单击标记为 **"取消阻止"** 的按钮（参见图 1）。</span><span class="sxs-lookup"><span data-stu-id="4646b-207">Before you unzip the download, make sure that you right-click the file and click the button labeled **Unblock** (see Figure 1).</span></span>
3. <span data-ttu-id="4646b-208">解压缩下载。</span><span class="sxs-lookup"><span data-stu-id="4646b-208">Unzip the download.</span></span>
4. <span data-ttu-id="4646b-209">通过右键单击 ContactManager 中的"引用"文件夹并选择 **"添加引用**"，添加对 Moq 程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="4646b-209">Add a reference to the Moq assembly by right-clicking the References folder in the ContactManager.Tests project and selecting **Add Reference**.</span></span> <span data-ttu-id="4646b-210">在"浏览"选项卡下，浏览到解压缩 Moq 的文件夹，然后选择 Moq.dll 程序集。</span><span class="sxs-lookup"><span data-stu-id="4646b-210">Under the Browse tab, browse to the folder where you unzipped Moq and select the Moq.dll assembly.</span></span> <span data-ttu-id="4646b-211">单击“确定”\*\*\*\* 按钮。</span><span class="sxs-lookup"><span data-stu-id="4646b-211">Click the **OK** button.</span></span>
5. <span data-ttu-id="4646b-212">完成这些步骤后，参考文件夹应类似于图 2。</span><span class="sxs-lookup"><span data-stu-id="4646b-212">After you complete these steps, your References folder should look like Figure 2.</span></span>

<span data-ttu-id="4646b-213">[![解除阻止莫克](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="4646b-213">[![Unblocking Moq](iteration-5-create-unit-tests-cs/_static/image1.jpg)](iteration-5-create-unit-tests-cs/_static/image1.png)</span></span>

<span data-ttu-id="4646b-214">**图 01**： 取消阻止 Moq（[单击以查看全尺寸图像](iteration-5-create-unit-tests-cs/_static/image2.png)）</span><span class="sxs-lookup"><span data-stu-id="4646b-214">**Figure 01**: Unblocking Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image2.png))</span></span>

<span data-ttu-id="4646b-215">[![添加 Moq 后的引用](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="4646b-215">[![References after adding Moq](iteration-5-create-unit-tests-cs/_static/image2.jpg)](iteration-5-create-unit-tests-cs/_static/image3.png)</span></span>

<span data-ttu-id="4646b-216">**图 02**： 添加 Moq（[单击以查看全尺寸图像](iteration-5-create-unit-tests-cs/_static/image4.png)）后的参考</span><span class="sxs-lookup"><span data-stu-id="4646b-216">**Figure 02**: References after adding Moq([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image4.png))</span></span>

## <a name="creating-unit-tests-for-the-service-layer"></a><span data-ttu-id="4646b-217">为服务层创建单元测试</span><span class="sxs-lookup"><span data-stu-id="4646b-217">Creating Unit Tests for the Service Layer</span></span>

<span data-ttu-id="4646b-218">让我们首先为联系人管理器应用程序的服务层创建一组单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-218">Let s start by creating a set of unit tests for our Contact Manager application s service layer.</span></span> <span data-ttu-id="4646b-219">我们将使用这些测试来验证我们的验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="4646b-219">We'll use these tests to verify our validation logic.</span></span>

<span data-ttu-id="4646b-220">在 ContactManager.测试项目中创建名为"模型"的新文件夹。</span><span class="sxs-lookup"><span data-stu-id="4646b-220">Create a new folder named Models in the ContactManager.Tests project.</span></span> <span data-ttu-id="4646b-221">接下来，右键单击"模型"文件夹并选择 **"添加、新建测试**"。</span><span class="sxs-lookup"><span data-stu-id="4646b-221">Next, right-click the Models folder and select **Add, New Test**.</span></span> <span data-ttu-id="4646b-222">将显示图 3 所示**的"添加新测试**"对话框。</span><span class="sxs-lookup"><span data-stu-id="4646b-222">The **Add New Test** dialog shown in Figure 3 appears.</span></span> <span data-ttu-id="4646b-223">选择 **"单元测试"** 模板并命名新测试ContactManagerServiceTest.cs。</span><span class="sxs-lookup"><span data-stu-id="4646b-223">Select the **Unit Test** template and name your new test ContactManagerServiceTest.cs.</span></span> <span data-ttu-id="4646b-224">单击 **"确定"** 按钮将新测试添加到测试项目。</span><span class="sxs-lookup"><span data-stu-id="4646b-224">Click the **OK** button to add your new test to your Test Project.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="4646b-225">通常，您希望测试项目的文件夹结构与 ASP.NET MVC 项目的文件夹结构匹配。</span><span class="sxs-lookup"><span data-stu-id="4646b-225">In general, you want the folder structure of your Test Project to match the folder structure of your ASP.NET MVC project.</span></span> <span data-ttu-id="4646b-226">例如，将控制器测试放在控制器文件夹中，在模型文件夹中放置模型测试，等等。</span><span class="sxs-lookup"><span data-stu-id="4646b-226">For example, you place controller tests in a Controllers folder, model tests in a Models folder, and so on.</span></span>

<span data-ttu-id="4646b-227">[![型号_联系管理器服务测试.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="4646b-227">[![Models\ContactManagerServiceTest.cs](iteration-5-create-unit-tests-cs/_static/image3.jpg)](iteration-5-create-unit-tests-cs/_static/image5.png)</span></span>

<span data-ttu-id="4646b-228">**图 03**：型号_ContactManagerServiceTest.cs（[单击以查看全尺寸图像](iteration-5-create-unit-tests-cs/_static/image6.png)）</span><span class="sxs-lookup"><span data-stu-id="4646b-228">**Figure 03**: Models\ContactManagerServiceTest.cs([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image6.png))</span></span>

<span data-ttu-id="4646b-229">最初，我们要测试 ContactManager 服务类公开的 CreateContact（） 方法。</span><span class="sxs-lookup"><span data-stu-id="4646b-229">Initially, we want to test the CreateContact() method exposed by the ContactManagerService class.</span></span> <span data-ttu-id="4646b-230">我们将创建以下五个测试：</span><span class="sxs-lookup"><span data-stu-id="4646b-230">We'll create the following five tests:</span></span>

- <span data-ttu-id="4646b-231">创建联系人（） - 当有效的联系人传递给方法时，创建联系人（） 的测试返回该值为 true。</span><span class="sxs-lookup"><span data-stu-id="4646b-231">CreateContact() - Tests that CreateContact() returns the value true when a valid Contact is passed to the method.</span></span>
- <span data-ttu-id="4646b-232">创建联系人需要先名（） - 测试当缺少名字的联系人传递给 CreateContact（） 方法时，错误消息是否添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="4646b-232">CreateContactRequiredFirstName() - Tests that an error message is added to model state when a Contact with a missing first name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="4646b-233">创建联系人需要LastName（） - 测试当缺少姓氏的联系人传递给 CreateContact（） 方法时，将错误消息添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="4646b-233">CreateContactRequiredLastName() - Tests that an error message is added to model state when a Contact with a missing last name is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="4646b-234">创建联系人无效电话（） - 测试当电话号码无效的联系人传递给 CreateContact（） 方法时，错误消息是否添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="4646b-234">CreateContactInvalidPhone() - Tests that an error message is added to model state when a Contact with an invalid phone number is passed to the CreateContact() method.</span></span>
- <span data-ttu-id="4646b-235">创建联系人无效电子邮件（） - 测试当具有无效电子邮件地址的联系人传递给 CreateContact（） 方法时，错误消息是否添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="4646b-235">CreateContactInvalidEmail() - Tests that an error message is added to model state when a Contact with an invalid email address is passed to the CreateContact() method..</span></span>

<span data-ttu-id="4646b-236">第一个测试验证有效的联系人未生成验证错误。</span><span class="sxs-lookup"><span data-stu-id="4646b-236">The first test verifies that a valid Contact does not generate a validation error.</span></span> <span data-ttu-id="4646b-237">其余的测试检查每个验证规则。</span><span class="sxs-lookup"><span data-stu-id="4646b-237">The remaining tests check each of the validation rules.</span></span>

<span data-ttu-id="4646b-238">这些测试的代码包含在清单 1 中。</span><span class="sxs-lookup"><span data-stu-id="4646b-238">The code for these tests is contained in Listing 1.</span></span>

<span data-ttu-id="4646b-239">**清单1 - 型号_联系管理器服务测试.cs**</span><span class="sxs-lookup"><span data-stu-id="4646b-239">**Listing 1 - Models\ContactManagerServiceTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample1.cs)]

<span data-ttu-id="4646b-240">由于我们使用清单 1 中的 Contact 类，因此我们需要将对 Microsoft 实体框架的引用添加到我们的测试项目中。</span><span class="sxs-lookup"><span data-stu-id="4646b-240">Because we use the Contact class in Listing 1, we need to add a reference to the Microsoft Entity Framework to our Test project.</span></span> <span data-ttu-id="4646b-241">添加对系统.Data.实体程序集的引用。</span><span class="sxs-lookup"><span data-stu-id="4646b-241">Add a reference to the System.Data.Entity assembly.</span></span>

<span data-ttu-id="4646b-242">清单1包含一个名为初始化（）的方法，该方法用 [测试初始化] 属性进行修饰。</span><span class="sxs-lookup"><span data-stu-id="4646b-242">Listing 1 contains a method named Initialize() that is decorated with the [TestInitialize] attribute.</span></span> <span data-ttu-id="4646b-243">在运行每个单元测试之前自动调用此方法（在每个单元测试之前调用此方法 5 次）。</span><span class="sxs-lookup"><span data-stu-id="4646b-243">This method is called automatically before each of the unit tests is run (it is called 5 times right before each of the unit tests).</span></span> <span data-ttu-id="4646b-244">初始化（）方法创建具有以下代码行的模拟存储库：</span><span class="sxs-lookup"><span data-stu-id="4646b-244">The Initialize() method creates a mock repository with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample2.cs)]

<span data-ttu-id="4646b-245">此代码行使用 Moq 框架从 IContactManagerRepository 接口生成模拟存储库。</span><span class="sxs-lookup"><span data-stu-id="4646b-245">This line of code uses the Moq framework to generate a mock repository from the IContactManagerRepository interface.</span></span> <span data-ttu-id="4646b-246">使用模拟存储库而不是实际的实体联系人管理器存储库，以避免在运行每个单元测试时访问数据库。</span><span class="sxs-lookup"><span data-stu-id="4646b-246">The mock repository is used instead of the actual EntityContactManagerRepository to avoid accessing the database when each unit test is run.</span></span> <span data-ttu-id="4646b-247">模拟存储库实现 IContactManagerRepository 接口的方法，但这些方法实际上不执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="4646b-247">The mock repository implements the methods of the IContactManagerRepository interface, but the methods don t actually do anything.</span></span>

> [!NOTE] 
> 
> <span data-ttu-id="4646b-248">使用 Moq 框架时，mockRepository 和\_\_mockRepository.Object 区别是有区别的。</span><span class="sxs-lookup"><span data-stu-id="4646b-248">When using the Moq framework, there is a distinction between \_mockRepository and \_mockRepository.Object.</span></span> <span data-ttu-id="4646b-249">前者是指模拟&lt;IContactManagerManagerRepository&gt;类，该类包含用于指定模拟存储库如何执行的方法。</span><span class="sxs-lookup"><span data-stu-id="4646b-249">The former refers to the Mock&lt;IContactManagerRepository&gt; class that contains methods for specifying how the mock repository will behave.</span></span> <span data-ttu-id="4646b-250">后者是指实现 IContactManager存储库接口的实际模拟存储库。</span><span class="sxs-lookup"><span data-stu-id="4646b-250">The latter refers to the actual mock repository that implements the IContactManagerRepository interface.</span></span>

<span data-ttu-id="4646b-251">创建 ContactManagerService 类的实例时，模拟存储库在初始化（） 方法中使用。</span><span class="sxs-lookup"><span data-stu-id="4646b-251">The mock repository is used in the Initialize() method when creating an instance of the ContactManagerService class.</span></span> <span data-ttu-id="4646b-252">所有单独的单元测试都使用此联系人管理器服务类的此实例。</span><span class="sxs-lookup"><span data-stu-id="4646b-252">All of the individual unit tests use this instance of the ContactManagerService class.</span></span>

<span data-ttu-id="4646b-253">清单1包含与每个单元测试对应的五种方法。</span><span class="sxs-lookup"><span data-stu-id="4646b-253">Listing 1 contains five methods that correspond to each of the unit tests.</span></span> <span data-ttu-id="4646b-254">这些方法中的每一个都用 [TestMethod] 属性进行修饰。</span><span class="sxs-lookup"><span data-stu-id="4646b-254">Each of these methods is decorated with the [TestMethod] attribute.</span></span> <span data-ttu-id="4646b-255">运行单元测试时，将调用具有此属性的任何方法。</span><span class="sxs-lookup"><span data-stu-id="4646b-255">When you run the unit tests, any method that has this attribute is called.</span></span> <span data-ttu-id="4646b-256">换句话说，使用 [TestMethod] 属性修饰的任何方法都是单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-256">In other words, any method that is decorated with the [TestMethod] attribute is a unit test.</span></span>

<span data-ttu-id="4646b-257">第一个单元测试名为 CreateContact（），验证在将 Contact 类的有效实例传递给该方法时调用 CreateContact（） 返回该值为 true。</span><span class="sxs-lookup"><span data-stu-id="4646b-257">The first unit test, named CreateContact(), verifies that calling CreateContact() returns the value true when a valid instance of the Contact class is passed to the method.</span></span> <span data-ttu-id="4646b-258">测试创建 Contact 类的实例，调用 CreateContact（） 方法，并验证 CreateContact（） 返回该值为 true。</span><span class="sxs-lookup"><span data-stu-id="4646b-258">The test creates an instance of the Contact class, calls the CreateContact() method, and verifies that CreateContact() returns the value true.</span></span>

<span data-ttu-id="4646b-259">其余测试验证当使用无效的 Contact 调用 CreateContact（） 方法时，该方法将返回 false，并且预期的验证错误消息将添加到模型状态。</span><span class="sxs-lookup"><span data-stu-id="4646b-259">The remaining tests verify that when the CreateContact() method is called with an invalid Contact then the method returns false and the expected validation error message is added to model state.</span></span> <span data-ttu-id="4646b-260">例如，"创建联系人需求名称（）"测试将创建联系人类的实例，该类的 FirstName 属性具有空字符串。</span><span class="sxs-lookup"><span data-stu-id="4646b-260">For example, the CreateContactRequiredFirstName() test creates an instance of the Contact class with an empty string for its FirstName property.</span></span> <span data-ttu-id="4646b-261">接下来，使用无效的联系人调用 CreateContact（） 方法。</span><span class="sxs-lookup"><span data-stu-id="4646b-261">Next, the CreateContact() method is called with the invalid Contact.</span></span> <span data-ttu-id="4646b-262">最后，测试验证 CreateContact（） 返回 false，并且模型状态包含预期的验证错误消息"需要名字"。</span><span class="sxs-lookup"><span data-stu-id="4646b-262">Finally, the test verifies that CreateContact() returns false and that model state contains the expected validation error message "First name is required."</span></span>

<span data-ttu-id="4646b-263">您可以通过选择菜单选项 **"测试"、"运行"、"解决方案中的所有测试"（CTRL+R、A）** 来在清单 1 中运行单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-263">You can run the unit tests in Listing 1 by selecting the menu option **Test, Run, All Tests in Solution (CTRL+R, A)**.</span></span> <span data-ttu-id="4646b-264">测试结果显示在"测试结果"窗口中（参见图 4）。</span><span class="sxs-lookup"><span data-stu-id="4646b-264">The results of the tests are displayed in the Test Results window (see Figure 4).</span></span>

<span data-ttu-id="4646b-265">[![测试结果](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="4646b-265">[![Test Results](iteration-5-create-unit-tests-cs/_static/image4.jpg)](iteration-5-create-unit-tests-cs/_static/image7.png)</span></span>

<span data-ttu-id="4646b-266">**图 04**： 测试结果 （[单击以查看全尺寸图像](iteration-5-create-unit-tests-cs/_static/image8.png)）</span><span class="sxs-lookup"><span data-stu-id="4646b-266">**Figure 04**: Test Results ([Click to view full-size image](iteration-5-create-unit-tests-cs/_static/image8.png))</span></span>

## <a name="creating-unit-tests-for-controllers"></a><span data-ttu-id="4646b-267">为控制器创建单元测试</span><span class="sxs-lookup"><span data-stu-id="4646b-267">Creating Unit Tests for Controllers</span></span>

<span data-ttu-id="4646b-268">ASP.NETMVC 应用程序控制用户交互流。</span><span class="sxs-lookup"><span data-stu-id="4646b-268">ASP.NETMVC application control the flow of user interaction.</span></span> <span data-ttu-id="4646b-269">测试控制器时，要测试控制器是否返回正确的操作结果并查看数据。</span><span class="sxs-lookup"><span data-stu-id="4646b-269">When testing a controller, you want to test whether the controller returns the right action result and view data.</span></span> <span data-ttu-id="4646b-270">您可能还希望测试控制器是否与模型类以预期的方式交互。</span><span class="sxs-lookup"><span data-stu-id="4646b-270">You also might want to test whether a controller interacts with model classes in the manner expected.</span></span>

<span data-ttu-id="4646b-271">例如，清单 2 包含联系人控制器 Create（） 方法的两个单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-271">For example, Listing 2 contains two unit tests for the Contact controller Create() method.</span></span> <span data-ttu-id="4646b-272">第一个单元测试验证当有效的联系人传递到 Create（） 方法时，Create（） 方法重定向到 Index 操作。</span><span class="sxs-lookup"><span data-stu-id="4646b-272">The first unit test verifies that when a valid Contact is passed to the Create() method then the Create() method redirects to the Index action.</span></span> <span data-ttu-id="4646b-273">换句话说，当传递有效的联系人时，Create（） 方法应返回表示索引操作的重定向到RouteResult。</span><span class="sxs-lookup"><span data-stu-id="4646b-273">In other words, when passed a valid Contact, the Create() method should return a RedirectToRouteResult that represents the Index action.</span></span>

<span data-ttu-id="4646b-274">在测试控制器层时，我们不想测试 ContactManager 服务层。</span><span class="sxs-lookup"><span data-stu-id="4646b-274">We don t want to test the ContactManager service layer when we are testing the controller layer.</span></span> <span data-ttu-id="4646b-275">因此，我们在初始化方法中使用以下代码模拟服务层：</span><span class="sxs-lookup"><span data-stu-id="4646b-275">Therefore, we mock the service layer with the following code in the Initialize method:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample3.cs)]

<span data-ttu-id="4646b-276">在 CreateValidContact（） 单元测试中，我们用以下代码行模拟调用服务层 CreateContact（） 方法的行为：</span><span class="sxs-lookup"><span data-stu-id="4646b-276">In the CreateValidContact() unit test, we mock the behavior of calling the service layer CreateContact() method with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample4.cs)]

<span data-ttu-id="4646b-277">此代码行在调用其 CreateContact（） 方法时，会导致模拟 ContactManager 服务返回该值 true。</span><span class="sxs-lookup"><span data-stu-id="4646b-277">This line of code causes the mock ContactManager service to return the value true when its CreateContact() method is called.</span></span> <span data-ttu-id="4646b-278">通过模拟服务层，我们可以测试控制器的行为，而无需在服务层中执行任何代码。</span><span class="sxs-lookup"><span data-stu-id="4646b-278">By mocking the service layer, we can test the behavior of our controller without needing to execute any code in the service layer.</span></span>

<span data-ttu-id="4646b-279">第二个单元测试验证 Create（） 操作在将无效联系人传递给方法时是否返回"创建"视图。</span><span class="sxs-lookup"><span data-stu-id="4646b-279">The second unit test verifies that the Create() action returns the Create view when an invalid contact is passed to the method.</span></span> <span data-ttu-id="4646b-280">我们使服务层 CreateContact（） 方法使用以下代码行返回错误值：</span><span class="sxs-lookup"><span data-stu-id="4646b-280">We cause the service layer CreateContact() method to return the value false with the following line of code:</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample5.cs)]

<span data-ttu-id="4646b-281">如果 Create（） 方法按预期方式进行，则当服务层返回值为 false 时，它应返回"创建"视图。</span><span class="sxs-lookup"><span data-stu-id="4646b-281">If the Create() method behaves as we expect then it should return the Create view when the service layer returns the value false.</span></span> <span data-ttu-id="4646b-282">这样，控制器可以在"创建"视图中显示验证错误消息，并且用户有机会更正无效的"联系人"属性。</span><span class="sxs-lookup"><span data-stu-id="4646b-282">That way, the controller can display the validation error messages in the Create view and the user has a chance to correct that invalid Contact properties.</span></span>

<span data-ttu-id="4646b-283">如果计划为控制器生成单元测试，则需要从控制器操作中返回显式视图名称。</span><span class="sxs-lookup"><span data-stu-id="4646b-283">If you plan to build unit tests for your controllers then you need to return explicit view names from your controller actions.</span></span> <span data-ttu-id="4646b-284">例如，不要返回如下所示的视图：</span><span class="sxs-lookup"><span data-stu-id="4646b-284">For example, do not return a view like this:</span></span>

<span data-ttu-id="4646b-285">return View();</span><span class="sxs-lookup"><span data-stu-id="4646b-285">return View();</span></span>

<span data-ttu-id="4646b-286">相反，返回视图如下所示：</span><span class="sxs-lookup"><span data-stu-id="4646b-286">Instead, return the view like this:</span></span>

<span data-ttu-id="4646b-287">返回视图（"创建"）;</span><span class="sxs-lookup"><span data-stu-id="4646b-287">return View("Create");</span></span>

<span data-ttu-id="4646b-288">如果在返回视图时不是显式，则 ViewResult.ViewName 属性将返回一个空字符串。</span><span class="sxs-lookup"><span data-stu-id="4646b-288">If you are not explicit when returning a view then the ViewResult.ViewName property returns an empty string.</span></span>

<span data-ttu-id="4646b-289">**清单2 - 控制器\联系控制器测试.cs**</span><span class="sxs-lookup"><span data-stu-id="4646b-289">**Listing 2 - Controllers\ContactControllerTest.cs**</span></span>

[!code-csharp[Main](iteration-5-create-unit-tests-cs/samples/sample6.cs)]

## <a name="summary"></a><span data-ttu-id="4646b-290">总结</span><span class="sxs-lookup"><span data-stu-id="4646b-290">Summary</span></span>

<span data-ttu-id="4646b-291">在此迭代中，我们为联系人管理器应用程序创建了单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-291">In this iteration, we created unit tests for our Contact Manager application.</span></span> <span data-ttu-id="4646b-292">我们可以随时运行这些单元测试，以验证我们的应用程序是否仍按预期方式运行。</span><span class="sxs-lookup"><span data-stu-id="4646b-292">We can run these unit tests at any time to verify that our application still behaves in the manner that we expect.</span></span> <span data-ttu-id="4646b-293">单元测试作为我们应用程序的安全网，使我们能够在未来安全地修改我们的应用程序。</span><span class="sxs-lookup"><span data-stu-id="4646b-293">The unit tests act as a safety net for our application enabling us to safely modify our application in the future.</span></span>

<span data-ttu-id="4646b-294">我们创建了两组单元测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-294">We created two sets of unit tests.</span></span> <span data-ttu-id="4646b-295">首先，我们通过为服务层创建单元测试来测试验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="4646b-295">First, we tested our validation logic by creating unit tests for our service layer.</span></span> <span data-ttu-id="4646b-296">接下来，我们通过为控制器层创建单元测试来测试流量控制逻辑。</span><span class="sxs-lookup"><span data-stu-id="4646b-296">Next, we tested our flow control logic by creating unit tests for our controller layer.</span></span> <span data-ttu-id="4646b-297">在测试服务层时，我们通过模拟存储库层将服务层的测试与存储库层隔离开来。</span><span class="sxs-lookup"><span data-stu-id="4646b-297">When testing our service layer, we isolated our tests for our service layer from our repository layer by mocking our repository layer.</span></span> <span data-ttu-id="4646b-298">测试控制器层时，我们通过模拟服务层来隔离控制器层的测试。</span><span class="sxs-lookup"><span data-stu-id="4646b-298">When testing the controller layer, we isolated our tests for our controller layer by mocking the service layer.</span></span>

<span data-ttu-id="4646b-299">在下一次迭代中，我们修改联系人管理器应用程序，以便它支持联系人组。</span><span class="sxs-lookup"><span data-stu-id="4646b-299">In the next iteration, we modify the Contact Manager application so that it supports Contact Groups.</span></span> <span data-ttu-id="4646b-300">我们将使用称为测试驱动开发的软件设计过程将这项新功能添加到我们的应用程序中。</span><span class="sxs-lookup"><span data-stu-id="4646b-300">We'll add this new functionality to our application using a software design process called test-driven development.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="4646b-301">[上一页](iteration-4-make-the-application-loosely-coupled-cs.md)
> [下一页](iteration-6-use-test-driven-development-cs.md)</span><span class="sxs-lookup"><span data-stu-id="4646b-301">[Previous](iteration-4-make-the-application-loosely-coupled-cs.md)
[Next](iteration-6-use-test-driven-development-cs.md)</span></span>

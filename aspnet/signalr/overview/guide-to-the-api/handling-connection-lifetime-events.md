---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 理解和处理信号R中的连接寿命事件 |微软文档
author: bradygaster
description: 本文介绍如何使用中心 API 公开的事件。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675825"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="79329-103">了解和处理 SignalR 中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="79329-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="79329-104">本文概述了可以处理的 SignalR 连接、重新连接和断开连接事件，以及可以配置的超时和保持活动设置。</span><span class="sxs-lookup"><span data-stu-id="79329-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="79329-105">本文假定您已经对 SignalR 和连接生存期事件有所了解。</span><span class="sxs-lookup"><span data-stu-id="79329-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="79329-106">有关信号R 的介绍，请参阅[信号R 简介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="79329-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="79329-107">有关连接生存期事件的列表，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="79329-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="79329-108">如何处理集线器类中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="79329-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="79329-109">如何处理 JavaScript 客户端中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="79329-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="79329-110">如何处理 .NET 客户端中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="79329-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="79329-111">本主题中使用的软件版本</span><span class="sxs-lookup"><span data-stu-id="79329-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="79329-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="79329-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="79329-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="79329-113">.NET 4.5</span></span>
> - <span data-ttu-id="79329-114">信号R版本 2</span><span class="sxs-lookup"><span data-stu-id="79329-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="79329-115">本主题的早期版本</span><span class="sxs-lookup"><span data-stu-id="79329-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="79329-116">有关早期版本的 SignalR 的信息，请参阅[SignalR 旧版本](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="79329-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="79329-117">问题和评论</span><span class="sxs-lookup"><span data-stu-id="79329-117">Questions and comments</span></span>
>
> <span data-ttu-id="79329-118">请留下反馈，关于你喜欢本教程的方式，以及我们可以在页面底部的评论中改进什么。</span><span class="sxs-lookup"><span data-stu-id="79329-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="79329-119">如果您有与本教程没有直接关系的问题，您可以将它们发布到[ASP.NET SignalR 论坛](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)或[StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="79329-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="79329-120">概述</span><span class="sxs-lookup"><span data-stu-id="79329-120">Overview</span></span>

<span data-ttu-id="79329-121">本文包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="79329-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="79329-122">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="79329-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="79329-123">信号R连接、传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="79329-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="79329-124">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="79329-125">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="79329-126">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="79329-127">超时和保持活动设置</span><span class="sxs-lookup"><span data-stu-id="79329-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="79329-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="79329-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="79329-129">断开连接超时</span><span class="sxs-lookup"><span data-stu-id="79329-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="79329-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="79329-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="79329-131">如何更改超时并保持活动设置</span><span class="sxs-lookup"><span data-stu-id="79329-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="79329-132">如何通知用户断开连接</span><span class="sxs-lookup"><span data-stu-id="79329-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="79329-133">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="79329-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="79329-134">如何在服务器代码中断开客户端</span><span class="sxs-lookup"><span data-stu-id="79329-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="79329-135">检测断开连接的原因</span><span class="sxs-lookup"><span data-stu-id="79329-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="79329-136">指向 API 参考主题的链接指向 API 的 .NET 4.5 版本。</span><span class="sxs-lookup"><span data-stu-id="79329-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="79329-137">如果使用 .NET 4，请参阅[API 主题的 .NET 4 版本](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="79329-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="79329-138">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="79329-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="79329-139">SignalR Hub 中`OnReconnected`的事件处理程序可以直接在给定客户端`OnConnected`之后执行，`OnDisconnected`但不能在之后执行。</span><span class="sxs-lookup"><span data-stu-id="79329-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="79329-140">在没有断开连接的情况下进行重新连接的原因是，在 SignalR 中使用"连接"一词有多种方式。</span><span class="sxs-lookup"><span data-stu-id="79329-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="79329-141">信号R连接、传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="79329-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="79329-142">本文将区分*SignalR 连接*、*传输连接*和*物理连接*：</span><span class="sxs-lookup"><span data-stu-id="79329-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="79329-143">**SignalR 连接**是指客户端和服务器 URL 之间的逻辑关系，由 SignalR API 维护，并由连接 ID 唯一标识。</span><span class="sxs-lookup"><span data-stu-id="79329-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="79329-144">有关此关系的数据由 SignalR 维护，用于建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="79329-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="79329-145">当客户端调用`Stop`方法或达到超时限制时，当 SignalR 尝试重新建立丢失的传输连接时，关系结束，SignalR 会释放数据。</span><span class="sxs-lookup"><span data-stu-id="79329-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="79329-146">**传输连接**是指客户端和服务器之间的逻辑关系，由四个传输 API 之一维护：WebSockets、服务器发送的事件、永久帧或长轮询。</span><span class="sxs-lookup"><span data-stu-id="79329-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="79329-147">SignalR 使用传输 API 创建传输连接，传输 API 取决于物理网络连接的存在来创建传输连接。</span><span class="sxs-lookup"><span data-stu-id="79329-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="79329-148">当 SignalR 终止传输连接或传输 API 检测到物理连接断开时，传输连接将结束。</span><span class="sxs-lookup"><span data-stu-id="79329-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="79329-149">**物理连接**是指促进客户端计算机与服务器计算机之间通信的物理网络链路（电线、无线信号、路由器等）。</span><span class="sxs-lookup"><span data-stu-id="79329-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="79329-150">物理连接必须存在才能建立传输连接，并且必须建立传输连接才能建立 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="79329-151">但是，中断物理连接并不总是会立即结束传输连接或 SignalR 连接，本主题稍后将对此进行说明。</span><span class="sxs-lookup"><span data-stu-id="79329-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="79329-152">在下图中，SignalR 连接由集线器 API 和持久连接 API SignalR 层表示，传输连接由传输层表示，物理连接由服务器和客户端之间的线表示。</span><span class="sxs-lookup"><span data-stu-id="79329-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![信号R架构图](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="79329-154">在 SignalR`Start`客户端中调用 该方法时，您提供 SignalR 客户端代码，并提供它所需的所有信息，以便建立与服务器的物理连接。</span><span class="sxs-lookup"><span data-stu-id="79329-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="79329-155">SignalR 客户端代码使用此信息发出 HTTP 请求，并建立使用四种传输方法之一的物理连接。</span><span class="sxs-lookup"><span data-stu-id="79329-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="79329-156">如果传输连接失败或服务器发生故障，SignalR 连接不会立即消失，因为客户端仍然拥有自动重新建立到同一 SignalR URL 的新传输连接所需的信息。</span><span class="sxs-lookup"><span data-stu-id="79329-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="79329-157">在这种情况下，不涉及来自用户应用程序的干预，当 SignalR 客户端代码建立新的传输连接时，它不会启动新的 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="79329-158">SignalR 连接的连续性反映在这样一个事实中：在调用`Start`方法时创建的连接 ID 不会更改。</span><span class="sxs-lookup"><span data-stu-id="79329-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="79329-159">当`OnReconnected`传输连接在丢失后自动重新建立时，中心上的事件处理程序将执行。</span><span class="sxs-lookup"><span data-stu-id="79329-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="79329-160">事件`OnDisconnected`处理程序在 SignalR 连接的末尾执行。</span><span class="sxs-lookup"><span data-stu-id="79329-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="79329-161">SignalR 连接可以以以下任何方式结束：</span><span class="sxs-lookup"><span data-stu-id="79329-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="79329-162">如果客户端调用 方法`Stop`，将停止消息将发送到服务器，并且客户端和服务器都会立即终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="79329-163">客户端和服务器之间的连接丢失后，客户端将尝试重新连接，并且服务器等待客户端重新连接。</span><span class="sxs-lookup"><span data-stu-id="79329-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="79329-164">如果重新连接的尝试不成功，并且断开连接超时期结束，则客户端和服务器都终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="79329-165">客户端停止尝试重新连接，服务器将释放其 SignalR 连接的表示形式。</span><span class="sxs-lookup"><span data-stu-id="79329-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="79329-166">如果客户端停止运行而没有机会调用`Stop`该方法，服务器将等待客户端重新连接，然后在断开连接超时期后结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="79329-167">如果服务器停止运行，客户端将尝试重新连接（重新创建传输连接），然后在断开连接超时期间后结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="79329-168">当没有连接问题时，并且用户应用程序通过调用`Stop`该方法结束 SignalR 连接时，SignalR 连接和传输连接大约在同一时间开始和结束。</span><span class="sxs-lookup"><span data-stu-id="79329-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="79329-169">以下各节将更详细地介绍其他方案。</span><span class="sxs-lookup"><span data-stu-id="79329-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="79329-170">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="79329-171">物理连接可能很慢，或者连接可能有中断。</span><span class="sxs-lookup"><span data-stu-id="79329-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="79329-172">根据中断长度等因素，可能会断开传输连接。</span><span class="sxs-lookup"><span data-stu-id="79329-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="79329-173">然后，SignalR 尝试重新建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="79329-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="79329-174">有时传输连接 API 检测到中断并丢弃传输连接，SignalR 会立即发现连接丢失。</span><span class="sxs-lookup"><span data-stu-id="79329-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="79329-175">在其他情况下，传输连接 API 和 SignalR 都不会立即意识到连接已丢失。</span><span class="sxs-lookup"><span data-stu-id="79329-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="79329-176">对于除长轮询之外的所有传输，SignalR 客户端使用名为 *"保持活动"* 的函数来检查传输 API 无法检测到的连接损失。</span><span class="sxs-lookup"><span data-stu-id="79329-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="79329-177">有关长轮询连接的信息，请参阅本主题后面的[超时和保持活动设置](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="79329-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="79329-178">当连接处于非活动状态时，服务器会定期向客户端发送保持活动数据包。</span><span class="sxs-lookup"><span data-stu-id="79329-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="79329-179">截至撰写本文之日，默认频率为每 10 秒一次。</span><span class="sxs-lookup"><span data-stu-id="79329-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="79329-180">通过侦听这些数据包，客户端可以判断是否有连接问题。</span><span class="sxs-lookup"><span data-stu-id="79329-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="79329-181">如果预期时未收到保持活动数据包，则在短时间内客户端假定存在连接问题，如速度缓慢或中断。</span><span class="sxs-lookup"><span data-stu-id="79329-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="79329-182">如果长时间后仍未收到保持活动，则客户端假定连接已断开，并开始尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="79329-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="79329-183">下图说明了在典型方案中在传输 API 无法立即识别的物理连接出现问题时引发的客户端和服务器事件。</span><span class="sxs-lookup"><span data-stu-id="79329-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="79329-184">该图适用于以下情况：</span><span class="sxs-lookup"><span data-stu-id="79329-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="79329-185">传输是 WebSocket、永久帧或服务器发送的事件。</span><span class="sxs-lookup"><span data-stu-id="79329-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="79329-186">物理网络连接中断的时间各不相同。</span><span class="sxs-lookup"><span data-stu-id="79329-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="79329-187">传输 API 不会意识到中断，因此 SignalR 依赖于保持状态功能来检测中断。</span><span class="sxs-lookup"><span data-stu-id="79329-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![传输断开](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="79329-189">如果客户端进入重新连接模式，但无法在断开连接超时限制内建立传输连接，服务器将终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="79329-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="79329-190">发生这种情况时，服务器将执行 Hub`OnDisconnected`的方法，并排队将断开连接消息发送到客户端，以防客户端以后设法连接。</span><span class="sxs-lookup"><span data-stu-id="79329-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="79329-191">如果客户端随后重新连接，它将接收断开连接命令并调用`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="79329-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="79329-192">在这种情况下，`OnReconnected`在客户端重新连接时不执行，并且`OnDisconnected`在客户端调用`Stop`时不执行。</span><span class="sxs-lookup"><span data-stu-id="79329-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="79329-193">下图说明了此方案。</span><span class="sxs-lookup"><span data-stu-id="79329-193">The following diagram illustrates this scenario.</span></span>

![传输中断 - 服务器超时](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="79329-195">可能在客户端上引发的 SignalR 连接生存期事件如下：</span><span class="sxs-lookup"><span data-stu-id="79329-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="79329-196">`ConnectionSlow`客户端事件。</span><span class="sxs-lookup"><span data-stu-id="79329-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="79329-197">自收到最后一条消息或保持活 ping 以来，保持活动超时的预设比例已过时引发。</span><span class="sxs-lookup"><span data-stu-id="79329-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="79329-198">默认保持活动超时警告周期为保持活动超时的 2/3。</span><span class="sxs-lookup"><span data-stu-id="79329-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="79329-199">保持活动超时为 20 秒，因此警告在大约 13 秒时发生。</span><span class="sxs-lookup"><span data-stu-id="79329-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="79329-200">默认情况下，服务器每 10 秒发送一次保持活动 ping，客户端大约每 2 秒检查一次保持活动 ping（保持活动超时值和保持活动超时警告值之间的三分之一差异）。</span><span class="sxs-lookup"><span data-stu-id="79329-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="79329-201">如果传输 API 意识到断开连接，则在保持活动超时警告期之前，可能会通知 SignalR 断开连接。</span><span class="sxs-lookup"><span data-stu-id="79329-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="79329-202">在这种情况下，`ConnectionSlow`将不会引发该事件，SignalR 将直接转到该`Reconnecting`事件。</span><span class="sxs-lookup"><span data-stu-id="79329-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="79329-203">`Reconnecting`客户端事件。</span><span class="sxs-lookup"><span data-stu-id="79329-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="79329-204">当 （a） 传输 API 检测到连接丢失，或 （b） 自上次收到消息或保持活动 ping 以来，保持活动超时期已过。</span><span class="sxs-lookup"><span data-stu-id="79329-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="79329-205">SignalR 客户端代码开始尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="79329-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="79329-206">如果您希望应用程序在传输连接丢失时执行某些操作，则可以处理此事件。</span><span class="sxs-lookup"><span data-stu-id="79329-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="79329-207">默认保持活动超时期限当前为 20 秒。</span><span class="sxs-lookup"><span data-stu-id="79329-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="79329-208">如果客户端代码尝试在 SignalR 处于重新连接模式时调用 Hub 方法，SignalR 将尝试发送命令。</span><span class="sxs-lookup"><span data-stu-id="79329-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="79329-209">大多数时候，这种尝试会失败，但在某些情况下，它们可能会成功。</span><span class="sxs-lookup"><span data-stu-id="79329-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="79329-210">对于服务器发送的事件、永久帧和长轮询传输，SignalR 使用两个通信通道，一个通信通道是客户端用于发送消息的，另一个用于接收消息。</span><span class="sxs-lookup"><span data-stu-id="79329-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="79329-211">用于接收的通道是永久打开的通道，在物理连接中断时，该通道将关闭。</span><span class="sxs-lookup"><span data-stu-id="79329-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="79329-212">用于发送的通道仍然可用，因此，如果恢复物理连接，则在重新建立接收通道之前，客户端到服务器的方法调用可能成功。</span><span class="sxs-lookup"><span data-stu-id="79329-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="79329-213">在 SignalR 重新打开用于接收的通道之前，不会接收返回值。</span><span class="sxs-lookup"><span data-stu-id="79329-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="79329-214">`Reconnected`客户端事件。</span><span class="sxs-lookup"><span data-stu-id="79329-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="79329-215">重新建立传输连接时引发。</span><span class="sxs-lookup"><span data-stu-id="79329-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="79329-216">中心`OnReconnected`中的事件处理程序执行。</span><span class="sxs-lookup"><span data-stu-id="79329-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="79329-217">`Closed`客户端事件（JavaScript`disconnected`中的事件）。</span><span class="sxs-lookup"><span data-stu-id="79329-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="79329-218">当断开连接超时期到期时，当 SignalR 客户端代码在丢失传输连接后尝试重新连接时引发。</span><span class="sxs-lookup"><span data-stu-id="79329-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="79329-219">默认断开连接超时为 30 秒。</span><span class="sxs-lookup"><span data-stu-id="79329-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="79329-220">（当连接结束时，也会引发此事件，`Stop`因为调用该方法。</span><span class="sxs-lookup"><span data-stu-id="79329-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="79329-221">传输 API 未检测到的传输连接中断，并且不会延迟服务器中保持活动 ping 的接收时间超过保持活动超时警告期的时间，则可能导致引发任何连接生存期事件。</span><span class="sxs-lookup"><span data-stu-id="79329-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="79329-222">某些网络环境有意关闭空闲连接，保持状态数据包的另一个功能是通过让这些网络知道 SignalR 连接正在使用来帮助防止这种情况。</span><span class="sxs-lookup"><span data-stu-id="79329-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="79329-223">在极端情况下，保持活值的默认频率可能不足以阻止关闭连接。</span><span class="sxs-lookup"><span data-stu-id="79329-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="79329-224">在这种情况下，您可以将保持活动 ping 配置为更频繁地发送。</span><span class="sxs-lookup"><span data-stu-id="79329-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="79329-225">有关详细信息，请参阅本主题后面的[超时和保持活动设置](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="79329-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="79329-226">**重要提示**：此处描述的事件序列不保证。</span><span class="sxs-lookup"><span data-stu-id="79329-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="79329-227">根据此方案，SignalR 会尝试以可预测的方式引发连接生存期事件，但网络事件有许多变化，以及传输 API 等基础通信框架处理这些事件的许多方式。</span><span class="sxs-lookup"><span data-stu-id="79329-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="79329-228">例如，客户端重新`Reconnected`连接时可能不会引发该事件，或者当尝试建立连接失败`OnConnected`时，服务器上的处理程序可能会运行。</span><span class="sxs-lookup"><span data-stu-id="79329-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="79329-229">本主题仅描述通常由某些典型情况产生的影响。</span><span class="sxs-lookup"><span data-stu-id="79329-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="79329-230">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-230">Client disconnection scenarios</span></span>

<span data-ttu-id="79329-231">在浏览器客户端中，维护 SignalR 连接的 SignalR 客户端代码在网页的 JavaScript 上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="79329-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="79329-232">这就是为什么当您从一个页面导航到另一个页面时，SignalR 连接必须结束，这就是为什么如果您从多个浏览器窗口或选项卡连接时，您有多个连接与多个连接指示。</span><span class="sxs-lookup"><span data-stu-id="79329-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="79329-233">当用户关闭浏览器窗口或选项卡，或导航到新页面或刷新页面时，SignalR 连接将立即结束，因为 SignalR 客户端代码会为您处理该浏览器事件并调用`Stop`该方法。</span><span class="sxs-lookup"><span data-stu-id="79329-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="79329-234">在这些情况下，或者在应用程序`Stop`调用方法时的任何客户端平台中，`OnDisconnected`事件处理程序会立即在服务器上执行，并且客户端引发`Closed`事件（事件在 JavaScript 中命名）。 `disconnected`</span><span class="sxs-lookup"><span data-stu-id="79329-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="79329-235">如果客户端应用程序或运行在崩溃时运行的计算机崩溃或进入睡眠状态（例如，当用户关闭便携式计算机时），服务器不会被告知发生了什么。</span><span class="sxs-lookup"><span data-stu-id="79329-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="79329-236">据服务器所知，客户端丢失可能是由于连接中断，客户端可能尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="79329-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="79329-237">因此，在这些情况下，服务器等待给客户端重新连接的机会，并且`OnDisconnected`在断开连接超时期到期之前不会执行（默认情况下约为 30 秒）。</span><span class="sxs-lookup"><span data-stu-id="79329-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="79329-238">下图说明了此方案。</span><span class="sxs-lookup"><span data-stu-id="79329-238">The following diagram illustrates this scenario.</span></span>

![客户端计算机故障](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="79329-240">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="79329-240">Server disconnection scenarios</span></span>

<span data-ttu-id="79329-241">当服务器脱机时 （它重新启动、 失败、 应用域回收等 ） 结果可能类似于丢失的连接，或者传输 API 和 SignalR 可能立即知道服务器已消失，SignalR 可能开始尝试重新连接而不引发`ConnectionSlow`事件。</span><span class="sxs-lookup"><span data-stu-id="79329-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="79329-242">如果客户端进入重新连接模式，并且服务器恢复或重新启动，或者新服务器在断开连接超时期到期之前联机，则客户端将重新连接到已还原或新服务器。</span><span class="sxs-lookup"><span data-stu-id="79329-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="79329-243">在这种情况下，SignalR 连接将继续在客户端上，`Reconnected`并引发事件。</span><span class="sxs-lookup"><span data-stu-id="79329-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="79329-244">在第一台服务器上，`OnDisconnected`从不执行，在新服务器上执行，`OnReconnected`尽管`OnConnected`以前从未为该服务器上的客户端执行过。</span><span class="sxs-lookup"><span data-stu-id="79329-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="79329-245">（如果客户端在重新启动或应用域回收后重新连接到同一服务器，则效果相同，因为当服务器重新启动时，它没有以前连接活动的内存。下图假定传输 API 会立即意识到丢失的连接，因此不会引发`ConnectionSlow`事件。</span><span class="sxs-lookup"><span data-stu-id="79329-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![服务器故障和重新连接](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="79329-247">如果服务器在断开连接超时期间不可用，SignalR 连接将结束。</span><span class="sxs-lookup"><span data-stu-id="79329-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="79329-248">在这种情况下，事件`Closed`（`disconnected`在 JavaScript 客户端中）在客户端上引发，但从未`OnDisconnected`在服务器上调用。</span><span class="sxs-lookup"><span data-stu-id="79329-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="79329-249">下图假定传输 API 不会意识到丢失的连接，因此 SignalR 保持活动功能检测到该`ConnectionSlow`事件并引发事件。</span><span class="sxs-lookup"><span data-stu-id="79329-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![服务器故障和超时](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="79329-251">超时和保持活动设置</span><span class="sxs-lookup"><span data-stu-id="79329-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="79329-252">默认`ConnectionTimeout`的`DisconnectTimeout`和`KeepAlive`值适用于大多数方案，但如果环境有特殊需要，则可以更改。</span><span class="sxs-lookup"><span data-stu-id="79329-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="79329-253">例如，如果网络环境关闭空闲 5 秒的连接，则可能必须减小保持活动值。</span><span class="sxs-lookup"><span data-stu-id="79329-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="79329-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="79329-254">ConnectionTimeout</span></span>

<span data-ttu-id="79329-255">此设置表示在关闭传输连接和打开新连接之前保持传输连接打开并等待响应的时间量。</span><span class="sxs-lookup"><span data-stu-id="79329-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="79329-256">默认值为 110 秒。</span><span class="sxs-lookup"><span data-stu-id="79329-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="79329-257">此设置仅在禁用保持活动功能时适用，这通常仅适用于长轮询传输。</span><span class="sxs-lookup"><span data-stu-id="79329-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="79329-258">下图说明了此设置对长轮询传输连接的影响。</span><span class="sxs-lookup"><span data-stu-id="79329-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![长轮询传输连接](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="79329-260">断开连接超时</span><span class="sxs-lookup"><span data-stu-id="79329-260">DisconnectTimeout</span></span>

<span data-ttu-id="79329-261">此设置表示引发`Disconnected`事件之前传输连接丢失后等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="79329-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="79329-262">默认值为 30 秒。</span><span class="sxs-lookup"><span data-stu-id="79329-262">The default value is 30 seconds.</span></span> <span data-ttu-id="79329-263">设置 时`DisconnectTimeout`，`KeepAlive`将自动设置为值的`DisconnectTimeout`1/3。</span><span class="sxs-lookup"><span data-stu-id="79329-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="79329-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="79329-264">KeepAlive</span></span>

<span data-ttu-id="79329-265">此设置表示在通过空闲连接发送保持活动数据包之前等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="79329-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="79329-266">默认值为 10 秒。</span><span class="sxs-lookup"><span data-stu-id="79329-266">The default value is 10 seconds.</span></span> <span data-ttu-id="79329-267">此值不能超过该值的`DisconnectTimeout`1/3。</span><span class="sxs-lookup"><span data-stu-id="79329-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="79329-268">`DisconnectTimeout`如果要同时设置 和`KeepAlive`，则`KeepAlive`设置为`DisconnectTimeout`。</span><span class="sxs-lookup"><span data-stu-id="79329-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="79329-269">否则，`KeepAlive`当自动设置为`KeepAlive`超时值的`DisconnectTimeout`1/3 时，您的设置将被覆盖。</span><span class="sxs-lookup"><span data-stu-id="79329-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="79329-270">如果要禁用保持活动功能，请设置为`KeepAlive`null。</span><span class="sxs-lookup"><span data-stu-id="79329-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="79329-271">对于长轮询传输，将自动禁用保持活动功能。</span><span class="sxs-lookup"><span data-stu-id="79329-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="79329-272">如何更改超时并保持活动设置</span><span class="sxs-lookup"><span data-stu-id="79329-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="79329-273">要更改这些设置的默认值，请将其设置在`Application_Start` *Global.asax*文件中，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="79329-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="79329-274">示例代码中显示的值与默认值相同。</span><span class="sxs-lookup"><span data-stu-id="79329-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="79329-275">如何通知用户断开连接</span><span class="sxs-lookup"><span data-stu-id="79329-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="79329-276">在某些应用程序中，您可能希望在存在连接问题时向用户显示消息。</span><span class="sxs-lookup"><span data-stu-id="79329-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="79329-277">对于如何以及何时执行此操作，您有多种选择。</span><span class="sxs-lookup"><span data-stu-id="79329-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="79329-278">以下代码示例适用于使用生成的代理的 JavaScript 客户端。</span><span class="sxs-lookup"><span data-stu-id="79329-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="79329-279">在`connectionSlow`SignalR 意识到连接问题后，在事件进入重新连接模式时，立即处理该事件以显示消息。</span><span class="sxs-lookup"><span data-stu-id="79329-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="79329-280">当`reconnecting`SignalR 意识到断开并进入重新连接模式时，处理事件以显示消息。</span><span class="sxs-lookup"><span data-stu-id="79329-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="79329-281">当尝试`disconnected`重新连接超时时，处理事件以显示消息。在这种情况下，再次与服务器重新建立连接的唯一方法是通过调用`Start`方法重新启动 SignalR 连接，这将创建新的连接 ID。</span><span class="sxs-lookup"><span data-stu-id="79329-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="79329-282">以下代码示例使用标志来确保仅在重新连接超时后发出通知，而不是在调用`Stop`方法导致的 SignalR 连接的正常结束之后发出通知。</span><span class="sxs-lookup"><span data-stu-id="79329-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="79329-283">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="79329-283">How to continuously reconnect</span></span>

<span data-ttu-id="79329-284">在某些应用程序中，您可能希望在连接丢失且重新连接尝试超时后自动重新建立连接。为此，可以从`Start``Closed`事件处理程序（JavaScript`disconnected`客户端上的事件处理程序）调用 方法。</span><span class="sxs-lookup"><span data-stu-id="79329-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="79329-285">您可能需要在调用`Start`之前等待一段时间，以避免在服务器或物理连接不可用时过于频繁地执行此操作。</span><span class="sxs-lookup"><span data-stu-id="79329-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="79329-286">以下代码示例适用于使用生成的代理的 JavaScript 客户端。</span><span class="sxs-lookup"><span data-stu-id="79329-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="79329-287">在移动客户端中需要注意的一个潜在问题是，当服务器或物理连接不可用时，连续重新连接尝试可能会导致不必要的电池耗尽。</span><span class="sxs-lookup"><span data-stu-id="79329-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="79329-288">如何在服务器代码中断开客户端</span><span class="sxs-lookup"><span data-stu-id="79329-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="79329-289">SignalR 版本 2 没有用于断开客户端的内置服务器 API。</span><span class="sxs-lookup"><span data-stu-id="79329-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="79329-290">有[计划在未来添加此功能](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="79329-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="79329-291">在当前 SignalR 版本中，将客户端与服务器断开连接的最简单方法是在客户端上实现断开连接方法，并从服务器调用该方法。</span><span class="sxs-lookup"><span data-stu-id="79329-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="79329-292">以下代码示例显示了使用生成的代理的 JavaScript 客户端的断开连接方法。</span><span class="sxs-lookup"><span data-stu-id="79329-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="79329-293">安全性 - 此连接客户端的方法和建议的内置 API 都不会解决运行恶意代码的受黑客攻击的客户端的情况，因为客户端可以重新连接，或者被黑客攻击的代码可能会删除`stopClient`该方法或更改它的作用。</span><span class="sxs-lookup"><span data-stu-id="79329-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="79329-294">实现有状态拒绝服务 （DOS） 保护的适当位置不在框架或服务器层中，而是在前端基础结构中。</span><span class="sxs-lookup"><span data-stu-id="79329-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="79329-295">检测断开连接的原因</span><span class="sxs-lookup"><span data-stu-id="79329-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="79329-296">SignalR 2.1 向服务器`OnDisconnect`事件添加重载，指示客户端是否有意断开连接，而不是超时。如果`StopCalled`客户端显式关闭连接，则参数为 true。</span><span class="sxs-lookup"><span data-stu-id="79329-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="79329-297">在 JavaScript 中，如果服务器错误导致客户端断开连接，则错误信息将作为 传递给客户端`$.connection.hub.lastError`。</span><span class="sxs-lookup"><span data-stu-id="79329-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="79329-298">**C# 服务器代码`stopCalled`：参数**</span><span class="sxs-lookup"><span data-stu-id="79329-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="79329-299">**JavaScript 客户端代码：在`lastError``disconnect`事件中访问。**</span><span class="sxs-lookup"><span data-stu-id="79329-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]

---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: 了解并处理 SignalR 中的连接生存期事件 |Microsoft Docs
author: bradygaster
description: 本文介绍如何使用由中心 API 公开的事件。
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78467420"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="b0a93-103">了解和处理 SignalR 中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="b0a93-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="b0a93-104">本文概述了你可以处理的 SignalR 连接、重新连接和断开连接事件，以及你可以配置的超时和 keepalive 设置。</span><span class="sxs-lookup"><span data-stu-id="b0a93-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="b0a93-105">本文假设你已了解 SignalR 和连接生存期事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="b0a93-106">有关 SignalR 的简介，请参阅[SignalR 简介](../getting-started/introduction-to-signalr.md)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="b0a93-107">有关连接生存期事件的列表，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="b0a93-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="b0a93-108">如何处理中心类中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="b0a93-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="b0a93-109">如何处理 JavaScript 客户端中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="b0a93-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="b0a93-110">如何处理 .NET 客户端中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="b0a93-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="b0a93-111">本主题中使用的软件版本</span><span class="sxs-lookup"><span data-stu-id="b0a93-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="b0a93-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="b0a93-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="b0a93-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="b0a93-113">.NET 4.5</span></span>
> - <span data-ttu-id="b0a93-114">SignalR 版本2</span><span class="sxs-lookup"><span data-stu-id="b0a93-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="b0a93-115">本主题的早期版本</span><span class="sxs-lookup"><span data-stu-id="b0a93-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="b0a93-116">有关早期版本的 SignalR 的信息，请参阅[SignalR 旧版本](../older-versions/index.md)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="b0a93-117">问题和注释</span><span class="sxs-lookup"><span data-stu-id="b0a93-117">Questions and comments</span></span>
>
> <span data-ttu-id="b0a93-118">请提供有关你喜欢本教程的方式的反馈，并在页面底部的评论中留下反馈。</span><span class="sxs-lookup"><span data-stu-id="b0a93-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="b0a93-119">如果你有与本教程不直接相关的问题，则可以将其发布到[ASP.NET SignalR 论坛](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR)或[StackOverflow.com](http://stackoverflow.com/)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="b0a93-120">概述</span><span class="sxs-lookup"><span data-stu-id="b0a93-120">Overview</span></span>

<span data-ttu-id="b0a93-121">本文包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="b0a93-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="b0a93-122">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="b0a93-123">SignalR 连接、传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="b0a93-124">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="b0a93-125">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="b0a93-126">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="b0a93-127">超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="b0a93-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="b0a93-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="b0a93-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="b0a93-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="b0a93-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="b0a93-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="b0a93-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="b0a93-131">如何更改超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="b0a93-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="b0a93-132">如何通知用户断开</span><span class="sxs-lookup"><span data-stu-id="b0a93-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="b0a93-133">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="b0a93-134">如何在服务器代码中断开客户端连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="b0a93-135">检测断开连接的原因</span><span class="sxs-lookup"><span data-stu-id="b0a93-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="b0a93-136">API 参考主题的链接适用于 .NET 4.5 版本的 API。</span><span class="sxs-lookup"><span data-stu-id="b0a93-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="b0a93-137">如果使用的是 .NET 4，请参阅[.net 4 版本的 API 主题](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="b0a93-138">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="b0a93-139">SignalR 中心内的 `OnReconnected` 事件处理程序可以在 `OnConnected` 后直接执行，但不能在给定客户端 `OnDisconnected` 后执行。</span><span class="sxs-lookup"><span data-stu-id="b0a93-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="b0a93-140">在没有断开连接的情况下，无需断开连接的原因是在 SignalR 中使用 "连接" 一词。</span><span class="sxs-lookup"><span data-stu-id="b0a93-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="b0a93-141">SignalR 连接、传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="b0a93-142">本文将区分*SignalR 连接*、*传输连接*和*物理连接*：</span><span class="sxs-lookup"><span data-stu-id="b0a93-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="b0a93-143">**SignalR 连接**是指由 SignalR API 维护的客户端和服务器 URL 之间的逻辑关系，由连接 ID 唯一标识。</span><span class="sxs-lookup"><span data-stu-id="b0a93-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="b0a93-144">有关此关系的数据由 SignalR 维护，并用于建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="b0a93-145">当客户端调用 `Stop` 方法时，或者当 SignalR 尝试重新建立丢失的传输连接时达到超时限制时，关系将结束并 SignalR 释放数据。</span><span class="sxs-lookup"><span data-stu-id="b0a93-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="b0a93-146">**传输连接**指的是客户端与服务器之间的逻辑关系，由四个传输 api 之一： websocket、服务器发送事件、永久帧或长轮询来维护。</span><span class="sxs-lookup"><span data-stu-id="b0a93-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="b0a93-147">SignalR 使用传输 API 创建传输连接，而传输 API 依赖于是否存在物理网络连接来创建传输连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="b0a93-148">当 SignalR 终止传输连接时，或当传输 API 检测到物理连接中断时，传输连接将结束。</span><span class="sxs-lookup"><span data-stu-id="b0a93-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="b0a93-149">**物理连接**指的是使客户端计算机和服务器计算机之间的通信更加便利的物理网络链接（线路、无线信号、路由器等）。</span><span class="sxs-lookup"><span data-stu-id="b0a93-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="b0a93-150">若要建立传输连接，必须建立物理连接，若要建立 SignalR 连接，必须建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="b0a93-151">但是，中断物理连接并不总是立即终止传输连接或 SignalR 连接，这将在本主题的后面部分进行说明。</span><span class="sxs-lookup"><span data-stu-id="b0a93-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="b0a93-152">在下图中，SignalR 连接由集线器 API 和 PersistentConnection API SignalR 层表示，传输连接由传输层表示，物理连接由服务器之间的线路表示和客户端。</span><span class="sxs-lookup"><span data-stu-id="b0a93-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 体系结构图](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="b0a93-154">在 SignalR 客户端中调用 `Start` 方法时，会向 SignalR 客户端代码提供所需的所有信息，以便与服务器建立物理连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="b0a93-155">SignalR 客户端代码使用此信息发出 HTTP 请求，并建立使用四种传输方法之一的物理连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="b0a93-156">如果传输连接失败或服务器发生故障，则 SignalR 连接不会立即消失，因为客户端仍然具有自动重新建立到相同 SignalR URL 的新传输连接所需的信息。</span><span class="sxs-lookup"><span data-stu-id="b0a93-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="b0a93-157">在这种情况下，不涉及用户应用程序的任何干预，并且当 SignalR 客户端代码建立新的传输连接时，它不会启动新的 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="b0a93-158">如果连接 ID 是在调用 `Start` 方法时创建的，则不会发生更改，因此，SignalR 连接的连续性会反映出来。</span><span class="sxs-lookup"><span data-stu-id="b0a93-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="b0a93-159">集线器上的 `OnReconnected` 事件处理程序在丢失后自动重新建立传输连接时执行。</span><span class="sxs-lookup"><span data-stu-id="b0a93-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="b0a93-160">`OnDisconnected` 事件处理程序在 SignalR 连接结束时执行。</span><span class="sxs-lookup"><span data-stu-id="b0a93-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="b0a93-161">SignalR 连接可以通过以下任一方式结束：</span><span class="sxs-lookup"><span data-stu-id="b0a93-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="b0a93-162">如果客户端调用 `Stop` 方法，将停止消息发送到服务器，客户端和服务器都将立即终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="b0a93-163">客户端与服务器之间的连接断开后，客户端会尝试重新连接，并且服务器会等待客户端重新连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="b0a93-164">如果尝试重新连接失败并且断开连接超时期限结束，则客户端和服务器都将结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="b0a93-165">客户端将停止尝试重新连接，并且服务器会释放其 SignalR 连接的表示形式。</span><span class="sxs-lookup"><span data-stu-id="b0a93-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="b0a93-166">如果客户端在没有机会调用 `Stop` 方法的情况下停止运行，则服务器将等待客户端重新连接，然后在断开连接超时期限后结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="b0a93-167">如果服务器停止运行，则客户端会尝试重新连接（重新创建传输连接），然后在断开连接超时期限后结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="b0a93-168">如果没有连接问题，并且用户应用程序通过调用 `Stop` 方法来结束 SignalR 连接，则 SignalR 连接和传输连接将开始和结束。</span><span class="sxs-lookup"><span data-stu-id="b0a93-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="b0a93-169">以下部分更详细地介绍了其他方案。</span><span class="sxs-lookup"><span data-stu-id="b0a93-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="b0a93-170">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="b0a93-171">物理连接可能较慢，或者连接可能中断。</span><span class="sxs-lookup"><span data-stu-id="b0a93-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="b0a93-172">根据各种因素（如中断长度），传输连接可能会断开。</span><span class="sxs-lookup"><span data-stu-id="b0a93-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="b0a93-173">SignalR 然后尝试重新建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="b0a93-174">有时，传输连接 API 会检测中断并断开传输连接，SignalR 会立即发现连接丢失。</span><span class="sxs-lookup"><span data-stu-id="b0a93-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="b0a93-175">在其他情况下，传输连接 API 和 SignalR 都不会立即意识到连接已丢失。</span><span class="sxs-lookup"><span data-stu-id="b0a93-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="b0a93-176">对于除了长时间轮询之外的所有传输，SignalR 客户端使用名为*keepalive*的函数检查传输 API 无法检测到的连接是否丢失。</span><span class="sxs-lookup"><span data-stu-id="b0a93-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="b0a93-177">有关长轮询连接的详细信息，请参阅本主题后面的[超时和 keepalive 设置](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="b0a93-178">当某个连接处于非活动状态时，服务器会定期将 keepalive 数据包发送到客户端。</span><span class="sxs-lookup"><span data-stu-id="b0a93-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="b0a93-179">截止本文撰写之日起，默认频率为每10秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="b0a93-180">通过侦听这些数据包，客户端可以判断是否存在连接问题。</span><span class="sxs-lookup"><span data-stu-id="b0a93-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="b0a93-181">如果在需要时未收到 keepalive 数据包，则在经过一段时间后，客户端会假定存在连接问题（如缓慢或中断）。</span><span class="sxs-lookup"><span data-stu-id="b0a93-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="b0a93-182">如果在较长时间后仍未收到 keepalive，则客户端会假定连接已断开，并开始尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="b0a93-183">下图说明了在传输 API 无法立即识别的物理连接问题时，在典型方案中引发的客户端和服务器事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="b0a93-184">此关系图适用于以下情况：</span><span class="sxs-lookup"><span data-stu-id="b0a93-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="b0a93-185">传输为 Websocket、永久帧或服务器发送事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="b0a93-186">物理网络连接中存在不同的中断段。</span><span class="sxs-lookup"><span data-stu-id="b0a93-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="b0a93-187">传输 API 不会发现中断，因此 SignalR 依赖于 keepalive 功能来检测它们。</span><span class="sxs-lookup"><span data-stu-id="b0a93-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![传输断开](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="b0a93-189">如果客户端进入重新连接模式，但无法在断开连接超时限制内建立传输连接，则服务器将终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="b0a93-190">发生这种情况时，服务器会执行中心的 `OnDisconnected` 方法，并将断开连接消息排队以发送到客户端，以防客户端管理稍后连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="b0a93-191">如果客户端重新连接，则它将接收 disconnect 命令并调用 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="b0a93-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="b0a93-192">在这种情况下，当客户端重新连接时，不会执行 `OnReconnected`，当客户端调用 `Stop`时不会执行 `OnDisconnected`。</span><span class="sxs-lookup"><span data-stu-id="b0a93-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="b0a93-193">下图说明了这种情况。</span><span class="sxs-lookup"><span data-stu-id="b0a93-193">The following diagram illustrates this scenario.</span></span>

![传输中断-服务器超时](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="b0a93-195">可能会在客户端上引发的 SignalR 连接生存期事件如下所示：</span><span class="sxs-lookup"><span data-stu-id="b0a93-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="b0a93-196">`ConnectionSlow` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="b0a93-197">自上次收到消息或 keepalive ping 后，当 keepalive 超时期限的预设比例已过去时引发。</span><span class="sxs-lookup"><span data-stu-id="b0a93-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="b0a93-198">默认的 keepalive 超时警告期为2/3。</span><span class="sxs-lookup"><span data-stu-id="b0a93-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="b0a93-199">Keepalive 超时为20秒，因此警告大约会在13秒后发生。</span><span class="sxs-lookup"><span data-stu-id="b0a93-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="b0a93-200">默认情况下，服务器每10秒发送一次 keepalive ping，客户端会检查是否每隔2秒（keepalive 超时值和 keepalive 超时警告值之间的差异之差）每隔2秒检查一次 keepalive ping。</span><span class="sxs-lookup"><span data-stu-id="b0a93-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="b0a93-201">如果传输 API 能识别断开连接，则在 keepalive 超时警告期通过之前，可能会通知 SignalR 断开连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="b0a93-202">在这种情况下，不会引发 `ConnectionSlow` 事件，SignalR 会直接跳到 `Reconnecting` 事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="b0a93-203">`Reconnecting` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="b0a93-204">如果为（a），则传输 API 检测到连接丢失，或者（b）自上一次消息或 keepalive ping 接收后的 keepalive 超时期限已过。</span><span class="sxs-lookup"><span data-stu-id="b0a93-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="b0a93-205">SignalR 客户端代码开始尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="b0a93-206">如果希望应用程序在传输连接丢失时执行某些操作，则可以处理此事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="b0a93-207">默认的 keepalive 超时期限当前为20秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="b0a93-208">如果客户端代码在 SignalR 处于重新连接模式时尝试调用集线器方法，SignalR 将尝试发送命令。</span><span class="sxs-lookup"><span data-stu-id="b0a93-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="b0a93-209">大多数情况下，此类尝试将会失败，但在某些情况下，它们可能会成功。</span><span class="sxs-lookup"><span data-stu-id="b0a93-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="b0a93-210">对于服务器发送的事件、永久帧和长轮询传输，SignalR 将使用两个信道，其中一个信道用于发送消息，另一个用于接收消息。</span><span class="sxs-lookup"><span data-stu-id="b0a93-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="b0a93-211">用于接收的通道是永久打开的通道，并且是物理连接中断时关闭的通道。</span><span class="sxs-lookup"><span data-stu-id="b0a93-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="b0a93-212">用于发送的通道仍可用，因此，如果恢复物理连接，则在重新建立接收通道之前，从客户端到服务器的方法调用可能会成功。</span><span class="sxs-lookup"><span data-stu-id="b0a93-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="b0a93-213">在 SignalR 重新打开用于接收的通道之前，将不会收到返回值。</span><span class="sxs-lookup"><span data-stu-id="b0a93-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="b0a93-214">`Reconnected` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="b0a93-215">重新建立传输连接时引发。</span><span class="sxs-lookup"><span data-stu-id="b0a93-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="b0a93-216">中心中的 `OnReconnected` 事件处理程序执行。</span><span class="sxs-lookup"><span data-stu-id="b0a93-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="b0a93-217">`Closed` 客户端事件（JavaScript 中的`disconnected` 事件）。</span><span class="sxs-lookup"><span data-stu-id="b0a93-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="b0a93-218">当断开连接超时期限过期时，SignalR 客户端代码在丢失传输连接后尝试重新连接时引发。</span><span class="sxs-lookup"><span data-stu-id="b0a93-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="b0a93-219">默认断开超时为30秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="b0a93-220">（由于调用 `Stop` 方法，连接结束时也将引发此事件。）</span><span class="sxs-lookup"><span data-stu-id="b0a93-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="b0a93-221">传输 API 未检测到的传输连接中断，并且不会延迟从服务器接收的 keepalive ping 超过 keepalive 超时警告期限，这可能不会导致任何连接生存期事件引发。</span><span class="sxs-lookup"><span data-stu-id="b0a93-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="b0a93-222">某些网络环境特意关闭空闲连接，而 keepalive 数据包的另一个功能是通过让这些网络知道 SignalR 连接正在使用来帮助防止这种情况。</span><span class="sxs-lookup"><span data-stu-id="b0a93-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="b0a93-223">在极端情况下，keepalive ping 的默认频率可能不足以防止关闭连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="b0a93-224">在这种情况下，你可以将 keepalive ping 配置为更频繁地发送。</span><span class="sxs-lookup"><span data-stu-id="b0a93-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="b0a93-225">有关详细信息，请参阅本主题后面的[超时和 keepalive 设置](#timeoutkeepalive)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="b0a93-226">**重要提示**：此处所述的事件序列不能得到保证。</span><span class="sxs-lookup"><span data-stu-id="b0a93-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="b0a93-227">SignalR 使每次尝试按照此方案以可预测的方式引发连接生存期事件，但有很多不同的网络事件，例如传输 Api 等基础通信框架处理它们。</span><span class="sxs-lookup"><span data-stu-id="b0a93-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="b0a93-228">例如，当客户端重新连接时，可能不会引发 `Reconnected` 事件，或者当尝试建立连接时，服务器上的 `OnConnected` 处理程序可能会运行失败。</span><span class="sxs-lookup"><span data-stu-id="b0a93-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="b0a93-229">本主题仅介绍某些典型情况下通常会产生的影响。</span><span class="sxs-lookup"><span data-stu-id="b0a93-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="b0a93-230">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-230">Client disconnection scenarios</span></span>

<span data-ttu-id="b0a93-231">在浏览器客户端中，维护 SignalR 连接的 SignalR 客户端代码在网页的 JavaScript 上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="b0a93-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="b0a93-232">这就是当您从一个页面导航到另一个页面时，SignalR 连接必须结束的原因，这就是当您从多个浏览器窗口或选项卡进行连接时，为什么您具有多个连接 Id 的连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="b0a93-233">当用户关闭浏览器窗口或选项卡，或者导航到新页面或刷新页面时，SignalR 连接将立即结束，因为 SignalR 客户端代码会处理该浏览器事件，并调用 `Stop` 方法。</span><span class="sxs-lookup"><span data-stu-id="b0a93-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="b0a93-234">在这些情况下，或者在任何客户端平台中，当应用程序调用 `Stop` 方法时，将立即在服务器上执行 `OnDisconnected` 事件处理程序，并且客户端将引发 `Closed` 事件（该事件在 JavaScript 中名为 `disconnected`）。</span><span class="sxs-lookup"><span data-stu-id="b0a93-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="b0a93-235">如果客户端应用程序或运行它的计算机发生崩溃或进入睡眠状态（例如，当用户关闭便携式计算机时），则不会通知服务器发生了什么情况。</span><span class="sxs-lookup"><span data-stu-id="b0a93-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="b0a93-236">服务器知道，客户端的丢失可能是由于连接中断，并且客户端可能会尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="b0a93-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="b0a93-237">因此，在这些情况下，服务器会等待，使客户端有机会重新连接，并且在断开连接超时期限（默认为大约30秒）后，才会执行 `OnDisconnected`。</span><span class="sxs-lookup"><span data-stu-id="b0a93-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="b0a93-238">下图说明了这种情况。</span><span class="sxs-lookup"><span data-stu-id="b0a93-238">The following diagram illustrates this scenario.</span></span>

![客户端计算机故障](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="b0a93-240">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="b0a93-240">Server disconnection scenarios</span></span>

<span data-ttu-id="b0a93-241">当服务器进入脱机状态时，重新启动、失败、应用程序域回收等。--结果可能类似于丢失的连接，或者传输 API 和 SignalR 可能会立即知道服务器已丢失，并且 SignalR 可能会开始尝试重新连接，而不会引发 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="b0a93-242">如果客户端进入重新连接模式，并且在断开连接超时期限过期之前，服务器恢复或重新启动，或者新服务器处于联机状态，则客户端将重新连接到已还原的或新的服务器。</span><span class="sxs-lookup"><span data-stu-id="b0a93-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="b0a93-243">在这种情况下，SignalR 连接在客户端上继续，并引发 `Reconnected` 事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="b0a93-244">在第一台服务器上，将永远不会执行 `OnDisconnected`，而在新服务器上，即使之前从未对该服务器上的该客户端执行 `OnConnected`，也会执行 `OnReconnected`。</span><span class="sxs-lookup"><span data-stu-id="b0a93-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="b0a93-245">（如果在重新启动或应用域回收后客户端重新连接到同一服务器，则效果是相同的，因为当服务器重启时，它没有以前的连接活动的内存。）以下关系图假定传输 API 立即意识到丢失的连接，因此不会引发 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![服务器故障和重新连接](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="b0a93-247">如果在断开连接超时期限内服务器不能使用，SignalR 连接将结束。</span><span class="sxs-lookup"><span data-stu-id="b0a93-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="b0a93-248">在这种情况下，客户端上会引发 `Closed` 事件（JavaScript 客户端`disconnected`），但不会在服务器上调用 `OnDisconnected`。</span><span class="sxs-lookup"><span data-stu-id="b0a93-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="b0a93-249">以下关系图假定传输 API 不会意识到丢失的连接，因此 SignalR keepalive 功能检测到该 API 并引发 `ConnectionSlow` 事件。</span><span class="sxs-lookup"><span data-stu-id="b0a93-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![服务器故障和超时](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="b0a93-251">超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="b0a93-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="b0a93-252">默认 `ConnectionTimeout`、`DisconnectTimeout`和 `KeepAlive` 值适用于大多数方案，但如果你的环境有特殊需求，则可以更改这些值。</span><span class="sxs-lookup"><span data-stu-id="b0a93-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="b0a93-253">例如，如果你的网络环境关闭闲置时间为5秒的连接，则可能需要减少 keepalive 值。</span><span class="sxs-lookup"><span data-stu-id="b0a93-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="b0a93-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="b0a93-254">ConnectionTimeout</span></span>

<span data-ttu-id="b0a93-255">此设置表示在关闭传输连接并打开新连接之前，该连接保持打开并等待响应的时间量。</span><span class="sxs-lookup"><span data-stu-id="b0a93-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="b0a93-256">默认值为110秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="b0a93-257">此设置仅适用于禁用 keepalive 功能的情况，该功能通常仅适用于长轮询传输。</span><span class="sxs-lookup"><span data-stu-id="b0a93-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="b0a93-258">下图说明了此设置对长轮询传输连接的影响。</span><span class="sxs-lookup"><span data-stu-id="b0a93-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![长轮询传输连接](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="b0a93-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="b0a93-260">DisconnectTimeout</span></span>

<span data-ttu-id="b0a93-261">此设置表示在引发 `Disconnected` 事件之前，传输连接丢失后要等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="b0a93-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="b0a93-262">默认值为 30 秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-262">The default value is 30 seconds.</span></span> <span data-ttu-id="b0a93-263">如果设置 `DisconnectTimeout`，则 `KeepAlive` `DisconnectTimeout` 值自动设置为1/3。</span><span class="sxs-lookup"><span data-stu-id="b0a93-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="b0a93-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="b0a93-264">KeepAlive</span></span>

<span data-ttu-id="b0a93-265">此设置表示在通过空闲连接发送 keepalive 数据包之前要等待的时间量。</span><span class="sxs-lookup"><span data-stu-id="b0a93-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="b0a93-266">默认值为 10 秒。</span><span class="sxs-lookup"><span data-stu-id="b0a93-266">The default value is 10 seconds.</span></span> <span data-ttu-id="b0a93-267">此值不得超过 `DisconnectTimeout` 值的1/3。</span><span class="sxs-lookup"><span data-stu-id="b0a93-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="b0a93-268">如果要同时设置 `DisconnectTimeout` 和 `KeepAlive`，请在 `DisconnectTimeout`后设置 `KeepAlive`。</span><span class="sxs-lookup"><span data-stu-id="b0a93-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="b0a93-269">否则，在 `DisconnectTimeout` 自动将 `KeepAlive` 设置为1/3 的超时值时，将覆盖 `KeepAlive` 设置。</span><span class="sxs-lookup"><span data-stu-id="b0a93-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="b0a93-270">如果要禁用 keepalive 功能，请将 `KeepAlive` 设置为 null。</span><span class="sxs-lookup"><span data-stu-id="b0a93-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="b0a93-271">自动为长轮询传输禁用 Keepalive 功能。</span><span class="sxs-lookup"><span data-stu-id="b0a93-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="b0a93-272">如何更改超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="b0a93-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="b0a93-273">若要更改这些设置的默认值，请在*global.asax*文件的 `Application_Start` 中设置这些值，如下面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="b0a93-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="b0a93-274">示例代码中显示的值与默认值相同。</span><span class="sxs-lookup"><span data-stu-id="b0a93-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="b0a93-275">如何通知用户断开</span><span class="sxs-lookup"><span data-stu-id="b0a93-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="b0a93-276">在某些应用程序中，当出现连接问题时，您可能希望向用户显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="b0a93-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="b0a93-277">您有几个选项可用于执行此操作的方式和时间。</span><span class="sxs-lookup"><span data-stu-id="b0a93-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="b0a93-278">下面的代码示例适用于使用生成的代理的 JavaScript 客户端。</span><span class="sxs-lookup"><span data-stu-id="b0a93-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="b0a93-279">处理 `connectionSlow` 事件，以便在 SignalR 了解连接问题之后，在进入重新连接模式之前立即显示消息。</span><span class="sxs-lookup"><span data-stu-id="b0a93-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="b0a93-280">处理 `reconnecting` 事件以便在 SignalR 知道断开连接并且进入重新连接模式时显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="b0a93-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="b0a93-281">处理 `disconnected` 事件，以便在尝试重新连接时显示一条消息。在此方案中，重新建立与服务器的连接的唯一方法是通过调用 `Start` 方法来重新启动 SignalR 连接，这将创建一个新的连接 ID。</span><span class="sxs-lookup"><span data-stu-id="b0a93-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="b0a93-282">下面的代码示例使用标志来确保只在重新连接超时后发出通知，而不是在通过调用 `Stop` 方法引起的 SignalR 连接后发出通知。</span><span class="sxs-lookup"><span data-stu-id="b0a93-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="b0a93-283">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-283">How to continuously reconnect</span></span>

<span data-ttu-id="b0a93-284">在某些应用程序中，你可能希望在连接丢失后自动重新建立连接，并且尝试重新连接已超时。为此，可以从 `Closed` 事件处理程序（JavaScript 客户端上`disconnected` 事件处理程序）调用 `Start` 方法。</span><span class="sxs-lookup"><span data-stu-id="b0a93-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="b0a93-285">你可能需要等待一段时间，然后再调用 `Start`，以避免在服务器或物理连接不可用时过于频繁地执行此操作。</span><span class="sxs-lookup"><span data-stu-id="b0a93-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="b0a93-286">下面的代码示例适用于使用生成的代理的 JavaScript 客户端。</span><span class="sxs-lookup"><span data-stu-id="b0a93-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="b0a93-287">在移动客户端中需要注意的一个潜在问题是：当服务器或物理连接不可用时，连续重新连接尝试可能会导致不必要的电池消耗。</span><span class="sxs-lookup"><span data-stu-id="b0a93-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="b0a93-288">如何在服务器代码中断开客户端连接</span><span class="sxs-lookup"><span data-stu-id="b0a93-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="b0a93-289">SignalR 版本2没有用于断开客户端的内置服务器 API。</span><span class="sxs-lookup"><span data-stu-id="b0a93-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="b0a93-290">将来有一些[用于添加此功能的计划](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="b0a93-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="b0a93-291">在当前的 SignalR 版本中，将客户端与服务器断开连接的最简单方法是在客户端上实现断开连接方法，并从服务器调用该方法。</span><span class="sxs-lookup"><span data-stu-id="b0a93-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="b0a93-292">下面的代码示例演示如何使用生成的代理为 JavaScript 客户端提供断开连接方法。</span><span class="sxs-lookup"><span data-stu-id="b0a93-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="b0a93-293">安全性-对于断开客户端和建议的内置 API，这两种方法都不会解决正在运行恶意代码的攻击者的应用场景，因为客户端可以重新连接或被攻击的代码可能会删除 `stopClient` 方法或更改其功能。</span><span class="sxs-lookup"><span data-stu-id="b0a93-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="b0a93-294">实现有状态拒绝服务（DOS）保护的适当位置不在框架或服务器层中，而是在前端基础结构中。</span><span class="sxs-lookup"><span data-stu-id="b0a93-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="b0a93-295">检测断开连接的原因</span><span class="sxs-lookup"><span data-stu-id="b0a93-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="b0a93-296">SignalR 2.1 将重载添加到服务器 `OnDisconnect` 事件，该事件指示客户端是否特意断开连接，而不是超时。如果客户端显式关闭连接，则 `StopCalled` 参数为 true。</span><span class="sxs-lookup"><span data-stu-id="b0a93-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="b0a93-297">在 JavaScript 中，如果服务器错误导致客户端断开连接，则错误信息将作为 `$.connection.hub.lastError`传递给客户端。</span><span class="sxs-lookup"><span data-stu-id="b0a93-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="b0a93-298">**C#服务器代码： `stopCalled` 参数**</span><span class="sxs-lookup"><span data-stu-id="b0a93-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="b0a93-299">**JavaScript 客户端代码：在 `disconnect` 事件中访问 `lastError`。**</span><span class="sxs-lookup"><span data-stu-id="b0a93-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]

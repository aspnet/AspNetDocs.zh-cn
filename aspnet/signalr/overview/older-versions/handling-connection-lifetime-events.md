---
uid: signalr/overview/older-versions/handling-connection-lifetime-events
title: 了解和处理 SignalR 中的连接生存期事件 1.x |Microsoft Docs
author: bradygaster
description: 本文介绍如何使用事件中心 API 公开的。
ms.author: bradyg
ms.date: 06/05/2013
ms.assetid: e608e263-264d-448b-b0eb-6eeb77713b22
msc.legacyurl: /signalr/overview/older-versions/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 2fb671e730a1d41c07b350bf1d64ac1d0b1be55c
ms.sourcegitcommit: 51b01b6ff8edde57d8243e4da28c9f1e7f1962b2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/06/2019
ms.locfileid: "65128792"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr-1x"></a><span data-ttu-id="96d7e-103">了解和处理 SignalR 中的连接生存期事件 1.x</span><span class="sxs-lookup"><span data-stu-id="96d7e-103">Understanding and Handling Connection Lifetime Events in SignalR 1.x</span></span>

<span data-ttu-id="96d7e-104">通过[Patrick Fletcher](https://github.com/pfletcher)， [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="96d7e-104">by [Patrick Fletcher](https://github.com/pfletcher), [Tom Dykstra](https://github.com/tdykstra)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="96d7e-105">本文概述了可以处理的 SignalR 连接、 重新连接和断开连接事件以及可以配置的超时和保持连接设置。</span><span class="sxs-lookup"><span data-stu-id="96d7e-105">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
> 
> <span data-ttu-id="96d7e-106">本文假设已有的 SignalR 和连接生存期事件一些知识。</span><span class="sxs-lookup"><span data-stu-id="96d7e-106">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="96d7e-107">有关 SignalR 的简介，请参阅[SignalR-概述-Getting Started](index.md)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-107">For an introduction to SignalR, see [SignalR - Overview - Getting Started](index.md).</span></span> <span data-ttu-id="96d7e-108">有关连接生存期事件的列表，请参阅以下资源：</span><span class="sxs-lookup"><span data-stu-id="96d7e-108">For lists of connection lifetime events, see the following resources:</span></span>
> 
> - [<span data-ttu-id="96d7e-109">如何处理中心类中的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="96d7e-109">How to handle connection lifetime events in the Hub class</span></span>](index.md)
> - [<span data-ttu-id="96d7e-110">如何处理在 JavaScript 客户端的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="96d7e-110">How to handle connection lifetime events in JavaScript clients</span></span>](index.md)
> - [<span data-ttu-id="96d7e-111">如何处理在.NET 客户端的连接生存期事件</span><span class="sxs-lookup"><span data-stu-id="96d7e-111">How to handle connection lifetime events in .NET clients</span></span>](index.md)

## <a name="overview"></a><span data-ttu-id="96d7e-112">概述</span><span class="sxs-lookup"><span data-stu-id="96d7e-112">Overview</span></span>

<span data-ttu-id="96d7e-113">本文包含以下各节：</span><span class="sxs-lookup"><span data-stu-id="96d7e-113">This article contains the following sections:</span></span>

- [<span data-ttu-id="96d7e-114">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-114">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="96d7e-115">SignalR 连接、 传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-115">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="96d7e-116">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-116">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="96d7e-117">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-117">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="96d7e-118">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-118">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="96d7e-119">超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="96d7e-119">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="96d7e-120">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="96d7e-120">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="96d7e-121">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="96d7e-121">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="96d7e-122">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="96d7e-122">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="96d7e-123">如何更改超时设置和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="96d7e-123">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="96d7e-124">如何通知用户有关的断开连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-124">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="96d7e-125">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-125">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="96d7e-126">如何断开连接在服务器代码中的客户端</span><span class="sxs-lookup"><span data-stu-id="96d7e-126">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)

<span data-ttu-id="96d7e-127">API 参考主题的链接将指向.NET 4.5 版本的 API。</span><span class="sxs-lookup"><span data-stu-id="96d7e-127">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="96d7e-128">如果使用的.NET 4，请参阅[API 主题的.NET 4 版本](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-128">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="96d7e-129">连接生存期术语和方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-129">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="96d7e-130">`OnReconnected` SignalR Hub 中的事件处理程序可以执行紧`OnConnected`但不是在`OnDisconnected`给定客户端。</span><span class="sxs-lookup"><span data-stu-id="96d7e-130">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="96d7e-131">你可以重新连接，而无需断开连接的原因是，有几种方法在 SignalR 中使用单词"连接"。</span><span class="sxs-lookup"><span data-stu-id="96d7e-131">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="96d7e-132">SignalR 连接、 传输连接和物理连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-132">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="96d7e-133">本文将区分*SignalR 连接*，*传输连接*，并*物理连接*:</span><span class="sxs-lookup"><span data-stu-id="96d7e-133">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="96d7e-134">**SignalR 连接**指的是客户端和服务器 URL，由 SignalR API 维护并由连接 ID 唯一标识之间的逻辑关系</span><span class="sxs-lookup"><span data-stu-id="96d7e-134">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="96d7e-135">有关此关系的数据由 SignalR 维护，用于建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-135">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="96d7e-136">数据的客户端调用时释放的关系端和 SignalR `Stop` SignalR 尝试重新建立丢失的传输连接时达到方法或超时限制。</span><span class="sxs-lookup"><span data-stu-id="96d7e-136">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="96d7e-137">**传输连接**指的是客户端和维护四个传输 Api 之一的服务器之间的逻辑关系：Websocket、 服务器发送事件、 永久帧或很长的轮询。</span><span class="sxs-lookup"><span data-stu-id="96d7e-137">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="96d7e-138">SignalR 使用传输 API 以创建传输的连接，并传输 API 取决于要创建传输连接的物理网络连接存在。</span><span class="sxs-lookup"><span data-stu-id="96d7e-138">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="96d7e-139">传输连接结束时 SignalR 将终止该进程，或当传输 API 检测到物理连接已断开。</span><span class="sxs-lookup"><span data-stu-id="96d7e-139">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="96d7e-140">**物理连接**指的是物理网络链接--电线，无线信号，路由器，等等-，便于您的客户端计算机和服务器计算机之间的通信。</span><span class="sxs-lookup"><span data-stu-id="96d7e-140">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="96d7e-141">物理连接必须存在才能建立传输连接，并且必须建立的 SignalR 连接建立的传输连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-141">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="96d7e-142">但是，重大的物理连接并不一定会立即结束传输连接或 SignalR 连接，如本主题稍后将对此进行解释。</span><span class="sxs-lookup"><span data-stu-id="96d7e-142">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="96d7e-143">在下图中，SignalR 连接由中心 API 和 PersistentConnection API SignalR 层、 由传输层，表示传输连接和服务器之间的直线表示的物理连接和的客户端。</span><span class="sxs-lookup"><span data-stu-id="96d7e-143">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR 体系结构关系图](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="96d7e-145">当您调用`Start`SignalR 客户端中的方法，您将向 SignalR 客户端代码提供建立物理连接到服务器所需的所有信息。</span><span class="sxs-lookup"><span data-stu-id="96d7e-145">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="96d7e-146">SignalR 客户端代码使用此信息来发出 HTTP 请求，并建立使用四种传输方法之一的物理连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-146">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="96d7e-147">如果传输连接失败或服务器出现故障，SignalR 连接不会立即消失因客户端仍有自动重新建立新的传输连接到相同的 SignalR URL 所需的信息。</span><span class="sxs-lookup"><span data-stu-id="96d7e-147">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="96d7e-148">在此方案中，涉及到从用户应用程序无需干预，并当 SignalR 客户端代码可创建新的传输连接，它不会启动新的 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-148">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="96d7e-149">SignalR 连接的连续性反映在这一事实，在调用时创建的连接 ID`Start`方法，不会更改。</span><span class="sxs-lookup"><span data-stu-id="96d7e-149">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="96d7e-150">`OnReconnected`集线器上的事件处理程序执行至今已有丢失后自动重新建立传输连接时。</span><span class="sxs-lookup"><span data-stu-id="96d7e-150">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="96d7e-151">`OnDisconnected` SignalR 连接结束时执行事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="96d7e-151">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="96d7e-152">SignalR 连接可以结束任何以下方法：</span><span class="sxs-lookup"><span data-stu-id="96d7e-152">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="96d7e-153">如果客户端调用`Stop`方法，一条停止消息发送到服务器，并且客户端和服务器立即结束 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-153">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="96d7e-154">客户端和服务器之间的连接丢失后，客户端将尝试重新连接和服务器将等待客户端重新连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-154">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="96d7e-155">如果尝试重新连接均不成功，并且在断开连接超时期限结束，客户端和服务器端 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-155">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="96d7e-156">客户端停止尝试重新连接，并在服务器释放的 SignalR 连接表示形式。</span><span class="sxs-lookup"><span data-stu-id="96d7e-156">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="96d7e-157">如果客户端停止运行而无需调用有机会`Stop`方法中，服务器将等待客户端重新连接，然后结束后断开连接超时期限的 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-157">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="96d7e-158">如果服务器停止运行，客户端尝试重新连接 （重新创建传输连接），然后结束后断开连接超时期限的 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-158">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="96d7e-159">当不存在连接问题，以及用户应用程序通过调用结束 SignalR 连接`Stop`方法、 SignalR 连接和传输连接开始和结束大约在同一时间。</span><span class="sxs-lookup"><span data-stu-id="96d7e-159">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="96d7e-160">以下部分更详细地介绍了其他方案。</span><span class="sxs-lookup"><span data-stu-id="96d7e-160">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="96d7e-161">传输断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-161">Transport disconnection scenarios</span></span>

<span data-ttu-id="96d7e-162">物理连接可能会较慢，或者可能有连接中断。</span><span class="sxs-lookup"><span data-stu-id="96d7e-162">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="96d7e-163">具体取决于因素，例如中断的长度，可能会删除该传输连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-163">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="96d7e-164">SignalR 然后尝试重新建立传输连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-164">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="96d7e-165">有时，传输连接 API 检测到发生中断，并且删除传输连接和 SignalR 发现立即的连接已丢失。</span><span class="sxs-lookup"><span data-stu-id="96d7e-165">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="96d7e-166">在其他情况下，既不传输连接 API，也不 SignalR 注意将立即变为的连接已丢失。</span><span class="sxs-lookup"><span data-stu-id="96d7e-166">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="96d7e-167">对于除长轮询的所有传输，SignalR 客户端使用名为的函数*keepalive*来检查传输 API 是无法检测到的连接丢失。</span><span class="sxs-lookup"><span data-stu-id="96d7e-167">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="96d7e-168">长轮询连接有关的信息，请参阅[超时设置和 keepalive 设置](#timeoutkeepalive)本主题中更高版本。</span><span class="sxs-lookup"><span data-stu-id="96d7e-168">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="96d7e-169">当连接处于非活动状态时，定期服务器会将保持连接数据包发送到客户端。</span><span class="sxs-lookup"><span data-stu-id="96d7e-169">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="96d7e-170">截至正在撰写这篇文章，默认频率为每隔 10 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-170">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="96d7e-171">通过侦听这些数据包，客户端可以判断是否存在连接问题。</span><span class="sxs-lookup"><span data-stu-id="96d7e-171">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="96d7e-172">如果在保持连接数据包未收到预期时，一段时间之后客户端会认为有连接问题，例如速度缓慢问题或中断。</span><span class="sxs-lookup"><span data-stu-id="96d7e-172">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="96d7e-173">如果在较长的时间后仍未收到保持连接，客户端会认为已删除该连接，并开始尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-173">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="96d7e-174">下图说明了物理连接不会立即识别传输 API 的问题时引发在典型方案中的客户端和服务器事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-174">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="96d7e-175">在关系图适用于下列情况：</span><span class="sxs-lookup"><span data-stu-id="96d7e-175">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="96d7e-176">传输协议是 Websocket、 永久帧或服务器发送事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-176">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="96d7e-177">有几个不同的物理网络连接中断。</span><span class="sxs-lookup"><span data-stu-id="96d7e-177">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="96d7e-178">传输 API 不会成为了解中断，因此 SignalR 依赖于 keepalive 功能以进行检测。</span><span class="sxs-lookup"><span data-stu-id="96d7e-178">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![传输的断开连接](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="96d7e-180">如果客户端将进入重新连接模式，但不能建立传输连接在断开连接超时限制内的，在被服务器终止 SignalR 连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-180">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="96d7e-181">在这种情况下，服务器执行的中心`OnDisconnected`方法，并将在客户端管理连接更高版本的情况下发送到客户端断开连接消息的队列。</span><span class="sxs-lookup"><span data-stu-id="96d7e-181">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="96d7e-182">如果客户端然后 does 重新连接，接收断开连接命令，并调用`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-182">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="96d7e-183">在此方案中，`OnReconnected`时客户端重新连接，不执行并`OnDisconnected`客户端调用时，不执行`Stop`。</span><span class="sxs-lookup"><span data-stu-id="96d7e-183">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="96d7e-184">下图说明了这种情况。</span><span class="sxs-lookup"><span data-stu-id="96d7e-184">The following diagram illustrates this scenario.</span></span>

![传输中断的服务器超时](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="96d7e-186">可能会在客户端引发的 SignalR 连接生存期事件如下所示：</span><span class="sxs-lookup"><span data-stu-id="96d7e-186">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="96d7e-187">`ConnectionSlow` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-187">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="96d7e-188">保持连接超时期限的预设的组成部分已通过自最后一条消息，或收到 keepalive ping 时引发。</span><span class="sxs-lookup"><span data-stu-id="96d7e-188">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="96d7e-189">默认 keepalive 超时警告期为 2/3 的保持连接超时。</span><span class="sxs-lookup"><span data-stu-id="96d7e-189">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="96d7e-190">保持连接超时是 20 秒，因此会在大约 13 秒出现的警告。</span><span class="sxs-lookup"><span data-stu-id="96d7e-190">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="96d7e-191">默认情况下，则服务器将 keepalive ping 每隔 10 秒，则客户端检查 keepalive ping 有关 （一个保持连接超时值和 keepalive 超时警告值之间的差异的第三） 每隔 2 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-191">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="96d7e-192">如果传输 API 会知道这一断开连接，SignalR 可能通知的断开连接之前保持连接的超时警告时间为止。</span><span class="sxs-lookup"><span data-stu-id="96d7e-192">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="96d7e-193">在这种情况下，`ConnectionSlow`不会引发事件，并 SignalR 将直接转到`Reconnecting`事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-193">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="96d7e-194">`Reconnecting` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-194">`Reconnecting` client event.</span></span>

    <span data-ttu-id="96d7e-195">当 API （a） 的传输检测到的连接已丢失，或 （b） 保持连接超时时间已通过自最后一条消息，或收到 keepalive ping 时引发。</span><span class="sxs-lookup"><span data-stu-id="96d7e-195">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="96d7e-196">SignalR 客户端代码先尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-196">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="96d7e-197">如果你希望应用程序采取某些操作传输连接丢失时，可以处理此事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-197">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="96d7e-198">当前，默认 keepalive 超时时间为 20 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-198">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="96d7e-199">如果客户端代码尝试在 SignalR 中重新连接模式下调用集线器方法，SignalR 将尝试发送该命令。</span><span class="sxs-lookup"><span data-stu-id="96d7e-199">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="96d7e-200">大多数情况下，此类尝试都将失败，但在某些情况下它们可能会成功。</span><span class="sxs-lookup"><span data-stu-id="96d7e-200">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="96d7e-201">对于服务器发送事件、 永久帧和长轮询传输，SignalR 使用两个通信通道，一个客户端用于发送消息，另一个用于接收消息。</span><span class="sxs-lookup"><span data-stu-id="96d7e-201">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="96d7e-202">用于接收的通道是永久打开，并且这是一个物理连接被中断时关闭的。</span><span class="sxs-lookup"><span data-stu-id="96d7e-202">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="96d7e-203">通道用于发送仍然可用，因此如果还原的物理连接，则重新建立接收通道之前，从客户端对服务器的方法调用可能会成功。</span><span class="sxs-lookup"><span data-stu-id="96d7e-203">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="96d7e-204">将接收返回的值，直到 SignalR 重新打开用于接收的通道。</span><span class="sxs-lookup"><span data-stu-id="96d7e-204">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="96d7e-205">`Reconnected` 客户端事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-205">`Reconnected` client event.</span></span>

    <span data-ttu-id="96d7e-206">当重新建立传输连接时引发。</span><span class="sxs-lookup"><span data-stu-id="96d7e-206">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="96d7e-207">`OnReconnected`中心中的事件处理程序执行。</span><span class="sxs-lookup"><span data-stu-id="96d7e-207">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="96d7e-208">`Closed` 客户端事件 (`disconnected`在 JavaScript 中的事件)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-208">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="96d7e-209">当断开连接超时期限过期时 SignalR 客户端代码尝试传输连接断开后重新连接时引发。</span><span class="sxs-lookup"><span data-stu-id="96d7e-209">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="96d7e-210">断开连接的默认超时为 30 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-210">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="96d7e-211">(由于连接而终止时，也会引发此事件`Stop`调用方法。)</span><span class="sxs-lookup"><span data-stu-id="96d7e-211">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="96d7e-212">通过传输 API 未检测到并不延迟接收来自服务器的时间超过保持连接超时警告期 keepalive ping 的传输连接中断问题可能不会导致任何连接生存期事件被引发。</span><span class="sxs-lookup"><span data-stu-id="96d7e-212">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="96d7e-213">某些网络环境中有意关闭空闲连接，并保持连接数据包的另一个功能是帮助防止这让这些网络知道 SignalR 连接正在使用的。</span><span class="sxs-lookup"><span data-stu-id="96d7e-213">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="96d7e-214">在极端情况下的 keepalive ping 默认频率可能不足以防止关闭的连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-214">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="96d7e-215">在这种情况下，你可以配置 keepalive ping 更频繁地发送。</span><span class="sxs-lookup"><span data-stu-id="96d7e-215">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="96d7e-216">有关详细信息，请参阅[超时设置和 keepalive 设置](#timeoutkeepalive)本主题中更高版本。</span><span class="sxs-lookup"><span data-stu-id="96d7e-216">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE] 
> 
> [!IMPORTANT]
> <span data-ttu-id="96d7e-217">此处所述的事件的顺序不能保证。</span><span class="sxs-lookup"><span data-stu-id="96d7e-217">The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="96d7e-218">SignalR 使每次尝试此方案中，根据不可预测的方式引发连接生存期事件，但有许多不同的网络事件以及基础通信框架，如传输 Api 处理它们的各种方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-218">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="96d7e-219">例如，`Reconnected`可能无法引发事件，当客户端重新连接，或`OnConnected`当尝试建立的连接不成功时，可能会运行在服务器上的处理程序。</span><span class="sxs-lookup"><span data-stu-id="96d7e-219">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="96d7e-220">本主题介绍的通常会生成某些典型的情况下的影响。</span><span class="sxs-lookup"><span data-stu-id="96d7e-220">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="96d7e-221">客户端断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-221">Client disconnection scenarios</span></span>

<span data-ttu-id="96d7e-222">在浏览器客户端中维护的 SignalR 连接的 SignalR 客户端代码在网页 JavaScript 上下文中运行。</span><span class="sxs-lookup"><span data-stu-id="96d7e-222">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="96d7e-223">具有为什么 SignalR 连接结束时从一个导航页到另一个，并且的为什么你有多个连接具有多个连接 Id 如果要连接的多个浏览器窗口或选项卡。</span><span class="sxs-lookup"><span data-stu-id="96d7e-223">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="96d7e-224">当用户关闭浏览器窗口或选项卡上，或导航到新页或刷新页面时，SignalR 连接立即结束因为 SignalR 客户端代码会为您和调用处理该浏览器事件`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-224">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="96d7e-225">在这些情况下，或当应用程序调用任何客户端平台`Stop`方法，`OnDisconnected`服务器上立即执行的事件处理程序和客户端引发`Closed`事件 (事件名为`disconnected`中JavaScript)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-225">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="96d7e-226">如果客户端应用程序或它所在的计算机崩溃或进入睡眠状态 （例如，当用户关闭便携式计算机），服务器不会知道有关发生了什么情况。</span><span class="sxs-lookup"><span data-stu-id="96d7e-226">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="96d7e-227">就服务器就知道，丢失的客户端可能是由于连接中断，客户端可能会尝试重新连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-227">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="96d7e-228">因此，在这些情况下，服务器会等待以使客户端重新连接，有机会和`OnDisconnected`断开连接超时期限过期 （默认情况下大约 30 秒），才会执行。</span><span class="sxs-lookup"><span data-stu-id="96d7e-228">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="96d7e-229">下图说明了这种情况。</span><span class="sxs-lookup"><span data-stu-id="96d7e-229">The following diagram illustrates this scenario.</span></span>

![客户端计算机故障](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="96d7e-231">服务器断开连接方案</span><span class="sxs-lookup"><span data-stu-id="96d7e-231">Server disconnection scenarios</span></span>

<span data-ttu-id="96d7e-232">当服务器处于脱机状态-它重新启动，出现故障，应用程序域回收，等等-结果可能是类似于连接断开，或传输 API 和 SignalR 可能会立即知道该服务器将消失，而 SignalR 可能开始尝试而无需重新连接引发`ConnectionSlow`事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-232">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="96d7e-233">如果客户端将进入重新连接模式，并且服务器将恢复或重新启动或新的服务器联机的断开连接超时期限过期之前，客户端将重新连接到已还原的或新服务器。</span><span class="sxs-lookup"><span data-stu-id="96d7e-233">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="96d7e-234">在这种情况下，在客户端将继续 SignalR 连接和`Reconnected`引发事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-234">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="96d7e-235">在第一个服务器上，`OnDisconnected`永远不会执行，并在新服务器上，`OnReconnected`尽管执行`OnConnected`永远不会为该客户端之前该服务器上执行。</span><span class="sxs-lookup"><span data-stu-id="96d7e-235">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="96d7e-236">（效果是相同，则客户端后重新连接到同一台服务器重新启动或应用程序域回收，因为当服务器重新启动它具有以前的连接活动的任何内存。）以下关系图假设，立即传输 API 会知道这一连接丢失，因此`ConnectionSlow`不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-236">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![服务器故障和重新连接](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="96d7e-238">如果服务器不会成为可用在断开连接超时期限内，SignalR 连接结束。</span><span class="sxs-lookup"><span data-stu-id="96d7e-238">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="96d7e-239">在此方案中，`Closed`事件 (`disconnected`在 JavaScript 客户端) 在客户端上引发但`OnDisconnected`从来不是在服务器上。</span><span class="sxs-lookup"><span data-stu-id="96d7e-239">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="96d7e-240">以下关系图假设传输 API 不会不将断开连接的注意，因此它检测到 SignalR keepalive 功能和`ConnectionSlow`引发事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-240">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![服务器故障和超时](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="96d7e-242">超时和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="96d7e-242">Timeout and keepalive settings</span></span>

<span data-ttu-id="96d7e-243">默认值`ConnectionTimeout`， `DisconnectTimeout`，和`KeepAlive`值适用于大多数方案，但如果你的环境有特殊需求，可以更改。</span><span class="sxs-lookup"><span data-stu-id="96d7e-243">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="96d7e-244">例如，如果您的网络环境将关闭 5 秒内处于空闲状态的连接，您可能需要减少的 keepalive 值。</span><span class="sxs-lookup"><span data-stu-id="96d7e-244">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="96d7e-245">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="96d7e-245">ConnectionTimeout</span></span>

<span data-ttu-id="96d7e-246">此设置表示打开并正在等待响应之前关闭和打开新的连接保持状态的传输连接的时间量。</span><span class="sxs-lookup"><span data-stu-id="96d7e-246">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="96d7e-247">默认值为 110 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-247">The default value is 110 seconds.</span></span>

<span data-ttu-id="96d7e-248">此设置适用仅 keepalive 功能禁用时，这通常仅适用于长时间轮询传输。</span><span class="sxs-lookup"><span data-stu-id="96d7e-248">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="96d7e-249">下图说明了此设置对长时间的影响轮询传输连接。</span><span class="sxs-lookup"><span data-stu-id="96d7e-249">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![长轮询传输连接](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="96d7e-251">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="96d7e-251">DisconnectTimeout</span></span>

<span data-ttu-id="96d7e-252">此设置表示的时间之后传输连接丢失引发之前要等待`Disconnected`事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-252">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="96d7e-253">默认值为 30 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-253">The default value is 30 seconds.</span></span> <span data-ttu-id="96d7e-254">当您将设置`DisconnectTimeout`，`KeepAlive`将自动设置为 1/3 的`DisconnectTimeout`值。</span><span class="sxs-lookup"><span data-stu-id="96d7e-254">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="96d7e-255">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="96d7e-255">KeepAlive</span></span>

<span data-ttu-id="96d7e-256">此设置表示要在通过空闲连接发送保持连接数据包之前等待时间的量。</span><span class="sxs-lookup"><span data-stu-id="96d7e-256">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="96d7e-257">默认值为 10 秒。</span><span class="sxs-lookup"><span data-stu-id="96d7e-257">The default value is 10 seconds.</span></span> <span data-ttu-id="96d7e-258">此值不能超过 1/3 的`DisconnectTimeout`值。</span><span class="sxs-lookup"><span data-stu-id="96d7e-258">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="96d7e-259">如果你想要同时设置`DisconnectTimeout`并`KeepAlive`，请设置`KeepAlive`后`DisconnectTimeout`。</span><span class="sxs-lookup"><span data-stu-id="96d7e-259">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="96d7e-260">否则为你`KeepAlive`设置时将覆盖`DisconnectTimeout`会自动设置`KeepAlive`为 1/3 的超时值。</span><span class="sxs-lookup"><span data-stu-id="96d7e-260">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="96d7e-261">如果你想要禁用 keepalive 功能，设置`KeepAlive`为 null。</span><span class="sxs-lookup"><span data-stu-id="96d7e-261">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="96d7e-262">Keepalive 功能会自动禁用用于长时间轮询传输。</span><span class="sxs-lookup"><span data-stu-id="96d7e-262">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="96d7e-263">如何更改超时设置和 keepalive 设置</span><span class="sxs-lookup"><span data-stu-id="96d7e-263">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="96d7e-264">若要更改这些设置的默认值，请将它们设置`Application_Start`在您*Global.asax*文件，在下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="96d7e-264">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="96d7e-265">示例代码所示的值是默认值相同。</span><span class="sxs-lookup"><span data-stu-id="96d7e-265">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="96d7e-266">如何通知用户有关的断开连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-266">How to notify the user about disconnections</span></span>

<span data-ttu-id="96d7e-267">在某些应用程序可能想要连接问题时向用户显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="96d7e-267">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="96d7e-268">有几种方法，何时执行此操作。</span><span class="sxs-lookup"><span data-stu-id="96d7e-268">You have several options for how and when to do this.</span></span> <span data-ttu-id="96d7e-269">下面的代码示例适用于 JavaScript 客户端使用生成的代理。</span><span class="sxs-lookup"><span data-stu-id="96d7e-269">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="96d7e-270">处理`connectionSlow`事件之前，它将进入重新连接模式下，SignalR 是识别连接问题时，就立即显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="96d7e-270">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="96d7e-271">处理`reconnecting`SignalR 已意识到断开连接并且转到重新连接模式时显示一条消息的事件。</span><span class="sxs-lookup"><span data-stu-id="96d7e-271">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="96d7e-272">处理`disconnected`事件，以显示一条消息时尝试重新连接已超时。在此方案中，重新建立与服务器的连接再次的唯一方法是通过调用重新启动的 SignalR 连接`Start`方法，将创建一个新的连接 id。</span><span class="sxs-lookup"><span data-stu-id="96d7e-272">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="96d7e-273">下面的代码示例使用一个标志来确保仅后重新连接超时，不通过调用导致的 SignalR 连接到正常结束后的通知颁发`Stop`方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-273">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="96d7e-274">如何持续重新连接</span><span class="sxs-lookup"><span data-stu-id="96d7e-274">How to continuously reconnect</span></span>

<span data-ttu-id="96d7e-275">在某些应用程序可能想要自动在已丢失，并尝试重新连接已超时后重新建立连接。若要执行此操作，可以调用`Start`方法从您`Closed`事件处理程序 (`disconnected` JavaScript 客户端上的事件处理程序)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-275">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="96d7e-276">可能需要等待一段时间，然后才能调用`Start`以避免执行此操作太频繁的服务器或物理连接不可用时。</span><span class="sxs-lookup"><span data-stu-id="96d7e-276">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="96d7e-277">下面的代码示例是 JavaScript 客户端使用生成的代理。</span><span class="sxs-lookup"><span data-stu-id="96d7e-277">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="96d7e-278">需要注意的移动客户端中的潜在问题是连续的重新连接尝试的服务器或物理连接不可用时可能会导致不必要的电池耗尽。</span><span class="sxs-lookup"><span data-stu-id="96d7e-278">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="96d7e-279">如何断开连接在服务器代码中的客户端</span><span class="sxs-lookup"><span data-stu-id="96d7e-279">How to disconnect a client in server code</span></span>

<span data-ttu-id="96d7e-280">SignalR 1.1.1 版之前没有为客户端断开连接的内置服务器 API。</span><span class="sxs-lookup"><span data-stu-id="96d7e-280">SignalR version 1.1.1 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="96d7e-281">有[计划在将来添加此功能](https://github.com/SignalR/SignalR/issues/2101)。</span><span class="sxs-lookup"><span data-stu-id="96d7e-281">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="96d7e-282">在当前的 SignalR 版本中，从服务器中断开客户端的最简单方法是在客户端上实现 disconnect 方法和从服务器调用该方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-282">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="96d7e-283">下面的代码示例显示使用生成的代理的 JavaScript 客户端断开连接方法。</span><span class="sxs-lookup"><span data-stu-id="96d7e-283">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="96d7e-284">安全性-既不此方法对于客户端断开连接，也不建议内置 API 将会解决受到攻击的客户端运行的恶意代码，因为客户端无法重新连接或受到攻击的代码可能会删除该方案`stopClient`方法或更改它的作用。</span><span class="sxs-lookup"><span data-stu-id="96d7e-284">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="96d7e-285">实现有状态的拒绝服务 (DOS) 保护的合适位置并不在框架或服务器层，而是中前端基础结构。</span><span class="sxs-lookup"><span data-stu-id="96d7e-285">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET Web API 2 中的全局错误处理 - ASP.NET 4.x
author: davidmatson
description: ASP.NET 4.x ASP.NET Web API 2 中的全局错误处理概述。
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 5ff54d2e4ed881ce927d0a401fb79d9b8bc5b8a1
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/06/2020
ms.locfileid: "80675419"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="cb46f-103">ASP.NET Web API 2 中的全局错误处理</span><span class="sxs-lookup"><span data-stu-id="cb46f-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="cb46f-104">由[大卫·马特森](https://github.com/davidmatson)，[里克·安德森](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="cb46f-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="cb46f-105">本主题概述了ASP.NET web API 2 中针对ASP.NET 4.x 的全局错误处理。</span><span class="sxs-lookup"><span data-stu-id="cb46f-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="cb46f-106">如今，Web API 中没有简单的方法来全局记录或处理错误。</span><span class="sxs-lookup"><span data-stu-id="cb46f-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="cb46f-107">某些未处理的异常可以通过[异常筛选器](exception-handling.md)进行处理，但有许多异常筛选器无法处理的情况。</span><span class="sxs-lookup"><span data-stu-id="cb46f-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="cb46f-108">例如：</span><span class="sxs-lookup"><span data-stu-id="cb46f-108">For example:</span></span>

1. <span data-ttu-id="cb46f-109">从控制器构造函数引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="cb46f-110">从消息处理程序引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="cb46f-111">在路由过程中引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="cb46f-112">在响应内容序列化期间引发的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-112">Exceptions thrown during response content serialization.</span></span>

<span data-ttu-id="cb46f-113">我们希望提供一种简单、一致的方式来记录和处理这些异常（如果可能）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="cb46f-114">处理异常有两个主要情况，即我们能够发送错误响应的情况，以及我们所能做的就是记录异常的情况。</span><span class="sxs-lookup"><span data-stu-id="cb46f-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="cb46f-115">后一种情况的一个示例是在流式响应内容中间引发异常时;在流式响应内容中引发异常时，则为后一种情况。在这种情况下，发送新的响应消息为时已晚，因为状态代码、标头和部分内容已经通过导线，因此我们只需中止连接即可。</span><span class="sxs-lookup"><span data-stu-id="cb46f-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="cb46f-116">即使无法处理异常以生成新的响应消息，我们仍支持记录异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="cb46f-117">在可以检测到错误的情况下，我们可以返回适当的错误响应，如下所示：</span><span class="sxs-lookup"><span data-stu-id="cb46f-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="cb46f-118">现有选项</span><span class="sxs-lookup"><span data-stu-id="cb46f-118">Existing Options</span></span>

<span data-ttu-id="cb46f-119">除了[异常筛选器](exception-handling.md)之外，[消息处理程序](../advanced/http-message-handlers.md)今天还可用于观察所有 500 级响应，但对这些响应进行操作很困难，因为它们缺少有关原始错误的上下文。</span><span class="sxs-lookup"><span data-stu-id="cb46f-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="cb46f-120">消息处理程序也有一些与异常筛选器相同的限制，涉及它们可以处理的情况。</span><span class="sxs-lookup"><span data-stu-id="cb46f-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.</span></span> <span data-ttu-id="cb46f-121">虽然 Web API 确实具有捕获错误条件的跟踪基础结构，但跟踪基础结构用于诊断目的，并且不适合在生产环境中运行。</span><span class="sxs-lookup"><span data-stu-id="cb46f-121">While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="cb46f-122">全局异常处理和日志记录应该是可在生产期间运行并插入现有监视解决方案（例如[ELMAH）](https://code.google.com/p/elmah/)的服务。</span><span class="sxs-lookup"><span data-stu-id="cb46f-122">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/)).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="cb46f-123">解决方案概述</span><span class="sxs-lookup"><span data-stu-id="cb46f-123">Solution Overview</span></span>

 <span data-ttu-id="cb46f-124">我们提供两种新的用户可替换服务[，IexceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)和 IexceptionHandler，用于记录和处理未处理的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-124">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="cb46f-125">服务非常相似，主要有两个区别：</span><span class="sxs-lookup"><span data-stu-id="cb46f-125">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="cb46f-126">我们支持注册多个异常记录器，但仅支持单个异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="cb46f-126">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="cb46f-127">异常记录器总是被调用，即使我们即将中止连接。</span><span class="sxs-lookup"><span data-stu-id="cb46f-127">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="cb46f-128">只有在我们仍可以选择要发送的响应消息时，才会调用异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="cb46f-128">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="cb46f-129">这两个服务都提供从检测到异常点包含相关信息的异常上下文的访问，特别是[HttpRequestMessage、HttpRequestContext、](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)引发异常和异常源（详情见下文）。 [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)</span><span class="sxs-lookup"><span data-stu-id="cb46f-129">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="cb46f-130">设计原理</span><span class="sxs-lookup"><span data-stu-id="cb46f-130">Design Principles</span></span>

1. <span data-ttu-id="cb46f-131">**无重大更改**由于此功能是在次要版本中添加的，因此影响解决方案的一个重要约束是，对于类型协定或行为，没有重大更改。</span><span class="sxs-lookup"><span data-stu-id="cb46f-131">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="cb46f-132">此约束排除了我们希望在现有 catch 块方面进行的一些清理，将异常转换为 500 个响应。</span><span class="sxs-lookup"><span data-stu-id="cb46f-132">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="cb46f-133">对于后续的主要版本，我们可以考虑此附加清理。</span><span class="sxs-lookup"><span data-stu-id="cb46f-133">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="cb46f-134">如果这对你很重要，请[ASP.NETWeb API用户语音](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)投。</span><span class="sxs-lookup"><span data-stu-id="cb46f-134">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="cb46f-135">**与 Web API 构造保持一致性**Web API 的筛选器管道是处理跨领域问题的绝佳方法，它可灵活地将逻辑应用于特定于操作、特定于控制器或全局的范围。</span><span class="sxs-lookup"><span data-stu-id="cb46f-135">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="cb46f-136">筛选器（包括异常筛选器）始终具有操作和控制器上下文，即使在全局作用域中注册也是如此。</span><span class="sxs-lookup"><span data-stu-id="cb46f-136">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="cb46f-137">该协定对筛选器有意义，但它意味着异常筛选器（即使是全局范围筛选器）不适合某些异常处理情况，例如消息处理程序的异常，其中不存在操作或控制器上下文。</span><span class="sxs-lookup"><span data-stu-id="cb46f-137">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="cb46f-138">如果我们想要使用筛选器提供的灵活范围来处理异常处理，我们仍然需要异常筛选器。</span><span class="sxs-lookup"><span data-stu-id="cb46f-138">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="cb46f-139">但是，如果需要在控制器上下文之外处理异常，我们还需要一个单独的构造来进行完整的全局错误处理（没有控制器上下文和操作上下文约束）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-139">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="cb46f-140">何时使用</span><span class="sxs-lookup"><span data-stu-id="cb46f-140">When to Use</span></span>

- <span data-ttu-id="cb46f-141">异常记录器是查看 Web API 捕获的所有未处理异常的解决方案。</span><span class="sxs-lookup"><span data-stu-id="cb46f-141">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="cb46f-142">异常处理程序是自定义 Web API 捕获的未处理异常的所有可能响应的解决方案。</span><span class="sxs-lookup"><span data-stu-id="cb46f-142">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="cb46f-143">异常筛选器是处理与特定操作或控制器相关的子集未处理异常的最简单解决方案。</span><span class="sxs-lookup"><span data-stu-id="cb46f-143">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="cb46f-144">服务详细信息</span><span class="sxs-lookup"><span data-stu-id="cb46f-144">Service Details</span></span>

 <span data-ttu-id="cb46f-145">异常记录器和处理程序服务接口是采用相应上下文的简单异步方法：</span><span class="sxs-lookup"><span data-stu-id="cb46f-145">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="cb46f-146">我们还为这两个接口提供基类。</span><span class="sxs-lookup"><span data-stu-id="cb46f-146">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="cb46f-147">重写核心（同步或异步）方法是在建议的时间记录或处理所需的全部方法。</span><span class="sxs-lookup"><span data-stu-id="cb46f-147">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="cb46f-148">对于日志记录，`ExceptionLogger`基类将确保每个异常只调用一次核心日志记录方法（即使它稍后在调用堆栈上传播并进一步传播并再次捕获）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-148">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="cb46f-149">基`ExceptionHandler`类将仅针对调用堆栈顶部的异常调用核心处理方法，而忽略旧嵌套 catch 块。</span><span class="sxs-lookup"><span data-stu-id="cb46f-149">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="cb46f-150">（这些基类的简化版本见下面的附录。和`IExceptionLogger``IExceptionHandler`都通过 接收有关异常的信息`ExceptionContext`。</span><span class="sxs-lookup"><span data-stu-id="cb46f-150">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="cb46f-151">当框架调用异常记录器或异常处理程序时，它将始终提供 和`Exception`。 `Request`</span><span class="sxs-lookup"><span data-stu-id="cb46f-151">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="cb46f-152">除了单元测试外，它还会始终提供 。 `RequestContext`</span><span class="sxs-lookup"><span data-stu-id="cb46f-152">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="cb46f-153">它很少提供 和`ControllerContext``ActionContext`（仅在从异常筛选器的 catch 块调用时）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-153">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="cb46f-154">它很少提供 （`Response`仅在某些 IIS 情况下，当尝试编写响应时）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-154">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="cb46f-155">请注意，由于其中一些属性可能`null`由使用者在访问异常类的成员`null`之前进行检查。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="cb46f-155">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="cb46f-156">是指示哪个 catch 块看到异常的字符串。</span><span class="sxs-lookup"><span data-stu-id="cb46f-156">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="cb46f-157">catch 块字符串如下所示：</span><span class="sxs-lookup"><span data-stu-id="cb46f-157">The catch block strings are as follows:</span></span>

- <span data-ttu-id="cb46f-158">HttpServer（发送同步方法）</span><span class="sxs-lookup"><span data-stu-id="cb46f-158">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="cb46f-159">HttpController调度程序（发送同步方法）</span><span class="sxs-lookup"><span data-stu-id="cb46f-159">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="cb46f-160">HttpBatchhandler（发送同步方法）</span><span class="sxs-lookup"><span data-stu-id="cb46f-160">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="cb46f-161">IExceptionFilter（ApiController 在 ExecuteAsync 中处理异常筛选器管道）</span><span class="sxs-lookup"><span data-stu-id="cb46f-161">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="cb46f-162">OWIN 主机：</span><span class="sxs-lookup"><span data-stu-id="cb46f-162">OWIN host:</span></span>

    - <span data-ttu-id="cb46f-163">HttpMessageHandlerAdapter.缓冲区响应内容同步（用于缓冲输出）</span><span class="sxs-lookup"><span data-stu-id="cb46f-163">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="cb46f-164">HttpMessageHandlerAdapter.复制响应内容同步（用于流式处理输出）</span><span class="sxs-lookup"><span data-stu-id="cb46f-164">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="cb46f-165">网络主机：</span><span class="sxs-lookup"><span data-stu-id="cb46f-165">Web host:</span></span>

    - <span data-ttu-id="cb46f-166">HttpControllerHandler.写入缓冲响应内容同步（用于缓冲输出）</span><span class="sxs-lookup"><span data-stu-id="cb46f-166">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="cb46f-167">HttpControllerHandler.写入流式响应内容同步（用于流式处理输出）</span><span class="sxs-lookup"><span data-stu-id="cb46f-167">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="cb46f-168">HttpControllerHandler.写入错误响应内容同步（对于缓冲输出模式下错误恢复失败）</span><span class="sxs-lookup"><span data-stu-id="cb46f-168">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="cb46f-169">catch 块字符串的列表也可通过静态只读属性提供。</span><span class="sxs-lookup"><span data-stu-id="cb46f-169">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="cb46f-170">（核心 catch 块字符串位于静态异常捕获块上;其余字符串出现在一个静态类中，每个静态类用于 OWIN 和 Web 主机）。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="cb46f-170">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="cb46f-171">有助于遵循仅在调用堆栈顶部处理异常的建议模式。</span><span class="sxs-lookup"><span data-stu-id="cb46f-171">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="cb46f-172">异常处理程序可以允许异常传播到主机即将看到之前，而不是将异常转换为 500 个响应。</span><span class="sxs-lookup"><span data-stu-id="cb46f-172">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="cb46f-173">除了 ，`ExceptionContext`记录器通过完整`ExceptionLoggerContext`获取了一条信息：</span><span class="sxs-lookup"><span data-stu-id="cb46f-173">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="cb46f-174">第二个属性`CanBeHandled`允许记录器标识无法处理的异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-174">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="cb46f-175">当连接即将中止，并且无法发送新的响应消息时，将调用记录器，但不会调用处理程序，并且记录器可以从此属性标识此方案***not***。</span><span class="sxs-lookup"><span data-stu-id="cb46f-175">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="cb46f-176">在 除`ExceptionContext`中，处理程序还可以获取一个可以设置在 full`ExceptionHandlerContext`上处理异常的属性：</span><span class="sxs-lookup"><span data-stu-id="cb46f-176">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="cb46f-177">`Result`异常处理程序通过将属性设置为操作结果（例如，[异常结果](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)、[内部服务器错误结果](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)、[状态代码结果](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)或自定义结果）来指示它已处理异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-177">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="cb46f-178">如果`Result`属性为 null，则异常将未处理，并且将重新引发原始异常。</span><span class="sxs-lookup"><span data-stu-id="cb46f-178">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="cb46f-179">对于调用堆栈顶部的异常，我们采取了额外的步骤，以确保响应适合 API 调用方。</span><span class="sxs-lookup"><span data-stu-id="cb46f-179">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="cb46f-180">如果异常传播到主机，调用方将看到死亡黄色屏幕或其他一些主机提供的响应，这些响应通常是 HTML，通常不是适当的 API 错误响应。</span><span class="sxs-lookup"><span data-stu-id="cb46f-180">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="cb46f-181">在这些情况下，结果开始为非空，只有当自定义异常处理程序显式将其设置回`null`（未处理）时，异常才会传播到主机。</span><span class="sxs-lookup"><span data-stu-id="cb46f-181">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="cb46f-182">在这种情况下`Result`，`null`设置为 可用于以下两种情况：</span><span class="sxs-lookup"><span data-stu-id="cb46f-182">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="cb46f-183">OWIN 托管 Web API，具有在 Web API 之前/外部注册的自定义异常处理中间件。</span><span class="sxs-lookup"><span data-stu-id="cb46f-183">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="cb46f-184">通过浏览器进行本地调试，其中死亡黄色屏幕实际上是对未处理异常的有用响应。</span><span class="sxs-lookup"><span data-stu-id="cb46f-184">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="cb46f-185">对于异常记录器和异常处理程序，如果记录器或处理程序本身引发异常，则不执行任何恢复操作。</span><span class="sxs-lookup"><span data-stu-id="cb46f-185">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="cb46f-186">（除了让异常传播外，如果您有更好的方法，请将反馈保留在此页面的底部。异常记录器和处理程序的协定是，它们不应让异常传播到其调用方;否则，异常将只传播到主机，导致 HTML 错误（如 ASP）。NET 的黄色屏幕）被发送回客户端（对于希望 JSON 或 XML 的 API 调用方来说，这通常不是首选选项）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-186">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="cb46f-187">示例</span><span class="sxs-lookup"><span data-stu-id="cb46f-187">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="cb46f-188">跟踪异常记录器</span><span class="sxs-lookup"><span data-stu-id="cb46f-188">Tracing Exception Logger</span></span>

<span data-ttu-id="cb46f-189">下面的异常记录器将异常数据发送到配置的跟踪源（包括 Visual Studio 中的调试输出窗口）。</span><span class="sxs-lookup"><span data-stu-id="cb46f-189">The exception logger below sends exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="cb46f-190">自定义错误消息异常处理程序</span><span class="sxs-lookup"><span data-stu-id="cb46f-190">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="cb46f-191">下面的异常处理程序生成对客户端的自定义错误响应，包括用于联系支持的电子邮件地址。</span><span class="sxs-lookup"><span data-stu-id="cb46f-191">The exception handler below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="cb46f-192">注册异常筛选器</span><span class="sxs-lookup"><span data-stu-id="cb46f-192">Registering Exception Filters</span></span>

<span data-ttu-id="cb46f-193">如果使用"ASP.NET MVC 4 Web 应用程序"项目模板创建项目，请将 Web API 配置代码`WebApiConfig`放入类中，放入*App_Start*文件夹中：</span><span class="sxs-lookup"><span data-stu-id="cb46f-193">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="cb46f-194">附录：基本课程详细信息</span><span class="sxs-lookup"><span data-stu-id="cb46f-194">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]

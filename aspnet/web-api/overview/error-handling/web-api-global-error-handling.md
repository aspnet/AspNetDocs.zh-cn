---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: ASP.NET Web API 2 中的全局错误处理-ASP.NET 4。x
author: davidmatson
description: ASP.NET 4.x 的 ASP.NET Web API 2 中全局错误处理的概述。
ms.author: riande
ms.date: 02/03/2014
ms.custom: seoapril2019
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 94f2d6d31d0b37f9bb0077e6258c70a2dfb1918d
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/06/2020
ms.locfileid: "78448964"
---
# <a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="c3a75-103">ASP.NET Web API 2 中的全局错误处理</span><span class="sxs-lookup"><span data-stu-id="c3a75-103">Global Error Handling in ASP.NET Web API 2</span></span>

<span data-ttu-id="c3a75-104">按[David Matson](https://github.com/davidmatson)， [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="c3a75-104">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

<span data-ttu-id="c3a75-105">本主题概述了 ASP.NET 4.x ASP.NET Web API 2 中的全局错误处理。</span><span class="sxs-lookup"><span data-stu-id="c3a75-105">This topic provides an overview of global error handling in ASP.NET Web API 2 for ASP.NET 4.x.</span></span> <span data-ttu-id="c3a75-106">现在，Web API 无法通过全局方式记录或处理错误。</span><span class="sxs-lookup"><span data-stu-id="c3a75-106">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="c3a75-107">某些未经处理的异常可以通过[异常筛选器](exception-handling.md)进行处理，但异常筛选器无法处理多种情况。</span><span class="sxs-lookup"><span data-stu-id="c3a75-107">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="c3a75-108">例如:</span><span class="sxs-lookup"><span data-stu-id="c3a75-108">For example:</span></span>

1. <span data-ttu-id="c3a75-109">从控制器构造函数引发的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-109">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="c3a75-110">从消息处理程序引发的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-110">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="c3a75-111">在路由过程中引发的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-111">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="c3a75-112">在响应内容序列化过程中引发的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-112">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="c3a75-113">我们想要提供一种简单、一致的方法来记录和处理这些异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-113">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="c3a75-114">处理异常的主要情况有两种，在这种情况下，我们能够发送错误响应，而我们只需要记录异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-114">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="c3a75-115">后一种情况的一个示例是在流响应内容的中间引发异常;在这种情况下，发送新响应消息的时间太晚，因为状态代码、标头和部分内容已在网络中消失，因此我们只需中止连接。</span><span class="sxs-lookup"><span data-stu-id="c3a75-115">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="c3a75-116">即使无法处理异常以生成新的响应消息，仍仍支持记录异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-116">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="c3a75-117">在检测到错误的情况下，我们可以返回相应的错误响应，如下所示：</span><span class="sxs-lookup"><span data-stu-id="c3a75-117">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="c3a75-118">现有选项</span><span class="sxs-lookup"><span data-stu-id="c3a75-118">Existing Options</span></span>

<span data-ttu-id="c3a75-119">除了[异常筛选器](exception-handling.md)外，现在还可以使用[消息处理程序](../advanced/http-message-handlers.md)来观察所有500级别的响应，但对这些响应的作用非常困难，因为它们缺乏有关原始错误的上下文。</span><span class="sxs-lookup"><span data-stu-id="c3a75-119">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="c3a75-120">消息处理程序还具有与异常筛选器有关的一些限制，这些限制与它们可以处理的情况有关。尽管 Web API 有捕获错误情况的跟踪基础结构，但跟踪基础结构用于诊断目的，但并不是在生产环境中运行或不适合在生产环境中运行。</span><span class="sxs-lookup"><span data-stu-id="c3a75-120">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="c3a75-121">全局异常处理和日志记录应该是可在生产过程中运行并插入现有监视解决方案（例如， [ELMAH](https://code.google.com/p/elmah/) ）的服务。</span><span class="sxs-lookup"><span data-stu-id="c3a75-121">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="c3a75-122">解决方案概述</span><span class="sxs-lookup"><span data-stu-id="c3a75-122">Solution Overview</span></span>

 <span data-ttu-id="c3a75-123">我们提供了两个新的用户可替换服务（ [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md)和 IExceptionHandler）来记录和处理未经处理的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-123">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="c3a75-124">服务非常相似，但有两个主要区别：</span><span class="sxs-lookup"><span data-stu-id="c3a75-124">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="c3a75-125">我们支持注册多个异常记录器，而只是一个异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="c3a75-125">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="c3a75-126">即使要中止连接，也始终会调用异常记录器。</span><span class="sxs-lookup"><span data-stu-id="c3a75-126">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="c3a75-127">仅当我们仍可以选择要发送的响应消息时，才会调用异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="c3a75-127">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="c3a75-128">这两种服务都提供对包含异常检测点的相关信息的异常上下文的访问，特别是[HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx)、 [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx)、引发的异常和异常源（下面的详细信息）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-128">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="c3a75-129">设计原理</span><span class="sxs-lookup"><span data-stu-id="c3a75-129">Design Principles</span></span>

1. <span data-ttu-id="c3a75-130">**无重大更改**由于此功能是在次要版本中添加的，因此，影响解决方案的一个重要约束是不会对类型协定或行为进行重大更改。</span><span class="sxs-lookup"><span data-stu-id="c3a75-130">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="c3a75-131">此约束排除了某些清理，我们想要在现有的 catch 块中实现将异常转换为500响应。</span><span class="sxs-lookup"><span data-stu-id="c3a75-131">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="c3a75-132">对于后续的主要发布，我们可能会考虑这种额外的清理操作。</span><span class="sxs-lookup"><span data-stu-id="c3a75-132">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="c3a75-133">如果这对你很重要，请在[ASP.NET Web API 用户语音](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)上投票。</span><span class="sxs-lookup"><span data-stu-id="c3a75-133">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="c3a75-134">**维护 WEB API 构造的一致性**Web API 的筛选器管道是一种很好的方法，可以通过在特定于控制器或全局范围内应用逻辑的灵活性来处理交叉切削问题。</span><span class="sxs-lookup"><span data-stu-id="c3a75-134">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="c3a75-135">筛选器（包括异常筛选器）始终具有操作和控制器上下文，即使是在全局范围内注册也是如此。</span><span class="sxs-lookup"><span data-stu-id="c3a75-135">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="c3a75-136">该协定对于筛选器是有意义的，但这意味着异常筛选器（甚至是全局范围的筛选器）不适合用于某些异常处理情况，如消息处理程序中不存在任何操作或控制器上下文的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-136">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="c3a75-137">如果我们想要使用筛选器提供的可变范围来处理异常，则仍需要异常筛选器。</span><span class="sxs-lookup"><span data-stu-id="c3a75-137">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="c3a75-138">但是，如果我们需要处理控制器上下文之外的异常，我们还需要一个单独的构造来实现全局错误处理（没有控制器上下文和操作上下文约束的内容）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-138">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="c3a75-139">何时使用</span><span class="sxs-lookup"><span data-stu-id="c3a75-139">When to Use</span></span>

- <span data-ttu-id="c3a75-140">异常记录器是查看 Web API 捕获的所有未处理异常的解决方案。</span><span class="sxs-lookup"><span data-stu-id="c3a75-140">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="c3a75-141">异常处理程序是一种解决方案，用于自定义对 Web API 捕获的未处理异常的所有可能的响应。</span><span class="sxs-lookup"><span data-stu-id="c3a75-141">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="c3a75-142">异常筛选器是处理与特定操作或控制器相关的部分未处理异常的最简单解决方案。</span><span class="sxs-lookup"><span data-stu-id="c3a75-142">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="c3a75-143">服务详情</span><span class="sxs-lookup"><span data-stu-id="c3a75-143">Service Details</span></span>

 <span data-ttu-id="c3a75-144">异常记录器和处理程序服务接口是简单的异步方法，采用各自的上下文：</span><span class="sxs-lookup"><span data-stu-id="c3a75-144">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="c3a75-145">我们还提供了这两个接口的基类。</span><span class="sxs-lookup"><span data-stu-id="c3a75-145">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="c3a75-146">重写核心（同步或异步）方法是指在建议时间记录或处理的全部。</span><span class="sxs-lookup"><span data-stu-id="c3a75-146">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="c3a75-147">对于日志记录，`ExceptionLogger` 基类将确保只为每个异常调用一次核心日志记录方法（即使稍后在调用堆栈上进一步传播并再次捕获）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-147">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="c3a75-148">`ExceptionHandler` 基类将仅对调用堆栈顶部的异常调用核心处理方法，同时忽略旧的嵌套 catch 块。</span><span class="sxs-lookup"><span data-stu-id="c3a75-148">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="c3a75-149">（下面的附录中介绍了这些基类的简化版本。）`IExceptionLogger` 和 `IExceptionHandler` 通过 `ExceptionContext`接收有关异常的信息。</span><span class="sxs-lookup"><span data-stu-id="c3a75-149">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="c3a75-150">当框架调用异常记录器或异常处理程序时，它将始终提供 `Exception` 和 `Request`。</span><span class="sxs-lookup"><span data-stu-id="c3a75-150">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="c3a75-151">除了单元测试以外，它还将始终提供 `RequestContext`。</span><span class="sxs-lookup"><span data-stu-id="c3a75-151">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="c3a75-152">它很少提供 `ControllerContext` 和 `ActionContext` （仅在从异常筛选器的 catch 块中调用时）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-152">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="c3a75-153">它很少提供 `Response`（仅在尝试写入响应的某些 IIS 情况下）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-153">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="c3a75-154">请注意，由于某些属性可能 `null` 在访问 exception 类的成员之前，使用者检查 `null`。`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="c3a75-154">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="c3a75-155">一个字符串，指示哪个 catch 块看到了该异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-155">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="c3a75-156">Catch 块字符串如下所示：</span><span class="sxs-lookup"><span data-stu-id="c3a75-156">The catch block strings are as follows:</span></span>

- <span data-ttu-id="c3a75-157">HttpServer （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c3a75-157">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="c3a75-158">System.web.http.exceptionhandling.exceptioncatchblocks.httpcontrollerdispatcher.sendasync （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c3a75-158">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="c3a75-159">System.web.http.exceptionhandling.exceptioncatchblocks.httpbatchhandler.sendasync （SendAsync 方法）</span><span class="sxs-lookup"><span data-stu-id="c3a75-159">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="c3a75-160">IExceptionFilter （ApiController 在 ExecuteAsync 中处理异常筛选器管道）</span><span class="sxs-lookup"><span data-stu-id="c3a75-160">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="c3a75-161">OWIN 主机：</span><span class="sxs-lookup"><span data-stu-id="c3a75-161">OWIN host:</span></span>

    - <span data-ttu-id="c3a75-162">HttpMessageHandlerAdapter. BufferResponseContentAsync （用于缓冲输出）</span><span class="sxs-lookup"><span data-stu-id="c3a75-162">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="c3a75-163">HttpMessageHandlerAdapter. CopyResponseContentAsync （用于流输出）</span><span class="sxs-lookup"><span data-stu-id="c3a75-163">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="c3a75-164">Web 主机：</span><span class="sxs-lookup"><span data-stu-id="c3a75-164">Web host:</span></span>

    - <span data-ttu-id="c3a75-165">HttpControllerHandler. System.web.http.webhost.httpcontrollerhandler.writebufferedresponsecontentasync （用于缓冲输出）</span><span class="sxs-lookup"><span data-stu-id="c3a75-165">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="c3a75-166">HttpControllerHandler. System.web.http.webhost.httpcontrollerhandler.writestreamedresponsecontentasync （用于流输出）</span><span class="sxs-lookup"><span data-stu-id="c3a75-166">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="c3a75-167">HttpControllerHandler. System.web.http.webhost.httpcontrollerhandler.writeerrorresponsecontentasync （在缓冲输出模式下恢复错误时）</span><span class="sxs-lookup"><span data-stu-id="c3a75-167">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="c3a75-168">Catch 块字符串列表还可通过静态 readonly 属性获得。</span><span class="sxs-lookup"><span data-stu-id="c3a75-168">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="c3a75-169">（核心 catch 块字符串位于静态 System.web.http.exceptionhandling.exceptioncatchblocks.httpserver.sendasync 上; 余数显示在一个静态类上，每个静态类用于 OWIN 和 web 主机）。`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="c3a75-169">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="c3a75-170">对于在调用堆栈顶部遵循建议的处理异常模式非常有用。</span><span class="sxs-lookup"><span data-stu-id="c3a75-170">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="c3a75-171">异常处理程序不会在嵌套的 catch 块发生的任何位置将异常转换为500响应，而是允许异常传播到它们即将被宿主查看。</span><span class="sxs-lookup"><span data-stu-id="c3a75-171">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="c3a75-172">除了 `ExceptionContext`，记录器还通过完整 `ExceptionLoggerContext`获取一段信息：</span><span class="sxs-lookup"><span data-stu-id="c3a75-172">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="c3a75-173">第二个属性 `CanBeHandled`允许记录器识别无法处理的异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-173">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="c3a75-174">当即将中止连接并且不能发送新的响应消息时，将调用记录器，但***不***会调用该处理程序，并且记录器可以通过此属性来标识此方案。</span><span class="sxs-lookup"><span data-stu-id="c3a75-174">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="c3a75-175">在 `ExceptionContext`中，处理程序将获取一个可在整个 `ExceptionHandlerContext` 上设置的属性来处理异常：</span><span class="sxs-lookup"><span data-stu-id="c3a75-175">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="c3a75-176">异常处理程序通过将 `Result` 属性设置为操作结果（例如， [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx)、 [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx)、 [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx)或自定义结果）来指示它已处理了异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-176">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="c3a75-177">如果 `Result` 属性为 null，则不会处理异常，将重新引发原始异常。</span><span class="sxs-lookup"><span data-stu-id="c3a75-177">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="c3a75-178">对于调用堆栈顶部的异常，我们采取了额外的步骤来确保响应适用于 API 调用方。</span><span class="sxs-lookup"><span data-stu-id="c3a75-178">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="c3a75-179">如果异常向上传播到主机，则调用方将显示死亡的黄色屏幕或一些其他主机提供的响应，通常是 HTML，通常不是相应的 API 错误响应。</span><span class="sxs-lookup"><span data-stu-id="c3a75-179">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="c3a75-180">在这些情况下，结果将从非空值开始，并且仅当自定义异常处理程序将其显式设置回 `null` （未处理）时，才会将异常传播到主机。</span><span class="sxs-lookup"><span data-stu-id="c3a75-180">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="c3a75-181">在这种情况下，将 `Result` 设置为 `null` 对于两种情况可能很有用：</span><span class="sxs-lookup"><span data-stu-id="c3a75-181">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="c3a75-182">OWIN 托管的 Web API，其中包含自定义异常处理在 Web API 之前/外部注册的中间件。</span><span class="sxs-lookup"><span data-stu-id="c3a75-182">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="c3a75-183">通过浏览器进行本地调试，其中黄色的死亡对于未经处理的异常实际上是一个有帮助的响应。</span><span class="sxs-lookup"><span data-stu-id="c3a75-183">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="c3a75-184">对于异常记录器和异常处理程序，如果记录器或处理程序本身引发异常，则不会执行任何操作。</span><span class="sxs-lookup"><span data-stu-id="c3a75-184">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="c3a75-185">（除了允许异常传播外，如果你有更好的方法，请在本页底部留下反馈。）异常记录器和处理程序的协定是它们不应允许异常传播到其调用方;否则，异常将直接传播到主机上，从而导致出现 HTML 错误（如 ASP）。NET 的黄色屏幕）发送回客户端（这通常不是需要 JSON 或 XML 的 API 调用方的首选选项）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-185">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="c3a75-186">示例</span><span class="sxs-lookup"><span data-stu-id="c3a75-186">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="c3a75-187">跟踪异常记录器</span><span class="sxs-lookup"><span data-stu-id="c3a75-187">Tracing Exception Logger</span></span>

<span data-ttu-id="c3a75-188">下面的异常记录器将异常数据发送到配置的跟踪源（包括 Visual Studio 中的 "调试输出" 窗口）。</span><span class="sxs-lookup"><span data-stu-id="c3a75-188">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="c3a75-189">自定义错误消息异常处理程序</span><span class="sxs-lookup"><span data-stu-id="c3a75-189">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="c3a75-190">以下为客户端生成自定义错误响应，包括与支持联系的电子邮件地址。</span><span class="sxs-lookup"><span data-stu-id="c3a75-190">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="c3a75-191">注册异常筛选器</span><span class="sxs-lookup"><span data-stu-id="c3a75-191">Registering Exception Filters</span></span>

<span data-ttu-id="c3a75-192">如果使用 "ASP.NET MVC 4 Web 应用程序" 项目模板来创建项目，请将 Web API 配置代码放在*应用/_Start*文件夹中的 `WebApiConfig` 类中：</span><span class="sxs-lookup"><span data-stu-id="c3a75-192">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="c3a75-193">附录：基类详细信息</span><span class="sxs-lookup"><span data-stu-id="c3a75-193">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
